/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Services = (
  | string
  | {
      /**
       * Full name of the image that should be used. It should contain the Registry part if needed.
       */
      name: string;
      /**
       * @minItems 1
       */
      entrypoint?: [string, ...string[]];
      docker?: {
        /**
         * Image architecture to pull.
         */
        platform?: string;
        /**
         * Username or UID to use for the container.
         */
        user?: string;
      };
      kubernetes?: {
        /**
         * Username or UID to use for the container. It also supports the UID:GID format.
         */
        user?: string | number;
      };
      pull_policy?:
        | ("always" | "never" | "if-not-present")
        | ["always" | "never" | "if-not-present", ...("always" | "never" | "if-not-present")[]];
      /**
       * @minItems 1
       */
      command?: [string, ...string[]];
      alias?: string;
      variables?: JobVariables;
    }
)[];
export type Reference = string[];
export type Artifacts = {
  /**
   * @minItems 1
   */
  paths?: [string, ...string[]];
  /**
   * @minItems 1
   */
  exclude?: [string, ...string[]];
  expose_as?: string;
  name?: string;
  untracked?: boolean;
  when?: "on_success" | "on_failure" | "always";
  access?: "none" | "developer" | "all";
  expire_in?: string;
  reports?: {
    /**
     * Path to JSON file with accessibility report.
     */
    accessibility?: string;
    /**
     * Path to JSON file with annotations report.
     */
    annotations?: string;
    /**
     * Path for file(s) that should be parsed as JUnit XML result
     */
    junit?: string | [string, ...string[]];
    /**
     * Path to a single file with browser performance metric report(s).
     */
    browser_performance?: string;
    /**
     * Used to collect coverage reports from the job.
     */
    coverage_report?: {
      /**
       * Code coverage format used by the test framework.
       */
      coverage_format?: "cobertura" | "jacoco";
      /**
       * Path to the coverage report file that should be parsed.
       */
      path?: string;
      [k: string]: unknown;
    } | null;
    /**
     * Path to file or list of files with code quality report(s) (such as Code Climate).
     */
    codequality?: string | string[];
    /**
     * Path to file or list of files containing runtime-created variables for this job.
     */
    dotenv?: string | string[];
    /**
     * Path to file or list of files containing code intelligence (Language Server Index Format).
     */
    lsif?: string | string[];
    /**
     * Path to file or list of files with SAST vulnerabilities report(s).
     */
    sast?: string | string[];
    /**
     * Path to file or list of files with Dependency scanning vulnerabilities report(s).
     */
    dependency_scanning?: string | string[];
    /**
     * Path to file or list of files with Container scanning vulnerabilities report(s).
     */
    container_scanning?: string | string[];
    /**
     * Path to file or list of files with DAST vulnerabilities report(s).
     */
    dast?: string | string[];
    /**
     * Deprecated in 12.8: Path to file or list of files with license report(s).
     */
    license_management?: string | string[];
    /**
     * Path to file or list of files with license report(s).
     */
    license_scanning?: string | string[];
    /**
     * Path to file or list of files with requirements report(s).
     */
    requirements?: string | string[];
    /**
     * Path to file or list of files with secret detection report(s).
     */
    secret_detection?: string | string[];
    /**
     * Path to file or list of files with custom metrics report(s).
     */
    metrics?: string | string[];
    /**
     * Path to file or list of files with terraform plan(s).
     */
    terraform?: string | string[];
    cyclonedx?: string | string[];
    load_performance?: string | string[];
    /**
     * Path to file or list of files with Repository X-Ray report(s).
     */
    repository_xray?: string | string[];
  };
} & Artifacts1;
export type Artifacts1 = {
  /**
   * @minItems 1
   */
  paths?: [string, ...string[]];
  /**
   * @minItems 1
   */
  exclude?: [string, ...string[]];
  expose_as?: string;
  name?: string;
  untracked?: boolean;
  when?: "on_success" | "on_failure" | "always";
  access?: "none" | "developer" | "all";
  expire_in?: string;
  reports?: {
    /**
     * Path to JSON file with accessibility report.
     */
    accessibility?: string;
    /**
     * Path to JSON file with annotations report.
     */
    annotations?: string;
    /**
     * Path for file(s) that should be parsed as JUnit XML result
     */
    junit?: string | [string, ...string[]];
    /**
     * Path to a single file with browser performance metric report(s).
     */
    browser_performance?: string;
    /**
     * Used to collect coverage reports from the job.
     */
    coverage_report?: {
      /**
       * Code coverage format used by the test framework.
       */
      coverage_format?: "cobertura" | "jacoco";
      /**
       * Path to the coverage report file that should be parsed.
       */
      path?: string;
      [k: string]: unknown;
    } | null;
    /**
     * Path to file or list of files with code quality report(s) (such as Code Climate).
     */
    codequality?: string | string[];
    /**
     * Path to file or list of files containing runtime-created variables for this job.
     */
    dotenv?: string | string[];
    /**
     * Path to file or list of files containing code intelligence (Language Server Index Format).
     */
    lsif?: string | string[];
    /**
     * Path to file or list of files with SAST vulnerabilities report(s).
     */
    sast?: string | string[];
    /**
     * Path to file or list of files with Dependency scanning vulnerabilities report(s).
     */
    dependency_scanning?: string | string[];
    /**
     * Path to file or list of files with Container scanning vulnerabilities report(s).
     */
    container_scanning?: string | string[];
    /**
     * Path to file or list of files with DAST vulnerabilities report(s).
     */
    dast?: string | string[];
    /**
     * Deprecated in 12.8: Path to file or list of files with license report(s).
     */
    license_management?: string | string[];
    /**
     * Path to file or list of files with license report(s).
     */
    license_scanning?: string | string[];
    /**
     * Path to file or list of files with requirements report(s).
     */
    requirements?: string | string[];
    /**
     * Path to file or list of files with secret detection report(s).
     */
    secret_detection?: string | string[];
    /**
     * Path to file or list of files with custom metrics report(s).
     */
    metrics?: string | string[];
    /**
     * Path to file or list of files with terraform plan(s).
     */
    terraform?: string | string[];
    cyclonedx?: string | string[];
    load_performance?: string | string[];
    /**
     * Path to file or list of files with Repository X-Ray report(s).
     */
    repository_xray?: string | string[];
  };
} | null;
export type Cache = CacheItem | CacheItem[];
export type Image =
  | string
  | {
      /**
       * Full name of the image that should be used. It should contain the Registry part if needed.
       */
      name: string;
      /**
       * Command or script that should be executed as the container's entrypoint. It will be translated to Docker's --entrypoint option while creating the container. The syntax is similar to Dockerfile's ENTRYPOINT directive, where each shell token is a separate string in the array.
       *
       * @minItems 1
       */
      entrypoint?: [unknown, ...unknown[]];
      docker?: {
        /**
         * Image architecture to pull.
         */
        platform?: string;
        /**
         * Username or UID to use for the container.
         */
        user?: string;
      };
      kubernetes?: {
        /**
         * Username or UID to use for the container. It also supports the UID:GID format.
         */
        user?: string | number;
      };
      pull_policy?:
        | ("always" | "never" | "if-not-present")
        | ["always" | "never" | "if-not-present", ...("always" | "never" | "if-not-present")[]];
    };
export type Interruptible = boolean;
export type Identity = "google_cloud";
export type Retry =
  | RetryMax
  | {
      max?: RetryMax;
      when?: RetryErrors | RetryErrors[];
      exit_codes?: [number, ...number[]] | number;
    };
/**
 * The number of times the job will be retried if it fails. Defaults to 0 and can max be retried 2 times (3 times total).
 */
export type RetryMax = number;
export type RetryErrors =
  | "always"
  | "unknown_failure"
  | "script_failure"
  | "api_failure"
  | "stuck_or_timeout_failure"
  | "runner_system_failure"
  | "runner_unsupported"
  | "stale_schedule"
  | "job_execution_timeout"
  | "archived_failure"
  | "unmet_prerequisites"
  | "scheduler_failure"
  | "data_integrity_failure"
  | "runner_provisioning_timeout";
export type Services1 = (
  | string
  | {
      /**
       * Full name of the image that should be used. It should contain the Registry part if needed.
       */
      name: string;
      /**
       * @minItems 1
       */
      entrypoint?: [string, ...string[]];
      docker?: {
        /**
         * Image architecture to pull.
         */
        platform?: string;
        /**
         * Username or UID to use for the container.
         */
        user?: string;
      };
      kubernetes?: {
        /**
         * Username or UID to use for the container. It also supports the UID:GID format.
         */
        user?: string | number;
      };
      pull_policy?:
        | ("always" | "never" | "if-not-present")
        | ["always" | "never" | "if-not-present", ...("always" | "never" | "if-not-present")[]];
      /**
       * @minItems 1
       */
      command?: [string, ...string[]];
      alias?: string;
      variables?: JobVariables;
    }
)[];
/**
 * @minItems 1
 */
export type Tags = [string | [string, ...string[]], ...(string | [string, ...string[]])[]];
export type Timeout = string;
export type IncludeItem =
  | ({
      [k: string]: unknown;
    } & string)
  | {
      /**
       * Relative path from local repository root (`/`) to the `yaml`/`yml` file template. The file must be on the same branch, and does not work across git submodules.
       */
      local: string;
      rules?: IncludeRules;
      inputs?: Inputs;
    }
  | {
      /**
       * Path to the project, e.g. `group/project`, or `group/sub-group/project` [Learn more](https://docs.gitlab.com/ci/yaml/#includeproject).
       */
      project: string;
      /**
       * Branch/Tag/Commit-hash for the target project.
       */
      ref?: string;
      file: string | string[];
      rules?: IncludeRules;
      inputs?: Inputs;
    }
  | {
      /**
       * Use a `.gitlab-ci.yml` template as a base, e.g. `Nodejs.gitlab-ci.yml`.
       */
      template: string;
      rules?: IncludeRules;
      inputs?: Inputs;
    }
  | {
      /**
       * Local path to component directory or full path to external component directory.
       */
      component: string;
      rules?: IncludeRules;
      inputs?: Inputs;
    }
  | {
      /**
       * URL to a `yaml`/`yml` template file using HTTP/HTTPS.
       */
      remote: string;
      /**
       * SHA256 integrity hash of the remote file content.
       */
      integrity?: string;
      rules?: IncludeRules;
      inputs?: Inputs;
    };
export type IncludeRules =
  | (
      | {
          if?: If;
          changes?: Changes;
          exists?: Exists;
          when?: ("never" | "always") | null;
        }
      | string
      | [string, ...string[]]
    )[]
  | null;
export type If = string;
export type Changes =
  | {
      /**
       * List of file paths.
       */
      paths: string[];
      /**
       * Ref for comparing changes.
       */
      compare_to?: string;
    }
  | string[];
export type Exists =
  | string[]
  | {
      /**
       * List of file paths.
       */
      paths: string[];
      /**
       * Path of the project to search in.
       */
      project?: string;
    }
  | {
      /**
       * List of file paths.
       */
      paths: string[];
      /**
       * Path of the project to search in.
       */
      project: string;
      /**
       * Ref of the project to search in.
       */
      ref?: string;
    };
export type JobTemplate = {
  image?: Image;
  services?: Services1;
  before_script?: string | (string | string[])[];
  after_script?: string | (string | string[])[];
  hooks?: Hooks;
  rules?: Rules;
  variables?: JobVariables1;
  cache?: Cache;
  id_tokens?: IdTokens;
  identity?: Identity;
  secrets?: Secrets;
  script?: string | [string | string[], ...(string | string[])[]];
  run?: Steps;
  /**
   * Define what stage the job will run in.
   */
  stage?: string | [string, ...string[]];
  /**
   * Job will run *only* when these filtering options match.
   */
  only?:
    | null
    | FilterRefs
    | {
        refs?: FilterRefs;
        /**
         * Filter job based on if Kubernetes integration is active.
         */
        kubernetes?: "active";
        variables?: string[];
        /**
         * Filter job creation based on files that were modified in a git push.
         */
        changes?: string[];
      };
  /**
   * The name of one or more jobs to inherit configuration from.
   */
  extends?: string | [string, ...string[]];
  /**
   * The list of jobs in previous stages whose sole completion is needed to start the current job.
   */
  needs?: (
    | string
    | {
        job: string;
        artifacts?: boolean;
        optional?: boolean;
        parallel?: ParallelMatrix;
      }
    | {
        pipeline: string;
        job: string;
        artifacts?: boolean;
        parallel?: ParallelMatrix;
      }
    | {
        job: string;
        project: string;
        ref: string;
        artifacts?: boolean;
        parallel?: ParallelMatrix;
      }
    | Reference
  )[];
  /**
   * Job will run *except* for when these filtering options match.
   */
  except?:
    | null
    | FilterRefs
    | {
        refs?: FilterRefs;
        /**
         * Filter job based on if Kubernetes integration is active.
         */
        kubernetes?: "active";
        variables?: string[];
        /**
         * Filter job creation based on files that were modified in a git push.
         */
        changes?: string[];
      };
  tags?: Tags;
  allow_failure?: AllowFailure;
  timeout?: Timeout;
  when?: When;
  start_in?: StartIn;
  manual_confirmation?: string;
  /**
   * Specify a list of job names from earlier stages from which artifacts should be loaded. By default, all previous artifacts are passed. Use an empty array to skip downloading artifacts.
   */
  dependencies?: string[];
  artifacts?: Artifacts;
  /**
   * Used to associate environment metadata with a deploy. Environment can have a name and URL attached to it, and will be displayed under /environments under the project.
   */
  environment?:
    | string
    | {
        /**
         * The name of the environment, e.g. 'qa', 'staging', 'production'.
         */
        name: string;
        /**
         * When set, this will expose buttons in various places for the current environment in GitLab, that will take you to the defined URL.
         */
        url?: string;
        /**
         * The name of a job to execute when the environment is about to be stopped.
         */
        on_stop?: string;
        /**
         * Specifies what this job will do. 'start' (default) indicates the job will start the deployment. 'prepare'/'verify'/'access' indicates this will not affect the deployment. 'stop' indicates this will stop the deployment.
         */
        action?: "start" | "prepare" | "stop" | "verify" | "access";
        /**
         * The amount of time it should take before GitLab will automatically stop the environment. Supports a wide variety of formats, e.g. '1 week', '3 mins 4 sec', '2 hrs 20 min', '2h20min', '6 mos 1 day', '47 yrs 6 mos and 4d', '3 weeks and 2 days'.
         */
        auto_stop_in?: string;
        /**
         * Used to configure the kubernetes deployment for this environment. This is currently not supported for kubernetes clusters that are managed by GitLab.
         */
        kubernetes?: {
          /**
           * Specifies the GitLab Agent for Kubernetes. The format is `path/to/agent/project:agent-name`.
           */
          agent?: string;
          /**
           * Deprecated. Use `dashboard.namespace` instead. The kubernetes namespace where this environment's dashboard should be deployed to.
           */
          namespace?: string;
          /**
           * Deprecated. Use `dashboard.flux_resource_path` instead. The Flux resource path to associate with this environment. This must be the full resource path. For example, 'helm.toolkit.fluxcd.io/v2/namespaces/gitlab-agent/helmreleases/gitlab-agent'.
           */
          flux_resource_path?: string;
          /**
           * Used to configure the managed resources for this environment.
           */
          managed_resources?: {
            /**
             * Indicates whether the managed resources are enabled for this environment.
             */
            enabled?: boolean;
            [k: string]: unknown;
          };
          /**
           * Used to configure the dashboard for this environment.
           */
          dashboard?: {
            /**
             * The kubernetes namespace where the dashboard for this environment should be deployed to.
             */
            namespace?: string;
            /**
             * The Flux resource path to associate with this environment. This must be the full resource path. For example, 'helm.toolkit.fluxcd.io/v2/namespaces/gitlab-agent/helmreleases/gitlab-agent'.
             */
            flux_resource_path?: string;
            [k: string]: unknown;
          };
          [k: string]: unknown;
        };
        /**
         * Explicitly specifies the tier of the deployment environment if non-standard environment name is used.
         */
        deployment_tier?: string;
      };
  /**
   * Indicates that the job creates a Release.
   */
  release?: {
    /**
     * The tag_name must be specified. It can refer to an existing Git tag or can be specified by the user.
     */
    tag_name: string;
    /**
     * Message to use if creating a new annotated tag.
     */
    tag_message?: string;
    /**
     * Specifies the longer description of the Release.
     */
    description: string;
    /**
     * The Release name. If omitted, it is populated with the value of release: tag_name.
     */
    name?: string;
    /**
     * If the release: tag_name doesnâ€™t exist yet, the release is created from ref. ref can be a commit SHA, another tag name, or a branch name.
     */
    ref?: string;
    /**
     * The title of each milestone the release is associated with.
     */
    milestones?: string[];
    /**
     * The date and time when the release is ready. Defaults to the current date and time if not defined. Should be enclosed in quotes and expressed in ISO 8601 format.
     */
    released_at?: string;
    assets?: {
      /**
       * Include asset links in the release.
       *
       * @minItems 1
       */
      links: [
        {
          /**
           * The name of the link.
           */
          name: string;
          /**
           * The URL to download a file.
           */
          url: string;
          /**
           * The redirect link to the url.
           */
          filepath?: string;
          /**
           * The content kind of what users can download via url.
           */
          link_type?: "runbook" | "package" | "image" | "other";
        },
        ...{
          /**
           * The name of the link.
           */
          name: string;
          /**
           * The URL to download a file.
           */
          url: string;
          /**
           * The redirect link to the url.
           */
          filepath?: string;
          /**
           * The content kind of what users can download via url.
           */
          link_type?: "runbook" | "package" | "image" | "other";
        }[]
      ];
    };
  };
  /**
   * Must be a regular expression, optionally but recommended to be quoted, and must be surrounded with '/'. Example: '/Code coverage: \d+\.\d+/'
   */
  coverage?: string;
  retry?: Retry;
  parallel?: Parallel;
  interruptible?: Interruptible;
  /**
   * Limit job concurrency. Can be used to ensure that the Runner will not run certain jobs simultaneously.
   */
  resource_group?: string;
  trigger?:
    | {
        /**
         * Path to the project, e.g. `group/project`, or `group/sub-group/project`.
         */
        project: string;
        /**
         * The branch name that a downstream pipeline will use
         */
        branch?: string;
        /**
         * You can mirror or depend on the pipeline status from the triggered pipeline to the source bridge job by using strategy: `depend` or `mirror`
         */
        strategy?: "depend" | "mirror";
        inputs?: Inputs;
        /**
         * Specify what to forward to the downstream pipeline.
         */
        forward?: {
          /**
           * Variables defined in the trigger job are passed to downstream pipelines.
           */
          yaml_variables?: boolean;
          /**
           * Variables added for manual pipeline runs and scheduled pipelines are passed to downstream pipelines.
           */
          pipeline_variables?: boolean;
        };
      }
    | {
        include?:
          | string
          | []
          | [
              | {
                  /**
                   * Relative path from local repository root (`/`) to the local YAML file to define the pipeline configuration.
                   */
                  local: string;
                  inputs?: Inputs;
                }
              | {
                  /**
                   * Name of the template YAML file to use in the pipeline configuration.
                   */
                  template: string;
                  inputs?: Inputs;
                }
              | {
                  /**
                   * Relative path to the generated YAML file which is extracted from the artifacts and used as the configuration for triggering the child pipeline.
                   */
                  artifact: string;
                  /**
                   * Job name which generates the artifact
                   */
                  job: string;
                  inputs?: Inputs;
                }
              | {
                  /**
                   * Path to another private project under the same GitLab instance, like `group/project` or `group/sub-group/project`.
                   */
                  project: string;
                  /**
                   * Branch/Tag/Commit hash for the target project.
                   */
                  ref?: string;
                  /**
                   * Relative path from repository root (`/`) to the pipeline configuration YAML file.
                   */
                  file: string;
                  inputs?: Inputs;
                }
              | {
                  /**
                   * Local path to component directory or full path to external component directory.
                   */
                  component: string;
                  inputs?: Inputs;
                }
              | {
                  /**
                   * URL to a `yaml`/`yml` template file using HTTP/HTTPS.
                   */
                  remote: string;
                  inputs?: Inputs;
                }
            ]
          | [
              (
                | {
                    /**
                     * Relative path from local repository root (`/`) to the local YAML file to define the pipeline configuration.
                     */
                    local: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Name of the template YAML file to use in the pipeline configuration.
                     */
                    template: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Relative path to the generated YAML file which is extracted from the artifacts and used as the configuration for triggering the child pipeline.
                     */
                    artifact: string;
                    /**
                     * Job name which generates the artifact
                     */
                    job: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Path to another private project under the same GitLab instance, like `group/project` or `group/sub-group/project`.
                     */
                    project: string;
                    /**
                     * Branch/Tag/Commit hash for the target project.
                     */
                    ref?: string;
                    /**
                     * Relative path from repository root (`/`) to the pipeline configuration YAML file.
                     */
                    file: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Local path to component directory or full path to external component directory.
                     */
                    component: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * URL to a `yaml`/`yml` template file using HTTP/HTTPS.
                     */
                    remote: string;
                    inputs?: Inputs;
                  }
              ),
              (
                | {
                    /**
                     * Relative path from local repository root (`/`) to the local YAML file to define the pipeline configuration.
                     */
                    local: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Name of the template YAML file to use in the pipeline configuration.
                     */
                    template: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Relative path to the generated YAML file which is extracted from the artifacts and used as the configuration for triggering the child pipeline.
                     */
                    artifact: string;
                    /**
                     * Job name which generates the artifact
                     */
                    job: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Path to another private project under the same GitLab instance, like `group/project` or `group/sub-group/project`.
                     */
                    project: string;
                    /**
                     * Branch/Tag/Commit hash for the target project.
                     */
                    ref?: string;
                    /**
                     * Relative path from repository root (`/`) to the pipeline configuration YAML file.
                     */
                    file: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Local path to component directory or full path to external component directory.
                     */
                    component: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * URL to a `yaml`/`yml` template file using HTTP/HTTPS.
                     */
                    remote: string;
                    inputs?: Inputs;
                  }
              )
            ]
          | [
              (
                | {
                    /**
                     * Relative path from local repository root (`/`) to the local YAML file to define the pipeline configuration.
                     */
                    local: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Name of the template YAML file to use in the pipeline configuration.
                     */
                    template: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Relative path to the generated YAML file which is extracted from the artifacts and used as the configuration for triggering the child pipeline.
                     */
                    artifact: string;
                    /**
                     * Job name which generates the artifact
                     */
                    job: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Path to another private project under the same GitLab instance, like `group/project` or `group/sub-group/project`.
                     */
                    project: string;
                    /**
                     * Branch/Tag/Commit hash for the target project.
                     */
                    ref?: string;
                    /**
                     * Relative path from repository root (`/`) to the pipeline configuration YAML file.
                     */
                    file: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Local path to component directory or full path to external component directory.
                     */
                    component: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * URL to a `yaml`/`yml` template file using HTTP/HTTPS.
                     */
                    remote: string;
                    inputs?: Inputs;
                  }
              ),
              (
                | {
                    /**
                     * Relative path from local repository root (`/`) to the local YAML file to define the pipeline configuration.
                     */
                    local: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Name of the template YAML file to use in the pipeline configuration.
                     */
                    template: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Relative path to the generated YAML file which is extracted from the artifacts and used as the configuration for triggering the child pipeline.
                     */
                    artifact: string;
                    /**
                     * Job name which generates the artifact
                     */
                    job: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Path to another private project under the same GitLab instance, like `group/project` or `group/sub-group/project`.
                     */
                    project: string;
                    /**
                     * Branch/Tag/Commit hash for the target project.
                     */
                    ref?: string;
                    /**
                     * Relative path from repository root (`/`) to the pipeline configuration YAML file.
                     */
                    file: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Local path to component directory or full path to external component directory.
                     */
                    component: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * URL to a `yaml`/`yml` template file using HTTP/HTTPS.
                     */
                    remote: string;
                    inputs?: Inputs;
                  }
              ),
              (
                | {
                    /**
                     * Relative path from local repository root (`/`) to the local YAML file to define the pipeline configuration.
                     */
                    local: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Name of the template YAML file to use in the pipeline configuration.
                     */
                    template: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Relative path to the generated YAML file which is extracted from the artifacts and used as the configuration for triggering the child pipeline.
                     */
                    artifact: string;
                    /**
                     * Job name which generates the artifact
                     */
                    job: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Path to another private project under the same GitLab instance, like `group/project` or `group/sub-group/project`.
                     */
                    project: string;
                    /**
                     * Branch/Tag/Commit hash for the target project.
                     */
                    ref?: string;
                    /**
                     * Relative path from repository root (`/`) to the pipeline configuration YAML file.
                     */
                    file: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * Local path to component directory or full path to external component directory.
                     */
                    component: string;
                    inputs?: Inputs;
                  }
                | {
                    /**
                     * URL to a `yaml`/`yml` template file using HTTP/HTTPS.
                     */
                    remote: string;
                    inputs?: Inputs;
                  }
              )
            ];
        /**
         * You can mirror or depend on the pipeline status from the triggered pipeline to the source bridge job by using strategy: `depend` or `mirror`
         */
        strategy?: "depend" | "mirror";
        /**
         * Specify what to forward to the downstream pipeline.
         */
        forward?: {
          /**
           * Variables defined in the trigger job are passed to downstream pipelines.
           */
          yaml_variables?: boolean;
          /**
           * Variables added for manual pipeline runs and scheduled pipelines are passed to downstream pipelines.
           */
          pipeline_variables?: boolean;
        };
      }
    | string;
  inherit?: {
    default?:
      | boolean
      | (
          | "after_script"
          | "artifacts"
          | "before_script"
          | "cache"
          | "image"
          | "interruptible"
          | "retry"
          | "services"
          | "tags"
          | "timeout"
        )[];
    variables?: boolean | string[];
  };
  /**
   * Deprecated. Use `pages.publish` instead. A path to a directory that contains the files to be published with Pages.
   */
  publish?: string;
  pages?:
    | {
        path_prefix?: string;
        expire_in?: string;
        publish?: string;
      }
    | boolean;
} & JobTemplate1;
export type Rules =
  | (
      | {
          if?: If;
          changes?: Changes;
          exists?: Exists;
          variables?: RulesVariables;
          when?: When;
          start_in?: StartIn;
          allow_failure?: AllowFailure;
          needs?: RulesNeeds;
          interruptible?: Interruptible;
        }
      | string
      | [string, ...string[]]
    )[]
  | null;
export type When = "on_success" | "on_failure" | "always" | "never" | "manual" | "delayed";
export type StartIn = string;
export type AllowFailure =
  | boolean
  | {
      exit_codes: number;
    }
  | {
      /**
       * @minItems 1
       */
      exit_codes: [number, ...number[]];
    };
export type RulesNeeds = (
  | string
  | {
      /**
       * Name of a job that is defined in the pipeline.
       */
      job: string;
      /**
       * Download artifacts of the job in needs.
       */
      artifacts?: boolean;
      /**
       * Whether the job needs to be present in the pipeline to run ahead of the current job.
       */
      optional?: boolean;
    }
)[];
/**
 * Any of these step use cases are valid.
 */
export type Step =
  | {
      name: StepName;
      env?: StepNamedStrings;
      inputs?: StepNamedValues;
      step: string | StepGitReference | StepOciReference;
    }
  | {
      env?: StepNamedStrings;
      run: Step[];
      outputs?: StepNamedValues;
      delegate?: string;
    }
  | {
      name: StepName;
      env?: StepNamedStrings;
      inputs?: StepNamedValues;
      action: string;
    }
  | {
      name: StepName;
      env?: StepNamedStrings;
      script: string;
    }
  | {
      env?: StepNamedStrings;
      exec: StepExec;
    };
export type StepName = string;
export type Steps = Step[];
/**
 * Filter job by different keywords that determine origin or state, or by supplying string/regex to check against branch/tag names.
 */
export type FilterRefs = (
  | ("branches" | "tags" | "api" | "external" | "pipelines" | "pushes" | "schedules" | "triggers" | "web")
  | string
)[];
/**
 * Use the `needs:parallel:matrix` keyword to specify parallelized jobs needed to be completed for the job to run. [Learn More](https://docs.gitlab.com/ci/yaml/#needsparallelmatrix)
 */
export type ParallelMatrix = {
  /**
   * Defines different variables for jobs that are running in parallel.
   *
   * @maxItems 200
   */
  matrix: {
    [k: string]: string | number | unknown[];
  }[];
};
/**
 * Splits up a single job into multiple that run in parallel. Provides `CI_NODE_INDEX` and `CI_NODE_TOTAL` environment variables to the jobs.
 */
export type Parallel =
  | number
  | {
      /**
       * Defines different variables for jobs that are running in parallel.
       *
       * @maxItems 200
       */
      matrix: {
        [k: string]: string | number | unknown[];
      }[];
    };
export type JobTemplate1 =
  | {
      when: "delayed";
      [k: string]: unknown;
    }
  | {
      when?: {
        [k: string]: unknown;
      };
      [k: string]: unknown;
    };
export type WorkflowName = string;
export type Job = JobTemplate;

export interface HttpsGitlabComGitlabCiYml {
  $schema?: string;
  spec?: {
    inputs?: InputParameters;
  };
  image?:
    | string
    | {
        /**
         * Full name of the image that should be used. It should contain the Registry part if needed.
         */
        name: string;
        /**
         * Command or script that should be executed as the container's entrypoint. It will be translated to Docker's --entrypoint option while creating the container. The syntax is similar to Dockerfile's ENTRYPOINT directive, where each shell token is a separate string in the array.
         *
         * @minItems 1
         */
        entrypoint?: [unknown, ...unknown[]];
        docker?: {
          /**
           * Image architecture to pull.
           */
          platform?: string;
          /**
           * Username or UID to use for the container.
           */
          user?: string;
        };
        kubernetes?: {
          /**
           * Username or UID to use for the container. It also supports the UID:GID format.
           */
          user?: string | number;
        };
        pull_policy?:
          | ("always" | "never" | "if-not-present")
          | ["always" | "never" | "if-not-present", ...("always" | "never" | "if-not-present")[]];
      };
  services?: Services;
  before_script?: string | (string | string[])[];
  after_script?: string | (string | string[])[];
  variables?: GlobalVariables;
  cache?: CacheItem | CacheItem[];
  "!reference"?: Reference;
  default?: {
    after_script?: string | (string | string[])[];
    artifacts?: Artifacts;
    before_script?: string | (string | string[])[];
    hooks?: Hooks;
    cache?: Cache;
    image?: Image;
    interruptible?: Interruptible;
    id_tokens?: IdTokens;
    identity?: Identity;
    retry?: Retry;
    services?: Services1;
    tags?: Tags;
    timeout?: Timeout;
    "!reference"?: Reference;
  };
  /**
   * @minItems 1
   */
  stages?: [string | string[], ...(string | string[])[]];
  include?: IncludeItem | IncludeItem[];
  pages?: JobTemplate;
  workflow?: {
    name?: WorkflowName;
    auto_cancel?: WorkflowAutoCancel;
    rules?: (
      | {
          [k: string]: unknown;
        }
      | [string, ...string[]]
    )[];
    [k: string]: unknown;
  };
  [k: string]: Job;
}
export interface InputParameters {
  /**
   * This interface was referenced by `InputParameters`'s JSON-Schema definition
   * via the `patternProperty` ".*".
   */
  [k: string]: {
    [k: string]: unknown;
  } | null;
}
export interface JobVariables {
  /**
   * This interface was referenced by `JobVariables`'s JSON-Schema definition
   * via the `patternProperty` ".*".
   *
   * This interface was referenced by `JobVariables1`'s JSON-Schema definition
   * via the `patternProperty` ".*".
   */
  [k: string]:
    | (boolean | number | string)
    | {
        value?: string;
        expand?: boolean;
      };
}
export interface GlobalVariables {
  /**
   * This interface was referenced by `GlobalVariables`'s JSON-Schema definition
   * via the `patternProperty` ".*".
   */
  [k: string]:
    | (boolean | number | string)
    | {
        value?: string;
        /**
         * @minItems 1
         */
        options?: [string, ...string[]];
        description?: string;
        expand?: boolean;
      };
}
export interface CacheItem {
  key?:
    | string
    | {
        /**
         * @minItems 1
         * @maxItems 2
         */
        files?: [string] | [string, string];
        /**
         * @minItems 1
         * @maxItems 2
         */
        files_commits?: [string] | [string, string];
        prefix?: string;
        [k: string]: unknown;
      };
  paths?: string[];
  policy?: string;
  unprotect?: boolean;
  untracked?: boolean;
  when?: "on_success" | "on_failure" | "always";
  /**
   * @maxItems 5
   */
  fallback_keys?:
    | []
    | [string]
    | [string, string]
    | [string, string, string]
    | [string, string, string, string]
    | [string, string, string, string, string];
  [k: string]: unknown;
}
export interface Hooks {
  pre_get_sources_script?: string | (string | string[])[];
}
export interface IdTokens {
  /**
   * This interface was referenced by `IdTokens`'s JSON-Schema definition
   * via the `patternProperty` ".*".
   */
  [k: string]: {
    aud: string | [string, ...string[]];
  };
}
export interface Inputs {
  /**
   * Input parameter value that matches parameter names defined in spec:inputs of the included configuration.
   *
   * This interface was referenced by `Inputs`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z0-9_-]+$".
   */
  [k: string]:
    | string
    | number
    | boolean
    | (
        | string
        | number
        | boolean
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }[]
      )[]
    | {
        [k: string]: unknown;
      }
    | null;
}
export interface RulesVariables {
  /**
   * This interface was referenced by `RulesVariables`'s JSON-Schema definition
   * via the `patternProperty` ".*".
   */
  [k: string]: boolean | number | string;
}
export interface JobVariables1 {
  /**
   * This interface was referenced by `JobVariables`'s JSON-Schema definition
   * via the `patternProperty` ".*".
   *
   * This interface was referenced by `JobVariables1`'s JSON-Schema definition
   * via the `patternProperty` ".*".
   */
  [k: string]:
    | (boolean | number | string)
    | {
        value?: string;
        expand?: boolean;
      };
}
export interface Secrets {
  /**
   * This interface was referenced by `Secrets`'s JSON-Schema definition
   * via the `patternProperty` ".*".
   */
  [k: string]: {
    [k: string]: unknown;
  };
}
export interface StepNamedStrings {
  /**
   * This interface was referenced by `StepNamedStrings`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z_][a-zA-Z0-9_]*$".
   */
  [k: string]: string;
}
export interface StepNamedValues {
  /**
   * This interface was referenced by `StepNamedValues`'s JSON-Schema definition
   * via the `patternProperty` "^[a-zA-Z_][a-zA-Z0-9_]*$".
   */
  [k: string]:
    | string
    | number
    | boolean
    | null
    | unknown[]
    | {
        [k: string]: unknown;
      };
}
/**
 * GitReference is a reference to a step in a Git repository.
 */
export interface StepGitReference {
  git: {
    url: string;
    dir?: string;
    rev: string;
    file?: string;
  };
}
/**
 * OCIReference is a reference to a step hosted in an OCI repository.
 */
export interface StepOciReference {
  oci: {
    /**
     * The <host>[:<port>] of the container registry server.
     */
    registry: string;
    /**
     * A path within the registry containing related OCI images. Typically the namespace, project, and image name.
     */
    repository: string;
    /**
     * A pointer to the image manifest hosted in the OCI repository.
     */
    tag: string;
    /**
     * A directory inside the OCI image where the step can be found.
     */
    dir?: string;
    /**
     * The name of the file that defines the step, defaults to step.yml.
     */
    file?: string;
  };
}
/**
 * Exec is a command to run.
 */
export interface StepExec {
  /**
   * Command are the parameters to the system exec API. It does not invoke a shell.
   *
   * @minItems 1
   */
  command: [string, ...string[]];
  /**
   * WorkDir is the working directly in which `command` will be exec'ed.
   */
  work_dir?: string;
}
/**
 * Define the rules for when pipeline should be automatically cancelled.
 */
export interface WorkflowAutoCancel {
  on_job_failure?: "none" | "all";
  on_new_commit?: "conservative" | "interruptible" | "none";
}

/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type PatternDtoNullable = {
  /**
   * Whether to ignore case.
   */
  ignore_case?: boolean & string;
  /**
   * Whether to invert the match.
   */
  inverted?: boolean & string;
  /**
   * A regex pattern used to match, cannot be empty. If you need a pattern that matches every string use ".*"
   */
  pattern: string;
} | null;
export type PatternWithRewriteDtoNullable = {
  regex?: PatternDtoNullable & {
    [k: string]: unknown;
  };
  /**
   * The rewrite expression.
   */
  substitution?: string | null;
} | null;
export type SimplePatternDtoNullable = {
  /**
   * The actual pattern.
   */
  pattern?: string | null;
} | null;
export type PatternWithoutInvertDtoNullable = null | PatternWithoutInvertDto;
export type ExpertSettingsDtoNullable = {
  /**
   * Expert settings for the Apache httpd.
   */
  apache?: string | null;
  /**
   * Expert settings for the Security Gate.
   */
  security_gate?: string | null;
} | null;
export type SimpleHeaderActionDtoNullable = {
  /**
   * The name of the header to add.
   */
  name?: string | null;
  /**
   * The value of the header to add.
   */
  value?: string | null;
} | null;
export type RemoveHeaderActionDtoNullable = {
  name?: PatternDtoNullable & {
    [k: string]: unknown;
  };
  value?: PatternDtoNullable & {
    [k: string]: unknown;
  };
} | null;
export type RewriteHeaderValueDtoNullable = {
  name?: PatternDtoNullable & {
    [k: string]: unknown;
  };
  /**
   * A string to rewrite the header value with. Can make back-references to the header value pattern.
   */
  replace?: string | null;
  value?: PatternDtoNullable & {
    [k: string]: unknown;
  };
} | null;

export interface AirlockMicrogateway3 {
  apps?: {
    mappings?: {
      access_token?: {
        /**
         * If the 'sub' claim should be extracted from the JWT and be used as audit token of the current session
         */
        audittoken?: boolean | null;
        /**
         * All specified claims are checked and must match the claim's value of the decoded token. If a claim is an array, at least one entry must match the specified regex.
         */
        claims?: {
          /**
           * The name of the claim you want to restrict.
           */
          claim?: string | null;
          regex?: PatternDtoNullable & {
            [k: string]: unknown;
          };
        }[];
        /**
         * If the JWT standard claims expiry (exp) and not before (nbf) will be checked and must be valid.
         */
        expiry_checked?: boolean | null;
        /**
         * How the token should be extracted.
         */
        extraction?: {
          /**
           * From which cookie the token should be extracted.
           */
          cookie?: string | null;
          header?: PatternWithRewriteDtoNullable & {
            [k: string]: unknown;
          };
          /**
           * From which part of the request the token should be extracted. Possible values are 'header', 'parameter', 'cookie'.
           */
          mode?: null | ("header" | "parameter" | "cookie");
          /**
           * From which query parameter the token should be extracted.
           */
          parameter?: string | null;
        } | null;
        /**
         * List of JWKS service providers referenced by their name. Can be local or remote providers.
         */
        jwks_providers?: string[];
        /**
         * If disabled, requests without a token are accepted. However, if a token is present,it is extracted and validated and the configured restrictions and role extractions are applied.
         */
        mandatory?: boolean | null;
        /**
         * Specifies which roles should be extracted from the claims.
         */
        roles?: {
          /**
           * Name of the claim you want to extract a role from.
           */
          claim?: string | null;
          extraction?: PatternWithRewriteDtoNullable & {
            [k: string]: unknown;
          };
          /**
           * If enabled, the expiry claim (exp) of the JWT will be used as the role lifetime.
           */
          token_lifetime?: boolean | null;
        }[];
        /**
         * Enforce a signed JWT
         */
        signature_mandatory?: boolean | null;
        /**
         * The allowed skew when checking expiry / not before in seconds.
         */
        skew?: number | null;
        /**
         * The claim to extract the technical client id from.
         */
        tech_client_id_claim?: string | null;
      } | null;
      allow_rules?: {
        content_type?: PatternDtoNullable & {
          [k: string]: unknown;
        };
        /**
         * Enable the allow rule.
         */
        enabled?: boolean & string;
        /**
         * Whether to log requests not matching this allow rule instead of blocking them.
         */
        log_only?: boolean & string;
        method?: PatternDtoNullable & {
          [k: string]: unknown;
        };
        /**
         * Unique name for the allow rule. If omitted, a unique name will be generated. To enable/disable the default allow rule or one from a mapping_template_file, use the same name.
         */
        name?: string;
        path?: PatternDtoNullable & {
          [k: string]: unknown;
        };
      }[];
      api_security?: {
        json_content_type?: PatternDtoNullable & string;
        /**
         * The specification to validate against.
         */
        openapi?: {
          /**
           * If enabled, potential attack requests are only logged but not blocked.
           */
          log_only?: boolean | null;
          /**
           * The Microgateway mapping can be configured to rewrite the incoming URL to a different back-end URL (asymmetric mappings). Due to this rewriting, the incoming URL path (client_view) will be different from the back-end URL path (backend_view).
           */
          path_matching?: null | ("client_view" | "backend_view");
          /**
           * Check responses against API specification.
           */
          response_validation?: boolean | null;
          /**
           * The OpenAPI specification.
           */
          spec?: string | null;
          /**
           * The OpenAPI file path.
           */
          spec_file?: string | null;
        } | null;
        /**
         * If enabled, Microgateway parses JSON objects in requests and filters JSON attributes with allow rules and deny rules.
         */
        treat_json_objects_as_parameters?: boolean | null;
        /**
         * If enabled, each path segment is interpreted as a separate parameter value and the deny rules for parameter values are applied to it.
         */
        treat_path_segments_as_parameters?: boolean | null;
      } | null;
      auth?: {
        /**
         * A list of access restrictions can be created. Each request matching the combination of HTTP method and path of a access restriction must have at least one of the specified roles to access the service. All matching restrictions must be satisfied to gain access.
         */
        access?: {
          method?: PatternDtoNullable & {
            [k: string]: unknown;
          };
          path?: PatternDtoNullable & {
            [k: string]: unknown;
          };
          /**
           * Can contain a list of roles for this service. Only sessions that have at least one of these roles will be able to access the service.
           */
          roles?: string[];
        }[];
        client_certificate?: {
          /**
           * The client certificate verification mode to use on this mapping. This can be used to override the setting from the virtual host with a stronger verification level (e.g. off -> optional or optional -> required). Possible values are 'inherit', 'optional' or 'required'.
           */
          verification?: "inherit" | "optional" | "required";
        } | null;
        /**
         * Defines the location of the authentication service. In case the required role for the mapping is missing on the current session, Airlock Gateway will redirect the client to this location. If this value is missing (default), the Global Denied Access URL will be used.
         */
        denied_access_url?: string | null;
        /**
         * The authentication flow, allowed values are: redirect, deny_access, one_shot, one_shot_with_body, ntlm
         */
        flow?: null | ("redirect" | "deny_access" | "one_shot" | "one_shot_with_body" | "ntlm");
        /**
         * In order to allow clean session termination on back-end systems when an Airlock Gateway session terminates, the administrator can configure one logout path per mapping.
         */
        logout_propagation_path?: string | null;
      } | null;
      backend?: {
        expert_settings?: {
          /**
           * Expert settings for the Security Gate.
           */
          security_gate?: string | null;
        } | null;
        hosts?: {
          /**
           * The hostname of the back-end host. Only characters a-Z, numbers, and the special characters '.', ':',  '-' and '_' are allowed.
           */
          name?: string;
          /**
           * Configuring a back-end port.
           */
          port?: number & string;
          /**
           * Allowed values are: http, https
           */
          protocol?: "https" | "http";
        }[];
        /**
         * The unique name of the back-end. Only characters a-Z, numbers, and the special characters '.', ':',  '-' and '_' are allowed.
         */
        name?: string;
      } | null;
      /**
       * The back-end path specifies the internal back-end path, i.e. the path of the request sent to the application server.
       */
      backend_path?: string | null;
      /**
       * Specifies whether Airlock Microgateway should compress the output on-the-fly for the client browser if supported and requested by the browser.
       */
      compress_response_traffic?: boolean | null;
      /**
       * Specifies whether the connected back-end service is allowed to use the Airlock Microgateway Control API via the control cookie mechanism. The Control API is normally used by authentication applications to communicate with the Microgateway.
       */
      control_api?: boolean | null;
      cookies?: {
        encrypted?: SimplePatternDtoNullable & {
          [k: string]: unknown;
        };
        passthrough?: SimplePatternDtoNullable & {
          [k: string]: unknown;
        };
      } | null;
      csrf_token?: {
        /**
         * Whether to enable automatic CSRF token injection and validation on this mapping.
         */
        enabled?: boolean | null;
        /**
         * All incoming URLs that match one of these patterns are accepted by Airlock Microgateway without a valid CSRF token.
         */
        exceptions?:
          | {
              path?: PatternWithoutInvertDtoNullable;
            }[]
          | null;
        /**
         * Specifies the location (e.g. /index.html) to which the client is redirected if a missing or invalid CSRF token is detected.
         */
        invalid_token_redirect_location?: string | null;
      } | null;
      deny_rule_groups?: {
        /**
         * Enable deny rule group
         */
        enabled?: boolean | null;
        exceptions?: {
          content_type?: PatternDtoNullable;
          header_name?: PatternDtoNullable;
          header_value?: PatternDtoNullable;
          method?: PatternDtoNullable;
          parameter_name?: PatternDtoNullable;
          parameter_value?: PatternDtoNullable;
          path?: PatternDtoNullable;
        }[];
        /**
         * Allowed values are: basic, standard, strict.
         */
        level?: null | ("basic" | "standard" | "strict");
        /**
         * If enabled, offending requests are not blocked but only logged
         */
        log_only?: boolean | null;
        /**
         * If deny rule group key is defined, the settings will only affect the specific deny rule group.
         */
        rule_group_keys?: string[];
      }[];
      /**
       * The entry path specifies the external URL path the mapping should be available under.
       */
      entry_path?: {
        /**
         * Whether a trailing slash is mandatory at the end of the entry path or not.
         */
        enforce_trailing_slashes?: boolean | null;
        /**
         * Whether to ignore case.
         */
        ignore_case?: boolean | null;
        /**
         * Allowed values are: directory, regex.
         */
        type?: null | ("directory" | "regex");
        /**
         * This specifies the external URL path.
         */
        value?: string | null;
      } | null;
      /**
       * Specifies whether Airlock environment cookies containing useful request information are sent to the connected back-end.
       */
      env_cookies?: boolean | null;
      expert_settings?: ExpertSettingsDtoNullable;
      limits?: {
        /**
         * The limits for HTTP parameters.
         */
        http_limits?: {
          /**
           * Defines the maximum length of a parameter name in bytes.
           */
          max_parameter_name_length?: number | null;
          /**
           * Defines the maximum length for a parameter value in bytes.
           */
          max_parameter_value_length?: number | null;
          /**
           * Defines the maximum number of parameters inside the request.
           */
          max_parameters?: number | null;
          parameter_length_exception?: PatternDtoNullable & {
            [k: string]: unknown;
          };
        } | null;
        /**
         * The limits for JSON structures.
         */
        json_limits?: {
          /**
           * Defines the maximum number of items in a single JSON array (non-recursive).
           */
          max_array_items?: number | null;
          /**
           * Defines the maximum length for a JSON key, also known as 'JSON property' or 'JSON object member' in bytes.
           */
          max_key_length?: number | null;
          /**
           * Defines the maximum number of keys of a single JSON object (non-recursive).
           */
          max_keys?: number | null;
          max_length_exception?: PatternDtoNullable & {
            [k: string]: unknown;
          };
          /**
           * Defines the maximum depth of nesting for JSON objects and JSON arrays.
           */
          max_nesting_depth?: number | null;
          /**
           * Defines the maximum number of keys and array items in the whole JSON document (recursive).
           */
          max_total_entries?: number | null;
          /**
           * Defines the maximum length for a JSON value (string or numbers) in bytes.
           */
          max_value_length?: number | null;
        } | null;
        /**
         * Defines the maximum path length for requests to the current mapping in bytes.
         */
        max_path_length?: number | null;
        /**
         * The maximum allowed total size of the request body in bytes. It specifies the number of bytes from 0 (meaning unlimited) to 2147483647 (2GB) that are allowed in the request body. To restrict the size of file uploads, set this limit to the maximum combined size of all files uploaded at once.
         */
        max_request_body_size?: number | null;
      } | null;
      /**
       * The Airlock Gateway mapping template file path.
       */
      mapping_template_file?: string | null;
      /**
       * The unique name of the mapping.
       */
      name?: string | null;
      /**
       * Allowed values are: production, integration.
       */
      operational_mode?: null | ("production" | "integration");
      parameter_pollution?: {
        mixed_type?: {
          /**
           * If enabled, requests are blocked if they contain the same parameter names with different parameter types (e.g. "id" is present as a POST parameter and as a query parameter simultaneously).
           */
          block_duplicates?: boolean | null;
          /**
           * If enabled, offending requests are not blocked but only logged.
           */
          log_only?: boolean | null;
          parameter_name_exception?: PatternDtoNullable & {
            [k: string]: unknown;
          };
        } | null;
        same_type?: {
          /**
           * If enabled, all the different values of a repeated parameter are joined by comma (in order of appearance). The aggregate value is then checked against deny rules (instead of the individual values).
           */
          join_duplicates?: boolean | null;
        } | null;
      } | null;
      /**
       * Specifies the priority of this mapping (highest: -999, lowest: 999) when a request matches the entry path of multiple mappings.
       * All mappings with entry_path.type regex must have a unique priority.
       */
      priority?: number | null;
      request?: {
        /**
         * A list of request custom actions executed in order of appearance. Only one action type (e.g. add_header or header_redirect) can be specified in each entry. Create multiple list positions if needed.
         */
        custom_actions?:
          | {
              add_header?: SimpleHeaderActionDtoNullable & {
                [k: string]: unknown;
              };
              add_missing_header?: SimpleHeaderActionDtoNullable & {
                [k: string]: unknown;
              };
              add_or_replace_header?: SimpleHeaderActionDtoNullable & {
                [k: string]: unknown;
              };
              /**
               * An action to redirect to a URL based on the geographic location of the request source IP.
               */
              geolocation_redirect?: {
                /**
                 * A list of alpha-2 continent codes to redirect clients from. See here: https://en.wikipedia.org/wiki/List_of_sovereign_states_and_dependent_territories_by_continent_(data_file)
                 */
                continent_codes?: string[] | null;
                /**
                 * A list of country codes to redirect clients from. See here for alpha-2 codes to use: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
                 */
                country_codes?: string[] | null;
                /**
                 * The http status code to use on redirect
                 */
                status_code?: number | null;
                /**
                 * The url to redirect to.
                 */
                target_url?: string | null;
              } | null;
              /**
               * An action to redirect to a URL based on a header name or value either matching the given name or value pattern on requests.
               */
              header_redirect?: {
                name?: PatternDtoNullable & {
                  [k: string]: unknown;
                };
                /**
                 * The http status code to use on redirect
                 */
                status_code?: number | null;
                /**
                 * The url to redirect to.
                 */
                target_url?: string | null;
                value?: PatternDtoNullable & {
                  [k: string]: unknown;
                };
              } | null;
              /**
               * A unique name for this action; if not specified, a unique name will be generated.
               */
              name?: string;
              remove_header?: RemoveHeaderActionDtoNullable & {
                [k: string]: unknown;
              };
              rewrite_header_value?: RewriteHeaderValueDtoNullable & {
                [k: string]: unknown;
              };
            }[]
          | null;
        default_actions?: DefaultActionDto[] | null;
      } | null;
      response?: {
        /**
         * A list of request custom actions executed in order of appearance. Only one action type (e.g. add_header or header_redirect) can be specified in each entry. Create multiple list positions if needed.
         */
        custom_actions?:
          | {
              add_header?: SimpleHeaderActionDtoNullable & {
                [k: string]: unknown;
              };
              add_missing_header?: SimpleHeaderActionDtoNullable & {
                [k: string]: unknown;
              };
              add_or_replace_header?: SimpleHeaderActionDtoNullable & {
                [k: string]: unknown;
              };
              /**
               * A unique name for this action; if not specified, a unique name will be generated.
               */
              name?: string;
              remove_header?: RemoveHeaderActionDtoNullable & {
                [k: string]: unknown;
              };
              /**
               * An action to rewrite a cookie based on patterns for cookie name, domain etc.
               */
              rewrite_cookie?: {
                cookie?: PatternDtoNullable & {
                  [k: string]: unknown;
                };
                domain?: PatternWithoutInvertDtoNullable & {
                  [k: string]: unknown;
                };
                /**
                 * What to replace the domain with; Can make back references to the pattern used to match.
                 */
                domain_replace?: string | null;
                /**
                 * Whether to `add`, `keep` or `remove` the `HttpOnly` (see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#HttpOnly) flag on cookies. AUTO will set the flag for encrypted cookies and KEEP it for others.
                 */
                http_only_mode?: "auto" | "keep" | "remove" | "add";
                path?: PatternWithoutInvertDtoNullable & {
                  [k: string]: unknown;
                };
                /**
                 * What to replace the path with; Can make back references to the pattern used to match.
                 */
                path_replace?: string | null;
                /**
                 * Whether to `add`, `keep` or `remove` the `Secure` (see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#Secure) flag on cookies. AUTO will set the flag on all connections that use HTTPS and remove it on others.
                 */
                secure_mode?: "auto" | "keep" | "remove" | "add";
              } | null;
              rewrite_header_value?: RewriteHeaderValueDtoNullable & {
                [k: string]: unknown;
              };
              /**
               * An action to rewrite the raw value of a cookie matching the given pattern.
               */
              rewrite_raw_cookie?: {
                /**
                 * A string to rewrite value pattern matches in the cookie value. Can make back references to the pattern used for matching.
                 */
                replace?: string | null;
                value?: PatternWithoutInvertDtoNullable & {
                  [k: string]: unknown;
                };
              } | null;
            }[]
          | null;
        default_actions?: DefaultActionDto[] | null;
        /**
         * Replacement rules for error responses returned by backend systems.
         */
        error_page_replacements?:
          | {
              /**
               * Error page file name that will be delivered to the client. (eg. 400.html)
               */
              page?: string | null;
              status_code?: SimplePatternDtoNullable & {
                [k: string]: unknown;
              };
            }[]
          | null;
        rewrites?: {
          /**
           * Rewrite the body of HTTP response.
           */
          any?: {
            content?: PatternWithoutInvertDtoNullable & {
              [k: string]: unknown;
            };
            /**
             * A response from the back-end server is rewritten only if the response header «Content-Type» matches this regular expression.
             */
            content_type?: string;
            /**
             * This is the target string which will replace the string matched by Content Pattern
             */
            to?: string | null;
          }[];
          /**
           * Rewriting HTML content may be necessary to modify URLs in the HTML content if the application creates absolute or incorrect links because it is not reverse proxy compatible
           */
          html?: {
            /**
             * This list defines the content to rewrite. Possible values are 'url', event', 'embedded'.
             */
            options?: string & ("url" | "event" | "embedded")[];
            /**
             * This is the target string which will replace the string matched by URL Pattern
             */
            to?: string | null;
            url?: PatternWithoutInvertDtoNullable & {
              [k: string]: unknown;
            };
          }[];
          /**
           * Rewrite the json body of http responses.
           */
          json?: {
            content?: PatternWithoutInvertDtoNullable & {
              [k: string]: unknown;
            };
            /**
             * The json path of the the property to rewrite.
             */
            path?: string;
            /**
             * This is the target content to replace the matched part with.
             */
            replace?: string;
          }[];
          /**
           * Rewrite option to modify the HTTP redirect location header sent from the back-end server before it is sent to the client.
           */
          location_header?: {
            /**
             * This is the target string which will replace the string matched by URL Pattern
             */
            to?: string | null;
            url?: PatternWithoutInvertDtoNullable & {
              [k: string]: unknown;
            };
          }[];
        } | null;
      } | null;
      /**
       * Allowed values are: enforce_session, optional_session, optional_session_no_refresh, ignore_session
       */
      session_handling?:
        | null
        | ("enforce_session" | "optional_session" | "optional_session_no_refresh" | "ignore_session");
      /**
       * Allowed values are: block, terminate_session, notify.
       */
      threat_handling?: null | ("terminate_session" | "block" | "notify");
      timeouts?: {
        /**
         * Defines the time in seconds Airlock Microgateway will wait for the back-end HTTP response. In case the request runs into the timeout, Airlock Microgateway will deliver an error page with the corresponding HTTP 503 status code.
         */
        backend_http_response?: number | null;
        /**
         * Defines the minimum session idle time in seconds for this mapping. The value will be ignored if minimum session idle timeout is smaller or equal to the global session idle timeout setting.
         */
        idle_session?: number | null;
      } | null;
    }[];
    virtual_host?: {
      /**
       * Additional hostnames which refer to this virtual host.
       */
      aliases?: string[];
      auth?: {
        client_certificate?: {
          /**
           * The concatenated certificates of the CAs which are sent to the client during the SSL handshake, in PEM format.
           */
          ca_selection?: string | null;
          /**
           * The file containing the selection CA certificates.
           */
          ca_selection_file?: string | null;
          /**
           * The concatenated certificates of the CAs which are used as trust anchor during chain validation, in PEM format.
           */
          ca_validation?: string | null;
          /**
           * The file containing the validation CA certificates.
           */
          ca_validation_file?: string | null;
          /**
           * PEM representation of certificate revocation lists. If a client certificate is on such a list it will not be accepted. Although Airlock provides this functionality, it is recommended to check certificates against CRLs and other types of blacklists within the authentication service and not in Airlock.
           */
          crl?: string | null;
          /**
           * The file containing the crl.
           */
          crl_file?: string | null;
          /**
           * Defines the default verification mode for client certificates on this virtual host. Possible values are 'off', 'optional' or 'required'.
           */
          verification?: "off" | "optional" | "required";
          /**
           * Maximum number of intermediate certificate issuers.
           */
          verification_depth?: number & string;
        } | null;
      } | null;
      certificate?: {
        /**
         * List of certificates of the CA chain for the certificate.
         */
        ca_chain?: string | null;
        /**
         * The CA chain file path.
         */
        ca_chain_file?: string | null;
        /**
         * The certificate in PEM format.
         */
        certificate?: string | null;
        /**
         * The certificate file path.
         */
        certificate_file?: string | null;
        /**
         * The private key for the certificate in PEM format.
         */
        privatekey?: string | null;
        /**
         * The private key file path
         */
        privatekey_file?: string | null;
      } | null;
      /**
       * Specifies whether encoded slashes (%2F) are allowed in URL path. Attention: combinations of client certificates per mapping and enabled encoded slashes in the same virtual host might result in configurations where client certificate evaluation might be evaded.
       */
      encoded_slashes?: boolean & string;
      expert_settings?: ExpertSettingsDtoNullable;
      /**
       * The hostname of the virtual host.
       */
      hostname?: string;
      /**
       * Specifies whether HTTP/2 connections are enabled for this host.
       */
      http2_enabled?: boolean & string;
      /**
       * Specifies whether HTTP connections are enabled for this host.
       */
      http_enabled?: boolean & string;
      /**
       * Specifies the port on which this host listens for HTTP connections.
       */
      http_port?: number & string;
      /**
       * Specifies whether HTTPS connections are enabled for this host.
       */
      https_enabled?: boolean & string;
      /**
       * Specifies the port on which this host listens for HTTPS connections.
       */
      https_port?: number & string;
      /**
       * The logical name of the virtual host.
       */
      name?: string;
      redirects?:
        | {
            /**
             * The destination can be relative to the current virtual host or an absolute URL including protocol and host. Relative redirect paths are extended with the incoming scheme and host header.
             */
            dest: string;
            path: PatternWithoutInvertDto & {
              [k: string]: unknown;
            };
            /**
             * The returned status code. Must be one of: [301, 302, 303, 307, 308]
             */
            status_code?: number & string;
          }[]
        | null;
      /**
       * Specifies the domain for Airlock’s session cookie if the cookie is created inside this virtual host.
       */
      session_cookie_domain?: string | null;
      /**
       * Specifies the cookie path for Airlock’s session cookie if the cookie is created inside this virtual host.
       */
      session_cookie_path?: string;
      /**
       * Specifies whether a virtual host should reply only to requests that match the hostname or any of its server alias names.
       */
      strict_fqdn?: boolean & string;
    } | null;
  }[];
  /**
   * Custom deny rule groups that can be referenced in mappings on top of the built in Airlock deny rules.
   */
  deny_rule_groups?: {
    /**
     * Filter rule that blocks requests based on the evaluation of different request attributes.
     */
    deny_rules?: {
      content_type?: PatternDtoNullable;
      header_name?: PatternDtoNullable;
      header_value?: PatternDtoNullable;
      method?: PatternDtoNullable;
      /**
       * Unique name. In order to prevent overriding built-in deny rules, the name may not start with '(default)'.
       */
      name?: string;
      parameter_name?: PatternDtoNullable;
      parameter_value?: PatternDtoNullable;
      path?: PatternDtoNullable;
      /**
       * Unique short name. In order to prevent overriding built-in deny rules, the name may not start with '(default)'.
       */
      rule_key?: string;
    }[];
    /**
     * Unique name. In order to prevent overriding built-in deny rule group, the name may not start with '(default)'.
     */
    name?: string;
    /**
     * Unique short name. In order to prevent overriding built-in deny rule group, the name may not start with '(default)'.
     */
    rule_group_key?: string;
  }[];
  expert_settings?: ExpertSettingsDtoNullable;
  /**
   * JWKS Providers which can be referenced in apps[].mappings[].access_token.
   */
  jwks_providers?: {
    /**
     * JWKS providers that are configured statically.
     */
    local?: string & string[];
    /**
     * Refresh interval for fetching from remote JWKS providers in seconds.
     */
    refresh_interval?: number & string;
    /**
     * Remote JWKS providers which are fetched according to the jwks_providers.refresh_interval.
     */
    remote?: string & string[];
  } | null;
  /**
   * The encoded license.
   */
  license?: string | null;
  /**
   * The license file path.
   */
  license_file?: string | null;
  log?: {
    /**
     * Allowed values are: info, trace
     */
    level?: "info" | "trace";
  } | null;
  /**
   * Configuration for metrics sending.
   */
  metrics?: {
    /**
     * Use this to enable sending metrics using the statsd protocol.
     */
    statsd?: {
      /**
       * Enable sending of statsd metrics. Default is 'true'
       */
      enabled?: boolean & string;
    };
  };
  remote_ip?: {
    /**
     * If set, Airlock Microgateway will treat the value of this header field as the useragent IP address.<br />Common values are 'X-Forwarded-For' or 'X-Client-IP'.<br /><strong>Warning</strong>: Make sure that internal_proxies is correctly configured for your setup.
     */
    header: string;
    /**
     * List of hostnames, IP addresses or IP address ranges (e.g. 10.0.0.0/8) to trust as presenting a valid Remote-IP header.
     */
    internal_proxies: string[];
  } | null;
  session?: {
    /**
     * Specifies the passphrase for the passphrase based encryption mechanism (PBE).
     */
    encryption_passphrase?: string | null;
    /**
     * The path of the passphrase file.
     */
    encryption_passphrase_file?: string | null;
    /**
     * Specifies the amount of idle time in seconds, after which an Airlock Microgateway session is terminated. This timeout should be smaller than all other session timeouts of your back-end applications. Even if the timeout can be configured in seconds, per default the resolution of the idle session timeout check is 5 seconds only.
     */
    idle_timeout?: number & string;
    /**
     * Specifies the absolute lifetime of an Airlock Microgateway session in seconds. After this time a session will be terminated.
     */
    lifetime?: number & string;
    /**
     * Name of the hosts running the Redis Server.
     */
    redis_hosts?: string & string[];
    /**
     * Defines the redis session store connection mode. By default, the Microgateway tries to determine the connection mode depending on the number of redis hosts configured:<br />- server mode if only one host is configured<br />- cluster mode if several hosts are configured<br /><br />Allowed values are: server, cluster and disabled.
     */
    store_mode?: "server" | "cluster" | "disabled";
  } | null;
}
export interface PatternWithoutInvertDto {
  /**
   * Whether to ignore case.
   */
  ignore_case?: boolean & string;
  /**
   * A regex pattern used to match, cannot be empty. If you need a pattern that matches every string use ".*"
   */
  pattern: string;
}
export interface DefaultActionDto {
  /**
   * Enable this default header action
   */
  enabled?: boolean | null;
  /**
   * Name of the default header action
   */
  name?: string | null;
}

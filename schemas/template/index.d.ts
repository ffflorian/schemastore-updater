/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Guid = string;
export type Source = Modifier;
export type Ice = string[] | string;
/**
 * Indicates limitations on the valid values a symbol may be assigned. At this point, the only valid datatype is "choice", which also requires providing symbols.choices configuration for the symbol.
 */
export type Datatype =
  | ("choice" | "bool" | "float" | "int" | "hex" | "text")
  | {
      [k: string]: any;
    };

export interface JsonSchemaNetTemplateFiles {
  /**
   * The author of the template
   */
  author: string;
  /**
   * Zero or more characteristics of the template that a user might search for it by
   */
  classifications: string[];
  /**
   * The name to use during creation if no name has been specified and no other opinionation about naming has been provided from the host
   */
  defaultName?: string;
  /**
   * The semantic version range of the Microsoft.TemplateEngine.Orchestrator.RunnableProjects package that this template is usable with. In older versions of the engine, the four octet version string is used but is matched against a constant which was never changed from 1.0.0.0 - either syntax is now accepted, however the four octet string will not be changed from 1.0.0.0
   */
  generatorVersions?: string;
  /**
   * The ID of the group this template belongs to. When combined with the "tags" section, this allows multiple templates to be displayed as one, with the the decision for which one to use being presented as a choice in each one of the pivot categories (keys).
   */
  groupIdentity?: string;
  /**
   * A list of guids which appear in the template source and should be replaced in the template output. For each guid listed, a replacement guid is generated, and replaces all occurrences of the source guid in the output.
   */
  guids?: Guid[];
  /**
   * A unique name for this template
   */
  identity: string;
  /**
   * The name for the template that users should see
   */
  name: string;
  /**
   * A filename that will be completely ignored except to indicate that its containing directory should be copied. This allows creation of an empty directory in the created template, by having a corresponding source directory containing just the placeholder file. Completely empty directories are ignored.
   */
  placeholderFilename?: string;
  /**
   * Defines an ordered list of actions to perform after template generation. The post action information is provided to the creation broker, to act on as appropriate.
   */
  postActions?: ({
    /**
     * A guid uniquely defining the action. The value must correspond to a post-action known by the broker.
     */
    actionId: Guid;
    /**
     * A list of key-value pairs to use when performing the action. The specific parameters required / allowed are defined by the action itself.
     */
    args?: {
      [k: string]: string;
    };
    /**
     * A C++ style expression that, if it evaluates to 'false' causes the post-action to be skipped. This expression may refer to any symbols that have been defined
     */
    condition?: string;
    /**
     * Additional configuration for the associated post action. The structure & content will vary based on the post action.
     */
    configFile?: string;
    /**
     * If this action fails, the value of continueOnError indicates whether to attempt the next action, or stop processing the post actions. Should be set to true when subsequent actions rely on the success of the current action.
     */
    continueOnError?: boolean;
    /**
     * A human-readable description of the action.
     */
    description?: string;
    /**
     * An ordered list of possible instructions to display if the action cannot be performed. Each element in the list must contain a key named "text", whose value contains the instructions. Each element may also optionally provide a key named "condition" - a Boolean evaluate-able string. The first instruction whose condition is false or blank will be considered valid, all others are ignored.
     */
    manualInstructions: {
      condition?: string;
      text: string;
      [k: string]: any;
    }[];
    [k: string]: any;
  } & (
    | {
        [k: string]: any;
      }
    | {
        actionId?: "AC1156F7-BB77-4DB8-B28F-24EEBCCA1E5C";
        args?: {
          /**
           * The executable to instruct the user to run
           */
          executable?: string;
          /**
           * The arguments to instruct the user to run the executable with - if executable is not specified, this value is unused
           */
          args?: string;
          [k: string]: any;
        };
        [k: string]: any;
      }
    | {
        actionId?: "3A7C4B45-1F5D-4A30-959A-51B88E82B5D2";
        args?: {
          /**
           * Whether or not to redirect stdout for the process (prevents output from being displayed if true)
           */
          redirectStandardOutput?: "true" | "false";
          /**
           * The executable to run
           */
          executable: string;
          /**
           * The arguments to supply to the executable
           */
          args?: string;
          [k: string]: any;
        };
        [k: string]: any;
      }
    | {
        actionId?: "B17581D1-C5C9-4489-8F0A-004BE667B814";
        args?: {
          /**
           * The type of reference to add. project = A project to project reference. package = A NuGet package reference. framework - A framework assembly reference.
           */
          referenceType: "project" | "package" | "framework";
          /**
           * Must be a literal extension for the project file(s) of interest, may be a semicolon delimited list. If unspecified, any project file (*.*proj) is allowed
           */
          projectFileExtensions?: string;
          /**
           * The reference to be added (if referenceType=package, this is the package ID; if referenceType=framework, this is the path or assembly name; if referenceType=project, this is the path to the project reference to add)
           */
          reference: string;
          /**
           * The version of the package reference to add, applicable only if referenceType=package
           */
          version?: string;
          [k: string]: any;
        };
        [k: string]: any;
      }
    | {
        actionId?: "cb9a6cf3-4f5c-4860-b9d2-03a574959774";
        args?: {
          [k: string]: any[] | string;
        };
        [k: string]: any;
      }
    | {
        actionId?: "210D431B-A78B-4D2F-B762-4ED3E3EA9025";
        args?: any;
        [k: string]: any;
      }
    | {
        actionId?: "D396686C-DE0E-4DE6-906D-291CD29FC5DE";
        args?: {
          /**
           * A semicolon delimited list of indexes of the primary outputs that should be added to the solution, if not specified, all primary outputs are used
           */
          primaryOutputIndexes?: string;
          [k: string]: any;
        };
        [k: string]: any;
      }
    | {
        actionId?: "84C0DA21-51C8-4541-9940-6CA19AF04EE6";
        args?: {
          /**
           * A semicolon delimited list of indexes of the primary outputs that should be opened in the editor
           */
          files?: string;
          [k: string]: any;
        };
        [k: string]: any;
      }))[];
  /**
   * A value used to determine how preferred this template is among the other templates with the same groupIdentity (higher values are more preferred)
   */
  precedence?: number | string;
  /**
   * Indicates whether to create a directory for the template if name is specified but an output directory is not set (instead of creating the content directly in the current directory)
   */
  preferNameDirectory?: boolean;
  /**
   * A list of important output paths created during template generation. These paths need to be added to the newly created project at the end of template creation.
   */
  primaryOutputs?: {
    /**
     * The path to the file in the template content whose corresponding output file should be included as a primary output
     */
    path: string;
    /**
     * The condition for including the specified path in the primary outputs set
     */
    condition?: string;
    [k: string]: any;
  }[];
  /**
   * A shorthand name or a list of names for selecting the template (applies to environments where the template name is specified by the user - not selected via a GUI). The first entry is the preferred short name.
   */
  shortName: string | any[];
  /**
   * The name in the source tree to replace with the name the user specifies
   */
  sourceName?: string;
  /**
   * The set of mappings in the template content to user directories
   */
  sources?: Source[];
  /**
   * Custom value forms used by the template
   */
  forms?: {
    [k: string]:
      | {
          [k: string]: any;
        }
      | {
          identifier?: "lowerCaseInvariant";
          [k: string]: any;
        }
      | {
          identifier?: "xmlEncode";
          [k: string]: any;
        }
      | {
          identifier?: "safe_name";
          [k: string]: any;
        }
      | {
          identifier?: "lower_safe_name";
          [k: string]: any;
        }
      | {
          identifier?: "replace";
          /**
           * A regular expression whose matches will be replaced with the literal value specified in replacement
           */
          pattern: string;
          /**
           * The value to replace the matches of the specified pattern in the source value with
           */
          replacement: string;
          [k: string]: any;
        }
      | {
          identifier?: "safe_namespace";
          [k: string]: any;
        }
      | {
          identifier?: "chain";
          steps: string[];
          [k: string]: any;
        }
      | {
          identifier?: "lowerCase";
          [k: string]: any;
        }
      | {
          identifier?: "identity";
          [k: string]: any;
        }
      | {
          identifier?: "upperCase";
          [k: string]: any;
        }
      | {
          identifier?: "jsonEncode";
          [k: string]: any;
        };
  };
  /**
   * The symbols section defines variables and their values, the values may be the defined in terms of other symbols. When a defined symbol name is encountered anywhere in the template definition, it is replaced by the value defined in this configuration. The symbols configuration is a collection of key-value pairs. The keys are the symbol names, and the value contains key-value-pair configuration information on how to assign the symbol a value.
   */
  symbols?: {
    [k: string]:
      | {
          /**
           * Defines a symbol that has its value provided by the host
           */
          type?: "bind";
          /**
           * The name of the host property to take the value from
           */
          binding: string;
          [k: string]: any;
        }
      | {
          /**
           * The value of this symbol is derived from the value of another symbol by the application of value forms
           */
          type?: "derived";
          /**
           * The name of the symbol that the value should be derived from
           */
          valueSource: string;
          /**
           * The name of the value form that should be applied to the source value to use as the value of this symbol
           */
          valueTransform?: string;
          [k: string]: any;
        }
      | (
          | GeneratorCasing
          | GeneratorCoalesce
          | GeneratorConstant
          | GeneratorEvaluate
          | GeneratorGuid
          | GeneratorNow
          | GeneratorPort
          | GeneratorRandom
          | GeneratorRegex
          | GeneratorSwitch)
      | {
          /**
           * Defines the high level configuration of symbol
           */
          type?: "parameter";
          isRequired?: boolean;
          /**
           * An array listing the valid choices for a symbol whose datatype = choice. If not provided, there are no valid choices for the symbol, so it can never be assigned a value.
           */
          choices?: {
            /**
             * A valid value for the symbol
             */
            choice: string;
            /**
             * Help text describing the meaning of the corresponding value
             */
            description?: string;
            [k: string]: any;
          }[];
          /**
           * The value assigned to the symbol if no value for it is provided by the user or host.
           */
          defaultValue?: string;
          /**
           * The description of the parameter
           */
          description?: string;
          onlyIf?: {
            /**
             * The replacement string occurs after this value
             */
            after?: string;
            /**
             * The replacement string occurs before this value
             */
            before?: string;
            [k: string]: any;
          };
          [k: string]: any;
        }
      | {
          /**
           * Defines the high level configuration of symbol
           */
          type?: "computed";
          /**
           * An evaluate-able condition whose result defines the value of the symbol.
           */
          value?: string;
          [k: string]: any;
        };
  };
  /**
   * Alternate sets of defaults for symbols
   */
  baselines?: {
    /**
     * A named set of alternate defaults
     */
    [k: string]: {
      /**
       * A string to use to indicate the intent of the baesline
       */
      description?: string;
      /**
       * A lookup of symbol names to new defaults
       */
      defaultOverrides?: {
        /**
         * An updated default value for the specified symbol
         */
        [k: string]: string;
      };
      [k: string]: any;
    };
  };
  /**
   * Common information about templates, these are effectively interchangeable with choice type parameter symbols
   */
  tags?: {
    /**
     * The programming language the template primarily contains or is intended for use with
     */
    language?: string;
    /**
     * The type of template. Commonly this is either project or item (and special checks are performed for these values to show only project or item type templates in certain contexts) but any string is allowed
     */
    type?: ("project" | "item") | string;
    [k: string]: any;
  };
  /**
   * An URL for a document indicating any libraries used by the template that are not owned/provided by the template author
   */
  thirdPartyNotices?: string;
  /**
   * A description of the template's purpose or contents for use in help
   */
  description?: string;
  [k: string]: any;
}
export interface Modifier {
  /**
   * A list of additional source information which gets added to the top-level source information, based on evaluation the corresponding source.modifiers.condition.
   */
  modifiers?: Modifier[];
  /**
   * Boolean-evaluable condition to indicate if the sources configuration should be included or ignored. If the condition evaluates to true or is not provided, the sources config will be used for creating the template. If it evaluates to false, the sources config will be ignored.
   */
  condition?: string;
  /**
   * The set of globbing patterns indicating the content that was included by sources.include that should not be processed
   */
  exclude?: Ice;
  /**
   * The set of globbing patterns indicating the content to process in the path referred to by sources.source
   */
  include?: Ice;
  /**
   * The set of globbing patterns indicating the content that was included by sources.include, that hasn't been excluded by sources.exclude that should be placed in the user's directory without modification
   */
  copyOnly?: Ice;
  /**
   * The set of explicit renames to perform. Each key is a path to a file in the source, each value is a path to the target location - only the values will be evaluated with the information the user supplies
   */
  rename?: {
    [k: string]: string;
  };
  [k: string]: any;
}
export interface GeneratorCasing {
  generator?: "casing";
  parameters?: {
    /**
     * The name of the symbol whose value should have its case changed
     */
    source: string;
    /**
     * Whether the case changed to should be lower case, if false, the value is made to be uppercase instead
     */
    toLower?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface GeneratorCoalesce {
  generator?: "coalesce";
  parameters?: {
    /**
     * The name of the symbol whose value will be inspected - if the value is effectively equal to the default value, the value of the symbol referred to by fallbackVariableName is used, otherwise the value of this symbol
     */
    sourceVariableName: string;
    /**
     * The value to consider as being the default - if the value of the symbol referred to by sourceVariableName is equal to this, the value of the symbol referred to in fallbackVariableName is used instead
     */
    defaultValue?: string;
    /**
     * The name of the symbol to return the value of if the symbol referred to by sourceVariableName has a value equal to the value of defaultValue
     */
    fallbackVariableName: string;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface GeneratorConstant {
  generator?: "constant";
  parameters?: {
    /**
     * The value to be assigned to the symbol
     */
    action?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface GeneratorEvaluate {
  generator?: "evaluate";
  parameters?: {
    /**
     * The Boolean predicate whose evaluation result becomes the symbol value
     */
    action?: string;
    /**
     * A string indicating the predicate evaluator to evaluate the action against.
     */
    evaluator?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface GeneratorGuid {
  generator?: "guid";
  parameters?: {
    /**
     * Must be the string literal "new".
     */
    action?: "new";
    /**
     * When a string representation of the guid is needed, this is used as the format string in Guid.ToString().
     */
    format?: string;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface GeneratorNow {
  generator?: "now";
  parameters?: {
    /**
     * The format string to use when converting the date-time to a string representation.
     */
    action?: string;
    /**
     * If true, use UTC time. If false, use local time.
     */
    utc?: boolean;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface GeneratorPort {
  generator?: "port";
  parameters?: {
    /**
     * The lower bound of acceptable port numbers
     */
    low?: number;
    /**
     * The upper bound of acceptable port numbers
     */
    high?: number;
    /**
     * The port number to use if no free ports could be found
     */
    fallback?: number;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface GeneratorRandom {
  generator?: "random";
  parameters?: {
    /**
     * Must be the string literal "new"
     */
    action?: "new";
    /**
     * An integer value indicating the low-end of the range to generate the random number in.
     */
    low: number;
    /**
     * An integer value indicating the high-end of the range to generate the random number in. If not explicitly provided, defaults to int.MaxValue.
     */
    high?: number;
    [k: string]: any;
  };
  [k: string]: any;
}
export interface GeneratorRegex {
  generator?: "regex";
  parameters?: {
    /**
     * Must be the string literal "replace"
     */
    action: "replace";
    /**
     * The name of a different parameter in the template configuration. A copy of its value will be used by this generator's regex to generate the value for this parameter. The value of the source parameter is not modified
     */
    source?: string;
    /**
     * An ordered list of key-value pairs indicating the regex replacement actions. Each element of the list must contain exactly the keys 'regex' and 'replacement' - along with their values. These replacements will be applied to the result of the previous replacement (except the first, which acts on the original value from the source).
     */
    steps?: {
      /**
       * The regular expression to use to locate the sequence to replace
       */
      regex: string;
      /**
       * The replacement for any sequences matched by the supplied regular expression
       */
      replacement: string;
      [k: string]: any;
    }[];
    [k: string]: any;
  };
  [k: string]: any;
}
export interface GeneratorSwitch {
  generator?: "switch";
  parameters?: {
    /**
     * The style of evaluator to use
     */
    evaluator?: "C++" | "C++2" | "MSBUILD" | "VB";
    datatype?: Datatype;
    /**
     * The set of cases to test for. The first one, in document order, to return true's value is used, if none return true, empty string is returned
     */
    cases?: {
      /**
       * An expression to be interpreted by the specified evaluator type
       */
      condition: string;
      /**
       * The value to return if the condition evaluates to true
       */
      value: string;
      [k: string]: any;
    }[];
    [k: string]: any;
  };
  [k: string]: any;
}

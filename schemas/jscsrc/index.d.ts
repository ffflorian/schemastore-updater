/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Removes the rule.
 */
export type NullRule = null;
export type Keywords2 = Keywords21 & Keywords22;
export type Keywords21 = Keywords | boolean;
export type Keywords =
  | (
      | "break"
      | "case"
      | "catch"
      | "continue"
      | "debugger"
      | "default"
      | "delete"
      | "do"
      | "else"
      | "finally"
      | "for"
      | "function"
      | "if"
      | "in"
      | "instanceof"
      | "new"
      | "return"
      | "switch"
      | "this"
      | "throw"
      | "try"
      | "typeof"
      | "var"
      | "void"
      | "while"
      | "with"
    )[]
  | null;
export type Keywords22 =
  | ((Keywords | boolean) & unknown[])
  | (boolean & (Keywords | boolean))
  | (null & (Keywords | boolean));
export type BlockKeywords =
  | ("catch" | "do" | "else" | "finally" | "for" | "function" | "if" | "try" | "while")[]
  | null;
export type EsprimaNodeTypes =
  | (
      | "ArrayExpression"
      | "ArrayPattern"
      | "ArrowFunctionExpression"
      | "AssignmentExpression"
      | "AssignmentPattern"
      | "BinaryExpression"
      | "BlockStatement"
      | "BreakStatement"
      | "CallExpression"
      | "CatchClause"
      | "ClassBody"
      | "ClassDeclaration"
      | "ClassExpression"
      | "ConditionalExpression"
      | "ContinueStatement"
      | "DebuggerStatement"
      | "DoWhileStatement"
      | "EmptyStatement"
      | "ExportAllDeclaration"
      | "ExportDefaultDeclaration"
      | "ExportNamedDeclaration"
      | "ExportSpecifier"
      | "ExpressionStatement"
      | "ForInStatement"
      | "ForStatement"
      | "FunctionDeclaration"
      | "FunctionExpression"
      | "Identifier"
      | "IfStatement"
      | "ImportDeclaration"
      | "ImportDefaultSpecifier"
      | "ImportNamespaceSpecifier"
      | "ImportSpecifier"
      | "LabeledStatement"
      | "Literal"
      | "LogicalExpression"
      | "MemberExpression"
      | "MethodDefinition"
      | "NewExpression"
      | "ObjectExpression"
      | "ObjectPattern"
      | "Program"
      | "Property"
      | "RestElement"
      | "ReturnStatement"
      | "SequenceExpression"
      | "SpreadElement"
      | "Super"
      | "SwitchCase"
      | "SwitchStatement"
      | "TaggedTemplateExpression"
      | "TemplateElement"
      | "TemplateLiteral"
      | "ThisExpression"
      | "ThrowStatement"
      | "TryStatement"
      | "UnaryExpression"
      | "UpdateExpression"
      | "VariableDeclaration"
      | "VariableDeclarator"
      | "WhileStatement"
      | "WithStatement"
    )[]
  | null;
export type Operators =
  | (
      | ","
      | ":"
      | "?"
      | "^"
      | "^="
      | "|"
      | "||"
      | "|="
      | "&"
      | "&&"
      | "&="
      | "+"
      | "+="
      | "-"
      | "-="
      | "%"
      | "%="
      | "/"
      | "/="
      | "*"
      | "*="
      | "="
      | "=="
      | "==="
      | "!="
      | "!=="
      | ">"
      | ">>"
      | ">>>"
      | ">="
      | ">>="
      | ">>>="
      | "<"
      | "<<"
      | "<="
      | "<<="
      | null
    )[]
  | boolean
  | null;
export type UnaryOperators = ("++" | "--" | "+" | "-" | "~" | "!")[] | boolean | null;
export type BraceRules = {
  beforeOpeningRoundBrace?: boolean | null;
  beforeOpeningCurlyBrace?: boolean | null;
  [k: string]: unknown;
} & BraceRules1;
export type BraceRules1 = null | {
  beforeOpeningRoundBrace?: boolean | null;
  beforeOpeningCurlyBrace?: boolean | null;
  [k: string]: unknown;
};
export type EqualityOperators = ("==" | "===" | "!=" | "!==" | null)[] | boolean | null;

export interface JSONSchemaForJSCSConfigurationFiles {
  /**
   * Path to load additional rules
   */
  additionalRules?: string[];
  /**
   * Requires that a function expression be named. Named functions provide more information in the error stack trace than anonymous functions.  This option does not help if you use Arrow functions (ES6) which are always anonymous.
   */
  disallowAnonymousFunctions?: boolean | null;
  /**
   * Disallows arrow functions.
   */
  disallowArrowFunctions?: boolean | null;
  /**
   * Requires the first alphabetical character of a comment to be lowercase.
   */
  disallowCapitalizedComments?: boolean | null;
  /**
   * Disallows commas as last token on a line in lists.
   */
  disallowCommaBeforeLineBreak?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: "function"[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: "function"[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: "function"[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: "function"[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows curly braces after statements.
   */
  disallowCurlyBraces?: Keywords2 &
    (
      | ((Keywords21 & Keywords22) & unknown[])
      | (boolean & (Keywords21 & Keywords22))
      | (null & (Keywords21 & Keywords22))
    );
  /**
   * Disallows identifiers that start or end in _.  Some popular identifiers are automatically listed as exceptions:  __proto__ (javascript), _ (underscore.js), __filename (node.js global), __dirname (node.js global), super_ (node.js, used by util.inherits).
   */
  disallowDanglingUnderscores?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: string[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: string[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows empty blocks (except for catch blocks).
   */
  disallowEmptyBlocks?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.  Blocks containing only comments would not be considered empty.
         *
         * @minItems 0
         */
        allExcept?: "comments"[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.  Blocks containing only comments would not be considered empty.
                 *
                 * @minItems 0
                 */
                allExcept?: "comments"[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.  Blocks containing only comments would not be considered empty.
                 *
                 * @minItems 0
                 */
                allExcept?: "comments"[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.  Blocks containing only comments would not be considered empty.
               *
               * @minItems 0
               */
              allExcept?: "comments"[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows function declarations.
   */
  disallowFunctionDeclarations?: boolean | null;
  /**
   * Disallows identical destructuring names for the key and value in favor of using shorthand destructuring.
   */
  disallowIdenticalDestructuringNames?: boolean | null;
  /**
   * Disallows a specified set of identifier names.
   */
  disallowIdentifierNames?: (string[] | NullRule) &
    (((string[] | NullRule) & unknown[]) | (null & (string[] | NullRule)));
  /**
   * Disallows implicit type conversion.
   */
  disallowImplicitTypeConversion?: ("numeric" | "boolean" | "binary" | "string")[] | null;
  /**
   * Disallows one or more keywords in comments.
   */
  disallowKeywordsInComments?: (string[] | boolean | NullRule | string) &
    (
      | ((string[] | boolean | NullRule | string) & unknown[])
      | (boolean & (string[] | boolean | NullRule | string))
      | (null & (string[] | boolean | NullRule | string))
      | ((string[] | boolean | NullRule | string) & string)
    );
  /**
   * Disallows placing the specified keywords on a new line.
   */
  disallowKeywordsOnNewLine?: Keywords & ((Keywords & unknown[]) | (null & Keywords));
  /**
   * Disallows usage of the specified keywords.
   */
  disallowKeywords?: Keywords & ((Keywords & unknown[]) | (null & Keywords));
  /**
   * Requires lines to not contain both spaces and tabs consecutively, or spaces after tabs only for alignment if "smart
   */
  disallowMixedSpacesAndTabs?: true | false | null | "smart";
  /**
   * Disallows the test, consequent and alternate to be on separate lines when using the ternary operator.
   */
  disallowMultiLineTernary?: boolean | null;
  /**
   * Disallows multiple blank lines in a row.
   */
  disallowMultipleLineBreaks?: boolean | null;
  /**
   * Disallows strings that span multiple lines without using concatenation.
   */
  disallowMultipleLineStrings?: boolean | null;
  /**
   * Disallows multiple indentation characters (tabs or spaces) between identifiers, keywords, and any other token.
   */
  disallowMultipleSpaces?: (
    | boolean
    | NullRule
    | {
        allowEOLComments?: boolean | null;
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                allowEOLComments?: boolean | null;
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                allowEOLComments?: boolean | null;
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              allowEOLComments?: boolean | null;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows multiple `var` declaration (except for-loop).
   */
  disallowMultipleVarDecl?: (
    | boolean
    | NullRule
    | {
        strict?: boolean | null;
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: (("require" | "undefined") & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                strict?: boolean | null;
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("require" | "undefined") & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                strict?: boolean | null;
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("require" | "undefined") & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              strict?: boolean | null;
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: (("require" | "undefined") & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows unassigned functions to be named inline.
   */
  disallowNamedUnassignedFunctions?: boolean | null;
  /**
   * Disallows nested ternaries.
   */
  disallowNestedTernaries?: (
    | boolean
    | NullRule
    | {
        /**
         * The maximum levels of ternary nesting to be allowed.
         */
        maxLevel?: number;
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * The maximum levels of ternary nesting to be allowed.
                 */
                maxLevel?: number;
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * The maximum levels of ternary nesting to be allowed.
                 */
                maxLevel?: number;
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * The maximum levels of ternary nesting to be allowed.
               */
              maxLevel?: number;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows newline before opening curly brace of all block statements.
   */
  disallowNewlineBeforeBlockStatements?: (
    | BlockKeywords
    | boolean
    | NullRule
    | {
        value?: unknown[] | boolean;
        /**
         * Array of quoted keywords to exempt.  If `multiline` is specified, when the conditions span on multiple lines, require a new line before the curly brace.
         *
         * @minItems 0
         */
        allExcept?: (string | "multiline")[];
        [k: string]: unknown;
      }
  ) &
    (
      | ((
          | BlockKeywords
          | boolean
          | NullRule
          | {
              value?: unknown[] | boolean;
              /**
               * Array of quoted keywords to exempt.  If `multiline` is specified, when the conditions span on multiple lines, require a new line before the curly brace.
               *
               * @minItems 0
               */
              allExcept?: (string | "multiline")[];
              [k: string]: unknown;
            }
        ) &
          unknown[])
      | (boolean &
          (
            | BlockKeywords
            | boolean
            | NullRule
            | {
                value?: unknown[] | boolean;
                /**
                 * Array of quoted keywords to exempt.  If `multiline` is specified, when the conditions span on multiple lines, require a new line before the curly brace.
                 *
                 * @minItems 0
                 */
                allExcept?: (string | "multiline")[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | BlockKeywords
            | boolean
            | NullRule
            | {
                value?: unknown[] | boolean;
                /**
                 * Array of quoted keywords to exempt.  If `multiline` is specified, when the conditions span on multiple lines, require a new line before the curly brace.
                 *
                 * @minItems 0
                 */
                allExcept?: (string | "multiline")[];
                [k: string]: unknown;
              }
          ))
      | (
          | BlockKeywords
          | boolean
          | NullRule
          | {
              value?: unknown[] | boolean;
              /**
               * Array of quoted keywords to exempt.  If `multiline` is specified, when the conditions span on multiple lines, require a new line before the curly brace.
               *
               * @minItems 0
               */
              allExcept?: (string | "multiline")[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallow use of certain node types (from Esprima/ESTree).  Value equals an array of parser node types to be disallowed.
   */
  disallowNodeTypes?: EsprimaNodeTypes & ((EsprimaNodeTypes & unknown[]) | (null & EsprimaNodeTypes));
  /**
   * Disallows the not, not equals, and strict not equals operators in conditionals.
   */
  disallowNotOperatorsInConditionals?: boolean | null;
  /**
   * Disallows placing object keys on new line.
   */
  disallowObjectKeysOnNewLine?: boolean | null;
  /**
   * Requires putting certain operators on the next line rather than on the current line before a line break.
   */
  disallowOperatorBeforeLineBreak?: Operators & ((Operators & unknown[]) | (boolean & Operators) | (null & Operators));
  /**
   * Disallow a newline after blocks.
   */
  disallowPaddingNewLinesAfterBlocks?: boolean | null;
  /**
   * Disallow a blank line after 'use strict'; statements.
   */
  disallowPaddingNewLinesAfterUseStrict?: boolean | null;
  /**
   * Disallows newline before module.exports.
   */
  disallowPaddingNewLinesBeforeExport?: boolean | null;
  /**
   * Disallow an empty line above the specified keywords.
   */
  disallowPaddingNewlinesBeforeKeywords?: (Keywords21 & Keywords22) &
    (
      | ((Keywords21 & Keywords22) & unknown[])
      | (boolean & (Keywords21 & Keywords22))
      | (null & (Keywords21 & Keywords22))
    );
  /**
   * Disallows newline before line comments.
   */
  disallowPaddingNewLinesBeforeLineComments?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Disallows blocks from beginning or ending with 2 newlines.
   */
  disallowPaddingNewlinesInBlocks?: (
    | boolean
    | NullRule
    | {
        /**
         * A value of true validates that there is a newline before the closing brace in a block.  A value of false ignores the newline validation before the closing brace in a block.
         */
        close?: boolean;
        /**
         * A value of true validates that there is a newline after the opening brace in a block.  A value of false ignores the newline validation after the opening brace in a block.
         */
        open?: boolean;
        /**
         * Array of quoted keywords to exempt.  If `conditionals` is specified, conditionals (if, else if, else) blocks are ignored.  If `functions` is specified, function blocks are ignored.
         *
         * @minItems 0
         */
        allExcept?: ("conditionals" | "functions")[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * A value of true validates that there is a newline before the closing brace in a block.  A value of false ignores the newline validation before the closing brace in a block.
                 */
                close?: boolean;
                /**
                 * A value of true validates that there is a newline after the opening brace in a block.  A value of false ignores the newline validation after the opening brace in a block.
                 */
                open?: boolean;
                /**
                 * Array of quoted keywords to exempt.  If `conditionals` is specified, conditionals (if, else if, else) blocks are ignored.  If `functions` is specified, function blocks are ignored.
                 *
                 * @minItems 0
                 */
                allExcept?: ("conditionals" | "functions")[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * A value of true validates that there is a newline before the closing brace in a block.  A value of false ignores the newline validation before the closing brace in a block.
                 */
                close?: boolean;
                /**
                 * A value of true validates that there is a newline after the opening brace in a block.  A value of false ignores the newline validation after the opening brace in a block.
                 */
                open?: boolean;
                /**
                 * Array of quoted keywords to exempt.  If `conditionals` is specified, conditionals (if, else if, else) blocks are ignored.  If `functions` is specified, function blocks are ignored.
                 *
                 * @minItems 0
                 */
                allExcept?: ("conditionals" | "functions")[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * A value of true validates that there is a newline before the closing brace in a block.  A value of false ignores the newline validation before the closing brace in a block.
               */
              close?: boolean;
              /**
               * A value of true validates that there is a newline after the opening brace in a block.  A value of false ignores the newline validation after the opening brace in a block.
               */
              open?: boolean;
              /**
               * Array of quoted keywords to exempt.  If `conditionals` is specified, conditionals (if, else if, else) blocks are ignored.  If `functions` is specified, function blocks are ignored.
               *
               * @minItems 0
               */
              allExcept?: ("conditionals" | "functions")[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows newlines adjacent to curly braces in all object literals.
   */
  disallowPaddingNewLinesInObjects?: boolean | null;
  /**
   * Disallows parentheses around arrow function expressions that contain a single parameter.
   */
  disallowParenthesesAroundArrowParam?: boolean | null;
  /**
   * Disallows quoted keys in object if possible.
   */
  disallowQuotedKeysInObjects?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: (string | "reserved")[];
        [k: string]: unknown;
      }
    | ("allButReserved" & string)
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (string | "reserved")[];
                [k: string]: unknown;
              }
            | ("allButReserved" & string)
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (string | "reserved")[];
                [k: string]: unknown;
              }
            | ("allButReserved" & string)
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: (string | "reserved")[];
              [k: string]: unknown;
            }
          | ("allButReserved" & string)
        )
      | ((
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: (string | "reserved")[];
              [k: string]: unknown;
            }
          | ("allButReserved" & string)
        ) &
          string)
    );
  /**
   * Disallows lines from ending in a semicolon.
   */
  disallowSemicolons?: boolean | null;
  /**
   * Require arrow functions to use a block statement (explicit return).
   */
  disallowShorthandArrowFunctions?: boolean | null;
  /**
   * Requires sticking binary operators to the right.
   */
  disallowSpaceAfterBinaryOperators?: Operators &
    ((Operators & unknown[]) | (boolean & Operators) | (null & Operators));
  /**
   * Disallows spaces after commas.
   */
  disallowSpaceAfterComma?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: ("sparseArrays" & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("sparseArrays" & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("sparseArrays" & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: ("sparseArrays" & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows space after the specified keywords.  A value of true will require spaces after all possible keywords.
   */
  disallowSpaceAfterKeywords?: (Keywords21 & Keywords22) &
    (
      | ((Keywords21 & Keywords22) & unknown[])
      | (boolean & (Keywords21 & Keywords22))
      | (null & (Keywords21 & Keywords22))
    );
  /**
   * Requires that a line comment (//) not be followed by a space.
   */
  disallowSpaceAfterLineComment?: boolean | null;
  /**
   * Disallows space after object keys.
   */
  disallowSpaceAfterObjectKeys?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: (("singleline" | "multiline" | "aligned" | "method") & string)[];
        [k: string]: unknown;
      }
    | (("ignoreSingleLine" | "ignoreMultiLine") & string)
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("singleline" | "multiline" | "aligned" | "method") & string)[];
                [k: string]: unknown;
              }
            | (("ignoreSingleLine" | "ignoreMultiLine") & string)
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("singleline" | "multiline" | "aligned" | "method") & string)[];
                [k: string]: unknown;
              }
            | (("ignoreSingleLine" | "ignoreMultiLine") & string)
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: (("singleline" | "multiline" | "aligned" | "method") & string)[];
              [k: string]: unknown;
            }
          | (("ignoreSingleLine" | "ignoreMultiLine") & string)
        )
      | ((
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: (("singleline" | "multiline" | "aligned" | "method") & string)[];
              [k: string]: unknown;
            }
          | (("ignoreSingleLine" | "ignoreMultiLine") & string)
        ) &
          string)
    );
  /**
   * Requires sticking unary operators to the right.
   */
  disallowSpaceAfterPrefixUnaryOperators?: UnaryOperators &
    ((UnaryOperators & unknown[]) | (boolean & UnaryOperators) | (null & UnaryOperators));
  /**
   * Requires sticking binary operators to the left.
   */
  disallowSpaceBeforeBinaryOperators?: Operators &
    ((Operators & unknown[]) | (boolean & Operators) | (null & Operators));
  /**
   * Disallows space before block statements (for loops, control structures).
   */
  disallowSpaceBeforeBlockStatements?: boolean | null;
  /**
   * Disallows spaces before commas.
   */
  disallowSpaceBeforeComma?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: ("sparseArrays" & string)[];
        [k: string]: unknown;
      }
    | ("exceptExports" & string)
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("sparseArrays" & string)[];
                [k: string]: unknown;
              }
            | ("exceptExports" & string)
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("sparseArrays" & string)[];
                [k: string]: unknown;
              }
            | ("exceptExports" & string)
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: ("sparseArrays" & string)[];
              [k: string]: unknown;
            }
          | ("exceptExports" & string)
        )
      | ((
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: ("sparseArrays" & string)[];
              [k: string]: unknown;
            }
          | ("exceptExports" & string)
        ) &
          string)
    );
  /**
   * Disallows space before keyword.
   */
  disallowSpaceBeforeKeywords?: (Keywords21 & Keywords22) &
    (
      | ((Keywords21 & Keywords22) & unknown[])
      | (boolean & (Keywords21 & Keywords22))
      | (null & (Keywords21 & Keywords22))
    );
  /**
   * Disallows space before object values.
   */
  disallowSpaceBeforeObjectValues?: boolean | null;
  /**
   * Requires sticking unary operators to the left.
   */
  disallowSpaceBeforePostfixUnaryOperators?: UnaryOperators &
    ((UnaryOperators & unknown[]) | (boolean & UnaryOperators) | (null & UnaryOperators));
  /**
   * Disallows spaces before semicolons.
   */
  disallowSpaceBeforeSemicolon?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted tokens to exempt (allows whitespace before semicolon if preceded by the specified token).
         *
         * @minItems 0
         */
        allExcept?: (("(" | string) & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted tokens to exempt (allows whitespace before semicolon if preceded by the specified token).
                 *
                 * @minItems 0
                 */
                allExcept?: (("(" | string) & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted tokens to exempt (allows whitespace before semicolon if preceded by the specified token).
                 *
                 * @minItems 0
                 */
                allExcept?: (("(" | string) & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted tokens to exempt (allows whitespace before semicolon if preceded by the specified token).
               *
               * @minItems 0
               */
              allExcept?: (("(" | string) & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Ensure there are no spaces after argument separators in call expressions.
   */
  disallowSpaceBetweenArguments?: boolean | null;
  /**
   * Disallows space before () or {} in anonymous function expressions.
   */
  disallowSpacesInAnonymousFunctionExpression?: BraceRules & ((null & BraceRules1) | BraceRules1);
  /**
   * Disallows space before () in call expressions.
   */
  disallowSpacesInCallExpression?: boolean | null;
  /**
   * Disallows space before and/or after ? or : in conditional expressions.
   */
  disallowSpacesInConditionalExpression?: (
    | boolean
    | NullRule
    | {
        afterConsequent?: boolean;
        afterTest?: boolean;
        beforeAlternate?: boolean;
        beforeConsequent?: boolean;
        [k: string]: unknown;
      }
  ) &
    (
      | ((
          | boolean
          | NullRule
          | {
              afterConsequent?: boolean;
              afterTest?: boolean;
              beforeAlternate?: boolean;
              beforeConsequent?: boolean;
              [k: string]: unknown;
            }
        ) &
          boolean)
      | ((
          | boolean
          | NullRule
          | {
              afterConsequent?: boolean;
              afterTest?: boolean;
              beforeAlternate?: boolean;
              beforeConsequent?: boolean;
              [k: string]: unknown;
            }
        ) &
          null)
      | (
          | boolean
          | NullRule
          | {
              afterConsequent?: boolean;
              afterTest?: boolean;
              beforeAlternate?: boolean;
              beforeConsequent?: boolean;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallow spaces in between for statement.
   */
  disallowSpacesInForStatement?: boolean | null;
  /**
   * Disallows space before `()` or `{}` in function expressions (both named and anonymous) and function declarations.
   */
  disallowSpacesInFunction?: BraceRules1 & ((null & BraceRules1) | BraceRules1);
  /**
   * Disallows space before () or {} in function declarations.
   */
  disallowSpacesInFunctionDeclaration?: BraceRules1 & ((null & BraceRules1) | BraceRules1);
  /**
   * Disallows space before `()` or `{}` in function expressions (both named and anonymous).
   */
  disallowSpacesInFunctionExpression?: BraceRules1 & ((null & BraceRules1) | BraceRules1);
  /**
   * Disallow space before or after * in generator functions.
   */
  disallowSpacesInGenerator?: (
    | NullRule
    | {
        /**
         * A value of true disallows space before *.
         */
        beforeStar?: boolean;
        /**
         * A value of true disallows space after *.
         */
        afterStar?: boolean;
        [k: string]: unknown;
      }
  ) &
    (
      | (null &
          (
            | NullRule
            | {
                /**
                 * A value of true disallows space before *.
                 */
                beforeStar?: boolean;
                /**
                 * A value of true disallows space after *.
                 */
                afterStar?: boolean;
                [k: string]: unknown;
              }
          ))
      | (
          | NullRule
          | {
              /**
               * A value of true disallows space before *.
               */
              beforeStar?: boolean;
              /**
               * A value of true disallows space after *.
               */
              afterStar?: boolean;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows space before () or {} in named function expressions
   */
  disallowSpacesInNamedFunctionExpression?: BraceRules1 & ((null & BraceRules1) | BraceRules1);
  /**
   * Disallows space after opening array square bracket and before closing.  Reports only on arrays, not on property accessors.  Use disallowSpacesInsideBrackets to report on all brackets.
   */
  disallowSpacesInsideArrayBrackets?: (
    | (true | false | "all")
    | NullRule
    | {
        /**
         * Array of quoted tokens to exempt.  Tokens should consist of an opener with a matching closer () {} [] etc.
         *
         * @minItems 0
         */
        allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
        [k: string]: unknown;
      }
    | ("nested" & string)
  ) &
    (
      | (boolean &
          (
            | (true | false | "all")
            | NullRule
            | {
                /**
                 * Array of quoted tokens to exempt.  Tokens should consist of an opener with a matching closer () {} [] etc.
                 *
                 * @minItems 0
                 */
                allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
                [k: string]: unknown;
              }
            | ("nested" & string)
          ))
      | (null &
          (
            | (true | false | "all")
            | NullRule
            | {
                /**
                 * Array of quoted tokens to exempt.  Tokens should consist of an opener with a matching closer () {} [] etc.
                 *
                 * @minItems 0
                 */
                allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
                [k: string]: unknown;
              }
            | ("nested" & string)
          ))
      | (
          | (true | false | "all")
          | NullRule
          | {
              /**
               * Array of quoted tokens to exempt.  Tokens should consist of an opener with a matching closer () {} [] etc.
               *
               * @minItems 0
               */
              allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
              [k: string]: unknown;
            }
          | ("nested" & string)
        )
      | ((
          | (true | false | "all")
          | NullRule
          | {
              /**
               * Array of quoted tokens to exempt.  Tokens should consist of an opener with a matching closer () {} [] etc.
               *
               * @minItems 0
               */
              allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
              [k: string]: unknown;
            }
          | ("nested" & string)
        ) &
          string)
    );
  /**
   * Disallows space after opening square bracket and before closing.  Reports on all on brackets, even on property accessors.  Use disallowSpacesInsideArrayBrackets to exclude property accessors.
   */
  disallowSpacesInsideBrackets?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted tokens to exempt.  Tokens should consist of an opener with a matching closer () {} [] etc.
         *
         * @minItems 0
         */
        allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted tokens to exempt.  Tokens should consist of an opener with a matching closer () {} [] etc.
                 *
                 * @minItems 0
                 */
                allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted tokens to exempt.  Tokens should consist of an opener with a matching closer () {} [] etc.
                 *
                 * @minItems 0
                 */
                allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted tokens to exempt.  Tokens should consist of an opener with a matching closer () {} [] etc.
               *
               * @minItems 0
               */
              allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows space after opening object curly brace and before closing.
   */
  disallowSpacesInsideObjectBrackets?: (
    | (true | false | "all")
    | NullRule
    | {
        /**
         * Array of quoted tokens to exempt.  Applies only to closer tokens:  e.g. ) } ].  If a (closer) token is specified, the rule ignores contiguous (closer) tokens.
         *
         * @minItems 0
         */
        allExcept?: ((")" | "}" | "]") & string)[];
        [k: string]: unknown;
      }
    | ("nested" & string)
  ) &
    (
      | (boolean &
          (
            | (true | false | "all")
            | NullRule
            | {
                /**
                 * Array of quoted tokens to exempt.  Applies only to closer tokens:  e.g. ) } ].  If a (closer) token is specified, the rule ignores contiguous (closer) tokens.
                 *
                 * @minItems 0
                 */
                allExcept?: ((")" | "}" | "]") & string)[];
                [k: string]: unknown;
              }
            | ("nested" & string)
          ))
      | (null &
          (
            | (true | false | "all")
            | NullRule
            | {
                /**
                 * Array of quoted tokens to exempt.  Applies only to closer tokens:  e.g. ) } ].  If a (closer) token is specified, the rule ignores contiguous (closer) tokens.
                 *
                 * @minItems 0
                 */
                allExcept?: ((")" | "}" | "]") & string)[];
                [k: string]: unknown;
              }
            | ("nested" & string)
          ))
      | (
          | (true | false | "all")
          | NullRule
          | {
              /**
               * Array of quoted tokens to exempt.  Applies only to closer tokens:  e.g. ) } ].  If a (closer) token is specified, the rule ignores contiguous (closer) tokens.
               *
               * @minItems 0
               */
              allExcept?: ((")" | "}" | "]") & string)[];
              [k: string]: unknown;
            }
          | ("nested" & string)
        )
      | ((
          | (true | false | "all")
          | NullRule
          | {
              /**
               * Array of quoted tokens to exempt.  Applies only to closer tokens:  e.g. ) } ].  If a (closer) token is specified, the rule ignores contiguous (closer) tokens.
               *
               * @minItems 0
               */
              allExcept?: ((")" | "}" | "]") & string)[];
              [k: string]: unknown;
            }
          | ("nested" & string)
        ) &
          string)
    );
  /**
   * Disallows space after opening round bracket and before closing.
   */
  disallowSpacesInsideParentheses?: (
    | (true | false | "all")
    | NullRule
    | {
        /**
         * Array of quoted values to target.
         *
         * @minItems 0
         */
        only?: ((("(" | ")" | "{" | "}" | "[" | "]" | "function") | string) & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | (true | false | "all")
            | NullRule
            | {
                /**
                 * Array of quoted values to target.
                 *
                 * @minItems 0
                 */
                only?: ((("(" | ")" | "{" | "}" | "[" | "]" | "function") | string) & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | (true | false | "all")
            | NullRule
            | {
                /**
                 * Array of quoted values to target.
                 *
                 * @minItems 0
                 */
                only?: ((("(" | ")" | "{" | "}" | "[" | "]" | "function") | string) & string)[];
                [k: string]: unknown;
              }
          ))
      | ((
          | (true | false | "all")
          | NullRule
          | {
              /**
               * Array of quoted values to target.
               *
               * @minItems 0
               */
              only?: ((("(" | ")" | "{" | "}" | "[" | "]" | "function") | string) & string)[];
              [k: string]: unknown;
            }
        ) &
          string)
      | (
          | (true | false | "all")
          | NullRule
          | {
              /**
               * Array of quoted values to target.
               *
               * @minItems 0
               */
              only?: ((("(" | ")" | "{" | "}" | "[" | "]" | "function") | string) & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows space after opening and before closing grouping parentheses.
   */
  disallowSpacesInsideParenthesizedExpression?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted tokens or items to exempt.  Tokens should consist of an opener with a matching closer () {} [] or `function`.
         *
         * @minItems 0
         */
        allExcept?: (("(" | ")" | "{" | "}" | "[" | "]" | "function") & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted tokens or items to exempt.  Tokens should consist of an opener with a matching closer () {} [] or `function`.
                 *
                 * @minItems 0
                 */
                allExcept?: (("(" | ")" | "{" | "}" | "[" | "]" | "function") & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted tokens or items to exempt.  Tokens should consist of an opener with a matching closer () {} [] or `function`.
                 *
                 * @minItems 0
                 */
                allExcept?: (("(" | ")" | "{" | "}" | "[" | "]" | "function") & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted tokens or items to exempt.  Tokens should consist of an opener with a matching closer () {} [] or `function`.
               *
               * @minItems 0
               */
              allExcept?: (("(" | ")" | "{" | "}" | "[" | "]" | "function") & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows spaces before and after curly brace inside template string placeholders.
   */
  disallowSpacesInsideTemplateStringPlaceholders?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Disallows tabs everywhere.
   */
  disallowTabs?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Disallows an extra comma following the final element of an array or object literal.
   */
  disallowTrailingComma?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires all lines to end on a non-whitespace character.
   */
  disallowTrailingWhitespace?: ((true | false | "ignoreEmptyLines") | NullRule) &
    (
      | (boolean & ((true | false | "ignoreEmptyLines") | NullRule))
      | (null & ((true | false | "ignoreEmptyLines") | NullRule))
      | (((true | false | "ignoreEmptyLines") | NullRule) & string)
    );
  /**
   * Disallows unused params in function expression and function declaration.
   */
  disallowUnusedParams?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Disallows declaring variables with var.
   */
  disallowVar?: boolean | NullRule;
  /**
   * Requires the variable to be the left hand operator when doing a boolean comparison.  Array of quoted operators or true to disallow yoda conditions for most possible comparison operators.
   */
  disallowYodaConditions?: EqualityOperators &
    ((EqualityOperators & unknown[]) | (boolean & EqualityOperators) | (null & EqualityOperators));
  /**
   * Disables style checking for specified paths.
   */
  excludeFiles?: string[];
  jsDoc?: JsDoc;
  /**
   * Requires all lines to be at most the number of characters specified.
   */
  maximumLineLength?: (
    | number
    | NullRule
    | {
        /**
         * Array of conditions that will exempt a line.
         *
         * @minItems 0
         */
        allExcept?: ("comments" | "functionSignature" | "regex" | "require" | "urlComments")[];
        /**
         * Considered the tab character as number of specified spaces.
         */
        tabSize?: number;
        /**
         * Lines should be at most the number of characters specified.
         */
        value: number;
        [k: string]: unknown;
      }
  ) &
    (
      | (number &
          (
            | number
            | NullRule
            | {
                /**
                 * Array of conditions that will exempt a line.
                 *
                 * @minItems 0
                 */
                allExcept?: ("comments" | "functionSignature" | "regex" | "require" | "urlComments")[];
                /**
                 * Considered the tab character as number of specified spaces.
                 */
                tabSize?: number;
                /**
                 * Lines should be at most the number of characters specified.
                 */
                value: number;
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | number
            | NullRule
            | {
                /**
                 * Array of conditions that will exempt a line.
                 *
                 * @minItems 0
                 */
                allExcept?: ("comments" | "functionSignature" | "regex" | "require" | "urlComments")[];
                /**
                 * Considered the tab character as number of specified spaces.
                 */
                tabSize?: number;
                /**
                 * Lines should be at most the number of characters specified.
                 */
                value: number;
                [k: string]: unknown;
              }
          ))
      | (
          | number
          | NullRule
          | {
              /**
               * Array of conditions that will exempt a line.
               *
               * @minItems 0
               */
              allExcept?: ("comments" | "functionSignature" | "regex" | "require" | "urlComments")[];
              /**
               * Considered the tab character as number of specified spaces.
               */
              tabSize?: number;
              /**
               * Lines should be at most the number of characters specified.
               */
              value: number;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires the file to be at most the number of lines specified.
   */
  maximumNumberOfLines?: (
    | number
    | NullRule
    | {
        /**
         * Array of conditions that will exempt a line.
         *
         * @minItems 0
         */
        allExcept?: "comments"[];
        /**
         * Lines should be at most the number of characters specified.
         */
        value: number;
        [k: string]: unknown;
      }
  ) &
    (
      | (number &
          (
            | number
            | NullRule
            | {
                /**
                 * Array of conditions that will exempt a line.
                 *
                 * @minItems 0
                 */
                allExcept?: "comments"[];
                /**
                 * Lines should be at most the number of characters specified.
                 */
                value: number;
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | number
            | NullRule
            | {
                /**
                 * Array of conditions that will exempt a line.
                 *
                 * @minItems 0
                 */
                allExcept?: "comments"[];
                /**
                 * Lines should be at most the number of characters specified.
                 */
                value: number;
                [k: string]: unknown;
              }
          ))
      | (
          | number
          | NullRule
          | {
              /**
               * Array of conditions that will exempt a line.
               *
               * @minItems 0
               */
              allExcept?: "comments"[];
              /**
               * Lines should be at most the number of characters specified.
               */
              value: number;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Extends defined rules with preset rules.
   */
  preset?:
    | "airbnb"
    | "crockford"
    | "google"
    | "grunt"
    | "idiomatic"
    | "jquery"
    | "mdcs"
    | "node-style-guide"
    | "wikimedia"
    | "wordpress"
    | "yandex";
  /**
   * Enforces indentation of parameters in multiline functions.
   */
  requireAlignedMultilineParams?: (boolean | number | NullRule | "firstParam") &
    (
      | (boolean & (boolean | number | NullRule | "firstParam"))
      | (number & (boolean | number | NullRule | "firstParam"))
      | (null & (boolean | number | NullRule | "firstParam"))
      | ((boolean | number | NullRule | "firstParam") & string)
    );
  /**
   * Requires proper alignment in object literals.
   */
  requireAlignedObjectValues?: (NullRule | (("all" | "ignoreFunction" | "ignoreLineBreak") & string)) &
    (
      | (null & (NullRule | (("all" | "ignoreFunction" | "ignoreLineBreak") & string)))
      | ((NullRule | (("all" | "ignoreFunction" | "ignoreLineBreak") & string)) & string)
    );
  /**
   * Requires that a function expression be anonymous.
   */
  requireAnonymousFunctions?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: "declarations"[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: "declarations"[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: "declarations"[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: "declarations"[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires that variable assignment from array values are * destructured.
   */
  requireArrayDestructuring?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires that arrow functions are used instead of anonymous function expressions in callbacks.
   */
  requireArrowFunctions?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires blocks to begin and end with a newline.
   */
  requireBlocksOnNewline?: (
    | boolean
    | number
    | NullRule
    | {
        /**
         * If true, includes comments as part of the validation.
         */
        includeComments?: boolean;
        /**
         * Specifies a minimum number of lines containing elements in the block before validating.
         */
        minLines?: number;
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | number
            | NullRule
            | {
                /**
                 * If true, includes comments as part of the validation.
                 */
                includeComments?: boolean;
                /**
                 * Specifies a minimum number of lines containing elements in the block before validating.
                 */
                minLines?: number;
                [k: string]: unknown;
              }
          ))
      | (number &
          (
            | boolean
            | number
            | NullRule
            | {
                /**
                 * If true, includes comments as part of the validation.
                 */
                includeComments?: boolean;
                /**
                 * Specifies a minimum number of lines containing elements in the block before validating.
                 */
                minLines?: number;
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | number
            | NullRule
            | {
                /**
                 * If true, includes comments as part of the validation.
                 */
                includeComments?: boolean;
                /**
                 * Specifies a minimum number of lines containing elements in the block before validating.
                 */
                minLines?: number;
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | number
          | NullRule
          | {
              /**
               * If true, includes comments as part of the validation.
               */
              includeComments?: boolean;
              /**
               * Specifies a minimum number of lines containing elements in the block before validating.
               */
              minLines?: number;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires identifiers to be camelCased or UPPERCASE_WITH_UNDERSCORES.
   */
  requireCamelCaseOrUpperCaseIdentifiers?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of String, RegExp, or ESTree RegExpLiteral values permitted as exceptions.
         *
         * @minItems 0
         */
        allExcept?: string[];
        /**
         * Array of String, RegExp, or ESTree RegExpLiteral values permitted as prefixes.
         *
         * @minItems 0
         */
        allowedPrefixes?: string[];
        /**
         * Array of String, RegExp, or ESTree RegExpLiteral values permitted as suffixes.
         *
         * @minItems 0
         */
        allowedSuffixes?: string[];
        /**
         * If true, allows an exception for object property names.
         */
        ignoreProperties?: boolean;
        /**
         * If true, forces the first character to not be capitalized.
         */
        strict?: boolean;
        [k: string]: unknown;
      }
    | ("ignoreProperties" & string)
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of String, RegExp, or ESTree RegExpLiteral values permitted as exceptions.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                /**
                 * Array of String, RegExp, or ESTree RegExpLiteral values permitted as prefixes.
                 *
                 * @minItems 0
                 */
                allowedPrefixes?: string[];
                /**
                 * Array of String, RegExp, or ESTree RegExpLiteral values permitted as suffixes.
                 *
                 * @minItems 0
                 */
                allowedSuffixes?: string[];
                /**
                 * If true, allows an exception for object property names.
                 */
                ignoreProperties?: boolean;
                /**
                 * If true, forces the first character to not be capitalized.
                 */
                strict?: boolean;
                [k: string]: unknown;
              }
            | ("ignoreProperties" & string)
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of String, RegExp, or ESTree RegExpLiteral values permitted as exceptions.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                /**
                 * Array of String, RegExp, or ESTree RegExpLiteral values permitted as prefixes.
                 *
                 * @minItems 0
                 */
                allowedPrefixes?: string[];
                /**
                 * Array of String, RegExp, or ESTree RegExpLiteral values permitted as suffixes.
                 *
                 * @minItems 0
                 */
                allowedSuffixes?: string[];
                /**
                 * If true, allows an exception for object property names.
                 */
                ignoreProperties?: boolean;
                /**
                 * If true, forces the first character to not be capitalized.
                 */
                strict?: boolean;
                [k: string]: unknown;
              }
            | ("ignoreProperties" & string)
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of String, RegExp, or ESTree RegExpLiteral values permitted as exceptions.
               *
               * @minItems 0
               */
              allExcept?: string[];
              /**
               * Array of String, RegExp, or ESTree RegExpLiteral values permitted as prefixes.
               *
               * @minItems 0
               */
              allowedPrefixes?: string[];
              /**
               * Array of String, RegExp, or ESTree RegExpLiteral values permitted as suffixes.
               *
               * @minItems 0
               */
              allowedSuffixes?: string[];
              /**
               * If true, allows an exception for object property names.
               */
              ignoreProperties?: boolean;
              /**
               * If true, forces the first character to not be capitalized.
               */
              strict?: boolean;
              [k: string]: unknown;
            }
          | ("ignoreProperties" & string)
        )
      | ((
          | boolean
          | NullRule
          | {
              /**
               * Array of String, RegExp, or ESTree RegExpLiteral values permitted as exceptions.
               *
               * @minItems 0
               */
              allExcept?: string[];
              /**
               * Array of String, RegExp, or ESTree RegExpLiteral values permitted as prefixes.
               *
               * @minItems 0
               */
              allowedPrefixes?: string[];
              /**
               * Array of String, RegExp, or ESTree RegExpLiteral values permitted as suffixes.
               *
               * @minItems 0
               */
              allowedSuffixes?: string[];
              /**
               * If true, allows an exception for object property names.
               */
              ignoreProperties?: boolean;
              /**
               * If true, forces the first character to not be capitalized.
               */
              strict?: boolean;
              [k: string]: unknown;
            }
          | ("ignoreProperties" & string)
        ) &
          string)
    );
  /**
   * Requires the first alphabetical character of a comment to be uppercase, unless it is part of a multi-line textblock.  This rule automatically ignores jscs, jshint, eslint, and istanbul specific comments.
   */
  requireCapitalizedComments?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: string[];
        /**
         * If true, ignore comments in the middle of the code line.
         */
        inlined?: boolean;
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                /**
                 * If true, ignore comments in the middle of the code line.
                 */
                inlined?: boolean;
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                /**
                 * If true, ignore comments in the middle of the code line.
                 */
                inlined?: boolean;
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: string[];
              /**
               * If true, ignore comments in the middle of the code line.
               */
              inlined?: boolean;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires capitalized constructors to to use the new keyword.
   */
  requireCapitalizedConstructorsNew?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: string[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: string[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires constructors to be capitalized (except for "this")
   */
  requireCapitalizedConstructors?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: string[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: string[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires commas as last token on a line in lists.
   */
  requireCommaBeforeLineBreak?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires curly braces after statements.  A value of true will require curly braces for all the necessary keywords:  if, else, for, while do, try, catch, case, and default.
   */
  requireCurlyBraces?: (
    | (Keywords21 & Keywords22)
    | {
        /**
         * Array of quoted keywords that would require curly braces.
         *
         * @minItems 0
         */
        keywords?: string[];
        /**
         * Array of quoted keywords to exempt.  Allows not using braces in some instances; ex.  /*allowed:* / if (x) return; /* not allowed* / if (x) i++; given "allExcept": ["return", "continue", "break", ...],
         *
         * @minItems 0
         */
        allExcept?: string[];
        [k: string]: unknown;
      }
  ) &
    (
      | ((
          | (Keywords21 & Keywords22)
          | {
              /**
               * Array of quoted keywords that would require curly braces.
               *
               * @minItems 0
               */
              keywords?: string[];
              /**
               * Array of quoted keywords to exempt.  Allows not using braces in some instances; ex.  /*allowed:* / if (x) return; /* not allowed* / if (x) i++; given "allExcept": ["return", "continue", "break", ...],
               *
               * @minItems 0
               */
              allExcept?: string[];
              [k: string]: unknown;
            }
        ) &
          unknown[])
      | (boolean &
          (
            | (Keywords21 & Keywords22)
            | {
                /**
                 * Array of quoted keywords that would require curly braces.
                 *
                 * @minItems 0
                 */
                keywords?: string[];
                /**
                 * Array of quoted keywords to exempt.  Allows not using braces in some instances; ex.  /*allowed:* / if (x) return; /* not allowed* / if (x) i++; given "allExcept": ["return", "continue", "break", ...],
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | (Keywords21 & Keywords22)
            | {
                /**
                 * Array of quoted keywords that would require curly braces.
                 *
                 * @minItems 0
                 */
                keywords?: string[];
                /**
                 * Array of quoted keywords to exempt.  Allows not using braces in some instances; ex.  /*allowed:* / if (x) return; /* not allowed* / if (x) i++; given "allExcept": ["return", "continue", "break", ...],
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (
          | (Keywords21 & Keywords22)
          | {
              /**
               * Array of quoted keywords that would require curly braces.
               *
               * @minItems 0
               */
              keywords?: string[];
              /**
               * Array of quoted keywords to exempt.  Allows not using braces in some instances; ex.  /*allowed:* / if (x) return; /* not allowed* / if (x) i++; given "allExcept": ["return", "continue", "break", ...],
               *
               * @minItems 0
               */
              allExcept?: string[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Require a $ before variable names that are jquery assignments.
   */
  requireDollarBeforejQueryAssignment?: ((true | false | "ignoreProperties") | NullRule) &
    (
      | (boolean & ((true | false | "ignoreProperties") | NullRule))
      | (null & ((true | false | "ignoreProperties") | NullRule))
      | (((true | false | "ignoreProperties") | NullRule) & string)
    );
  /**
   * Requires member expressions to use dot notation when possible.
   */
  requireDotNotation?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: (("keywords" | "snake_case") & string)[];
        [k: string]: unknown;
      }
    | ("except_snake_case" & string)
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("keywords" | "snake_case") & string)[];
                [k: string]: unknown;
              }
            | ("except_snake_case" & string)
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("keywords" | "snake_case") & string)[];
                [k: string]: unknown;
              }
            | ("except_snake_case" & string)
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: (("keywords" | "snake_case") & string)[];
              [k: string]: unknown;
            }
          | ("except_snake_case" & string)
        )
      | ((
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: (("keywords" | "snake_case") & string)[];
              [k: string]: unknown;
            }
          | ("except_snake_case" & string)
        ) &
          string)
    );
  /**
   * Requires early return in a function.
   */
  requireEarlyReturn?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires declaring objects via ES6 enhanced object literals.
   */
  requireEnhancedObjectLiterals?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires function declarations by disallowing assignment of functions expressions to variables. Function expressions are allowed in all other contexts, including when passed as function arguments or immediately invoked.  Assignment of function expressions to object members is also permitted, since these can't be declared.
   */
  requireFunctionDeclarations?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires imports to be alphabetized (A-Z).
   */
  requireImportAlphabetized?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires placing the specified keywords on a new line.
   */
  requireKeywordsOnNewLine?: Keywords & ((Keywords & unknown[]) | (null & Keywords));
  /**
   * Requires placing line feed after assigning a variable.
   */
  requireLineBreakAfterVariableAssignment?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires placing line feed at file end.
   */
  requireLineFeedAtFileEnd?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires function names to match member and property names.  It doesn't affect anonymous functions nor functions assigned to members or properties named with a reserved word.  Assigning to module.exports is also ignored, unless includeModuleExports: true is configured.
   */
  requireMatchingFunctionName?: (
    | boolean
    | NullRule
    | {
        includeModuleExports?: boolean;
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                includeModuleExports?: boolean;
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                includeModuleExports?: boolean;
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              includeModuleExports?: boolean;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires the test, consequent and alternate to be on separate lines when using the ternary operator.
   */
  requireMultiLineTernary?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires multiple `var` declaration.
   */
  requireMultipleVarDecl?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: ("require" & string)[];
        [k: string]: unknown;
      }
    | ("onevar" & string)
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("require" & string)[];
                [k: string]: unknown;
              }
            | ("onevar" & string)
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("require" & string)[];
                [k: string]: unknown;
              }
            | ("onevar" & string)
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: ("require" & string)[];
              [k: string]: unknown;
            }
          | ("onevar" & string)
        )
      | ((
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: ("require" & string)[];
              [k: string]: unknown;
            }
          | ("onevar" & string)
        ) &
          string)
    );
  /**
   * Require unassigned functions to be named inline.
   */
  requireNamedUnassignedFunctions?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: string[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: string[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires newline before opening curly brace of all block statements.  If true, always requires newline before curly brace of block statements.  Array specifies block-type keywords after which newlines are required before curly brace.
   */
  requireNewlineBeforeBlockStatements?: (Keywords21 & Keywords22) &
    (
      | ((Keywords21 & Keywords22) & unknown[])
      | (boolean & (Keywords21 & Keywords22))
      | (null & (Keywords21 & Keywords22))
    );
  /**
   * Requires use of binary, hexadecimal, and octal literals instead of parseInt.
   */
  requireNumericLiterals?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires variable declarations from objects via destructuring.
   */
  requireObjectDestructuring?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires placing object keys on new line.
   */
  requireObjectKeysOnNewLine?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: ("sameLine" & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("sameLine" & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("sameLine" & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: ("sameLine" & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires operators to appear before line breaks and not after.
   */
  requireOperatorBeforeLineBreak?: Operators & ((Operators & unknown[]) | (boolean & Operators) | (null & Operators));
  /**
   * Requires an extra blank newline after var declarations, as long as it is not the last expression in the current block.
   */
  requirePaddingNewLineAfterVariableDeclaration?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires newline after blocks.
   */
  requirePaddingNewLinesAfterBlocks?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: (("inCallExpressions" | "inNewExpressions" | "inArrayExpressions" | "inProperties") & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("inCallExpressions" | "inNewExpressions" | "inArrayExpressions" | "inProperties") &
                  string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("inCallExpressions" | "inNewExpressions" | "inArrayExpressions" | "inProperties") &
                  string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: (("inCallExpressions" | "inNewExpressions" | "inArrayExpressions" | "inProperties") &
                string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires a blank line after 'use strict'; statements.
   */
  requirePaddingNewLinesAfterUseStrict?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: ("require" & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("require" & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("require" & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: ("require" & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires newline before module.exports.
   */
  requirePaddingNewLinesBeforeExport?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires an empty line above the specified keywords unless the keyword is the first expression in a block.  If true, specifies that the spacedKeywords found in the utils module require an empty line above it.  Array values indicate keywords that require an empty line above it.
   */
  requirePaddingNewlinesBeforeKeywords?: (Keywords21 & Keywords22) &
    (
      | ((Keywords21 & Keywords22) & unknown[])
      | (boolean & (Keywords21 & Keywords22))
      | (null & (Keywords21 & Keywords22))
    );
  /**
   * Requires newline before line comments.
   */
  requirePaddingNewLinesBeforeLineComments?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: ("firstAfterCurly" & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("firstAfterCurly" & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("firstAfterCurly" & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: ("firstAfterCurly" & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires blocks to begin and end with 2 newlines.
   */
  requirePaddingNewlinesInBlocks?: (
    | boolean
    | number
    | NullRule
    | {
        /**
         * If true, validates that there is a newline after the opening brace in a block.
         */
        open?: boolean;
        /**
         * If true, validates that there is a newline before the closing brace in a block.
         */
        close?: boolean;
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: (("conditionals" | "functions") & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | number
            | NullRule
            | {
                /**
                 * If true, validates that there is a newline after the opening brace in a block.
                 */
                open?: boolean;
                /**
                 * If true, validates that there is a newline before the closing brace in a block.
                 */
                close?: boolean;
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("conditionals" | "functions") & string)[];
                [k: string]: unknown;
              }
          ))
      | (number &
          (
            | boolean
            | number
            | NullRule
            | {
                /**
                 * If true, validates that there is a newline after the opening brace in a block.
                 */
                open?: boolean;
                /**
                 * If true, validates that there is a newline before the closing brace in a block.
                 */
                close?: boolean;
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("conditionals" | "functions") & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | number
            | NullRule
            | {
                /**
                 * If true, validates that there is a newline after the opening brace in a block.
                 */
                open?: boolean;
                /**
                 * If true, validates that there is a newline before the closing brace in a block.
                 */
                close?: boolean;
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("conditionals" | "functions") & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | number
          | NullRule
          | {
              /**
               * If true, validates that there is a newline after the opening brace in a block.
               */
              open?: boolean;
              /**
               * If true, validates that there is a newline before the closing brace in a block.
               */
              close?: boolean;
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: (("conditionals" | "functions") & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires newline inside curly braces of all objects.
   */
  requirePaddingNewLinesInObjects?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires parentheses around arrow function expressions with a single parameter.
   */
  requireParenthesesAroundArrowParam?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires parentheses around immediately invoked function expressions.
   */
  requireParenthesesAroundIIFE?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires quoted keys in objects.
   */
  requireQuotedKeysInObjects?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires semicolon after:  var declaration, expression statement, return, throw, break, continue, do-while.
   */
  requireSemicolons?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Require arrow functions to use an expression body when returning a single statement (no block statement, implicit return).
   */
  requireShorthandArrowFunctions?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Disallows sticking binary operators to the right.
   */
  requireSpaceAfterBinaryOperators?: Operators & ((Operators & unknown[]) | (boolean & Operators) | (null & Operators));
  /**
   * Requires space after comma.
   */
  requireSpaceAfterComma?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: ("trailing" & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("trailing" & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("trailing" & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: ("trailing" & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires space after the specified keywords.  A value of true will disallow spaces after all possible keywords.
   */
  requireSpaceAfterKeywords?: (Keywords21 & Keywords22) &
    (
      | ((Keywords21 & Keywords22) & unknown[])
      | (boolean & (Keywords21 & Keywords22))
      | (null & (Keywords21 & Keywords22))
    );
  /**
   * Requires that a line comment (`//`) be followed by a space.
   */
  requireSpaceAfterLineComment?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of allowed strings before space.
         *
         * @minItems 0
         */
        allExcept?: string[];
        [k: string]: unknown;
      }
    | ("allowSlash" & string)
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of allowed strings before space.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
            | ("allowSlash" & string)
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of allowed strings before space.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
            | ("allowSlash" & string)
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of allowed strings before space.
               *
               * @minItems 0
               */
              allExcept?: string[];
              [k: string]: unknown;
            }
          | ("allowSlash" & string)
        )
      | ((
          | boolean
          | NullRule
          | {
              /**
               * Array of allowed strings before space.
               *
               * @minItems 0
               */
              allExcept?: string[];
              [k: string]: unknown;
            }
          | ("allowSlash" & string)
        ) &
          string)
    );
  /**
   * Requires space after object keys.
   */
  requireSpaceAfterObjectKeys?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Disallows sticking unary operators to the right.
   */
  requireSpaceAfterPrefixUnaryOperators?: UnaryOperators &
    ((UnaryOperators & unknown[]) | (boolean & UnaryOperators) | (null & UnaryOperators));
  /**
   * Disallows sticking binary operators to the left.
   */
  requireSpaceBeforeBinaryOperators?: Operators &
    ((Operators & unknown[]) | (boolean & Operators) | (null & Operators));
  /**
   * Requires space before block statements (for loops, control structures).
   */
  requireSpaceBeforeBlockStatements?: (boolean | NullRule | number) &
    (
      | (boolean & (boolean | NullRule | number))
      | (null & (boolean | NullRule | number))
      | (number & (boolean | NullRule | number))
    );
  /**
   * Requires a space before a comma.
   */
  requireSpaceBeforeComma?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires a space before a keyword.
   */
  requireSpaceBeforeKeywords?: (
    | BlockKeywords
    | boolean
    | NullRule
    | {
        /**
         * Array of allowed strings before space.
         *
         * @minItems 0
         */
        allExcept?: string[];
        [k: string]: unknown;
      }
  ) &
    (
      | ((
          | BlockKeywords
          | boolean
          | NullRule
          | {
              /**
               * Array of allowed strings before space.
               *
               * @minItems 0
               */
              allExcept?: string[];
              [k: string]: unknown;
            }
        ) &
          unknown[])
      | (boolean &
          (
            | BlockKeywords
            | boolean
            | NullRule
            | {
                /**
                 * Array of allowed strings before space.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | BlockKeywords
            | boolean
            | NullRule
            | {
                /**
                 * Array of allowed strings before space.
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (
          | BlockKeywords
          | boolean
          | NullRule
          | {
              /**
               * Array of allowed strings before space.
               *
               * @minItems 0
               */
              allExcept?: string[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires space after object keys.
   */
  requireSpaceBeforeObjectValues?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Disallows sticking unary operators to the left.
   */
  requireSpaceBeforePostfixUnaryOperators?: UnaryOperators &
    ((UnaryOperators & unknown[]) | (boolean & UnaryOperators) | (null & UnaryOperators));
  /**
   * Ensure there are spaces after argument separators in call expressions.
   */
  requireSpaceBetweenArguments?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires space before `()` or `{}` in function expressions (both named and anonymous).
   */
  requireSpacesInAnonymousFunctionExpression?: {
    beforeOpeningRoundBrace?: boolean | null;
    beforeOpeningCurlyBrace?: boolean | null;
    /**
     * A boolean or an array of quoted exceptions.
     */
    allExcept?: (boolean | NullRule | ("shorthand" & string)[]) &
      (
        | (boolean & (boolean | NullRule | ("shorthand" & string)[]))
        | (null & (boolean | NullRule | ("shorthand" & string)[]))
        | ((boolean | NullRule | ("shorthand" & string)[]) & unknown[])
      );
    [k: string]: unknown;
  } & (
    | (null & {
        beforeOpeningRoundBrace?: boolean | null;
        beforeOpeningCurlyBrace?: boolean | null;
        /**
         * A boolean or an array of quoted exceptions.
         */
        allExcept?: (boolean | NullRule | ("shorthand" & string)[]) &
          (
            | (boolean & (boolean | NullRule | ("shorthand" & string)[]))
            | (null & (boolean | NullRule | ("shorthand" & string)[]))
            | ((boolean | NullRule | ("shorthand" & string)[]) & unknown[])
          );
        [k: string]: unknown;
      })
    | {
        beforeOpeningRoundBrace?: boolean | null;
        beforeOpeningCurlyBrace?: boolean | null;
        /**
         * A boolean or an array of quoted exceptions.
         */
        allExcept?: (boolean | NullRule | ("shorthand" & string)[]) &
          (
            | (boolean & (boolean | NullRule | ("shorthand" & string)[]))
            | (null & (boolean | NullRule | ("shorthand" & string)[]))
            | ((boolean | NullRule | ("shorthand" & string)[]) & unknown[])
          );
        [k: string]: unknown;
      }
  );
  /**
   * Requires space before `()` in call expressions.
   */
  requireSpacesInCallExpression?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires space before and/or after `?` or `:` in conditional expressions.
   */
  requireSpacesInConditionalExpression?: (
    | boolean
    | NullRule
    | {
        afterTest?: boolean;
        beforeConsequent?: boolean;
        afterConsequent?: boolean;
        beforeAlternate?: boolean;
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                afterTest?: boolean;
                beforeConsequent?: boolean;
                afterConsequent?: boolean;
                beforeAlternate?: boolean;
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                afterTest?: boolean;
                beforeConsequent?: boolean;
                afterConsequent?: boolean;
                beforeAlternate?: boolean;
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              afterTest?: boolean;
              beforeConsequent?: boolean;
              afterConsequent?: boolean;
              beforeAlternate?: boolean;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires spaces in between `for` statement.
   */
  requireSpacesInForStatement?: (boolean | NullRule) &
    ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires space before `()` or `{}` in function expressions (both named and anonymous) and function declarations.
   */
  requireSpacesInFunction?: BraceRules1 & ((null & BraceRules1) | BraceRules1);
  /**
   * Requires space before `()` or `{}` in function declarations.
   */
  requireSpacesInFunctionDeclaration?: BraceRules1 & ((null & BraceRules1) | BraceRules1);
  /**
   * Requires space before `()` or `{}` in function expressions (both named and anonymous).
   */
  requireSpacesInFunctionExpression?: BraceRules1 & ((null & BraceRules1) | BraceRules1);
  /**
   * Requires space before and after `*` in generator functions.
   */
  requireSpacesInGenerator?: (
    | NullRule
    | {
        /**
         * If true, validates that there is a space before `*`.
         */
        beforeStar?: boolean;
        /**
         * If true, validates that there is a space after `*`.
         */
        afterStar?: boolean;
        [k: string]: unknown;
      }
  ) &
    (
      | (null &
          (
            | NullRule
            | {
                /**
                 * If true, validates that there is a space before `*`.
                 */
                beforeStar?: boolean;
                /**
                 * If true, validates that there is a space after `*`.
                 */
                afterStar?: boolean;
                [k: string]: unknown;
              }
          ))
      | (
          | NullRule
          | {
              /**
               * If true, validates that there is a space before `*`.
               */
              beforeStar?: boolean;
              /**
               * If true, validates that there is a space after `*`.
               */
              afterStar?: boolean;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires space before `()` or `{}` in named function expressions.
   */
  requireSpacesInNamedFunctionExpression?: BraceRules1 & ((null & BraceRules1) | BraceRules1);
  /**
   * Requires space after opening array square bracket and before closing.  Reports only on arrays, not on property accessors.  Use requireSpacesInsideBrackets to report on all brackets.
   */
  requireSpacesInsideArrayBrackets?: (
    | NullRule
    | {
        /**
         * Array of quoted tokens that can occur after an opening square bracket or before a closing square bracket without a space.
         *
         * @minItems 0
         */
        allExcept?: (("{" | "}" | "[" | "]") & string)[];
        [k: string]: unknown;
      }
    | (("all" | "allButNested") & string)
  ) &
    (
      | (null &
          (
            | NullRule
            | {
                /**
                 * Array of quoted tokens that can occur after an opening square bracket or before a closing square bracket without a space.
                 *
                 * @minItems 0
                 */
                allExcept?: (("{" | "}" | "[" | "]") & string)[];
                [k: string]: unknown;
              }
            | (("all" | "allButNested") & string)
          ))
      | (
          | NullRule
          | {
              /**
               * Array of quoted tokens that can occur after an opening square bracket or before a closing square bracket without a space.
               *
               * @minItems 0
               */
              allExcept?: (("{" | "}" | "[" | "]") & string)[];
              [k: string]: unknown;
            }
          | (("all" | "allButNested") & string)
        )
      | ((
          | NullRule
          | {
              /**
               * Array of quoted tokens that can occur after an opening square bracket or before a closing square bracket without a space.
               *
               * @minItems 0
               */
              allExcept?: (("{" | "}" | "[" | "]") & string)[];
              [k: string]: unknown;
            }
          | (("all" | "allButNested") & string)
        ) &
          string)
    );
  /**
   * Requires space after opening square bracket and before closing.  Reports on all on brackets, even on property accessors.  Use requireSpacesInsideArrayBrackets to exclude property accessors.
   */
  requireSpacesInsideBrackets?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted tokens that can occur after an opening square bracket or before a closing square bracket without a space.
         *
         * @minItems 0
         */
        allExcept?: (("{" | "}" | "[" | "]") & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted tokens that can occur after an opening square bracket or before a closing square bracket without a space.
                 *
                 * @minItems 0
                 */
                allExcept?: (("{" | "}" | "[" | "]") & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted tokens that can occur after an opening square bracket or before a closing square bracket without a space.
                 *
                 * @minItems 0
                 */
                allExcept?: (("{" | "}" | "[" | "]") & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted tokens that can occur after an opening square bracket or before a closing square bracket without a space.
               *
               * @minItems 0
               */
              allExcept?: (("{" | "}" | "[" | "]") & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires space after opening object curly brace and before closing.
   */
  requireSpacesInsideObjectBrackets?: (
    | NullRule
    | {
        /**
         * Array of quoted tokens that can occur after an opening object brace or before a closing object brace without a space.
         *
         * @minItems 0
         */
        allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
        [k: string]: unknown;
      }
    | (("all" | "allButNested") & string)
  ) &
    (
      | (null &
          (
            | NullRule
            | {
                /**
                 * Array of quoted tokens that can occur after an opening object brace or before a closing object brace without a space.
                 *
                 * @minItems 0
                 */
                allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
                [k: string]: unknown;
              }
            | (("all" | "allButNested") & string)
          ))
      | (
          | NullRule
          | {
              /**
               * Array of quoted tokens that can occur after an opening object brace or before a closing object brace without a space.
               *
               * @minItems 0
               */
              allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
              [k: string]: unknown;
            }
          | (("all" | "allButNested") & string)
        )
      | ((
          | NullRule
          | {
              /**
               * Array of quoted tokens that can occur after an opening object brace or before a closing object brace without a space.
               *
               * @minItems 0
               */
              allExcept?: (("(" | ")" | "{" | "}" | "[" | "]") & string)[];
              [k: string]: unknown;
            }
          | (("all" | "allButNested") & string)
        ) &
          string)
    );
  /**
   * Requires space after opening round bracket and before closing.
   */
  requireSpacesInsideParentheses?: (
    | NullRule
    | {
        all?: boolean;
        ignoreParenthesizedExpression?: boolean;
        /**
         * Array of quoted tokens that can occur after an opening bracket or before a closing bracket without a space.
         *
         * @minItems 0
         */
        except?: ((("(" | ")" | "{" | "}" | "[" | "]") | string) & string)[];
        [k: string]: unknown;
      }
    | (("all" | "allButNested") & string)
  ) &
    (
      | (null &
          (
            | NullRule
            | {
                all?: boolean;
                ignoreParenthesizedExpression?: boolean;
                /**
                 * Array of quoted tokens that can occur after an opening bracket or before a closing bracket without a space.
                 *
                 * @minItems 0
                 */
                except?: ((("(" | ")" | "{" | "}" | "[" | "]") | string) & string)[];
                [k: string]: unknown;
              }
            | (("all" | "allButNested") & string)
          ))
      | (
          | NullRule
          | {
              all?: boolean;
              ignoreParenthesizedExpression?: boolean;
              /**
               * Array of quoted tokens that can occur after an opening bracket or before a closing bracket without a space.
               *
               * @minItems 0
               */
              except?: ((("(" | ")" | "{" | "}" | "[" | "]") | string) & string)[];
              [k: string]: unknown;
            }
          | (("all" | "allButNested") & string)
        )
      | ((
          | NullRule
          | {
              all?: boolean;
              ignoreParenthesizedExpression?: boolean;
              /**
               * Array of quoted tokens that can occur after an opening bracket or before a closing bracket without a space.
               *
               * @minItems 0
               */
              except?: ((("(" | ")" | "{" | "}" | "[" | "]") | string) & string)[];
              [k: string]: unknown;
            }
          | (("all" | "allButNested") & string)
        ) &
          string)
    );
  /**
   * Requires space after opening and before closing grouping parentheses.
   */
  requireSpacesInsideParenthesizedExpression?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: (("{" | "}" | "function") & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("{" | "}" | "function") & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("{" | "}" | "function") & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: (("{" | "}" | "function") & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Disallows using `.apply` in favor of the spread operator.
   */
  requireSpread?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires the use of template strings instead of string concatenation.
   */
  requireTemplateStrings?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: ("stringConcatenation" & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("stringConcatenation" & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: ("stringConcatenation" & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: ("stringConcatenation" & string)[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires an extra comma following the final element of an array or object literal.
   */
  requireTrailingComma?: (
    | boolean
    | NullRule
    | {
        /**
         * If true, allows single property objects and single element arrays to not require a trailing comma.
         */
        ignoreSingleValue?: boolean;
        /**
         * If true, allows objects and arrays on a single line to not require a trailing comma.
         */
        ignoreSingleLine?: boolean;
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * If true, allows single property objects and single element arrays to not require a trailing comma.
                 */
                ignoreSingleValue?: boolean;
                /**
                 * If true, allows objects and arrays on a single line to not require a trailing comma.
                 */
                ignoreSingleLine?: boolean;
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * If true, allows single property objects and single element arrays to not require a trailing comma.
                 */
                ignoreSingleValue?: boolean;
                /**
                 * If true, allows objects and arrays on a single line to not require a trailing comma.
                 */
                ignoreSingleLine?: boolean;
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * If true, allows single property objects and single element arrays to not require a trailing comma.
               */
              ignoreSingleValue?: boolean;
              /**
               * If true, allows objects and arrays on a single line to not require a trailing comma.
               */
              ignoreSingleLine?: boolean;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Requires `var` declaration to be on the top of an enclosing scope.
   */
  requireVarDeclFirst?: (boolean | NullRule) & ((boolean & (boolean | NullRule)) | (null & (boolean | NullRule)));
  /**
   * Requires the variable to be the right hand operator when doing a boolean comparison.  An array of quoted operators can be supplied to indicate which operators requires yoda conditions.
   */
  requireYodaConditions?: (EqualityOperators | boolean | NullRule) &
    (
      | ((EqualityOperators | boolean | NullRule) & unknown[])
      | (boolean & (EqualityOperators | boolean | NullRule))
      | (null & (EqualityOperators | boolean | NullRule))
    );
  /**
   * Option to check `var that = this` expressions.
   */
  safeContextKeyword?: (string[] | NullRule | string) &
    (
      | ((string[] | NullRule | string) & unknown[])
      | (null & (string[] | NullRule | string))
      | ((string[] | NullRule | string) & string)
    );
  /**
   * Validates proper alignment of function parameters.
   */
  validateAlignedFunctionParameters?: (
    | boolean
    | NullRule
    | {
        /**
         * If true, specifies that the first function parameter must not be on the same line as the opening parenthesis `(` of the function parameters list.
         */
        lineBreakAfterOpeningBrace?: boolean;
        /**
         * If true, specifies that the last function parameter must not be on the same line as the closing parenthesis `)` of the function parameters list.
         */
        lineBreakBeforeClosingBrace?: boolean;
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * If true, specifies that the first function parameter must not be on the same line as the opening parenthesis `(` of the function parameters list.
                 */
                lineBreakAfterOpeningBrace?: boolean;
                /**
                 * If true, specifies that the last function parameter must not be on the same line as the closing parenthesis `)` of the function parameters list.
                 */
                lineBreakBeforeClosingBrace?: boolean;
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * If true, specifies that the first function parameter must not be on the same line as the opening parenthesis `(` of the function parameters list.
                 */
                lineBreakAfterOpeningBrace?: boolean;
                /**
                 * If true, specifies that the last function parameter must not be on the same line as the closing parenthesis `)` of the function parameters list.
                 */
                lineBreakBeforeClosingBrace?: boolean;
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * If true, specifies that the first function parameter must not be on the same line as the opening parenthesis `(` of the function parameters list.
               */
              lineBreakAfterOpeningBrace?: boolean;
              /**
               * If true, specifies that the last function parameter must not be on the same line as the closing parenthesis `)` of the function parameters list.
               */
              lineBreakBeforeClosingBrace?: boolean;
              [k: string]: unknown;
            }
        )
    );
  /**
   * This rule is for validating the positioning of line comments.  Block comments are ignored.  Comments that start with the following keywords are also ignored:  `eslint`, `jshint`, `jslint`, `istanbul`, `global`, `exported`, `jscs`, `falls through` eg. // jshint strict: true
   */
  validateCommentPosition?: (
    | NullRule
    | {
        position?: "above" | "beside";
        /**
         * Array of quoted exceptions (comments that start with these values will be excepted).
         *
         * @minItems 0
         */
        allExcept?: string[];
        [k: string]: unknown;
      }
  ) &
    (
      | (null &
          (
            | NullRule
            | {
                position?: "above" | "beside";
                /**
                 * Array of quoted exceptions (comments that start with these values will be excepted).
                 *
                 * @minItems 0
                 */
                allExcept?: string[];
                [k: string]: unknown;
              }
          ))
      | (
          | NullRule
          | {
              position?: "above" | "beside";
              /**
               * Array of quoted exceptions (comments that start with these values will be excepted).
               *
               * @minItems 0
               */
              allExcept?: string[];
              [k: string]: unknown;
            }
        )
    );
  /**
   * Validates indentation for switch statements and block statements.
   */
  validateIndentation?: (
    | number
    | NullRule
    | {
        value: (number | string) & ((number & (number | string)) | ((number | string) & string));
        /**
         * Deprecated.  Require empty lines to be indented.
         */
        includeEmptyLines?: boolean;
        /**
         * Array of quoted exceptions.
         *
         * @minItems 0
         */
        allExcept?: (("comments" | "emptyLines") & string)[];
        [k: string]: unknown;
      }
  ) &
    (
      | (number &
          (
            | number
            | NullRule
            | {
                value: (number | string) & ((number & (number | string)) | ((number | string) & string));
                /**
                 * Deprecated.  Require empty lines to be indented.
                 */
                includeEmptyLines?: boolean;
                /**
                 * Array of quoted exceptions.
                 *
                 * @minItems 0
                 */
                allExcept?: (("comments" | "emptyLines") & string)[];
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | number
            | NullRule
            | {
                value: (number | string) & ((number & (number | string)) | ((number | string) & string));
                /**
                 * Deprecated.  Require empty lines to be indented.
                 */
                includeEmptyLines?: boolean;
                /**
                 * Array of quoted exceptions.
                 *
                 * @minItems 0
                 */
                allExcept?: (("comments" | "emptyLines") & string)[];
                [k: string]: unknown;
              }
          ))
      | (
          | number
          | NullRule
          | {
              value: (number | string) & ((number & (number | string)) | ((number | string) & string));
              /**
               * Deprecated.  Require empty lines to be indented.
               */
              includeEmptyLines?: boolean;
              /**
               * Array of quoted exceptions.
               *
               * @minItems 0
               */
              allExcept?: (("comments" | "emptyLines") & string)[];
              [k: string]: unknown;
            }
        )
      | ((
          | number
          | NullRule
          | {
              value: (number | string) & ((number & (number | string)) | ((number | string) & string));
              /**
               * Deprecated.  Require empty lines to be indented.
               */
              includeEmptyLines?: boolean;
              /**
               * Array of quoted exceptions.
               *
               * @minItems 0
               */
              allExcept?: (("comments" | "emptyLines") & string)[];
              [k: string]: unknown;
            }
        ) &
          string)
    );
  /**
   * Option to check line break characters.
   */
  validateLineBreaks?: (
    | NullRule
    | {
        character?: "CR" | "LF" | "CRLF";
        /**
         * If true, specifies that validation for the file should stop running upon encountering the first rule violation and return the details of that violation in the report.
         */
        reportOncePerFile?: boolean;
        [k: string]: unknown;
      }
    | ("CR" | "LF" | "CRLF")
  ) &
    (
      | (null &
          (
            | NullRule
            | {
                character?: "CR" | "LF" | "CRLF";
                /**
                 * If true, specifies that validation for the file should stop running upon encountering the first rule violation and return the details of that violation in the report.
                 */
                reportOncePerFile?: boolean;
                [k: string]: unknown;
              }
            | ("CR" | "LF" | "CRLF")
          ))
      | (
          | NullRule
          | {
              character?: "CR" | "LF" | "CRLF";
              /**
               * If true, specifies that validation for the file should stop running upon encountering the first rule violation and return the details of that violation in the report.
               */
              reportOncePerFile?: boolean;
              [k: string]: unknown;
            }
          | ("CR" | "LF" | "CRLF")
        )
      | ((
          | NullRule
          | {
              character?: "CR" | "LF" | "CRLF";
              /**
               * If true, specifies that validation for the file should stop running upon encountering the first rule violation and return the details of that violation in the report.
               */
              reportOncePerFile?: boolean;
              [k: string]: unknown;
            }
          | ("CR" | "LF" | "CRLF")
        ) &
          string)
    );
  /**
   * Requires each element in array on a single line when array length is more than passed maximum number or array fills more than one line.
   */
  validateNewlineAfterArrayElements?: (
    | boolean
    | number
    | NullRule
    | {
        maximum?: number;
        /**
         * If true, specifies that the `[` and `]` brackets can be placed on the same line as the array elements.
         */
        ignoreBrackets?: boolean;
        [k: string]: unknown;
      }
  ) &
    (
      | (boolean &
          (
            | boolean
            | number
            | NullRule
            | {
                maximum?: number;
                /**
                 * If true, specifies that the `[` and `]` brackets can be placed on the same line as the array elements.
                 */
                ignoreBrackets?: boolean;
                [k: string]: unknown;
              }
          ))
      | (number &
          (
            | boolean
            | number
            | NullRule
            | {
                maximum?: number;
                /**
                 * If true, specifies that the `[` and `]` brackets can be placed on the same line as the array elements.
                 */
                ignoreBrackets?: boolean;
                [k: string]: unknown;
              }
          ))
      | (null &
          (
            | boolean
            | number
            | NullRule
            | {
                maximum?: number;
                /**
                 * If true, specifies that the `[` and `]` brackets can be placed on the same line as the array elements.
                 */
                ignoreBrackets?: boolean;
                [k: string]: unknown;
              }
          ))
      | (
          | boolean
          | number
          | NullRule
          | {
              maximum?: number;
              /**
               * If true, specifies that the `[` and `]` brackets can be placed on the same line as the array elements.
               */
              ignoreBrackets?: boolean;
              [k: string]: unknown;
            }
        )
    );
  /**
   * Validates the order in object keys.
   */
  validateOrderInObjectKeys?: (
    | boolean
    | NullRule
    | (("asc" | "asc-insensitive" | "asc-natural" | "desc" | "desc-insensitive" | "desc-natural") & string)
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | (("asc" | "asc-insensitive" | "asc-natural" | "desc" | "desc-insensitive" | "desc-natural") & string)
          ))
      | (null &
          (
            | boolean
            | NullRule
            | (("asc" | "asc-insensitive" | "asc-natural" | "desc" | "desc-insensitive" | "desc-natural") & string)
          ))
      | ((
          | boolean
          | NullRule
          | (("asc" | "asc-insensitive" | "asc-natural" | "desc" | "desc-insensitive" | "desc-natural") & string)
        ) &
          string)
    );
  /**
   * Enable validation of separators between function parameters.  Will ignore newlines.
   */
  validateParameterSeparator?: (NullRule | (("," | ", " | " ," | " , ") & string)) &
    (
      | (null & (NullRule | (("," | ", " | " ," | " , ") & string)))
      | ((NullRule | (("," | ", " | " ," | " , ") & string)) & string)
    );
  /**
   * Requires all quote marks to be either the supplied value, or consistent if `true`.
   */
  validateQuoteMarks?: (
    | boolean
    | NullRule
    | {
        /**
         * Allow the "other" quote mark to be used, but only to avoid having to escape.
         */
        escape?: boolean;
        /**
         * The same effect as the non-object values.
         */
        mark?: "" & string;
        /**
         * Ignore JSX nodes.
         */
        ignoreJSX?: boolean;
        [k: string]: unknown;
      }
    | (('"' | "'") & string)
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Allow the "other" quote mark to be used, but only to avoid having to escape.
                 */
                escape?: boolean;
                /**
                 * The same effect as the non-object values.
                 */
                mark?: "" & string;
                /**
                 * Ignore JSX nodes.
                 */
                ignoreJSX?: boolean;
                [k: string]: unknown;
              }
            | (('"' | "'") & string)
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Allow the "other" quote mark to be used, but only to avoid having to escape.
                 */
                escape?: boolean;
                /**
                 * The same effect as the non-object values.
                 */
                mark?: "" & string;
                /**
                 * Ignore JSX nodes.
                 */
                ignoreJSX?: boolean;
                [k: string]: unknown;
              }
            | (('"' | "'") & string)
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Allow the "other" quote mark to be used, but only to avoid having to escape.
               */
              escape?: boolean;
              /**
               * The same effect as the non-object values.
               */
              mark?: "" & string;
              /**
               * Ignore JSX nodes.
               */
              ignoreJSX?: boolean;
              [k: string]: unknown;
            }
          | (('"' | "'") & string)
        )
      | ((
          | boolean
          | NullRule
          | {
              /**
               * Allow the "other" quote mark to be used, but only to avoid having to escape.
               */
              escape?: boolean;
              /**
               * The same effect as the non-object values.
               */
              mark?: "" & string;
              /**
               * Ignore JSX nodes.
               */
              ignoreJSX?: boolean;
              [k: string]: unknown;
            }
          | (('"' | "'") & string)
        ) &
          string)
    );
  [k: string]: unknown;
}
/**
 * Validate jsdoc comments.
 */
export interface JsDoc {
  /**
   * Checks whether tag names are valid.
   */
  checkAnnotations?: (
    | boolean
    | NullRule
    | {
        preset?: ("closurecompiler" | "jsdoc3" | "jsduck5") & string;
        /**
         * Add custom tags with the extra field.  The extra field should contain tags in keys with true, false, or "some" for the values.
         */
        extra?: {
          [k: string]: true | false | "some";
        };
        [k: string]: unknown;
      }
    | (("closurecompiler" | "jsdoc3" | "jsduck5") & string)
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                preset?: ("closurecompiler" | "jsdoc3" | "jsduck5") & string;
                /**
                 * Add custom tags with the extra field.  The extra field should contain tags in keys with true, false, or "some" for the values.
                 */
                extra?: {
                  [k: string]: true | false | "some";
                };
                [k: string]: unknown;
              }
            | (("closurecompiler" | "jsdoc3" | "jsduck5") & string)
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                preset?: ("closurecompiler" | "jsdoc3" | "jsduck5") & string;
                /**
                 * Add custom tags with the extra field.  The extra field should contain tags in keys with true, false, or "some" for the values.
                 */
                extra?: {
                  [k: string]: true | false | "some";
                };
                [k: string]: unknown;
              }
            | (("closurecompiler" | "jsdoc3" | "jsduck5") & string)
          ))
      | (
          | boolean
          | NullRule
          | {
              preset?: ("closurecompiler" | "jsdoc3" | "jsduck5") & string;
              /**
               * Add custom tags with the extra field.  The extra field should contain tags in keys with true, false, or "some" for the values.
               */
              extra?: {
                [k: string]: true | false | "some";
              };
              [k: string]: unknown;
            }
          | (("closurecompiler" | "jsdoc3" | "jsduck5") & string)
        )
      | ((
          | boolean
          | NullRule
          | {
              preset?: ("closurecompiler" | "jsdoc3" | "jsduck5") & string;
              /**
               * Add custom tags with the extra field.  The extra field should contain tags in keys with true, false, or "some" for the values.
               */
              extra?: {
                [k: string]: true | false | "some";
              };
              [k: string]: unknown;
            }
          | (("closurecompiler" | "jsdoc3" | "jsduck5") & string)
        ) &
          string)
    );
  /**
   * Checks whether all parameters are documented.
   */
  checkParamExistence?: boolean | null;
  /**
   * Checks whether param names in jsdoc and in function declaration are equal.
   */
  checkParamNames?: boolean | null;
  /**
   * Checks whether params in jsdoc contains type.
   */
  requireParamTypes?: boolean | null;
  /**
   * Reports redundant params in jsdoc.
   */
  checkRedundantParams?: boolean | null;
  /**
   * Checks for differences between the jsdoc and actual return types if both exist.
   */
  checkReturnTypes?: boolean | null;
  /**
   * Report statements for functions without a return, which are described with an @return tag.
   */
  checkRedundantReturns?: boolean | null;
  /**
   * Checks whether @returns in jsdoc contains type.
   */
  requireReturnTypes?: boolean | null;
  /**
   * Reports invalid types for bunch of tags.
   */
  checkTypes?: (boolean | NullRule | (("strictNativeCase" | "capitalizedNativeCase") & string)) &
    (
      | (boolean & (boolean | NullRule | (("strictNativeCase" | "capitalizedNativeCase") & string)))
      | (null & (boolean | NullRule | (("strictNativeCase" | "capitalizedNativeCase") & string)))
      | ((boolean | NullRule | (("strictNativeCase" | "capitalizedNativeCase") & string)) & string)
    );
  /**
   * Reports redundant access declarations.
   */
  checkRedundantAccess?: (boolean | NullRule | (("enforceLeadingUnderscore" | "enforceTrailingUnderscore") & string)) &
    (
      | (boolean & (boolean | NullRule | (("enforceLeadingUnderscore" | "enforceTrailingUnderscore") & string)))
      | (null & (boolean | NullRule | (("enforceLeadingUnderscore" | "enforceTrailingUnderscore") & string)))
      | ((boolean | NullRule | (("enforceLeadingUnderscore" | "enforceTrailingUnderscore") & string)) & string)
    );
  /**
   * Checks whether access declaration is set for _underscored function names.  Ignores a bunch of popular identifiers: __filename, __dirname, __proto__, __defineGetter__, super_, __constructor, etc.
   */
  leadingUnderscoreAccess?: (boolean | NullRule | (("private" | "protected") & string)) &
    (
      | (boolean & (boolean | NullRule | (("private" | "protected") & string)))
      | (null & (boolean | NullRule | (("private" | "protected") & string)))
      | ((boolean | NullRule | (("private" | "protected") & string)) & string)
    );
  /**
   * Checks whether jsdoc block exists.
   */
  enforceExistence?: (
    | boolean
    | NullRule
    | {
        /**
         * Array of quoted keywords to exempt.
         *
         * @minItems 0
         */
        allExcept?: (("expressions" | "exports" | "paramless-procedures") & string)[];
        [k: string]: unknown;
      }
    | ("exceptExports" & string)
  ) &
    (
      | (boolean &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("expressions" | "exports" | "paramless-procedures") & string)[];
                [k: string]: unknown;
              }
            | ("exceptExports" & string)
          ))
      | (null &
          (
            | boolean
            | NullRule
            | {
                /**
                 * Array of quoted keywords to exempt.
                 *
                 * @minItems 0
                 */
                allExcept?: (("expressions" | "exports" | "paramless-procedures") & string)[];
                [k: string]: unknown;
              }
            | ("exceptExports" & string)
          ))
      | (
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: (("expressions" | "exports" | "paramless-procedures") & string)[];
              [k: string]: unknown;
            }
          | ("exceptExports" & string)
        )
      | ((
          | boolean
          | NullRule
          | {
              /**
               * Array of quoted keywords to exempt.
               *
               * @minItems 0
               */
              allExcept?: (("expressions" | "exports" | "paramless-procedures") & string)[];
              [k: string]: unknown;
            }
          | ("exceptExports" & string)
        ) &
          string)
    );
  /**
   * Checks whether a jsdoc param description has a hyphen before it (checks for -).
   */
  requireHyphenBeforeDescription?: boolean | null;
  /**
   * Checks whether a jsdoc comment description has a padding (trailing) newline separator between it and additional @tags.
   */
  requireNewlineAfterDescription?: boolean | null;
  /**
   * Checks whether a jsdoc comment description has no padding (trailing) newline separator between it and additional @tags.
   */
  disallowNewlineAfterDescription?: boolean | null;
  /**
   * Checks whether a jsdoc comment description is a complete sentence.  A complete sentence is defined as starting with an upper case letter and ending with a period.
   */
  requireDescriptionCompleteSentence?: boolean | null;
  /**
   * Checks whether a jsdoc param description exists.
   */
  requireParamDescription?: boolean | null;
  /**
   * Checks whether a jsdoc return description exists.
   */
  requireReturnDescription?: boolean | null;
  [k: string]: unknown;
}

/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * A more detailed description
 */
export type Description = string;
/**
 * A human-readable name
 */
export type DisplayName = string;
/**
 * A URL pointing to an icon image
 */
export type IconUrl = string;
/**
 * The alias to use as the name of the option
 */
export type As = string;
/**
 * The options name
 */
export type Name = string;
/**
 * The original name of the option
 */
export type Name1 = string;
/**
 * The list of fragment options to make available as accelerator options
 */
export type Expose = Expose1[];
/**
 * The alias to use as the name of the type
 */
export type As1 = string;
/**
 * The original name of the type
 */
export type Name2 = string;
/**
 * The list of fragment types to make available as accelerator types
 */
export type ExposeTypes = ExposeTypes1[];
/**
 * The name of the fragment to import
 */
export type Name3 = string;
/**
 * The list of fragment to import
 */
export type Imports = Imports1[];
export type AcceleratorOption = AcceleratorOption1 & {
  choices?: Choices;
  dataType?: DataType;
  defaultValue?: DefaultValue;
  dependsOn?: DependsOn & DependsOn2;
  description?: Description1;
  inputType?: InputType;
  label?: Label;
  name?: Name4;
  required?: Required;
  validationRegex?: Pattern & ValidationRegex;
  [k: string]: unknown | undefined;
};
export type AcceleratorOption1 =
  | {
      dataType?: "string";
      defaultValue?: string;
      [k: string]: unknown | undefined;
    }
  | {
      dataType?: "string"[];
      defaultValue?: string[];
      [k: string]: unknown | undefined;
    }
  | {
      dataType?: "number";
      defaultValue?: number;
      [k: string]: unknown | undefined;
    }
  | {
      dataType?: "number"[];
      defaultValue?: number[];
      [k: string]: unknown | undefined;
    }
  | {
      dataType?: "boolean";
      defaultValue?: boolean;
      [k: string]: unknown | undefined;
    }
  | {
      dataType?: "boolean"[];
      defaultValue?: boolean[];
      [k: string]: unknown | undefined;
    }
  | {
      dataType?: string;
      defaultValue?: {
        [k: string]: unknown | undefined;
      };
      [k: string]: unknown | undefined;
    }
  | {
      dataType?: string[];
      defaultValue?: {
        [k: string]: unknown | undefined;
      }[];
      [k: string]: unknown | undefined;
    };
/**
 * The displayed text
 */
export type Text = string;
/**
 * A list of predefined choices
 */
export type Choices = Choices1[];
/**
 * The option data type
 */
export type DataType =
  | "string"
  | "number"
  | "boolean"
  | string
  | ["string"]
  | ["number"]
  | ["boolean"]
  | [string]
  | null;
/**
 * A tooltip to accompany the input
 */
export type Description1 = string;
/**
 * The HTML input type used to display the option
 */
export type InputType = "text" | "textarea" | "checkbox" | "select" | "radio";
/**
 * A human-readable version of the name identifying the option
 */
export type Label = string;
/**
 * A unique, camelCase name
 */
export type Name4 = string;
/**
 * Whether the user is required to enter a value in the UI
 */
export type Required = boolean;
export type Pattern = string;
/**
 * The list of options passed to the UI to create input text boxes
 */
export type Options = (AcceleratorOption & Options1)[];
export type Tags1 = string;
/**
 * A list of tags used to filter accelerators
 */
export type Tags = Tags1[];
/**
 * The capitalized name of this custom type
 */
export type Name5 = string;
/**
 * A sequence of option definitions
 *
 * @minItems 1
 */
export type Struct = [AcceleratorOption1 & Struct1, ...(AcceleratorOption1 & Struct1)[]];
/**
 * The definitions of custom types
 */
export type Types = Types1[];
export type Loop2 = Loop1 & {
  type: "Loop";
  [k: string]: unknown | undefined;
};
export type Expression = string;
export type Chain2 = Chain1 & {
  type: "Chain";
  [k: string]: unknown | undefined;
};
/**
 * The path patterns used to filter which files to apply the Transforms to
 *
 * @minItems 1
 */
export type ApplyTo = [ApplyTo1, ...ApplyTo1[]];
export type ApplyTo1 = string;
/**
 * The transform name
 */
export type Name6 = string;
export type Provenance2 = Provenance1 & {
  type: "Provenance";
  [k: string]: unknown | undefined;
};
/**
 * The transform name
 */
export type Name7 = string;
export type Exclude2 = Exclude1 & {
  type: "Exclude";
  [k: string]: unknown | undefined;
};
/**
 * The transform name
 */
export type Name8 = string;
export type Patterns1 = string;
/**
 * The path patterns used to filter which files to exclude
 */
export type Patterns = Patterns1[];
export type Include2 = Include1 & {
  type: "Include";
  [k: string]: unknown | undefined;
};
/**
 * The transform name
 */
export type Name9 = string;
export type Patterns3 = string;
/**
 * The path patterns used to filter which files to include
 */
export type Patterns2 = Patterns3[];
export type Combo2 = Combo1 & {
  type?: "Combo";
  [k: string]: unknown | undefined;
};
/**
 * The path patterns used to filter which files to apply the Transforms to
 *
 * @minItems 1
 */
export type ApplyTo2 = [ApplyTo3, ...ApplyTo3[]];
export type ApplyTo3 = string;
export type ReplaceText2 = ReplaceText1 & {
  type: "ReplaceText";
  [k: string]: unknown | undefined;
};
/**
 * The transform name
 */
export type Name10 = string;
/**
 * The text that will be replaced
 */
export type Text1 = string;
/**
 * The replacement rules using literal text tokens
 */
export type Substitutions = Substitutions1[];
export type InvokeFragment2 = InvokeFragment1 & {
  type: "InvokeFragment";
  [k: string]: unknown | undefined;
};
export type Anchor = string;
/**
 * The name under which the new symbol will be added
 */
export type Name11 = string;
export type Let = (DerivedSymbol & Let1)[];
/**
 * The transform name
 */
export type Name12 = string;
export type Reference = string;
export type Merge2 = Merge1 & {
  type: "Merge";
  [k: string]: unknown | undefined;
};
/**
 * The transform name
 */
export type Name13 = string;
export type OpenRewriteRecipe2 = OpenRewriteRecipe1 & {
  type: "OpenRewriteRecipe";
  [k: string]: unknown | undefined;
};
/**
 * The transform name
 */
export type Name14 = string;
export type ParseOrFail = boolean;
/**
 * Full qualified classname of the recipe
 */
export type Recipe = string;
export type RewritePath2 = RewritePath1 & {
  type: "RewritePath";
  [k: string]: unknown | undefined;
};
/**
 * Whether an error should occur if the regex doesn't match
 */
export type MatchOrFail = boolean;
/**
 * The transform name
 */
export type Name15 = string;
export type UniquePath2 = UniquePath1 & {
  type: "UniquePath";
  [k: string]: unknown | undefined;
};
/**
 * The transform name
 */
export type Name16 = string;
export type ConflictResolution = "Fail" | "UseFirst" | "UseLast" | "Append" | "FavorOwn" | "FavorForeign" | "NWayDiff";
export type YTT2 = YTT1 & {
  type: "YTT";
  [k: string]: unknown | undefined;
};
/**
 * A list of variable names that are allowed to be passed to YTT
 */
export type AllowList = (Pattern & AllowList1)[];
/**
 * A list of variable names that are denied from being passed to YTT
 */
export type DenyList = (Pattern & DenyList1)[];
/**
 * A list of SpEL expressions whose results are additional command line arguments
 */
export type ExtraArgs = (Expression & ExtraArgs1)[];
/**
 * The transform name
 */
export type Name17 = string;
export type Let2 = Let11 & {
  type: "Let";
  [k: string]: unknown | undefined;
};
export type UseEncoding2 = UseEncoding1 & {
  type: "UseEncoding";
  [k: string]: unknown | undefined;
};
/**
 * The transform name
 */
export type Name18 = string;
/**
 * The transform name
 */
export type Name19 = string;
/**
 * Whether shadowing should be turned off
 */
export type NoShadow = boolean;
/**
 * A list of additional variables and their values
 */
export type Symbols = (DerivedSymbol & Symbols1)[];
/**
 * A list of child Transforms to be executed in parallel
 */
export type Sources = (
  | Loop2
  | Chain2
  | Provenance2
  | Exclude2
  | Include2
  | Combo2
  | ReplaceText2
  | InvokeFragment2
  | Merge2
  | OpenRewriteRecipe2
  | RewritePath2
  | UniquePath2
  | YTT2
  | Let2
  | UseEncoding2
  | InvokeFragment2
)[];
/**
 * A list of child Transforms to apply sequentially
 */
export type Chain = (
  | Loop2
  | Chain2
  | Provenance2
  | Exclude2
  | Include2
  | Combo2
  | ReplaceText2
  | InvokeFragment2
  | Merge2
  | OpenRewriteRecipe2
  | RewritePath2
  | UniquePath2
  | YTT2
  | Let2
  | UseEncoding2
  | InvokeFragment2
)[];
export type Exclude3 = string;
/**
 * The path patterns used to filter which files to exclude
 */
export type Exclude = Exclude3[];
export type Include3 = string;
/**
 * The path patterns used to filter which files to include
 */
export type Include = Include3[];
/**
 * A list of additional variables and their values
 */
export type Let3 = (DerivedSymbol & Let4)[];
/**
 * A list of child Transforms to be executed in parallel
 */
export type Merge = (
  | Loop2
  | Chain2
  | Provenance2
  | Exclude2
  | Include2
  | Combo2
  | ReplaceText2
  | InvokeFragment2
  | Merge2
  | OpenRewriteRecipe2
  | RewritePath2
  | UniquePath2
  | YTT2
  | Let2
  | UseEncoding2
  | InvokeFragment2
)[];
/**
 * The transform name
 */
export type Name20 = string;
/**
 * A list of child Transforms to apply sequentially
 */
export type Transformations = (
  | Loop2
  | Chain2
  | Provenance2
  | Exclude2
  | Include2
  | Combo2
  | ReplaceText2
  | InvokeFragment2
  | Merge2
  | OpenRewriteRecipe2
  | RewritePath2
  | UniquePath2
  | YTT2
  | Let2
  | UseEncoding2
  | InvokeFragment2
)[];
/**
 * The variable's name to be assigned to the index of the current element on each iteration
 */
export type Index = string;
/**
 * The transform name
 */
export type Name21 = string;
/**
 * The name of the variable to be assigned to the current element on each iteration
 */
export type Var = string;

export interface Accelerator {
  accelerator?: Accelerator1;
  engine?:
    | Loop2
    | Chain2
    | Provenance2
    | Exclude2
    | Include2
    | Combo2
    | ReplaceText2
    | InvokeFragment2
    | Merge2
    | OpenRewriteRecipe2
    | RewritePath2
    | UniquePath2
    | YTT2
    | Let2
    | UseEncoding2;
  [k: string]: unknown | undefined;
}
/**
 * The metadata (non-behavioral) part of an App Accelerator's accelerator.yaml file
 */
export interface Accelerator1 {
  description?: Description;
  displayName?: DisplayName;
  iconUrl?: IconUrl;
  imports?: Imports;
  options?: Options;
  tags?: Tags;
  types?: Types;
  [k: string]: unknown | undefined;
}
export interface Imports1 {
  expose?: Expose;
  exposeTypes?: ExposeTypes;
  name?: Name3;
  [k: string]: unknown | undefined;
}
export interface Expose1 {
  as?: As;
  dependsOn?: DependsOn & DependsOn1;
  name?: Name1;
  [k: string]: unknown | undefined;
}
export interface DependsOn {
  name?: Name;
  value?: Value;
  [k: string]: unknown | undefined;
}
/**
 * The desired options value to compare against
 */
export interface Value {
  [k: string]: unknown | undefined;
}
/**
 * The dependency that controls this options visibility
 */
export interface DependsOn1 {
  [k: string]: unknown | undefined;
}
export interface ExposeTypes1 {
  as?: As1;
  name?: Name2;
  [k: string]: unknown | undefined;
}
export interface Choices1 {
  text?: Text;
  value?: Value1;
  [k: string]: unknown | undefined;
}
/**
 * The value that the form returns for this choice
 */
export interface Value1 {
  [k: string]: unknown | undefined;
}
/**
 * The value used to pre-populate the option
 */
export interface DefaultValue {
  [k: string]: unknown | undefined;
}
/**
 * The dependency that controls this options visibility
 */
export interface DependsOn2 {
  [k: string]: unknown | undefined;
}
/**
 * A regex that validates the string representation of the option value when set
 */
export interface ValidationRegex {
  [k: string]: unknown | undefined;
}
export interface Options1 {
  [k: string]: unknown | undefined;
}
export interface Types1 {
  name?: Name5;
  struct?: Struct;
  [k: string]: unknown | undefined;
}
export interface Struct1 {
  [k: string]: unknown | undefined;
}
export interface Loop1 {
  condition?: Expression & Condition;
  doAsChain?:
    | Loop2
    | Chain2
    | Provenance2
    | Exclude2
    | Include2
    | Combo2
    | ReplaceText2
    | InvokeFragment2
    | Merge2
    | OpenRewriteRecipe2
    | RewritePath2
    | UniquePath2
    | YTT2
    | Let2
    | UseEncoding2;
  doAsMerge?:
    | Loop2
    | Chain2
    | Provenance2
    | Exclude2
    | Include2
    | Combo2
    | ReplaceText2
    | InvokeFragment2
    | Merge2
    | OpenRewriteRecipe2
    | RewritePath2
    | UniquePath2
    | YTT2
    | Let2
    | UseEncoding2;
  index?: Index;
  name?: Name21;
  on?: Expression & On;
  var?: Var;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition {
  [k: string]: unknown | undefined;
}
export interface Chain1 {
  applyTo?: ApplyTo;
  condition?: Expression & Condition1;
  name?: Name6;
  transformations?: Transformations;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition1 {
  [k: string]: unknown | undefined;
}
export interface Provenance1 {
  condition?: Expression & Condition2;
  name?: Name7;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition2 {
  [k: string]: unknown | undefined;
}
export interface Exclude1 {
  condition?: Expression & Condition3;
  name?: Name8;
  patterns?: Patterns;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition3 {
  [k: string]: unknown | undefined;
}
export interface Include1 {
  condition?: Expression & Condition4;
  name?: Name9;
  patterns?: Patterns2;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition4 {
  [k: string]: unknown | undefined;
}
export interface Combo1 {
  applyTo?: ApplyTo2;
  chain?: Chain;
  condition?: Expression & Condition14;
  exclude?: Exclude;
  include?: Include;
  let?: Let3;
  merge?: Merge;
  name?: Name20;
  onConflict?: ConflictResolution & OnConflict;
  [k: string]: unknown | undefined;
}
export interface ReplaceText1 {
  condition?: Expression & Condition5;
  name?: Name10;
  regex?: Regex;
  substitutions?: Substitutions;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition5 {
  [k: string]: unknown | undefined;
}
/**
 * The replacement rule using a single regular expression
 */
export interface Regex {
  pattern?: Pattern & Pattern1;
  with?: Expression & With;
  [k: string]: unknown | undefined;
}
/**
 * The regular expression that determines text that will be replaced
 */
export interface Pattern1 {
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that evaluates to the text that will replace the previous string
 */
export interface With {
  [k: string]: unknown | undefined;
}
export interface Substitutions1 {
  text?: Text1;
  with?: Expression & With1;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that evaluates to the text that will replace the previous string
 */
export interface With1 {
  [k: string]: unknown | undefined;
}
export interface InvokeFragment1 {
  anchor?: Anchor;
  condition?: Expression & Condition6;
  let?: Let;
  name?: Name12;
  reference?: Reference;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition6 {
  [k: string]: unknown | undefined;
}
export interface DerivedSymbol {
  expression?: Expression & Expression1;
  name?: Name11;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression to evaluate to compute the symbol value
 */
export interface Expression1 {
  [k: string]: unknown | undefined;
}
export interface Let1 {
  [k: string]: unknown | undefined;
}
export interface Merge1 {
  condition?: Expression & Condition7;
  name?: Name13;
  sources?: Sources;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition7 {
  [k: string]: unknown | undefined;
}
export interface OpenRewriteRecipe1 {
  condition?: Expression & Condition8;
  name?: Name14;
  options?: Options2;
  parseOrFail?: ParseOrFail;
  recipe?: Recipe;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition8 {
  [k: string]: unknown | undefined;
}
/**
 * Keys and values that depend on the class of the recipe
 */
export interface Options2 {
  [k: string]: unknown | undefined;
}
export interface RewritePath1 {
  condition?: Expression & Condition9;
  matchOrFail?: MatchOrFail;
  name?: Name15;
  regex?: Pattern & Regex1;
  rewriteTo?: Expression & RewriteTo;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition9 {
  [k: string]: unknown | undefined;
}
/**
 * The regular expression used to match each input files path
 */
export interface Regex1 {
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression of the location that the file will be rewritten to
 */
export interface RewriteTo {
  [k: string]: unknown | undefined;
}
export interface UniquePath1 {
  condition?: Expression & Condition10;
  name?: Name16;
  strategy?: ConflictResolution & Strategy;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition10 {
  [k: string]: unknown | undefined;
}
/**
 * How conflict is handled when an operation produces multiple files at the same path
 */
export interface Strategy {
  [k: string]: unknown | undefined;
}
export interface YTT1 {
  allowList?: AllowList;
  condition?: Expression & Condition11;
  denyList?: DenyList;
  extraArgs?: ExtraArgs;
  name?: Name17;
  [k: string]: unknown | undefined;
}
export interface AllowList1 {
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition11 {
  [k: string]: unknown | undefined;
}
export interface DenyList1 {
  [k: string]: unknown | undefined;
}
export interface ExtraArgs1 {
  [k: string]: unknown | undefined;
}
export interface Let11 {
  condition?: Expression & Condition12;
  in?:
    | Loop2
    | Chain2
    | Provenance2
    | Exclude2
    | Include2
    | Combo2
    | ReplaceText2
    | InvokeFragment2
    | Merge2
    | OpenRewriteRecipe2
    | RewritePath2
    | UniquePath2
    | YTT2
    | Let2
    | UseEncoding2;
  name?: Name19;
  noShadow?: NoShadow;
  symbols?: Symbols;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition12 {
  [k: string]: unknown | undefined;
}
export interface UseEncoding1 {
  condition?: Expression & Condition13;
  encoding?: Encoding;
  name?: Name18;
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition13 {
  [k: string]: unknown | undefined;
}
/**
 * The encuding to use, as recognized by the java java.nio.charset.Charset class
 */
export interface Encoding {
  [k: string]: unknown | undefined;
}
export interface Symbols1 {
  [k: string]: unknown | undefined;
}
/**
 * The SpEL expression that determines if this Transform should execute
 */
export interface Condition14 {
  [k: string]: unknown | undefined;
}
export interface Let4 {
  [k: string]: unknown | undefined;
}
/**
 * How conflict is handled when an operation produces multiple files at the same path
 */
export interface OnConflict {
  [k: string]: unknown | undefined;
}
/**
 * A SpEL expression that evaluates a list that contains the elements to be iterated over
 */
export interface On {
  [k: string]: unknown | undefined;
}

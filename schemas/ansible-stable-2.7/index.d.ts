/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Auto-Generated JSON Schema for Ansible-stable 2.7 (https://github.com/shaded-enmity/ansible-schema-generator)
 */
export type Ansible27 = (
  | {
      /**
       * Accepts a hash of task keywords (e.g. C(tags), C(become)) that will be applied to the tasks within the include.
       */
      apply?: string;
      /**
       * The name of the imported file is specified directly without any other option.
       * Unlike M(import_tasks), most keywords, including loop, with_items, and conditionals, apply to this statement.
       * The do until loop is not supported on M(include_tasks).
       */
      file?: string;
      [k: string]: unknown;
    }
  | {
      [k: string]: unknown;
    }
  | {
      /**
       * List of file names to ignore.
       */
      ignore_files?: unknown[];
      /**
       * Ignore unknown file extensions within the directory. This allows users to specify a directory containing vars files that are intermingled with non vars files extension types (For example, a directory with a README in it and vars files)
       */
      ignore_unknown_extensions?: string;
      /**
       * Limit the files that are loaded within any directory to this regular expression.
       */
      files_matching?: string;
      /**
       * When using C(dir), this module will, by default, recursively go through each sub directory and load up the variables. By explicitly setting the depth, this module will only go as deep as the depth.
       */
      depth?: string;
      /**
       * Default: ['yaml', 'yml', 'json']
       *
       * List of file extensions to read when using C(dir).
       */
      extensions?: unknown[];
      /**
       * The file name from which variables should be loaded.
       * If the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook.
       */
      file?: string;
      /**
       * The directory name from which the variables should be loaded.
       * If the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook.
       */
      dir?: string;
      /**
       * The name of a variable into which assign the included vars. If omitted (null) they will be made top level vars.
       */
      name?: string;
      [k: string]: unknown;
    }
  | {
      [k: string]: unknown;
    }
  | {
      [k: string]: unknown;
    }
  | {
      args?: {
        /**
         * A filename or (since 2.0) glob pattern. If it already exists, this step B(won't) be run.
         */
        creates?: string;
        /**
         * Change into this directory before running the command.
         */
        chdir?: string;
        /**
         * Set the stdin of the command directly to the specified value.
         */
        stdin?: string;
        /**
         * A filename or (since 2.0) glob pattern. If it already exists, this step B(will) be run.
         */
        removes?: string;
        /**
         * Allows the user to provide the command as a list vs. a string.  Only the string or the list form can be provided, not both.  One or the other must be provided.
         */
        argv?: string;
        /**
         * Default: yes
         *
         * If command_warnings are on in ansible.cfg, do not warn about this particular line if set to C(no).
         */
        warn?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      command: string;
      name?: string;
      [k: string]: unknown;
    }
  | {
      raw: string;
      args?: {
        /**
         * change the shell used to execute the command. Should be an absolute path to the executable.
         * when using privilege escalation (C(become)), a default shell will be assigned if one is not provided as privilege escalation requires a shell.
         */
        executable?: string;
        [k: string]: unknown;
      };
      name?: string;
      [k: string]: unknown;
    }
  | {
      shell: string;
      args?: {
        /**
         * a filename, when it already exists, this step will B(not) be run.
         */
        creates?: string;
        /**
         * change the shell used to execute the command. Should be an absolute path to the executable.
         */
        executable?: string;
        /**
         * cd into this directory before running the command
         */
        chdir?: string;
        /**
         * Set the stdin of the command directly to the specified value.
         */
        stdin?: string;
        /**
         * a filename, when it does not exist, this step will B(not) be run.
         */
        removes?: string;
        /**
         * Default: yes
         *
         * if command warnings are on in ansible.cfg, do not warn about this particular line if set to no/false.
         */
        warn?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      name?: string;
      [k: string]: unknown;
    }
  | {
      args?: {
        /**
         * A filename on the remote node, when it already exists, this step will B(not) be run.
         */
        creates?: string;
        /**
         * Name or path of a executable to invoke the script with.
         */
        executable?: string;
        /**
         * Change into this directory on the remote node before running the script.
         */
        chdir?: string;
        /**
         * A filename on the remote node, when it does not exist, this step will B(not) be run.
         */
        removes?: string;
        [k: string]: unknown;
      };
      name?: string;
      script: string;
      [k: string]: unknown;
    }
  | {
      /**
       * Manage TCP profiles on a BIG-IP. Many TCP profiles; each with their own adjustments to the standard C(tcp) profile. Users of this module should be aware that many of the adjustable knobs have no module default. Instead, the default is assigned by the BIG-IP system itself which, in most cases, is acceptable.
       */
      bigip_profile_tcp?: {
        /**
         * Specifies the name of the profile.
         */
        name?: string;
        /**
         * Specifies the profile from which this profile inherits settings.
         * When creating a new profile, if this parameter is not specified, the default is the system-supplied C(tcp) profile.
         */
        parent?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the length of time that a connection is idle (has no traffic) before the connection is eligible for deletion.
         * When creating a new profile, if this parameter is not specified, the remote device will choose a default value appropriate for the profile, based on its C(parent) profile.
         * When a number is specified, indicates the number of seconds that the TCP connection can remain idle before the system deletes it.
         * When C(0), or C(indefinite), specifies that the system does not delete TCP connections regardless of how long they remain idle.
         */
        idle_timeout?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the profile exists.
         * When C(absent), ensures the profile is removed.
         */
        state?: string;
        /**
         * Specifies that connections in a TIME-WAIT state are reused, if a SYN packet, indicating a request for a new connection, is received.
         * When C(no), connections in a TIME-WAIT state remain unused for a specified length of time.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        time_wait_recycle?: string;
        [k: string]: unknown;
      };
      /**
       * Registers or deregisters task definitions in the Amazon Web Services (AWS) EC2 Container Service (ECS)
       */
      ecs_taskdefinition?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure AlertScriptConfig object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_alertscriptconfig?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * A user-friendly name of the script.
         */
        name: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * User defined alert action script.
         * Please refer to kb.avinetworks.com for more information.
         */
        action_script?: string;
        [k: string]: unknown;
      };
      /**
       * Reboot a machine, wait for it to go down, come back up, and respond to commands.
       */
      reboot?: {
        blacklist_file?: string;
        state?: "absent" | "present";
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete an Azure Container Service Instance.
       */
      azure_rm_acs?: {
        /**
         * Name of a resource group where the Container Services exists or will be created.
         */
        resource_group: string;
        cloud_environment?: string;
        secret?: string;
        /**
         * Should VM Diagnostics be enabled for the Container Service VM's.
         */
        diagnostics_profile:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        cert_validation_mode?: "validate" | "ignore";
        /**
         * Master profile suboptions.
         */
        master_profile:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        /**
         * Specifies the Container Orchestration Platform to use. Currently can be either DCOS, Kubernetes or Swarm.
         */
        orchestration_platform: "DCOS" | "Kubernetes" | "Swarm";
        /**
         * Default: present
         *
         * Assert the state of the ACS. Use 'present' to create or update an ACS and 'absent' to delete it.
         */
        state?: "absent" | "present";
        /**
         * Valid azure location. Defaults to location of the resource group.
         */
        location?: string;
        subscription_id?: string;
        /**
         * The service principal suboptions.
         */
        service_principal?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        profile?: string;
        /**
         * The linux profile suboptions.
         */
        linux_profile:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        tags?: {
          [k: string]: unknown;
        };
        /**
         * The agent pool profile suboptions.
         */
        agent_pool_profiles:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        tenant?: string;
        /**
         * Name of the Container Services instance.
         */
        name: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        [k: string]: unknown;
      };
      /**
       * Sends a request to the remote device running JUNOS to execute the specified RPC using the NetConf transport.  The reply is then returned to the playbook in the C(xml) key.  If an alternate output format is requested, the reply is transformed to the requested output.
       */
      junos_rpc?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * The C(args) argument provides a set of arguments for the RPC call and are encoded in the request message.  This argument accepts a set of key=value arguments.
         */
        args?: {
          [k: string]: unknown;
        };
        /**
         * The C(rpc) argument specifies the RPC call to send to the remote devices to be executed.  The RPC Reply message is parsed and the contents are returned to the playbook.
         */
        rpc: string;
        host?: string;
        /**
         * The C(attrs) arguments defines a list of attributes and their values to set for the RPC call. This accepts a dictionary of key-values.
         */
        attrs?: {
          [k: string]: unknown;
        };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: xml
         *
         * The C(output) argument specifies the desired output of the return data.  This argument accepts one of C(xml), C(text), or C(json).  For C(json), the JUNOS device must be running a version of software that supports native JSON output.
         */
        output?: "xml" | "json" | "text";
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Create, delete, modify VLAN
       */
      na_elementsw_vlan?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Execute vrouter-ospf-add, vrouter-ospf-remove command.
       * This command adds/removes Open Shortest Path First(OSPF) routing protocol to a virtual router(vRouter) service.
       */
      pn_ospf?: {
        /**
         * Stub area number for the configuration. Required for vrouter-ospf-add.
         */
        pn_ospf_area?: string;
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Specify the name of the vRouter.
         */
        pn_vrouter_name: string;
        /**
         * Specify the network IP (IPv4 or IPv6) address.
         */
        pn_network_ip: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Default: present
         *
         * Assert the state of the ospf. Use 'present' to add ospf and 'absent' to remove ospf.
         */
        state?: "present" | "absent";
        /**
         * Target switch to run the CLI on.
         */
        pn_cliswitch?: string;
        [k: string]: unknown;
      };
      /**
       * List Topics/Subscriptions from Google PubSub.  Use the gcpubsub module for topic/subscription management. See U(https://cloud.google.com/pubsub/docs) for an overview.
       */
      gcpubsub_facts?: {
        service_account_email?: string;
        /**
         * GCP pubsub topic name.  Only the name, not the full path, is required.
         */
        topic?: string;
        /**
         * list is the only valid option.
         */
        state?: "list";
        credentials_file?: string;
        project_id?: string;
        /**
         * Choices are 'topics' or 'subscriptions'
         */
        view?: "topics" | "subscriptions";
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about the OneView Data Centers.
       */
      oneview_datacenter_facts?: {
        username?: string;
        image_streamer_hostname?: string;
        /**
         * Data Center name.
         */
        name?: string;
        hostname?: string;
        params?: {
          [k: string]: unknown;
        };
        password?: string;
        config?: string;
        /**
         * Retrieve additional facts. Options available: 'visualContent'.
         */
        options?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Like M(win_file), M(win_reg_stat) will return whether the key/property exists.
       * It also returns the sub keys and properties of the key specified.
       * If specifying a property name through I(property), it will return the information specific for that property.
       */
      win_reg_stat?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete volume snapshot policies.
       */
      cs_snapshot_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Install an operating system by setting the boot options like boot image and kickstart image and optionally select to install using ISSU (In Server Software Upgrade).
       */
      nxos_install_os?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the system (or combined) image file on flash.
         */
        system_image_file: string;
        /**
         * Name of the kickstart image file on flash. (Not required on all Nexus platforms)
         */
        kickstart_image_file?: string;
        auth_pass?: string;
        /**
         * Default: no
         *
         * Upgrade using In Service Software Upgrade (ISSU). (Supported on N5k, N7k, N9k platforms)
         * Selecting 'required' or 'yes' means that upgrades will only proceed if the switch is capable of ISSU.
         * Selecting 'desired' means that upgrades will use ISSU if possible but will fall back to disruptive upgrade if needed.
         * Selecting 'no' means do not use ISSU. Forced disruptive.
         */
        issu?: "required" | "desired" | "yes" | "no";
        host?: string;
        ssh_keyfile?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Get facts of MySQL Server.
       */
      azure_rm_mysqlserver_facts?: {
        profile?: string;
        /**
         * The name of the server.
         */
        name?: string;
        /**
         * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
         */
        resource_group: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about a one or more OpenStack users
       */
      os_user_facts?: {
        /**
         * Name or ID of the domain containing the user if the cloud supports domains
         */
        domain?: string;
        /**
         * Name or ID of the user
         */
        name?: string;
        /**
         * A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
         */
        filters?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * Configures IP address pools and blocks of IP addresses on Cisco UCS Manager.
       * Examples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).
       */
      ucs_ip_pool?: {
        /**
         * Default: ::
         *
         * The primary DNS server that this block of IPv6 addresses should access.
         */
        ipv6_primary_dns?: string;
        /**
         * The last IPv6 address in the IPv6 addresses block.
         * This is the To field in the UCS Manager Add IPv6 Blocks menu.
         */
        ipv6_last_addr?: string;
        /**
         * The name of the IP address pool.
         * This name can be between 1 and 32 alphanumeric characters.
         * You cannot use spaces or any special characters other than - (hyphen), "_" (underscore), : (colon), and . (period).
         * You cannot change this name after the IP address pool is created.
         */
        name?: string;
        /**
         * The last IPv4 address in the IPv4 addresses block.
         * This is the To field in the UCS Manager Add IPv4 Blocks menu.
         */
        last_addr?: string;
        /**
         * Default: 0.0.0.0
         *
         * The primary DNS server that this block of IPv4 addresses should access.
         */
        primary_dns?: string;
        /**
         * Default: ::
         *
         * The default gateway associated with the IPv6 addresses in the block.
         */
        ipv6_default_gw?: string;
        /**
         * Default: org-root
         *
         * Org dn (distinguished name)
         */
        org_dn?: string;
        /**
         * Default: 0.0.0.0
         *
         * The default gateway associated with the IPv4 addresses in the block.
         */
        default_gw?: string;
        /**
         * Default: default
         *
         * The Assignment Order field.
         * This can be one of the following:
         * default - Cisco UCS Manager selects a random identity from the pool.
         * sequential - Cisco UCS Manager selects the lowest available identity from the pool.
         */
        order?: string;
        /**
         * Default: 255.255.255.0
         *
         * The subnet mask associated with the IPv4 addresses in the block.
         */
        subnet_mask?: string;
        /**
         * Default: present
         *
         * If C(present), will verify IP pool is present and will create if needed.
         * If C(absent), will verify IP pool is absent and will delete if needed.
         */
        state?: string;
        /**
         * The first IPv4 address in the IPv4 addresses block.
         * This is the From field in the UCS Manager Add IPv4 Blocks menu.
         */
        first_addr?: string;
        /**
         * Default: 64
         *
         * The network address prefix associated with the IPv6 addresses in the block.
         */
        ipv6_prefix?: string;
        /**
         * The first IPv6 address in the IPv6 addresses block.
         * This is the From field in the UCS Manager Add IPv6 Blocks menu.
         */
        ipv6_first_addr?: string;
        /**
         * Default: ::
         *
         * The secondary DNS server that this block of IPv6 addresses should access.
         */
        ipv6_secondary_dns?: string;
        /**
         * Default: 0.0.0.0
         *
         * The secondary DNS server that this block of IPv4 addresses should access.
         */
        secondary_dns?: string;
        /**
         * The user-defined description of the IP address pool.
         * Enter up to 256 characters.
         * You can use any characters or spaces except the following:
         * ` (accent mark),  (backslash), ^ (carat), " (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).
         */
        descrption?: string;
        [k: string]: unknown;
      };
      /**
       * Allows the addition, clearing and removal of local Windows event logs, and the creation and removal of sources from a given event log.  Also allows the specification of settings per log and source.
       */
      win_eventlog?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to create / delete / update VMware categories.
       * Tag feature is introduced in vSphere 6 version, so this module is not supported in the earlier versions of vSphere.
       * All variables and VMware object names are case sensitive.
       */
      vmware_category?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or destroy or modify volumes on NetApp ONTAP.
       */
      na_ontap_volume?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create or destroy users.
       */
      na_ontap_user?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage Layer 3 Outside (L3Out) on Cisco ACI fabrics.
       */
      aci_l3out?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * This module can be used for calling any resources defined in Avi REST API. U(https://avinetworks.com/)
       * This module is useful for invoking HTTP Patch methods and accessing resources that do not have an REST object associated with them.
       */
      avi_api_session?: {
        username?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        controller?: string;
        /**
         * Allowed HTTP methods for RESTful services and are supported by Avi Controller.
         */
        http_method: "get" | "put" | "post" | "patch" | "delete";
        /**
         * Query parameters passed to the HTTP API.
         */
        params?: {
          [k: string]: unknown;
        };
        tenant?: string;
        /**
         * Default: 60
         *
         * Timeout (in seconds) for Avi API calls.
         */
        timeout?: number | string;
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Path for Avi API resource. For example, C(path: virtualservice) will translate to C(api/virtualserivce).
         */
        path: string;
        password?: string;
        /**
         * HTTP body in YAML or JSON format.
         */
        data?: string;
        tenant_uuid?: string;
        api_version?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure NetworkProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_networkprofile?: {
        /**
         * Networkprofileunion settings for networkprofile.
         */
        profile: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Uuid of the network profile.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * The name of the network profile.
         */
        name: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure Backup object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_backup?: {
        /**
         * Scheduler information.
         * It is a reference to an object of type scheduler.
         */
        scheduler_ref?: string;
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Url to download the backup file.
         */
        local_file_url?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Unix timestamp of when the backup file is created.
         */
        timestamp?: string;
        /**
         * Url to download the backup file.
         */
        remote_file_url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Backupconfiguration information.
         * It is a reference to an object of type backupconfiguration.
         */
        backup_config_ref?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * The file name of backup.
         */
        file_name: string;
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        [k: string]: unknown;
      };
      /**
       * Manages global configuration of EVPN on HUAWEI CloudEngine switches.
       */
      ce_evpn_global?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Configure EVPN as the VXLAN control plane.
         */
        evpn_overlay_enable: "enable" | "disable";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Creates a BackendService resource in the specified project using the data included in the request.
       */
      gcp_compute_backend_service?: {
        [k: string]: unknown;
      };
      /**
       * Allows uploading or removing IAM policies for IAM users, groups or roles.
       */
      iam_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Ansible module which helps to manage Jenkins plugins.
       */
      jenkins_plugin?: {
        [k: string]: unknown;
      };
      /**
       * Manage the state of a program or group of programs running via supervisord
       */
      supervisorctl?: {
        /**
         * username to use for authentication
         */
        username?: string;
        /**
         * path to supervisorctl executable
         */
        supervisorctl_path?: string;
        /**
         * The name of the supervisord program or group to manage.
         * The name will be taken as group name when it ends with a colon I(:)
         * Group support is only available in Ansible version 1.6 or later.
         */
        name: string;
        /**
         * URL on which supervisord server is listening
         */
        server_url?: string;
        /**
         * The desired state of program/group.
         */
        state: "present" | "started" | "stopped" | "restarted" | "absent";
        /**
         * password to use for authentication
         */
        password?: string;
        /**
         * The supervisor configuration file path
         */
        config?: string;
        [k: string]: unknown;
      };
      /**
       * Manipulate Rackspace Cloud Block Storage Volume Attachments
       */
      rax_cbs_attachments?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP TargetTcpProxy
       */
      gcp_compute_target_tcp_proxy_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * This module allows configuring block device partition using the C(parted) command line tool. For a full description of the fields and the options check the GNU parted manual.
       */
      parted?: {
        /**
         * Default: 0%
         *
         * Where the partition will start as offset from the beginning of the disk, that is, the "distance" from the start of the disk. The distance can be specified with all the units supported by parted (except compat) and it is case sensitive. E.g. C(10GiB), C(15%).
         */
        part_start?: string;
        /**
         * Default: 100%
         *
         * Where the partition will end as offset from the beginning of the disk, that is, the "distance" from the start of the disk. The distance can be specified with all the units supported by parted (except compat) and it is case sensitive. E.g. C(10GiB), C(15%).
         */
        part_end?: string;
        /**
         * Sets the name for the partition number (GPT, Mac, MIPS and PC98 only).
         */
        name?: string;
        /**
         * Default: optimal
         *
         * Set alignment for newly created partitions.
         */
        align?: "none" | "cylinder" | "minimal" | "optimal";
        /**
         * The number of the partition to work with or the number of the partition that will be created. Required when performing any action on the disk, except fetching information.
         */
        number?: number | string;
        /**
         * Default: msdos
         *
         * Creates a new disk label.
         */
        label?: "aix" | "amiga" | "bsd" | "dvh" | "gpt" | "loop" | "mac" | "msdos" | "pc98" | "sun";
        /**
         * Default: info
         *
         * If to create or delete a partition. If set to C(info) the module will only return the device information.
         */
        state?: "present" | "absent" | "info";
        /**
         * Default: primary
         *
         * Is one of 'primary', 'extended' or 'logical' and may be specified only with 'msdos' or 'dvh' partition tables. A name must be specified for a 'gpt' partition table. Neither part-type nor name may be used with a 'sun' partition table.
         */
        part_type?: "primary" | "extended" | "logical";
        /**
         * A list of the flags that has to be set on the partition.
         */
        flags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The block device (disk) where to operate.
         */
        device: string;
        /**
         * Default: KiB
         *
         * Selects the current default unit that Parted will use to display locations and capacities on the disk and to interpret those given by the user if they are not suffixed by an unit. When fetching information about a disk, it is always recommended to specify a unit.
         */
        unit?: "s" | "B" | "KB" | "KiB" | "MB" | "MiB" | "GB" | "GiB" | "TB" | "TiB" | "%" | "cyl" | "chs" | "compact";
        [k: string]: unknown;
      };
      /**
       * Creates AWS VPN Virtual Gateways
       * Deletes AWS VPN Virtual Gateways
       * Attaches Virtual Gateways to VPCs
       * Detaches Virtual Gateways from VPCs
       */
      ec2_vpc_vgw?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can be used for placing a ESXi host into maintenance mode.
       * Support for VSAN compliant maintenance mode when selected.
       */
      vmware_maintenancemode?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create/Delete vserver peer
       */
      na_ontap_vserver_peer?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Returns list of matching Launch Configurations for a given name, along with other useful information
       * Results can be sorted and sliced
       * It depends on boto
       * Based on the work by Tom Bamford (https://github.com/tombamford)
       */
      ec2_lc_find?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create, update and remove CloudStack role permissions.
       * Managing role permissions only supported in CloudStack >= 4.9.
       */
      cs_role_permission?: {
        /**
         * The parent role permission uuid. use 0 to move this rule at the top of the list.
         */
        parent?: string;
        /**
         * The description of the role permission.
         */
        description?: string;
        api_http_method?: "get" | "post";
        /**
         * Default: deny
         *
         * The rule permission, allow or deny. Defaulted to deny.
         */
        permission?: "allow" | "deny";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * The API name of the permission.
         */
        name: string;
        /**
         * Default: present
         *
         * State of the role permission.
         */
        state?: "present" | "absent";
        /**
         * Name or ID of the role.
         */
        role: string;
        api_key?: string;
        api_url?: string;
        [k: string]: unknown;
      };
      /**
       * Create, destroy, or update accounts on SolidFire
       */
      sf_snapshot_schedule_manager?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Configures NTP server on Cisco UCS Manager.
       * Examples can be used with the L(UCS Platform Emulator,https://communities.cisco.com/ucspe).
       */
      ucs_ntp_server?: {
        /**
         * Default: present
         *
         * If C(absent), will remove an NTP server.
         * If C(present), will add or update an NTP server.
         */
        state?: string;
        /**
         * NTP server IP address or hostname.
         * Enter up to 63 characters that form a valid hostname.
         * Enter a valid IPV4 Address.
         */
        ntp_server?: string;
        /**
         * A user-defined description of the NTP server.
         * Enter up to 256 characters.
         * You can use any characters or spaces except the following:
         * ` (accent mark),  (backslash), ^ (carat), " (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP BackendBucket
       */
      gcp_compute_backend_bucket_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Create/destroy Block Storage volume in DigitalOcean, or attach/detach Block Storage volume to a droplet.
       */
      digital_ocean_block_storage?: {
        [k: string]: unknown;
      };
      /**
       * Manage content switching actions
       * This module is intended to run either on the ansible  control node or a bastion (jumpserver) with access to the actual netscaler instance
       */
      netscaler_cs_action?: {
        /**
         * Comments associated with this cs action.
         */
        comment?: string;
        /**
         * Name for the content switching action. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the content switching action is created.
         */
        name?: string;
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        state?: "present" | "absent";
        /**
         * Name of the load balancing virtual server to which the content is switched.
         */
        targetlbvserver?: string;
        nitro_protocol?: "http" | "https";
        nsip: string;
        nitro_user: string;
        nitro_pass: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_timeout?: number;
        /**
         * Information about this content switching action.
         */
        targetvserverexpr?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV hosts.
       */
      ovirt_host_facts?: {
        /**
         * If I(true) all the attributes of the hosts should be included in the response.
         */
        all_content?: string;
        /**
         * Search term which is accepted by oVirt/RHV search backend.
         * For example to search host X from datacenter Y use following pattern: name=X and datacenter=Y
         */
        pattern?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure GslbApplicationPersistenceProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_gslbapplicationpersistenceprofile?: {
        username?: string;
        /**
         * Uuid of the persistence profile.
         * Field introduced in 17.1.1.
         */
        uuid?: string;
        /**
         * Field introduced in 17.1.1.
         */
        description?: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.1.1.
         */
        tenant_ref?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * A user-friendly name for the persistence profile.
         * Field introduced in 17.1.1.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts from ZFS dataset properties.
       */
      zfs_facts?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Module to manage storage domains in oVirt/RHV
       */
      ovirt_storage_domain?: {
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP InstanceGroupManager
       */
      gcp_compute_instance_group_manager_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The zone the managed instance group resides.
         */
        zone: string;
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Creates or destroy Google instance templates of Compute Engine of Google Cloud Platform.
       */
      gce_instance_template?: {
        [k: string]: unknown;
      };
      /**
       * An instance is a virtual machine (VM) hosted on Google's infrastructure.
       */
      gcp_compute_instance?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * An array of configurations for this interface. This specifies how this interface is configured to interact with other network services, such as connecting to the internet. Only one network interface is supported per instance.
         */
        network_interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The name of the resource, provided by the client when initially creating the resource. The resource name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name?: string;
        /**
         * A reference to the zone where the machine resides.
         */
        zone: string;
        /**
         * A list of tags to apply to this instance. Tags are used to identify valid sources or targets for network firewalls and are specified by the client during instance creation. The tags can be later modified by the setTags method. Each tag within the list must comply with RFC1035.
         */
        tags?: {
          [k: string]: unknown;
        };
        /**
         * A list of service accounts, with their specified scopes, authorized for this instance. Only one service account per VM instance is supported.
         */
        service_accounts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * An array of disks that are associated with the instances that are created from this template.
         */
        disks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List of the type and count of accelerator cards attached to the instance .
         */
        guest_accelerators?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * A reference to a machine type which defines VM kind.
         */
        machine_type?: string;
        /**
         * Specifies a minimum CPU platform for the VM instance. Applicable values are the friendly names of CPU platforms .
         */
        min_cpu_platform?: string;
        /**
         * Sets the scheduling options for this instance.
         */
        scheduling?: {
          [k: string]: unknown;
        };
        service_account_file?: string;
        /**
         * Allows this instance to send and receive packets with non-matching destination or source IPs. This is required if you plan to use this instance to forward routes.
         */
        can_ip_forward?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * A fingerprint for this request, which is essentially a hash of the metadata's contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update metadata. You must always provide an up-to-date fingerprint hash in order to update or change metadata.
         */
        label_fingerprint?: string;
        /**
         * The metadata key/value pairs to assign to instances that are created from this template. These pairs can consist of custom metadata or predefined keys.
         */
        metadata?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Manages the inittab on AIX.
       */
      aix_inittab?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * AireOS does not use a block indent file syntax, so there are no sections or parents. This module provides an implementation for working with AireOS configurations in a deterministic way.
       */
      aireos_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Represents a TargetHttpProxy resource, which is used by one or more global forwarding rule to route incoming HTTP requests to a URL map.
       */
      gcp_compute_target_http_proxy?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        service_account_email?: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        /**
         * A reference to the UrlMap resource that defines the mapping from URL to the BackendService.
         */
        url_map: {
          [k: string]: unknown;
        };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * An optional description of this resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manages the AFM port lists on a BIG-IP. This module can be used to add and remove port list entries.
       */
      bigip_firewall_port_list?: {
        /**
         * Specifies the name of the port list.
         */
        name?: string;
        /**
         * A list of port ranges where the range starts with a port number, is followed by a dash (-) and then a second number.
         * If the first number is greater than the second number, the numbers will be reversed so-as to be properly formatted. ie, 90-78 would become 78-90.
         */
        port_ranges?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Simple list of existing port lists to add to this list. Port lists can be specified in either their fully qualified name (/Common/foo) or their short name (foo). If a short name is used, the C(partition) argument will automatically be prepended to the short name.
         */
        port_lists?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the address list and entries exists.
         * When C(absent), ensures the address list is removed.
         */
        state?: string;
        /**
         * Simple list of port values to add to the list
         */
        ports?: string;
        /**
         * Description of the port list
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Add, modify and delete a role within FreeIPA server using FreeIPA API
       */
      ipa_role?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Retrieve facts about one or more oVirt/RHV disks.
       */
      ovirt_disk_facts?: {
        /**
         * Search term which is accepted by oVirt/RHV search backend.
         * For example to search Disk X from storage Y use following pattern: name=X and storage.name=Y
         */
        pattern?: string;
        [k: string]: unknown;
      };
      /**
       * Service policies allow you to configure timers and port misuse rules, if enabled, on a per rule or per context basis.
       */
      bigip_service_policy?: {
        /**
         * Description of the service policy.
         */
        description?: string;
        /**
         * The timer policy to attach to the service policy.
         */
        timer_policy?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Name of the service policy.
         */
        name?: string;
        /**
         * Default: present
         *
         * Whether the resource should exist or not.
         */
        state?: string;
        /**
         * The port misuse policy to attach to the service policy.
         * Requires that C(afm) be provisioned to use. If C(afm) is not provisioned, this parameter will be ignored.
         */
        port_misuse_policy?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about DigitalOcean provided volumes.
       */
      digital_ocean_volume_facts?: {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of IPL (inter-peer link) management on Mellanox ONYX network devices.
       */
      onyx_mlag_ipl?: {
        /**
         * Name of the IPL vlan interface.
         */
        vlan_interface?: string;
        /**
         * Default: present
         *
         * IPL state.
         */
        state?: "present" | "absent";
        /**
         * Name of the interface (port-channel) IPL should be configured on.
         */
        name: string;
        /**
         * IPL peer IP address.
         */
        peer_address?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of logging on Cisco NX-OS devices.
       */
      nxos_logging?: {
        [k: string]: unknown;
      };
      /**
       * Manage BIG-IP data center configuration. A data center defines the location where the physical network components reside, such as the server and link objects that share the same subnet on the network. This module is able to manipulate the data center definitions in a BIG-IP.
       */
      bigip_gtm_datacenter?: {
        /**
         * The description of the data center.
         */
        description?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Default: present
         *
         * The virtual address state. If C(absent), an attempt to delete the virtual address will be made. This will only succeed if this virtual address is not in use by a virtual server. C(present) creates the virtual address and enables it. If C(enabled), enable the virtual address if it exists. If C(disabled), create the virtual address if needed, and set state to C(disabled).
         */
        state?: string;
        /**
         * The name of the contact for the data center.
         */
        contact?: string;
        /**
         * The location of the data center.
         */
        location?: string;
        /**
         * The name of the data center.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module will replace all instances of a pattern within a file.
       * It is up to the user to maintain idempotence by ensuring that the same pattern would never match any replacements made.
       */
      replace?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Provides support for deploying resources with Terraform and pulling resource information back into Ansible.
       */
      terraform?: {
        /**
         * The path to a variables file for Terraform to fill into the TF configurations.
         */
        variables_file?: string;
        /**
         * A group of key-values to provide at init stage to the -backend-config parameter.
         */
        backend_config?: {
          [k: string]: unknown;
        };
        /**
         * How long to maintain the lock on the statefile, if you use a service that accepts locks (such as S3+DynamoDB).
         */
        lock_timeout?: number | string;
        /**
         * Enable statefile locking, if you use a service that accepts locks (such as S3+DynamoDB) to store your statefile.
         */
        lock?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A group of key-values to override template variables or those in variables files.
         */
        variables?: {
          [k: string]: unknown;
        };
        /**
         * The path to the root of the Terraform directory with the vars.tf/main.tf/etc to use.
         */
        project_path: string;
        /**
         * Default: present
         *
         * Goal state of given stage/project
         */
        state?: "planned" | "present" | "absent";
        /**
         * The path to an existing Terraform plan file to apply. If this is not specified, Ansible will build a new TF plan and execute it. Note that this option is required if 'state' has the 'planned' value.
         */
        plan_file?: string;
        /**
         * Only works with state = absent
         * If true, the workspace will be deleted after the "terraform destroy" action.
         * The 'default' workspace will not be deleted.
         */
        purge_workspace?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The path to an existing Terraform state file to use when building plan. If this is not specified, the default `terraform.tfstate` will be used.
         * This option is ignored when plan is specified.
         */
        state_file?: string;
        /**
         * Default: default
         *
         * The terraform workspace to work with.
         */
        workspace?: string;
        /**
         * To avoid duplicating infra, if a state file can't be found this will force a `terraform init`. Generally, this should be turned off unless you intend to provision an entirely new Terraform deployment.
         */
        force_init?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The path of a terraform binary to use, relative to the 'service_path' unless you supply an absolute path.
         */
        binary_path?: string;
        /**
         * A list of specific resources to target in this plan/application. The resources selected here will also auto-include any dependencies.
         */
        targets?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Module to manage host networks in oVirt/RHV.
       */
      ovirt_host_network?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Represents a TargetTcpProxy resource, which is used by one or more global forwarding rule to route incoming TCP requests to a Backend service.
       */
      gcp_compute_target_tcp_proxy?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        /**
         * A reference to the BackendService resource.
         */
        service: {
          [k: string]: unknown;
        };
        service_account_email?: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
         */
        proxy_header?: "NONE" | "PROXY_V1";
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * An optional description of this resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Send a message to a Hipchat room, with options to control the formatting.
       */
      hipchat?: {
        [k: string]: unknown;
      };
      /**
       * Installs, upgrade, removes, and lists packages and groups with the I(dnf) package manager.
       */
      dnf?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * nssm is a service helper which doesn't suck. See U(https://nssm.cc/) for more information.
       */
      win_nssm?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure CloudConnectorUser object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_cloudconnectoruser?: {
        username?: string;
        /**
         * Public_key of cloudconnectoruser.
         */
        public_key?: string;
        /**
         * Private_key of cloudconnectoruser.
         */
        private_key?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Field introduced in 17.2.1.
         */
        azure_serviceprincipal?: {
          [k: string]: unknown;
        };
        /**
         * Field introduced in 17.2.1.
         */
        azure_userpass?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Name of the object.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manage installation and Gem version dependencies for Ruby using the Bundler gem
       */
      bundler?: {
        /**
         * The path to the bundler executable
         */
        executable?: string;
        /**
         * Default: temporary working directory
         *
         * The directory to execute the bundler commands from. This directoy needs to contain a valid Gemfile or .bundle/ directory
         */
        chdir?: string;
        /**
         * Default: Gemfile in current directory
         *
         * Only applies if state is C(present). The path to the gemfile to use to install gems.
         */
        gemfile?: string;
        /**
         * Default: no
         *
         * Only applies if state is C(present). If set it will install gems in ./vendor/bundle instead of the default location. Requires a Gemfile.lock file to have been created prior
         */
        deployment_mode?: string;
        /**
         * Default: yes
         *
         * Only applies if state is C(present). Installs gems in the local user's cache or for all users
         */
        user_install?: string;
        /**
         * A space separated string of additional commands that can be applied to the Bundler command. Refer to the Bundler documentation for more information
         */
        extra_args?: string;
        /**
         * Default: present
         *
         * The desired state of the Gem bundle. C(latest) updates gems to the most recent, acceptable version
         */
        state?: string;
        /**
         * Default: no
         *
         * Only applies if state is C(present). If set removes any gems on the target host that are not in the gemfile
         */
        clean?: string;
        /**
         * Only applies if state is C(present). Specifies the directory to install any gem bins files to. When executed the bin files will run within the context of the Gemfile and fail if any required gem dependencies are not installed. If C(chdir) is set then this path is relative to C(chdir)
         */
        binstub_directory?: string;
        /**
         * A list of Gemfile groups to exclude during operations. This only applies when state is C(present). Bundler considers this a 'remembered' property for the Gemfile and will automatically exclude groups in future operations even if C(exclude_groups) is not set
         */
        exclude_groups?: string;
        /**
         * Default: no
         *
         * If set only installs gems from the cache on the target host
         */
        local?: string;
        /**
         * Default: RubyGems gem paths
         *
         * Only applies if state is C(present). Specifies the directory to install the gems into. If C(chdir) is set then this path is relative to C(chdir)
         */
        gem_path?: string;
        [k: string]: unknown;
      };
      /**
       * Sync Cobbler to commit changes.
       */
      cobbler_sync?: {
        /**
         * Default: cobbler
         *
         * The username to log in to Cobbler.
         */
        username?: string;
        /**
         * Default: 127.0.0.1
         *
         * The name or IP address of the Cobbler system.
         */
        host?: string;
        /**
         * Default: yes
         *
         * If C(no), an HTTP connection will be used instead of the default HTTPS connection.
         */
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The password to log in to Cobbler.
         */
        password?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated.
         * This should only set to C(no) when used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Port number to be used for REST connection.
         * The default value depends on parameter C(use_ssl).
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module allows to manage user groups on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
       */
      udm_group?: {
        /**
         * Group description.
         */
        description?: string;
        /**
         * Subpath inside the OU, e.g. C(cn=classes,cn=students,cn=groups).
         */
        subpath?: string;
        /**
         * Default: present
         *
         * Whether the group is present or not.
         */
        state?: "present" | "absent";
        /**
         * define the whole ldap position of the group, e.g. C(cn=g123m-1A,cn=classes,cn=schueler,cn=groups,ou=schule,dc=example,dc=com).
         */
        position?: string;
        /**
         * LDAP OU, e.g. school for LDAP OU C(ou=school,dc=example,dc=com).
         */
        ou?: string;
        /**
         * Name of the posix group.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages packages with I(urpmi) (such as for Mageia or Mandriva)
       */
      urpmi?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure Cluster object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_cluster?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Name of the object.
         */
        name: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * A virtual ip address.
         * This ip address will be dynamically reconfigured so that it always is the ip of the cluster leader.
         */
        virtual_ip?: {
          [k: string]: unknown;
        };
        api_context?: {
          [k: string]: unknown;
        };
        tenant?: string;
        /**
         * List of clusternode.
         */
        nodes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Re-join cluster nodes automatically in the event one of the node is reset to factory.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        rejoin_nodes_automatically?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Start, restart, stop and destroy routers.
       * C(state=present) is not able to create routers, use M(cs_network) instead.
       */
      cs_router?: {
        /**
         * Account the router is related to.
         */
        account?: string;
        api_key?: string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Name of the project the router is related to.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the router.
         */
        state?: "present" | "absent" | "started" | "stopped" | "restarted";
        /**
         * Domain the router is related to.
         */
        domain?: string;
        /**
         * Name or id of the service offering of the router.
         */
        service_offering?: string;
        /**
         * Name of the zone the router is deployed in.
         * If not set, all zones are used.
         */
        zone?: string;
        /**
         * Name of the router.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create or delete a Rackspace Cloud Monitoring notification that specifies a channel that can be used to communicate alarms, such as email, webhooks, or PagerDuty. Rackspace monitoring module flow | rax_mon_entity -> rax_mon_check -> *rax_mon_notification* -> rax_mon_notification_plan -> rax_mon_alarm
       */
      rax_mon_notification?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or remove VMware vSphere clusters.
       */
      vmware_cluster?: {
        /**
         * Default: no
         *
         * If set to C(yes) will enable HA when the cluster is created.
         */
        enable_ha?: string;
        /**
         * Default: no
         *
         * If set to C(yes) will enable vSAN when the cluster is created.
         */
        enable_vsan?: string;
        /**
         * The name of the datacenter the cluster will be created in.
         */
        datacenter_name?: string;
        /**
         * The name of the cluster that will be created.
         */
        cluster_name?: string;
        /**
         * Default: present
         *
         * Create (C(present)) or remove (C(absent)) a VMware vSphere cluster.
         */
        state?: string;
        /**
         * Default: no
         *
         * If set to C(yes) will enable DRS when the cluster is created.
         */
        enable_drs?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of LLDP service on Cisco NXOS network devices.
       */
      nxos_lldp?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of the LLDP configuration. If value is I(present) lldp will be enabled else if it is I(absent) it will be disabled.
         */
        state?: "present" | "absent" | "enabled" | "disabled";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Manage filter entries for a filter on Cisco ACI fabrics.
       */
      aci_filter_entry?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Waiting for a process to start or stop.
       * This is useful when Windows services behave poorly and do not enumerate external dependencies in their manifest.
       */
      win_wait_for_process?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Launch an Ansible Tower jobs. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_job_launch?: {
        /**
         * Credential to use for job, only used if prompt for credential is set.
         */
        credential?: string;
        /**
         * Name of the job template to use.
         */
        job_template: string;
        /**
         * Specific tags to use for from playbook.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Extra_vars to use for the job_template. Prepend C(@) if a file.
         */
        extra_vars?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Job_type to use for the job, only used if prompt for job_type is set.
         */
        job_type?: "run" | "check" | "scan";
        tower_config_file?: string;
        /**
         * Limit to use for the I(job_template).
         */
        limit?: string;
        /**
         * Inventory to use for the job, only used if prompt for inventory is set.
         */
        inventory?: string;
        tower_password?: string;
        tower_username?: string;
        tower_host?: string;
        [k: string]: unknown;
      };
      /**
       * This module provide management of firewall addresses on FortiOS devices.
       */
      fortios_address?: {
        /**
         * free text to describe address.
         */
        comment?: string;
        username?: string;
        config_file?: string;
        /**
         * Name of the address to add or delete.
         */
        name: string;
        backup_path?: string;
        /**
         * 2 letter country code (like FR).
         */
        country?: string;
        /**
         * Specifies if address need to be added or deleted.
         */
        state: "present" | "absent";
        /**
         * Address value, based on type. If type=fqdn, somthing like www.google.com. If type=ipmask, you can use simple ip (192.168.0.1), ip+mask (192.168.0.1 255.255.255.0) or CIDR (192.168.0.1/32).
         */
        value?: string;
        /**
         * First ip in range (used only with type=iprange).
         */
        start_ip?: string;
        host?: string;
        /**
         * Last ip in range (used only with type=iprange).
         */
        end_ip?: string;
        backup_filename?: string;
        timeout?: number | string;
        /**
         * Type of the address.
         */
        type?: "iprange" | "fqdn" | "ipmask" | "geography";
        /**
         * Default: any
         *
         * interface name the address apply to.
         */
        interface?: string;
        password?: string;
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        vdom?: string;
        file_mode?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module is automatically called by playbooks to gather useful variables about remote hosts that can be used in playbooks. It can also be executed directly by C(/usr/bin/ansible) to check what variables are available to a host. Ansible provides many I(facts) about the system, automatically.
       * This module is also supported for Windows targets.
       */
      setup?: {
        /**
         * Default: *
         *
         * if supplied, only return facts that match this shell-style (fnmatch) wildcard.
         */
        filter?: string;
        /**
         * Default: all
         *
         * if supplied, restrict the additional facts collected to the given subset. Possible values: C(all), C(min), C(hardware), C(network), C(virtual), C(ohai), and C(facter). Can specify a list of values to specify a larger subset. Values can also be used with an initial C(!) to specify that that specific subset should not be collected.  For instance: C(!hardware,!network,!virtual,!ohai,!facter). If C(!all) is specified then only the min subset is collected. To avoid collecting even the min subset, specify C(!all,!min). To collect only specific facts, use C(!all,!min), and specify the particular fact subsets. Use the filter parameter if you do not want to display some collected facts.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: /etc/ansible/facts.d
         *
         * path used for local ansible facts (C(*.fact)) - files in this dir will be run (if executable) and their results be added to C(ansible_local) facts if a file is not executable it is read. Check notes for Windows options. (from 2.1 on) File/results format can be json or ini-format
         */
        fact_path?: string;
        /**
         * Default: 10
         *
         * Set the default timeout in seconds for individual fact gathering
         */
        gather_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Obtain facts of any resource using Azure REST API.
       * This module gives access to resources that are not supported via Ansible modules.
       * Refer to https://docs.microsoft.com/en-us/rest/api/ regarding details related to specific resource REST API.
       */
      azure_rm_resource_facts?: {
        profile?: string;
        /**
         * Resource name.
         */
        resource_name?: string;
        /**
         * List of subresources
         */
        subresource?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Resource group to be used.
         * Required if URL is not specified.
         */
        resource_group?: string;
        /**
         * Azure RM Resource URL.
         */
        url?: string;
        cloud_environment?: string;
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        tenant?: string;
        secret?: string;
        /**
         * Resource type.
         */
        resource_type?: string;
        client_id?: string;
        /**
         * Provider type, should be specified in no URL is given
         */
        provider?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        /**
         * Specific API version to be used.
         */
        api_version: string;
        api_profile?: string;
        [k: string]: unknown;
      };
      /**
       * Gets various details related to AWS VPC Managed Nat Gateways
       */
      ec2_vpc_nat_gateway_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV permissions.
       */
      ovirt_permission_facts?: {
        /**
         * Authorization provider of the user/group. In previous versions of oVirt/RHV known as domain.
         */
        authz_name?: string;
        /**
         * Namespace of the authorization provider, where user/group resides.
         */
        namespace?: string;
        /**
         * Username of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.
         */
        user_name?: string;
        /**
         * Name of the group to manage.
         */
        group_name?: string;
        [k: string]: unknown;
      };
      /**
       * Manage key-value pairs in aws parameter store.
       */
      aws_ssm_parameter_store?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can be used to create, delete and update snapshot(s) of the given virtual machine.
       * All parameters and VMware object names are case sensitive.
       */
      vmware_guest_snapshot?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt scheduling policies.
       */
      ovirt_scheduling_policy_facts?: {
        /**
         * ID of the scheduling policy.
         */
        id?: string;
        /**
         * Name of the scheduling policy, can be used as glob expression.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module ensures a particular line is in a file, or replace an existing line using a back-referenced regular expression.
       * This is primarily useful when you want to change a single line in a file only. See the M(replace) module if you want to change multiple, similar lines or check M(blockinfile) if you want to insert/update/remove a block of lines in a file. For other cases, see the M(copy) or M(template) modules.
       */
      lineinfile?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        };
      /**
       * This module allows you to work with access-lists on a Cisco ASA device.
       */
      asa_acl?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module can be used to gather facts about disks belonging to given virtual machine.
       * All parameters and VMware object names are case sensitive.
       */
      vmware_guest_disk_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure VirtualService object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_virtualservice?: {
        /**
         * (internal-use) network port assigned to the virtual service ip address.
         * Field deprecated in 17.1.1.
         */
        port_uuid?: string;
        /**
         * Availability-zone to place the virtual service.
         * Field deprecated in 17.1.1.
         */
        availability_zone?: string;
        /**
         * Datascripts applied on the data traffic of the virtual service.
         */
        vs_datascripts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Enable route health injection for source nat'ted floating ip address using the bgp config in the vrf context.
         */
        enable_rhi_snat?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Sideband configuration to be used for this virtualservice.it can be used for sending traffic to sideband vips for external inspection etc.
         */
        sideband_profile?: {
          [k: string]: unknown;
        };
        /**
         * Rate limit the incoming requests to this virtual service.
         */
        requests_rate_limit?: {
          [k: string]: unknown;
        };
        /**
         * Uuid of the virtualservice.
         */
        uuid?: string;
        /**
         * Determines the set of ssl versions and ciphers to accept for ssl/tls terminated connections.
         * It is a reference to an object of type sslprofile.
         */
        ssl_profile_ref?: string;
        /**
         * Creator name.
         */
        created_by?: string;
        /**
         * Maximum connections per second per client ip.
         * Allowed values are 10-1000.
         * Special values are 0- 'unlimited'.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         */
        max_cps_per_client?: number | string;
        /**
         * The pool group is an object that contains pools.
         * It is a reference to an object of type poolgroup.
         */
        pool_group_ref?: string;
        /**
         * Knob to enable the virtual service traffic on its assigned service engines.
         * This setting is effective only when the enabled flag is set to true.
         * Field introduced in 17.2.8.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        traffic_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Error page profile to be used for this virtualservice.this profile is used to send the custom error page to the client generated by the proxy.
         * It is a reference to an object of type errorpageprofile.
         * Field introduced in 17.2.4.
         */
        error_page_profile_ref?: string;
        /**
         * Enable application layer specific features for the virtual service.
         * It is a reference to an object of type applicationprofile.
         */
        application_profile_ref?: string;
        /**
         * This configuration only applies if the virtualservice is in legacy active standby ha mode and load distribution among active standby is enabled.
         * This field is used to tag the virtualservice so that virtualservices with the same tag will share the same active serviceengine.
         * Virtualservices with different tags will have different active serviceengines.
         * If one of the serviceengine's in the serviceenginegroup fails, all virtualservices will end up using the same active serviceengine.
         * Redistribution of the virtualservices can be either manual or automated when the failed serviceengine recovers.
         * Redistribution is based on the auto redistribute property of the serviceenginegroup.
         * Enum options - ACTIVE_STANDBY_SE_1, ACTIVE_STANDBY_SE_2.
         * Default value when not specified in API or module is interpreted by Avi Controller as ACTIVE_STANDBY_SE_1.
         */
        active_standby_se_tag?: string;
        /**
         * Use the virtual ip as the snat ip for health monitoring and sending traffic to the backend servers instead of the service engine interface ip.
         * The caveat of enabling this option is that the virtualservice cannot be configued in an active-active ha mode.
         * Dns based multi vip solution has to be used for ha & non-disruptive upgrade purposes.
         * Field introduced in 17.1.9,17.2.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        use_vip_as_snat?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        /**
         * Ip address of the virtual service.
         * Field deprecated in 17.1.1.
         */
        ip_address?: {
          [k: string]: unknown;
        };
        /**
         * It represents subnet for the virtual service ip address allocation when auto_allocate_ip is true.it is only applicable in openstack or aws cloud.
         * This field is required if auto_allocate_ip is true.
         * Field deprecated in 17.1.1.
         */
        subnet_uuid?: string;
        /**
         * Name for the virtual service.
         */
        name: string;
        /**
         * Response traffic to clients will be sent back to the source mac address of the connection, rather than statically sent to a default gateway.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        enable_autogw?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Profile used to match and rewrite strings in request and/or response body.
         */
        content_rewrite?: {
          [k: string]: unknown;
        };
        /**
         * List of static dns records applied to this virtual service.
         * These are static entries and no health monitoring is performed against the ip addresses.
         */
        static_dns_records?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Determines analytics settings for the application.
         */
        analytics_policy?: {
          [k: string]: unknown;
        };
        tenant_uuid?: string;
        /**
         * The quality of service weight to assign to traffic transmitted from this virtual service.
         * A higher weight will prioritize traffic versus other virtual services sharing the same service engines.
         * Allowed values are 1-128.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.
         */
        weight?: number | string;
        /**
         * Enable or disable the virtual service.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Remove listening port if virtualservice is down.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        remove_listening_port_on_vs_down?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Server network or list of servers for cloning traffic.
         * It is a reference to an object of type trafficcloneprofile.
         * Field introduced in 17.1.1.
         */
        traffic_clone_profile_ref?: string;
        /**
         * Virtual routing context that the virtual service is bound to.
         * This is used to provide the isolation of the set of networks the application is attached to.
         * It is a reference to an object of type vrfcontext.
         */
        vrf_context_ref?: string;
        /**
         * Subnet providing reachability for client facing virtual service ip.
         * Field deprecated in 17.1.1.
         */
        subnet?: {
          [k: string]: unknown;
        };
        /**
         * The exact name requested from the client's sni-enabled tls hello domain name field.
         * If this is a match, the parent vs will forward the connection to this child vs.
         */
        vh_domain_name?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The service engine group to use for this virtual service.
         * Moving to a new se group is disruptive to existing connections for this vs.
         * It is a reference to an object of type serviceenginegroup.
         */
        se_group_ref?: string;
        /**
         * Waf policy for the virtual service.
         * It is a reference to an object of type wafpolicy.
         * Field introduced in 17.2.1.
         */
        waf_policy_ref?: string;
        /**
         * Disable re-distribution of flows across service engines for a virtual service.
         * Enable if the network itself performs flow hashing with ecmp in environments such as gcp.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        scaleout_ecmp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        api_version?: string;
        /**
         * Mostly used during the creation of shared vs, this field refers to entities that can be shared across virtual services.
         * It is a reference to an object of type vsvip.
         * Field introduced in 17.1.1.
         */
        vsvip_ref?: string;
        /**
         * Optional settings that determine performance limits like max connections or bandwdith etc.
         */
        performance_limits?: {
          [k: string]: unknown;
        };
        /**
         * Floating ip to associate with this virtual service.
         * Field deprecated in 17.1.1.
         */
        floating_ip?: {
          [k: string]: unknown;
        };
        /**
         * Auto-allocate floating/elastic ip from the cloud infrastructure.
         * Field deprecated in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        auto_allocate_floating_ip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Rate limit the incoming connections to this virtual service.
         */
        connections_rate_limit?: {
          [k: string]: unknown;
        };
        /**
         * The pool is an object that contains destination servers and related attributes such as load-balancing and persistence.
         * It is a reference to an object of type pool.
         */
        pool_ref?: string;
        /**
         * Ignore pool servers network reachability constraints for virtual service placement.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        ign_pool_net_reach?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tenant?: string;
        /**
         * Auto-allocate vip from the provided subnet.
         * Field deprecated in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        auto_allocate_ip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Dns resolvable, fully qualified domain name of the virtualservice.
         * Only one of 'fqdn' and 'dns_info' configuration is allowed.
         */
        fqdn?: string;
        /**
         * Criteria for flow labelling.
         * Enum options - NO_LABEL, APPLICATION_LABEL, SERVICE_LABEL.
         * Default value when not specified in API or module is interpreted by Avi Controller as NO_LABEL.
         */
        flow_label_type?: string;
        /**
         * (internal-use) fip allocated by avi in the cloud infrastructure.
         * Field deprecated in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        avi_allocated_fip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Http authentication configuration for protected resources.
         */
        client_auth?: {
          [k: string]: unknown;
        };
        /**
         * If auto_allocate_floating_ip is true and more than one floating-ip subnets exist, then the subnet for the floating ip address allocation.
         * This field is applicable only if the virtualservice belongs to an openstack or aws cloud.
         * In openstack or aws cloud it is required when auto_allocate_floating_ip is selected.
         * Field deprecated in 17.1.1.
         */
        floating_subnet_uuid?: string;
        /**
         * Select the algorithm for qos fairness.
         * This determines how multiple virtual services sharing the same service engines will prioritize traffic over a congested network.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        delay_fairness?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of virtual service ips.
         * While creating a 'shared vs',please use vsvip_ref to point to the shared entities.
         * Field introduced in 17.1.1.
         */
        vip?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Nat'ted floating source ip address(es) for upstream connection to servers.
         */
        snat_ip?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (internal-use) vip allocated by avi in the cloud infrastructure.
         * Field deprecated in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        avi_allocated_vip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies settings related to analytics.
         * It is a reference to an object of type analyticsprofile.
         */
        analytics_profile_ref?: string;
        /**
         * Determines the network settings profile for the server side of tcp proxied connections.
         * Leave blank to use the same settings as the client to vs side of the connection.
         * It is a reference to an object of type networkprofile.
         */
        server_network_profile_ref?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Expected number of ssl session cache entries (may be exceeded).
         * Allowed values are 1024-16383.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1024.
         */
        ssl_sess_cache_avg_size?: number | string;
        /**
         * L4 policies applied to the data traffic of the virtual service.
         * Field introduced in 17.2.7.
         */
        l4_policies?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        username?: string;
        /**
         * Criteria for flow distribution among ses.
         * Enum options - LOAD_AWARE, CONSISTENT_HASH_SOURCE_IP_ADDRESS, CONSISTENT_HASH_SOURCE_IP_ADDRESS_AND_PORT.
         * Default value when not specified in API or module is interpreted by Avi Controller as LOAD_AWARE.
         */
        flow_dist?: string;
        /**
         * Http policies applied on the data traffic of the virtual service.
         */
        http_policies?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Force placement on all se's in service group (mesos mode only).
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        east_west_placement?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Select pool based on destination port.
         */
        service_pool_select?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Close client connection on vs config update.
         * Field introduced in 17.2.4.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        close_client_conn_on_config_update?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify if this is a normal virtual service, or if it is the parent or child of an sni-enabled virtual hosted virtual service.
         * Enum options - VS_TYPE_NORMAL, VS_TYPE_VH_PARENT, VS_TYPE_VH_CHILD.
         * Default value when not specified in API or module is interpreted by Avi Controller as VS_TYPE_NORMAL.
         */
        type?: string;
        /**
         * (internal-use) discovered networks providing reachability for client facing virtual service ip.
         * This field is used internally by avi, not editable by the user.
         * Field deprecated in 17.1.1.
         */
        discovered_networks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Service discovery specific data including fully qualified domain name, type and time-to-live of the dns record.
         * Note that only one of fqdn and dns_info setting is allowed.
         */
        dns_info?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Subnet and/or network for allocating virtualservice ip by ipam provider module.
         * Field deprecated in 17.1.1.
         */
        ipam_network_subnet?: {
          [k: string]: unknown;
        };
        /**
         * Select or create one or two certificates, ec and/or rsa, that will be presented to ssl/tls terminated connections.
         * It is a reference to an object of type sslkeyandcertificate.
         */
        ssl_key_and_certificate_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Gslb pools used to manage site-persistence functionality.
         * Each site-persistence pool contains the virtualservices in all the other sites, that is auto-generated by the gslb manager.
         * This is a read-only field for the user.
         * It is a reference to an object of type pool.
         * Field introduced in 17.2.2.
         */
        sp_pool_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Network security policies for the virtual service.
         * It is a reference to an object of type networksecuritypolicy.
         */
        network_security_policy_ref?: string;
        /**
         * Determines network settings such as protocol, tcp or udp, and related options for the protocol.
         * It is a reference to an object of type networkprofile.
         */
        network_profile_ref?: string;
        /**
         * Metadata pertaining to the service provided by this virtual service.
         * In openshift/kubernetes environments, egress pod info is stored.
         * Any user input to this field will be overwritten by avi vantage.
         */
        service_metadata?: string;
        /**
         * (this is a beta feature).
         * Sync key-value cache to the new ses when vs is scaled out.
         * For ex  ssl sessions are stored using vs's key-value cache.
         * When the vs is scaled out, the ssl session information is synced to the new se, allowing existing ssl sessions to be reused on the new se.
         * Field introduced in 17.2.7, 18.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        bulk_sync_kvcache?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enum options - cloud_none, cloud_vcenter, cloud_openstack, cloud_aws, cloud_vca, cloud_apic, cloud_mesos, cloud_linuxserver, cloud_docker_ucp,
         * cloud_rancher, cloud_oshift_k8s, cloud_azure.
         * Default value when not specified in API or module is interpreted by Avi Controller as CLOUD_NONE.
         */
        cloud_type?: string;
        /**
         * It is a reference to an object of type cloud.
         */
        cloud_ref?: string;
        /**
         * Enable route health injection using the bgp config in the vrf context.
         */
        enable_rhi?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * A list of nsx service groups representing the clients which can access the virtual ip of the virtual service.
         * Field introduced in 17.1.1.
         */
        nsx_securitygroup?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * Use bridge ip as vip on each host in mesos deployments.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        use_bridge_ip_as_vip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Translate the host name sent to the servers to this value.
         * Translate the host name sent from servers back to the value used by the client.
         */
        host_name_xlate?: string;
        /**
         * Specifies the virtual service acting as virtual hosting (sni) parent.
         */
        vh_parent_vs_uuid?: string;
        /**
         * List of services defined for this virtual service.
         */
        services?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Microservice representing the virtual service.
         * It is a reference to an object of type microservice.
         */
        microservice_ref?: string;
        /**
         * (internal-use) discovered networks providing reachability for client facing virtual service ip.
         * This field is deprecated.
         * It is a reference to an object of type network.
         * Field deprecated in 17.1.1.
         */
        discovered_network_ref?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Limit potential dos attackers who exceed max_cps_per_client significantly to a fraction of max_cps_per_client for a while.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        limit_doser?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Manually override the network on which the virtual service is placed.
         * It is a reference to an object of type network.
         * Field deprecated in 17.1.1.
         */
        network_ref?: string;
        /**
         * (internal-use) discovered subnets providing reachability for client facing virtual service ip.
         * This field is deprecated.
         * Field deprecated in 17.1.1.
         */
        discovered_subnet?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Dns policies applied on the dns traffic of the virtual service.
         * Field introduced in 17.1.1.
         */
        dns_policies?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Checksum of cloud configuration for vs.
         * Internally set by cloud connector.
         */
        cloud_config_cksum?: string;
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific public IP or all public IPs within a resource group.
       */
      azure_rm_publicipaddress_facts?: {
        profile?: string;
        /**
         * Only show results for a specific Public IP.
         */
        name?: string;
        /**
         * Limit results by resource group. Required when using name parameter.
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Create an EC2 Placement Group; if the placement group already exists, nothing is done. Or, delete an existing placement group. If the placement group is absent, do nothing. See also http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html
       */
      ec2_placement_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allows for creation, management, and visibility into layer 3 firewalls implemented on Meraki MR access points.
       */
      meraki_mr_l3_firewall?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Interfaces on Extreme SLX-OS network devices.
       */
      slxos_interface?: {
        /**
         * Check the operational state of given interface C(name) for LLDP neighbor.
         * The following suboptions are available.
         */
        neighbors?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 10
         *
         * Time in seconds to wait before checking for the operational state on remote device. This wait is applicable for operational state argument which are I(state) with values C(up)/C(down), I(tx_rate) and I(rx_rate).
         */
        delay?: number | string;
        /**
         * Description of Interface.
         */
        description?: string;
        /**
         * Default: True
         *
         * Interface link status.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Maximum size of transmit packet.
         */
        mtu?: string;
        /**
         * Receiver rate in bits per second (bps).
         */
        rx_rate?: string;
        /**
         * Default: present
         *
         * State of the Interface configuration, C(up) means present and operationally up and C(down) means present and operationally C(down)
         */
        state?: "present" | "absent" | "up" | "down";
        /**
         * List of Interfaces definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Interface link speed.
         */
        speed?: string;
        /**
         * Transmit rate in bits per second (bps).
         */
        tx_rate?: string;
        /**
         * Name of the Interface.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manage load balancing vserver configuration
       * This module is intended to run either on the ansible  control node or a bastion (jumpserver) with access to the actual netscaler instance
       */
      netscaler_lb_vserver?: {
        /**
         * List of services along with the weights that are load balanced.
         * The following suboptions are available.
         */
        servicebindings?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Use network address translation (NAT) for RTSP data connections.
         */
        rtspnat?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * When set to C(yes) the lb vserver will be disabled.
         * When set to C(no) the lb vserver will be enabled.
         * Note that due to limitations of the underlying NITRO API a C(disabled) state change alone does not cause the module result to report a changed status.
         */
        disabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * This option is used to retain vlan information of incoming packet when macmode is enabled.
         */
        macmoderetainvlan?: "enabled" | "disabled";
        /**
         * Enable database specific load balancing for MySQL and MSSQL service types.
         */
        dbslb?: "enabled" | "disabled";
        /**
         * Default syntax expression identifying traffic accepted by the virtual server. Can be either an expression (for example, C(CLIENT.IP.DST.IN_SUBNET(192.0.2.0/24)) or the name of a named expression. In the above example, the virtual server accepts all requests whose destination IP address is in the 192.0.2.0/24 subnet.
         */
        listenpolicy?: string;
        /**
         * IP mask, in dotted decimal notation, for the IP Pattern parameter. Can have leading or trailing non-zero octets (for example, C(255.255.240.0) or C(0.0.255.255)). Accordingly, the mask specifies whether the first n bits or the last n bits of the destination IP address in a client request are to be matched with the corresponding bits in the IP pattern. The former is called a forward mask. The latter is called a reverse mask.
         */
        ipmask?: string;
        /**
         * Name for the inserted header. The default name is vip-header.
         * Minimum length = 1
         */
        vipheader?: string;
        /**
         * Name of the load balancing virtual server, of type PUSH or SSL_PUSH, to which the server pushes updates received on the load balancing virtual server that you are configuring.
         * Minimum length = 1
         */
        pushvserver?: string;
        /**
         * Offset to be considered when extracting a token from the TCP payload. Applicable to virtual servers, of type TCP, using the token method of load balancing. Must be within the first 24 KB of the TCP payload.
         * Minimum value = C(0)
         * Maximum value = C(25400)
         */
        dataoffset?: number;
        /**
         * Length of the token to be extracted from the data segment of an incoming packet, for use in the token method of load balancing. The length of the token, specified in bytes, must not be greater than 24 KB. Applicable to virtual servers of type TCP.
         * Minimum value = C(1)
         * Maximum value = C(100)
         */
        datalength?: number;
        nitro_timeout?: number;
        /**
         * Apply AppFlow logging to the virtual server.
         */
        appflowlog?: "enabled" | "disabled";
        /**
         * If the primary virtual server goes down, do not allow it to return to primary status until manually enabled.
         */
        disableprimaryondown?: "enabled" | "disabled";
        /**
         * By turning on this option packets destined to a vserver in a cluster will not under go any steering. Turn this option for single packet request response mode or when the upstream device is performing a proper RSS for connection based distribution.
         */
        processlocal?: "enabled" | "disabled";
        /**
         * Minimum number of members expected to be present when vserver is used in Autoscale.
         * Minimum value = C(0)
         * Maximum value = C(5000)
         */
        minautoscalemembers?: number;
        /**
         * Name for the virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the virtual server is created.
         * Minimum length = 1
         */
        name?: string;
        /**
         * Backup load balancing method. Becomes operational if the primary load balancing me
         * thod fails or cannot be used.
         * Valid only if the primary method is based on static proximity.
         */
        backuplbmethod?:
          | "ROUNDROBIN"
          | "LEASTCONNECTION"
          | "LEASTRESPONSETIME"
          | "SOURCEIPHASH"
          | "LEASTBANDWIDTH"
          | "LEASTPACKETS"
          | "CUSTOMLOAD";
        /**
         * Flush all active transactions associated with a virtual server whose state transitions from UP to DOWN. Do not enable this option for applications that must complete their transactions.
         */
        downstateflush?: "enabled" | "disabled";
        /**
         * Expression for extracting a label from the server's response. Can be either an expression or the name of a named expression.
         */
        pushlabel?: string;
        /**
         * Number of bytes to consider for the hash value used in the URLHASH and DOMAINHASH load balancing methods.
         * Minimum value = C(1)
         * Maximum value = C(4096)
         */
        hashlength?: number;
        /**
         * Time period for which a persistence session is in effect.
         * Minimum value = C(0)
         * Maximum value = C(1440)
         */
        timeout?: number;
        /**
         * Persistence mask for IP based persistence types, for IPv6 virtual servers.
         * Minimum value = C(1)
         * Maximum value = C(128)
         */
        v6persistmasklen?: number;
        /**
         * When set to YES, this option causes the DNS replies from this vserver to have the RA bit turned on. Typically one would set this option to YES, when the vserver is load balancing a set of DNS servers thatsupport recursive queries.
         */
        recursionavailable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Maximum number of members expected to be present when vserver is used in Autoscale.
         * Minimum value = C(0)
         * Maximum value = C(5000)
         */
        maxautoscalemembers?: number;
        /**
         * Oracle server version.
         */
        oracleserverversion?: "10G" | "11G";
        /**
         * Name of the authentication profile to be used when authentication is turned on.
         */
        authnprofile?: string;
        /**
         * Port number for the virtual server.
         * Range C(1) - C(65535)
         * * in CLI is represented as C(65535) in NITRO API
         */
        port?: number | string;
        /**
         * The name of the ssl certificate that is bound to this service.
         * The ssl certificate must already exist.
         * Creating the certificate can be done with the M(netscaler_ssl_certkey) module.
         * This option is only applicable only when C(servicetype) is C(SSL).
         */
        ssl_certkey?: string;
        /**
         * Character set that the virtual server advertises to clients.
         */
        mysqlcharacterset?: number;
        /**
         * Enable or disable user authentication with HTTP 401 responses.
         */
        authn401?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        state?: "present" | "absent";
        /**
         * Name of an authentication virtual server with which to authenticate users.
         * Minimum length = 1
         * Maximum length = 252
         */
        authnvsname?: string;
        nitro_user: string;
        /**
         * Name of the network profile to associate with the virtual server. If you set this parameter, the virtual server uses only the IP addresses in the network profile as source IP addresses when initiating connections with servers.
         * Minimum length = 1
         * Maximum length = 127
         */
        netprofile?: string;
        /**
         * Allow multiple Web 2.0 connections from the same client to connect to the virtual server and expect updates.
         */
        pushmulticlients?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Load balancing method. The available settings function as follows:
         * * C(ROUNDROBIN) - Distribute requests in rotation, regardless of the load. Weights can be assigned to services to enforce weighted round robin distribution.
         * * C(LEASTCONNECTION) (default) - Select the service with the fewest connections.
         * * C(LEASTRESPONSETIME) - Select the service with the lowest average response time.
         * * C(LEASTBANDWIDTH) - Select the service currently handling the least traffic.
         * * C(LEASTPACKETS) - Select the service currently serving the lowest number of packets per second.
         * * C(CUSTOMLOAD) - Base service selection on the SNMP metrics obtained by custom load monitors.
         * * C(LRTM) - Select the service with the lowest response time. Response times are learned through monitoring probes. This method also takes the number of active connections into account.
         * Also available are a number of hashing methods, in which the appliance extracts a predetermined portion of the request, creates a hash of the portion, and then checks whether any previous requests had the same hash value. If it finds a match, it forwards the request to the service that served those previous requests. Following are the hashing methods:
         * * C(URLHASH) - Create a hash of the request URL (or part of the URL).
         * * C(DOMAINHASH) - Create a hash of the domain name in the request (or part of the domain name). The domain name is taken from either the URL or the Host header. If the domain name appears in both locations, the URL is preferred. If the request does not contain a domain name, the load balancing method defaults to C(LEASTCONNECTION).
         * * C(DESTINATIONIPHASH) - Create a hash of the destination IP address in the IP header.
         * * C(SOURCEIPHASH) - Create a hash of the source IP address in the IP header.
         * * C(TOKEN) - Extract a token from the request, create a hash of the token, and then select the service to which any previous requests with the same token hash value were sent.
         * * C(SRCIPDESTIPHASH) - Create a hash of the string obtained by concatenating the source IP address and destination IP address in the IP header.
         * * C(SRCIPSRCPORTHASH) - Create a hash of the source IP address and source port in the IP header.
         * * C(CALLIDHASH) - Create a hash of the SIP Call-ID header.
         */
        lbmethod?:
          | "ROUNDROBIN"
          | "LEASTCONNECTION"
          | "LEASTRESPONSETIME"
          | "URLHASH"
          | "DOMAINHASH"
          | "DESTINATIONIPHASH"
          | "SOURCEIPHASH"
          | "SRCIPDESTIPHASH"
          | "LEASTBANDWIDTH"
          | "LEASTPACKETS"
          | "TOKEN"
          | "SRCIPSRCPORTHASH"
          | "LRTM"
          | "CALLIDHASH"
          | "CUSTOMLOAD"
          | "LEASTREQUEST"
          | "AUDITLOGHASH"
          | "STATICPROXIMITY";
        /**
         * Mode in which the connection failover feature must operate for the virtual server. After a failover, established TCP connections and UDP packet flows are kept active and resumed on the secondary appliance. Clients remain connected to the same servers. Available settings function as follows:
         * * C(STATEFUL) - The primary appliance shares state information with the secondary appliance, in real time, resulting in some runtime processing overhead.
         * * C(STATELESS) - State information is not shared, and the new primary appliance tries to re-create the packet flow on the basis of the information contained in the packets it receives.
         * * C(DISABLED) - Connection failover does not occur.
         */
        connfailover?: "DISABLED" | "STATEFUL" | "STATELESS";
        /**
         * Threshold at which spillover occurs. Specify an integer for the C(CONNECTION) spillover method, a bandwidth value in kilobits per second for the C(BANDWIDTH) method (do not enter the units), or a percentage for the C(HEALTH) method (do not enter the percentage symbol).
         * Minimum value = C(1)
         * Maximum value = C(4294967287)
         */
        sothreshold?: number;
        /**
         * If spillover occurs, maintain source IP address based persistence for both primary and backup virtual servers.
         */
        sopersistence?: "enabled" | "disabled";
        /**
         * This argument is for enabling/disabling the C(dns64) on lbvserver.
         */
        dns64?: "enabled" | "disabled";
        /**
         * This argument decides the behavior incase the service which is selected from an existing persistence session has reached threshold.
         */
        skippersistency?: "Bypass" | "ReLb" | "None";
        /**
         * TOS ID of the virtual server. Applicable only when the load balancing redirection mode is set to TOS.
         * Minimum value = C(1)
         * Maximum value = C(63)
         */
        tosid?: number;
        /**
         * Name of the TCP profile whose settings are to be applied to the virtual server.
         * Minimum length = 1
         * Maximum length = 127
         */
        tcpprofilename?: string;
        /**
         * Time period for which backup persistence is in effect.
         * Minimum value = C(2)
         * Maximum value = C(1440)
         */
        backuppersistencetimeout?: number;
        /**
         * Units in which to increment load at each interval in slow-start mode.
         */
        newservicerequestunit?: "PER_SECOND" | "PERCENT";
        /**
         * Integer specifying the priority of the listen policy. A higher number specifies a lower priority. If a request matches the listen policies of more than one virtual server the virtual server whose listen policy has the highest priority (the lowest priority number) accepts the request.
         * Minimum value = C(0)
         * Maximum value = C(101)
         */
        listenpriority?: number;
        /**
         * Number of IP addresses that the appliance must generate and assign to the virtual server. The virtual server then functions as a network virtual server, accepting traffic on any of the generated IP addresses. The IP addresses are generated automatically, as follows:
         * * For a range of n, the last octet of the address specified by the IP Address parameter increments n-1 times.
         * * If the last octet exceeds 255, it rolls over to 0 and the third octet increments by 1.
         * Note: The Range parameter assigns multiple IP addresses to one virtual server. To generate an array of virtual servers, each of which owns only one IP address, use brackets in the IP Address and Name parameters to specify the range. For example:
         * add lb vserver my_vserver[1-3] HTTP 192.0.2.[1-3] 80.
         * Minimum value = C(1)
         * Maximum value = C(254)
         */
        range?: number;
        nitro_pass: string;
        /**
         * Any comments that you might want to associate with the virtual server.
         */
        comment?: string;
        /**
         * Insert an HTTP header, whose value is the IP address and port number of the virtual server, before forwarding a request to the server. The format of the header is <vipHeader>: <virtual server IP address>_<port number >, where vipHeader is the name that you specify for the header. If the virtual server has an IPv6 address, the address in the header is enclosed in brackets ([ and ]) to separate it from the port number. If you have mapped an IPv4 address to a virtual server's IPv6 address, the value of this parameter determines which IP address is inserted in the header, as follows:
         * * C(VIPADDR) - Insert the IP address of the virtual server in the HTTP header regardless of whether the virtual server has an IPv4 address or an IPv6 address. A mapped IPv4 address, if configured, is ignored.
         * * C(V6TOV4MAPPING) - Insert the IPv4 address that is mapped to the virtual server's IPv6 address. If a mapped IPv4 address is not configured, insert the IPv6 address.
         * * C(OFF) - Disable header insertion.
         */
        insertvserveripport?: "OFF" | "VIPADDR" | "V6TOV4MAPPING";
        /**
         * Rewrite the port and change the protocol to ensure successful HTTP redirects from services.
         */
        redirectportrewrite?: "enabled" | "disabled";
        /**
         * Idle time, in seconds, after which a client connection is terminated.
         * Minimum value = C(0)
         * Maximum value = C(31536000)
         */
        clttimeout?: number;
        /**
         * Fully qualified domain name (FQDN) of the authentication virtual server to which the user must be redirected for authentication. Make sure that the Authentication parameter is set to C(yes).
         * Minimum length = 3
         * Maximum length = 252
         */
        authenticationhost?: string;
        /**
         * Protocol used by the service (also called the service type).
         */
        servicetype?:
          | "HTTP"
          | "FTP"
          | "TCP"
          | "UDP"
          | "SSL"
          | "SSL_BRIDGE"
          | "SSL_TCP"
          | "DTLS"
          | "NNTP"
          | "DNS"
          | "DHCPRA"
          | "ANY"
          | "SIP_UDP"
          | "SIP_TCP"
          | "SIP_SSL"
          | "DNS_TCP"
          | "RTSP"
          | "PUSH"
          | "SSL_PUSH"
          | "RADIUS"
          | "RDP"
          | "MYSQL"
          | "MSSQL"
          | "DIAMETER"
          | "SSL_DIAMETER"
          | "TFTP"
          | "ORACLE"
          | "SMPP"
          | "SYSLOGTCP"
          | "SYSLOGUDP"
          | "FIX"
          | "SSL_FIX";
        /**
         * Server capabilities that the virtual server advertises to clients.
         */
        mysqlservercapabilities?: number;
        /**
         * Name of the HTTP profile whose settings are to be applied to the virtual server.
         * Minimum length = 1
         * Maximum length = 127
         */
        httpprofilename?: string;
        /**
         * Interval, in seconds, between successive increments in the load on a new service or a service whose state has just changed from DOWN to UP. A value of 0 (zero) specifies manual slow start.
         * Minimum value = C(0)
         * Maximum value = C(3600)
         */
        newservicerequestincrementinterval?: number;
        /**
         * IPv4 subnet mask to apply to the destination IP address or source IP address when the load balancing method is C(DESTINATIONIPHASH) or C(SOURCEIPHASH).
         * Minimum length = 1
         */
        netmask?: string;
        /**
         * Type of threshold that, when exceeded, triggers spillover. Available settings function as follows:
         * * C(CONNECTION) - Spillover occurs when the number of client connections exceeds the threshold.
         * * DYNAMICCONNECTION - Spillover occurs when the number of client connections at the virtual server exceeds the sum of the maximum client (Max Clients) settings for bound services. Do not specify a spillover threshold for this setting, because the threshold is implied by the Max Clients settings of bound services.
         * * C(BANDWIDTH) - Spillover occurs when the bandwidth consumed by the virtual server's incoming and outgoing traffic exceeds the threshold.
         * * C(HEALTH) - Spillover occurs when the percentage of weights of the services that are UP drops below the threshold. For example, if services svc1, svc2, and svc3 are bound to a virtual server, with weights 1, 2, and 3, and the spillover threshold is 50%, spillover occurs if svc1 and svc3 or svc2 and svc3 transition to DOWN.
         * * C(NONE) - Spillover does not occur.
         */
        somethod?: "CONNECTION" | "DYNAMICCONNECTION" | "BANDWIDTH" | "HEALTH" | "NONE";
        /**
         * Persistence mask for IP based persistence types, for IPv4 virtual servers.
         * Minimum length = 1
         */
        persistmask?: string;
        /**
         * Name of the DNS profile to be associated with the VServer. DNS profile properties will be applied to the transactions processed by a VServer. This parameter is valid only for DNS and DNS-TCP VServers.
         * Minimum length = 1
         * Maximum length = 127
         */
        dnsprofilename?: string;
        /**
         * How the NetScaler appliance responds to ping requests received for an IP address that is common to one or more virtual servers. Available settings function as follows:
         * * If set to C(PASSIVE) on all the virtual servers that share the IP address, the appliance always responds to the ping requests.
         * * If set to C(ACTIVE) on all the virtual servers that share the IP address, the appliance responds to the ping requests if at least one of the virtual servers is UP. Otherwise, the appliance does not respond.
         * * If set to C(ACTIVE) on some virtual servers and PASSIVE on the others, the appliance responds if at least one virtual server with the ACTIVE setting is UP. Otherwise, the appliance does not respond.
         * Note: This parameter is available at the virtual server level. A similar parameter, ICMP Response, is available at the IP address level, for IPv4 addresses of type VIP. To set that parameter, use the add ip command in the CLI or the Create IP dialog box in the GUI.
         */
        icmpvsrresponse?: "PASSIVE" | "ACTIVE";
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * If this option is enabled while resolving DNS64 query AAAA queries are not sent to back end dns server.
         */
        bypassaaaa?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Use this parameter to specify the cookie name for C(COOKIE) peristence type. It specifies the name of cookie with a maximum of 32 characters. If not specified, cookie name is internally generated.
         */
        cookiename?: string;
        nitro_protocol?: "http" | "https";
        /**
         * MySQL protocol version that the virtual server advertises to clients.
         */
        mysqlprotocolversion?: number;
        /**
         * URL to which to redirect traffic if the virtual server becomes unavailable.
         * WARNING! Make sure that the domain in the URL does not match the domain specified for a content switching policy. If it does, requests are continuously redirected to the unavailable virtual server.
         * Minimum length = 1
         */
        redirurl?: string;
        /**
         * List of service groups along with the weights that are load balanced.
         * The following suboptions are available.
         */
        servicegroupbindings?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Route cacheable requests to a cache redirection virtual server. The load balancing virtual server can forward requests only to a transparent cache redirection virtual server that has an IP address and port combination of *:80, so such a cache redirection virtual server must be configured on the appliance.
         */
        cacheable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Backup persistence type for the virtual server. Becomes operational if the primary persistence mechanism fails.
         */
        persistencebackup?: "SOURCEIP" | "NONE";
        /**
         * MySQL server version string that the virtual server advertises to clients.
         * Minimum length = 1
         * Maximum length = 31
         */
        mysqlserverversion?: string;
        /**
         * Enable or disable user authentication.
         */
        authentication?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Threshold in percent of active services below which vserver state is made down. If this threshold is 0, vserver state will be up even if one bound service is up.
         * Minimum value = C(0)
         * Maximum value = C(100)
         */
        healththreshold?: number;
        /**
         * Route Health Injection (RHI) functionality of the NetSaler appliance for advertising the route of the VIP address associated with the virtual server. When Vserver RHI Level (RHI) parameter is set to VSVR_CNTRLD, the following are different RHI behaviors for the VIP address on the basis of RHIstate (RHI STATE) settings on the virtual servers associated with the VIP address:
         * * If you set C(rhistate) to C(PASSIVE) on all virtual servers, the NetScaler ADC always advertises the route for the VIP address.
         * * If you set C(rhistate) to C(ACTIVE) on all virtual servers, the NetScaler ADC advertises the route for the VIP address if at least one of the associated virtual servers is in UP state.
         * * If you set C(rhistate) to C(ACTIVE) on some and PASSIVE on others, the NetScaler ADC advertises the route for the VIP address if at least one of the associated virtual servers, whose C(rhistate) set to C(ACTIVE), is in UP state.
         */
        rhistate?: "PASSIVE" | "ACTIVE";
        /**
         * Action to be performed if spillover is to take effect, but no backup chain to spillover is usable or exists.
         */
        sobackupaction?: "DROP" | "ACCEPT" | "REDIRECT";
        /**
         * Use Layer 2 parameters (channel number, MAC address, and VLAN ID) in addition to the 4-tuple (<source IP>:<source port>::<destination IP>:<destination port>) that is used to identify a connection. Allows multiple TCP and non-TCP connections with the same 4-tuple to co-exist on the NetScaler appliance.
         */
        l2conn?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Number of bits to consider in an IPv6 destination or source IP address, for creating the hash that is required by the C(DESTINATIONIPHASH) and C(SOURCEIPHASH) load balancing methods.
         * Minimum value = C(1)
         * Maximum value = C(128)
         */
        v6netmasklen?: number;
        /**
         * Perform load balancing on a per-packet basis, without establishing sessions. Recommended for load balancing of intrusion detection system (IDS) servers and scenarios involving direct server return (DSR), where session information is unnecessary.
         */
        sessionless?: "enabled" | "disabled";
        /**
         * IPv4 or IPv6 address to assign to the virtual server.
         */
        ipv46?: string;
        /**
         * Type of persistence for the virtual server. Available settings function as follows:
         * * C(SOURCEIP) - Connections from the same client IP address belong to the same persistence session.
         * * C(COOKIEINSERT) - Connections that have the same HTTP Cookie, inserted by a Set-Cookie directive from a server, belong to the same persistence session.
         * * C(SSLSESSION) - Connections that have the same SSL Session ID belong to the same persistence session.
         * * C(CUSTOMSERVERID) - Connections with the same server ID form part of the same session. For this persistence type, set the Server ID (CustomServerID) parameter for each service and configure the Rule parameter to identify the server ID in a request.
         * * C(RULE) - All connections that match a user defined rule belong to the same persistence session.
         * * C(URLPASSIVE) - Requests that have the same server ID in the URL query belong to the same persistence session. The server ID is the hexadecimal representation of the IP address and port of the service to which the request must be forwarded. This persistence type requires a rule to identify the server ID in the request.
         * * C(DESTIP) - Connections to the same destination IP address belong to the same persistence session.
         * * C(SRCIPDESTIP) - Connections that have the same source IP address and destination IP address belong to the same persistence session.
         * * C(CALLID) - Connections that have the same CALL-ID SIP header belong to the same persistence session.
         * * C(RTSPSID) - Connections that have the same RTSP Session ID belong to the same persistence session.
         * * FIXSESSION - Connections that have the same SenderCompID and TargetCompID values belong to the same persistence session.
         */
        persistencetype?:
          | "SOURCEIP"
          | "COOKIEINSERT"
          | "SSLSESSION"
          | "RULE"
          | "URLPASSIVE"
          | "CUSTOMSERVERID"
          | "DESTIP"
          | "SRCIPDESTIP"
          | "CALLID"
          | "RTSPSID"
          | "DIAMETER"
          | "FIXSESSION"
          | "NONE";
        /**
         * IP address pattern, in dotted decimal notation, for identifying packets to be accepted by the virtual server. The IP Mask parameter specifies which part of the destination IP address is matched against the pattern. Mutually exclusive with the IP Address parameter.
         * For example, if the IP pattern assigned to the virtual server is C(198.51.100.0) and the IP mask is C(255.255.240.0) (a forward mask), the first 20 bits in the destination IP addresses are matched with the first 20 bits in the pattern. The virtual server accepts requests with IP addresses that range from C(198.51.96.1) to C(198.51.111.254). You can also use a pattern such as C(0.0.2.2) and a mask such as C(0.0.255.255) (a reverse mask).
         * If a destination IP address matches more than one IP pattern, the pattern with the longest match is selected, and the associated virtual server processes the request. For example, if virtual servers C(vs1) and C(vs2) have the same IP pattern, C(0.0.100.128), but different IP masks of C(0.0.255.255) and C(0.0.224.255), a destination IP address of C(198.51.100.128) has the longest match with the IP pattern of vs1. If a destination IP address matches two or more virtual servers to the same extent, the request is processed by the virtual server whose port number matches the port number in the request.
         */
        ippattern?: string;
        /**
         * Name of the DB profile whose settings are to be applied to the virtual server.
         * Minimum length = 1
         * Maximum length = 127
         */
        dbprofilename?: string;
        /**
         * Redirection mode for load balancing. Available settings function as follows:
         * * C(IP) - Before forwarding a request to a server, change the destination IP address to the server's IP address.
         * * C(MAC) - Before forwarding a request to a server, change the destination MAC address to the server's MAC address. The destination IP address is not changed. MAC-based redirection mode is used mostly in firewall load balancing deployments.
         * * C(IPTUNNEL) - Perform IP-in-IP encapsulation for client IP packets. In the outer IP headers, set the destination IP address to the IP address of the server and the source IP address to the subnet IP (SNIP). The client IP packets are not modified. Applicable to both IPv4 and IPv6 packets.
         * * C(TOS) - Encode the virtual server's TOS ID in the TOS field of the IP header.
         * You can use either the C(IPTUNNEL) or the C(TOS) option to implement Direct Server Return (DSR).
         */
        m?: "IP" | "MAC" | "IPTUNNEL" | "TOS";
        /**
         * For a load balancing virtual server of type C(MSSQL), the Microsoft SQL Server version. Set this parameter if you expect some clients to run a version different from the version of the database. This setting provides compatibility between the client-side and server-side connections by ensuring that all communication conforms to the server's version.
         */
        mssqlserverversion?: "70" | "2000" | "2000SP1" | "2005" | "2008" | "2008R2" | "2012" | "2014";
        /**
         * Timeout for spillover persistence, in minutes.
         * Minimum value = C(2)
         * Maximum value = C(1440)
         */
        sopersistencetimeout?: number;
        nsip: string;
        /**
         * Number of requests, or percentage of the load on existing services, by which to increase the load on a new service at each interval in slow-start mode. A non-zero value indicates that slow-start is applicable. A zero value indicates that the global RR startup parameter is applied. Changing the value to zero will cause services currently in slow start to take the full traffic as determined by the LB method. Subsequently, any new services added will use the global RR factor.
         */
        newservicerequest?: number;
        /**
         * Process traffic with the push virtual server that is bound to this load balancing virtual server.
         */
        push?: "enabled" | "disabled";
        [k: string]: unknown;
      };
      /**
       * Create volume clones on Element OS
       */
      na_elementsw_volume_clone?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Get info about available Python requirements on the target host, including listing required libraries and gathering versions.
       */
      python_requirements_facts?: {
        /**
         * A list of version-likes or module names to check for installation. Supported operators: <, >, <=, >=, or ==. The bare module name like I(ansible), the module with a specific version like I(boto3==1.6.1), or a partial version like I(requests>2) are all valid specifications.
         *
         */
        dependencies?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about an ESXi host's capability information when ESXi hostname or Cluster name is given.
       */
      vmware_host_capability_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and remove zones.
       */
      cs_zone?: {
        /**
         * Domain the zone is related to.
         * Zone is a public zone if not set.
         */
        domain?: string;
        api_http_method?: "get" | "post";
        /**
         * DHCP provider for the Zone.
         */
        dhcp_provider?: string;
        /**
         * uuid of the existing zone.
         */
        id?: string;
        /**
         * First DNS for IPv6 for the zone.
         */
        dns1_ipv6?: string;
        /**
         * First internal DNS for the zone.
         * If not set C(dns1) will be used on C(state=present).
         */
        internal_dns1?: string;
        /**
         * Second internal DNS for the zone.
         */
        internal_dns2?: string;
        api_url?: string;
        /**
         * Default: present
         *
         * State of the zone.
         */
        state?: "present" | "enabled" | "disabled" | "absent";
        api_key?: string;
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Second DNS for IPv6 for the zone.
         */
        dns2_ipv6?: string;
        securitygroups_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the zone.
         */
        name: string;
        /**
         * Second DNS for the zone.
         */
        dns2?: string;
        /**
         * First DNS for the zone.
         * Required if C(state=present)
         */
        dns1?: string;
        api_region?: string;
        /**
         * Guest CIDR address for the zone.
         */
        guest_cidr_address?: string;
        /**
         * Network domain for the zone.
         */
        network_domain?: string;
        local_storage_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: basic
         *
         * Network type of the zone.
         */
        network_type?: "Basic" | "basic" | "Advanced" | "advanced";
        [k: string]: unknown;
      };
      /**
       * Manage and query Windows services.
       * For non-Windows targets, use the M(service) module instead.
       */
      win_service?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV HostStorages (applicable only for block storage).
       */
      ovirt_host_storage_facts?: {
        /**
         * Dictionary with values for fibre channel storage type:
         * C(address) - Address of the fibre channel storage server.
         * C(port) - Port of the fibre channel storage server.
         * C(lun_id) - LUN id.
         */
        fcp?: string;
        /**
         * Host to get device list from.
         */
        host?: string;
        /**
         * Dictionary with values for iSCSI storage type:
         * C(address) - Address of the iSCSI storage server.
         * C(target) - The target IQN for the storage device.
         * C(username) - A CHAP user name for logging into a target.
         * C(password) - A CHAP password for logging into a target.
         */
        iscsi?: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an Mellanox ONYX network device and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(onyx_config) to configure Mellanox ONYX devices.
       */
      onyx_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        /**
         * List of commands to send to the remote Mellanox ONYX network device. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: "any" | "all";
        [k: string]: unknown;
      };
      /**
       * Map and unmap LUNs on NetApp ONTAP.
       */
      na_ontap_lun_map?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage AWS IAM roles
       */
      iam_role?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages source address persistence profiles.
       */
      bigip_profile_persistence_src_addr?: {
        /**
         * Specifies the name of the profile.
         */
        name?: string;
        /**
         * Specifies the profile from which this profile inherits settings.
         * When creating a new profile, if this parameter is not specified, the default is the system-supplied C(source_addr) profile.
         */
        parent?: string;
        /**
         * When C(yes), specifies that the system can use any pool that contains this persistence record.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        match_across_pools?: string;
        /**
         * Specifies the duration of the persistence entries.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         * To specify an indefinite timeout, use the value C(indefinite).
         * If specifying a numeric timeout, the value must be between C(1) and C(4294967295).
         */
        entry_timeout?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * When C(yes), specifies that all persistent connections from a client IP address that go to the same virtual IP address also go to the same node.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        match_across_services?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the profile exists.
         * When C(absent), ensures the profile is removed.
         */
        state?: string;
        /**
         * When C(yes), specifies that all persistent connections from the same client IP address go to the same node.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        match_across_virtuals?: string;
        /**
         * Specifies the algorithm the system uses for hash persistence load balancing. The hash result is the input for the algorithm.
         * When C(default), specifies that the system uses the index of pool members to obtain the hash result for the input to the algorithm.
         * When C(carp), specifies that the system uses the Cache Array Routing Protocol (CARP) to obtain the hash result for the input to the algorithm.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        hash_algorithm?: string;
        /**
         * When C(yes), specifies that the system allows you to specify that pool member connection limits will be overridden for persisted clients.
         * Per-virtual connection limits remain hard limits and are not overridden.
         */
        override_connection_limit?: string;
        [k: string]: unknown;
      };
      /**
       * This module helps to install Powershell modules and register custom modules repository on Windows Server.
       */
      win_psmodule?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Used to enable or disable features in Chocolatey.
       */
      win_chocolatey_feature?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, delete or modify hosts on Pure Storage FlashArrays.
       */
      purefa_host?: {
        /**
         * Default: iscsi
         *
         * Defines the host connection protocol for volumes.
         */
        protocol?: string;
        /**
         * The name of the host.
         */
        host?: string;
        /**
         * Volume name to map to the host.
         */
        volume?: string;
        /**
         * Default: present
         *
         * Define whether the host should exist or not.
         * When removing host all connected volumes will be disconnected.
         */
        state?: string;
        /**
         * List of IQNs of the host if protocol is iscsi or mixed.
         */
        iqn?: string;
        /**
         * Define which operating systen the host is. Recommend for ActiveCluster integration
         */
        personality?: string;
        /**
         * List of wwns of the host if protocol is fc or mixed.
         */
        wwns?: string;
        [k: string]: unknown;
      };
      /**
       * Gets various details related to AWS VPC Endpoints
       */
      ec2_vpc_endpoint_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Checks management connectivity of a windows host.
       * This is NOT ICMP ping, this is just a trivial test module.
       * For non-Windows targets, use the M(ping) module instead.
       * For Network targets, use the M(net_ping) module instead.
       */
      win_ping?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to manage maintenance mode of a datastore.
       */
      vmware_datastore_maintenancemode?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update, or destroy Ansible Tower projects. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_project?: {
        /**
         * Name of the credential to use with this SCM resource.
         */
        scm_credential?: string;
        /**
         * The branch to use for the SCM resource.
         */
        scm_branch?: string;
        /**
         * Description to use for the project.
         */
        description?: string;
        tower_host?: string;
        tower_password?: string;
        /**
         * Default: no
         *
         * Remove local modifications before updating.
         */
        scm_clean?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: manual
         *
         * Type of SCM resource.
         */
        scm_type?: "manual" | "git" | "hg" | "svn";
        /**
         * Default: no
         *
         * Remove the repository completely before updating.
         */
        scm_delete_on_update?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * The server playbook directory for manual projects.
         */
        local_path?: string;
        /**
         * URL of SCM resource.
         */
        scm_url?: string;
        /**
         * Default: no
         *
         * Before an update to the local repository before launching a job with this project.
         */
        scm_update_on_launch?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_username?: string;
        /**
         * Primary key of organization for project.
         */
        organization?: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name to use for the project.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Returns information about the load balancer.
       * Will be marked changed when called only if state is changed.
       */
      elb_classic_lb?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Uses syslog to add log entries to the host.
       * Can specify facility and priority.
       */
      syslogger?: {
        /**
         * Default: info
         *
         * Set the log priority
         */
        priority?: "emerg" | "alert" | "crit" | "err" | "warning" | "notice" | "info" | "debug";
        /**
         * This is the message to place in syslog
         */
        msg: string;
        /**
         * Default: daemon
         *
         * Set the log facility
         */
        facility?:
          | "kern"
          | "user"
          | "mail"
          | "daemon"
          | "auth"
          | "lpr"
          | "news"
          | "uucp"
          | "cron"
          | "syslog"
          | "local0"
          | "local1"
          | "local2"
          | "local3"
          | "local4"
          | "local5"
          | "local6"
          | "local7";
        /**
         * Default: no
         *
         * Log the pid in brackets
         */
        log_pid?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create, update, or delete OpenStack Identity service. If a service with the supplied name already exists, it will be updated with the new description and enabled attributes.
       */
      os_keystone_service?: {
        /**
         * Description of the service
         */
        description?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Default: yes
         *
         * Is the service enabled
         */
        enabled?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * The type of service
         */
        service_type?: string;
        /**
         * Name of the service
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Adds or removes nat rules from a gateway in a vca environment
       */
      vca_nat?: {
        /**
         * A list of rules to be added to the gateway, Please see examples on valid entries
         */
        nat_rules?: string;
        /**
         * If set to true, it will delete all rules in the gateway that are not given as parameter to this module.
         */
        purge_rules?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP GlobalAddress
       */
      gcp_compute_global_address_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * This is a simple module that supports creating or removing vDCs. A vDC is required before you can create servers. This module has a dependency on profitbricks >= 1.0.0
       */
      profitbricks_datacenter?: {
        /**
         * The description of the virtual datacenter.
         */
        description?: string;
        /**
         * The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
         */
        subscription_user?: string;
        /**
         * The name of the virtual datacenter.
         */
        name?: string;
        /**
         * THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
         */
        subscription_password?: string;
        /**
         * Default: present
         *
         * create or terminate datacenters
         */
        state?: string;
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: string;
        /**
         * Default: us/las
         *
         * The datacenter location.
         */
        location?: "us/las" | "de/fra" | "de/fkb";
        /**
         * Default: yes
         *
         * wait for the datacenter to be created before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more of the Enclosures from OneView.
       */
      oneview_enclosure_facts?: {
        username?: string;
        image_streamer_hostname?: string;
        /**
         * Enclosure name.
         */
        name?: string;
        hostname?: string;
        params?: {
          [k: string]: unknown;
        };
        password?: string;
        config?: string;
        /**
         * List with options to gather additional facts about an Enclosure and related resources. Options allowed: C(script), C(environmentalConfiguration), and C(utilization). For the option C(utilization), you can provide specific parameters.
         */
        options?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages access list entries for ACLs.
       */
      nxos_acl?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Sequence number of the entry (ACE).
         */
        seq?: string;
        /**
         * Name of time-range to apply.
         */
        time_range?: string;
        /**
         * Destination port operands such as eq, neq, gt, lt, range.
         */
        dest_port_op?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        /**
         * Match established connections.
         */
        established?: "enable";
        /**
         * Match packets with given precedence.
         */
        precedence?:
          | "critical"
          | "flash"
          | "flash-override"
          | "immediate"
          | "internet"
          | "network"
          | "priority"
          | "routine";
        /**
         * Port number or protocol (as supported by the switch).
         */
        proto?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent" | "delete_acl";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Check non-initial fragments.
         */
        fragments?: "enable";
        /**
         * Match on the FIN bit.
         */
        fin?: "enable";
        /**
         * Second (end) port when using range operand.
         */
        src_port2?: string;
        username?: string;
        /**
         * Source port operands such as eq, neq, gt, lt, range.
         */
        src_port_op?: string;
        /**
         * Match on the PSH bit.
         */
        psh?: "enable";
        /**
         * Destination ip and mask using IP/MASK notation and supports the keyword 'any'.
         */
        dest?: string;
        /**
         * Match on the SYN bit.
         */
        syn?: "enable";
        /**
         * Match packets with given dscp value.
         */
        dscp?:
          | "af11"
          | "af12"
          | "af13"
          | "af21"
          | "af22"
          | "af23"
          | "af31"
          | "af32"
          | "af33"
          | "af41"
          | "af42"
          | "af43"
          | "cs1"
          | "cs2"
          | "cs3"
          | "cs4"
          | "cs5"
          | "cs6"
          | "cs7"
          | "default"
          | "ef";
        host?: string;
        /**
         * Match on the URG bit.
         */
        urg?: "enable";
        /**
         * Match on the RST bit.
         */
        rst?: "enable";
        password?: string;
        /**
         * Log matches against this entry.
         */
        log?: "enable";
        /**
         * Source ip and mask using IP/MASK notation and supports keyword 'any'.
         */
        src?: string;
        /**
         * If action is set to remark, this is the description.
         */
        remark?: string;
        ssh_keyfile?: string;
        /**
         * Case sensitive name of the access list (ACL).
         */
        name: string;
        /**
         * Match on the ACK bit.
         */
        ack?: "enable";
        /**
         * Port/protocol and also first (lower) port when using range operand.
         */
        src_port1?: string;
        timeout?: number | string;
        /**
         * Action of the ACE.
         */
        action?: "permit" | "deny" | "remark";
        /**
         * Port/protocol and also first (lower) port when using range operand.
         */
        dest_port1?: string;
        /**
         * Second (end) port when using range operand.
         */
        dest_port2?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module provides configuration file management of EdgeOS devices. It provides arguments for managing both the configuration file and state of the active configuration. All configuration statements are based on `set` and `delete` commands in the device configuration.
       * This is a network module and requires the C(connection: network_cli) in order to work properly.
       * For more information please see the L(Network Guide,../network/getting_started/index.html).
       */
      edgeos_config?: {
        /**
         * Default: configured by edgeos_config
         *
         * Allows a commit description to be specified to be included when the configuration is committed. If the configuration is not changed or committed, this argument is ignored.
         */
        comment?: string;
        /**
         * The C(src) argument specifies the path to the source config file to load. The source config file can either be in bracket format or set format. The source file can include Jinja2 template variables.
         */
        src?: string;
        /**
         * The C(config) argument specifies the base configuration to use to compare against the desired configuration. If this value is not specified, the module will automatically retrieve the current active configuration from the remote device.
         */
        config?: string;
        /**
         * The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.
         */
        lines?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: no
         *
         * The C(save) argument controls whether or not changes made to the active configuration are saved to disk. This is independent of committing the config. When set to C(True), the active configuration is saved.
         */
        save?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * The C(backup) argument will backup the current device's active configuration to the Ansible control host prior to making any changes. The backup file will be located in the backup folder in the playbook root directory or role root directory if the playbook is part of an ansible role. If the directory does not exist, it is created.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: line
         *
         * The C(match) argument controls the method used to match against the current active configuration. By default, the desired config is matched against the active config and the deltas are loaded. If the C(match) argument is set to C(none) the active configuration is ignored and the configuration is always loaded.
         */
        match?: "line" | "none";
        [k: string]: unknown;
      };
      /**
       * This module is used to configure IpAddrGroup object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_ipaddrgroup?: {
        /**
         * Configure ip address prefix(es).
         */
        prefixes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Uuid of the ip address group.
         */
        uuid?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Populate ip addresses from members of this cisco apic epg.
         */
        apic_epg_name?: string;
        /**
         * Populate the ip address ranges from the geo database for this country.
         */
        country_codes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        api_version?: string;
        username?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Task port associated with marathon service port.
         * If marathon app has multiple service ports, this is required.
         * Else, the first task port is used.
         */
        marathon_service_port?: number | string;
        /**
         * Configure ip address range(s).
         */
        ranges?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        controller?: string;
        /**
         * Configure ip address(es).
         */
        addrs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * Name of the ip address group.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        tenant_uuid?: string;
        /**
         * Configure (ip address, port) tuple(s).
         */
        ip_ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Populate ip addresses from tasks of this marathon app.
         */
        marathon_app_name?: string;
        [k: string]: unknown;
      };
      /**
       * Create and remove domain records.
       */
      exo_dns_domain?: {
        /**
         * Name of the record.
         */
        name: string;
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Default: present
         *
         * State of the resource.
         */
        state?: "present" | "absent";
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create a policy nat rule. Keep in mind that we can either end up configuring source NAT, destination NAT, or both. Instead of splitting it into two we will make a fair attempt to determine which one the user wants.
       */
      panos_nat_policy?: {
        /**
         * Default: admin
         *
         * username for authentication
         */
        username?: string;
        /**
         * dnat translated address
         */
        dnat_address?: string;
        /**
         * Default: no
         *
         * bidirectional flag
         */
        snat_bidirectional?: string;
        /**
         * destination zone
         */
        to_zone: string;
        /**
         * Default: any
         *
         * service
         */
        service?: string;
        /**
         * type of source translation
         */
        snat_type?: string;
        /**
         * Default: ['any']
         *
         * list of source addresses
         */
        source?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * list of source zones
         */
        from_zone:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: ['any']
         *
         * list of destination addresses
         */
        destination?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * dnat translated port
         */
        dnat_port?: string;
        /**
         * snat interface address
         */
        snat_interface_address?: string;
        /**
         * name of the SNAT rule
         */
        rule_name: string;
        /**
         * Default: no
         *
         * attempt to override rule if one with the same name already exists
         */
        override?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * commit if changed
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * password for authentication
         */
        password: string;
        /**
         * IP address (or hostname) of PAN-OS device
         */
        ip_address: string;
        /**
         * snat translated address
         */
        snat_address?: string;
        /**
         * snat interface
         */
        snat_interface?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides functionality to copy file from Ansible controller to network devices.
       */
      net_put?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host: string;
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Execute show command in the nodes and returns the results read from the device.
       */
      pn_show?: {
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword: string;
        /**
         * The C(pn_command) takes a CLI show command as value.
         */
        pn_command: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername: string;
        /**
         * Display output using a specific parameter. Use 'all' to display possible output. List of comma separated parameters.
         */
        pn_parameters?: string;
        /**
         * Specify formatting options.
         */
        pn_options?: string;
        /**
         * Target switch(es) to run the cli on.
         */
        pn_cliswitch?: string;
        [k: string]: unknown;
      };
      /**
       * Manages Sensu handler configuration
       * For more information, refer to the Sensu documentation: U(https://sensuapp.org/docs/latest/reference/handlers.html)
       */
      sensu_handler?: {
        /**
         * The Sensu event filter (name) to use when filtering events for the handler.
         */
        filter?: string;
        /**
         * The socket definition scope, used to configure the TCP/UDP handler socket.
         * NOTE: the socket attribute is only required for TCP/UDP handlers (i.e. handlers configured with "type": "tcp" or "type": "udp").
         */
        socket?: {
          [k: string]: unknown;
        };
        /**
         * An array of Sensu event handlers (names) to use for events using the handler set.
         * Each array item must be a string.
         * NOTE: the handlers attribute is only required for handler sets (i.e. handlers configured with "type": "set").
         */
        handlers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * An array of Sensu event filters (names) to use when filtering events for the handler.
         * Each array item must be a string.
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * An array of check result severities the handler will handle.
         * NOTE: event resolution bypasses this filtering.
         */
        severities?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The pipe definition scope, used to configure the Sensu transport pipe.
         * NOTE: the pipe attribute is only required for Transport handlers (i.e. handlers configured with "type": "transport").
         */
        pipe?: {
          [k: string]: unknown;
        };
        /**
         * The Sensu event mutator (name) to use to mutate event data for the handler.
         */
        mutator?: string;
        /**
         * Default: present
         *
         * Whether the handler should be present or not
         */
        state?: "present" | "absent";
        /**
         * The handler command to be executed.
         * The event data is passed to the process via STDIN.
         * NOTE: the command attribute is only required for Pipe handlers (i.e. handlers configured with "type": "pipe").
         */
        command?: string;
        /**
         * Default: 10
         *
         * The handler execution duration timeout in seconds (hard stop).
         * Only used by pipe and tcp handler types.
         */
        timeout?: number | string;
        /**
         * Default: no
         *
         * If events in the flapping state should be handled.
         */
        handle_flapping?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * If events matching one or more silence entries should be handled.
         */
        handle_silenced?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The handler type
         */
        type?: "pipe" | "tcp" | "udp" | "transport" | "set";
        /**
         * A unique name for the handler. The name cannot contain special characters or spaces.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create or destroy Qtrees.
       */
      na_ontap_qtree?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Module to manage datacenter quotas in oVirt/RHV
       */
      ovirt_quota?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage SLB (Server Load Balancer) server objects on A10 Networks devices via aXAPIv2.
       */
      a10_server?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module allows the administration of Keycloak clients via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
       * The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(http://www.keycloak.org/docs-api/3.3/rest-api/). Aliases are provided so camelCased versions can be used as well.
       * The Keycloak API does not always enforce for only sensible settings to be used -- you can set SAML-specific settings on an OpenID Connect client for instance and vice versa. Be careful. If you do not specify a setting, usually a sensible default is chosen.
       */
      keycloak_client?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Allows you to set the local security policies that are configured by SecEdit.exe.
       */
      win_security_policy?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Allows for easy creation, updating and deletion of origin access identities.
       */
      cloudfront_origin_access_identity?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates, removes and configures a binding to an existing IIS Web site.
       */
      win_iis_webbinding?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 80
         *
         * The port to bind to / use for the new site.
         */
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Adds or removes Red Hat software channels.
       */
      rhn_channel?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage service configuration in Netscaler.
       * This module allows the creation, deletion and modification of Netscaler services.
       * This module is intended to run either on the ansible  control node or a bastion (jumpserver) with access to the actual netscaler instance.
       * This module supports check mode.
       */
      netscaler_service?: {
        /**
         * Any information about the service.
         */
        comment?: string;
        /**
         * Enable TCP buffering for the service.
         */
        tcpb?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Cache type supported by the cache server.
         */
        cachetype?: "TRANSPARENT" | "REVERSE" | "FORWARD";
        /**
         * Default: None
         *
         * Unique identifier for the service. Used when the persistency type for the virtual server is set to Custom Server ID.
         */
        customserverid?: string;
        /**
         * Name of the server that hosts the service.
         * Minimum length = 1
         */
        servername?: string;
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * When set to C(yes) the service state will be set to DISABLED.
         * When set to C(no) the service state will be set to ENABLED.
         * Note that due to limitations of the underlying NITRO API a C(disabled) state change alone does not cause the module result to report a changed status.
         */
        disabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_protocol?: "http" | "https";
        /**
         * Maximum number of requests that can be sent on a persistent connection to the service.
         * Note: Connection requests beyond this value are rejected.
         * Minimum value = 0
         * Maximum value = 65535
         */
        maxreq?: number;
        /**
         * Shut down gracefully, not accepting any new connections, and disabling the service when all of its connections are closed.
         */
        graceful?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Maximum bandwidth, in Kbps, allocated to the service.
         * Minimum value = 0
         * Maximum value = 4294967287
         */
        maxbandwidth?: number;
        /**
         * Time, in seconds, after which to terminate an idle server connection.
         * Minimum value = 0
         * Maximum value = 31536000
         */
        svrtimeout?: number;
        /**
         * Port number of the service.
         * Range 1 - 65535
         * * in CLI is represented as 65535 in NITRO API
         */
        port?: number | string;
        /**
         * Time, in seconds, after which to terminate an idle client connection.
         * Minimum value = 0
         * Maximum value = 31536000
         */
        clttimeout?: number;
        /**
         * Protocol in which data is exchanged with the service.
         */
        servicetype?:
          | "HTTP"
          | "FTP"
          | "TCP"
          | "UDP"
          | "SSL"
          | "SSL_BRIDGE"
          | "SSL_TCP"
          | "DTLS"
          | "NNTP"
          | "RPCSVR"
          | "DNS"
          | "ADNS"
          | "SNMP"
          | "RTSP"
          | "DHCPRA"
          | "ANY"
          | "SIP_UDP"
          | "SIP_TCP"
          | "SIP_SSL"
          | "DNS_TCP"
          | "ADNS_TCP"
          | "MYSQL"
          | "MSSQL"
          | "ORACLE"
          | "RADIUS"
          | "RADIUSListener"
          | "RDP"
          | "DIAMETER"
          | "SSL_DIAMETER"
          | "TFTP"
          | "SMPP"
          | "PPTP"
          | "GRE"
          | "SYSLOGTCP"
          | "SYSLOGUDP"
          | "FIX"
          | "SSL_FIX";
        /**
         * Minimum sum of weights of the monitors that are bound to this service. Used to determine whether to mark a service as UP or DOWN.
         * Minimum value = 0
         * Maximum value = 65535
         */
        monthreshold?: number;
        /**
         * Maximum number of simultaneous open connections to the service.
         * Minimum value = 0
         * Maximum value = 4294967294
         */
        maxclient?: number;
        /**
         * The new IP address of the service.
         */
        ipaddress?: string;
        state?: "present" | "absent";
        /**
         * Use the client's IP address as the source IP address when initiating a connection to the server. When creating a service, if you do not set this parameter, the service inherits the global Use Source IP setting (available in the enable ns mode and disable ns mode CLI commands, or in the System > Settings > Configure modes > Configure Modes dialog box). However, you can override this setting after you create the service.
         */
        usip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_user: string;
        /**
         * Network profile to use for the service.
         * Minimum length = 1
         * Maximum length = 127
         */
        netprofile?: string;
        /**
         * Enable RTSP session ID mapping for the service.
         */
        rtspsessionidremap?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_timeout?: number;
        /**
         * IP to assign to the service.
         * Minimum length = 1
         */
        ip?: string;
        /**
         * Port to which clear text data must be sent after the appliance decrypts incoming SSL traffic. Applicable to transparent SSL services.
         * Minimum value = 1
         */
        cleartextport?: number | string;
        /**
         * Enable logging of AppFlow information.
         */
        appflowlog?: "enabled" | "disabled";
        /**
         * Use the transparent cache redirection virtual server to forward requests to the cache server.
         * Note: Do not specify this parameter if you set the Cache Type parameter.
         */
        cacheable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A list of load balancing monitors to bind to this service.
         * Each monitor entry is a dictionary which may contain the following options.
         * Note that if not using the built in monitors they must first be setup.
         */
        monitor_bindings?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A numerical identifier that can be used by hash based load balancing methods. Must be unique for each service.
         * Minimum value = 1
         */
        hashid?: number;
        /**
         * By turning on this option packets destined to a service in a cluster will not under go any steering. Turn this option for single packet request response mode or when the upstream device is performing a proper RSS for connection based distribution.
         */
        processlocal?: "enabled" | "disabled";
        /**
         * Use Layer 2 mode to bridge the packets sent to this service if it is marked as DOWN. If the service is DOWN, and this parameter is disabled, the packets are dropped.
         */
        accessdown?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name for the service. Must begin with an ASCII alphabetic or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the service has been created.
         * Minimum length = 1
         */
        name?: string;
        /**
         * Name of the TCP profile that contains TCP configuration settings for the service.
         * Minimum length = 1
         * Maximum length = 127
         */
        tcpprofilename?: string;
        /**
         * Enable surge protection for the service.
         */
        sp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Flush all active transactions associated with a service whose state transitions from UP to DOWN. Do not enable this option for applications that must complete their transactions.
         */
        downstateflush?: "enabled" | "disabled";
        /**
         * Name for the HTTP header whose value must be set to the IP address of the client. Used with the Client IP parameter. If you set the Client IP parameter, and you do not specify a name for the header, the appliance uses the header name specified for the global Client IP Header parameter (the cipHeader parameter in the set ns param CLI command or the Client IP Header parameter in the Configure HTTP Parameters dialog box at System > Settings > Change HTTP parameters). If the global Client IP Header parameter is not specified, the appliance inserts a header with the name "client-ip.".
         * Minimum length = 1
         */
        cipheader?: string;
        /**
         * Name of the HTTP profile that contains HTTP configuration settings for the service.
         * Minimum length = 1
         * Maximum length = 127
         */
        httpprofilename?: string;
        nsip: string;
        /**
         * Before forwarding a request to the service, insert an HTTP header with the client's IPv4 or IPv6 address as its value. Used if the server needs the client's IP address for security, accounting, or other purposes, and setting the Use Source IP parameter is not a viable option.
         */
        cip?: "enabled" | "disabled";
        /**
         * Default: True
         *
         * Monitor the health of this service
         */
        healthmonitor?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Use the proxy port as the source port when initiating connections with the server. With the NO setting, the client-side connection port is used as the source port for the server-side connection.
         * Note: This parameter is available only when the Use Source IP (USIP) parameter is set to YES.
         */
        useproxyport?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable client keep-alive for the service.
         */
        cka?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_pass: string;
        /**
         * Enable compression for the service.
         */
        cmp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the DNS profile to be associated with the service. DNS profile properties will applied to the transactions processed by a service. This parameter is valid only for ADNS and ADNS-TCP services.
         * Minimum length = 1
         * Maximum length = 127
         */
        dnsprofilename?: string;
        [k: string]: unknown;
      };
      /**
       * Create, delete volume pair
       */
      na_elementsw_volume_pair?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Allows for invalidation of a batch of paths for a CloudFront distribution.
       */
      cloudfront_invalidation?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage Config Snapshots on Cisco ACI fabrics.
       * Creating new Snapshots is done using the configExportP class.
       * Removing Snapshots is done using the configSnapshot class.
       */
      aci_config_snapshot?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Assume a role using AWS Security Token Service and obtain temporary credentials
       */
      sts_assume_role?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * create / delete a database in the Cloud Databases.
       */
      rax_cdb_user?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * allows you to create/delete/stop instances in Proxmox VE cluster
       * Starting in Ansible 2.1, it automatically detects containerization type (lxc for PVE 4, openvz for older)
       */
      proxmox?: {
        /**
         * Default: no
         *
         * forcing operations
         * can be used only with states C(present), C(stopped), C(restarted)
         * with C(state=present) force option allow to overwrite existing container
         * with states C(stopped) , C(restarted) allow to force stop instance
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * numbers of allocated cpus for instance
         */
        cpus?: number | string;
        /**
         * the template for VM creating
         * required only for C(state=present)
         */
        ostemplate?: string;
        /**
         * Default: no
         *
         * Indicate if the container should be unprivileged
         */
        unprivileged?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 3
         *
         * hard disk size in GB for instance
         */
        disk?: string;
        /**
         * sets DNS search domain for a container
         */
        searchdomain?: string;
        /**
         * the user to authenticate with
         */
        api_user: string;
        /**
         * the instance hostname
         * required only for C(state=present)
         * must be unique if vmid is not passed
         */
        hostname?: string;
        /**
         * Default: local
         *
         * target storage
         */
        storage?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the instance
         */
        state?: "present" | "started" | "absent" | "stopped" | "restarted";
        /**
         * swap memory size in MB for instance
         */
        swap?: number | string;
        /**
         * Default: 512
         *
         * memory size in MB for instance
         */
        memory?: number | string;
        /**
         * Public key to add to /root/.ssh/authorized_keys. This was added on Proxmox 4.2, it is ignored for earlier versions
         */
        pubkey?: string;
        /**
         * Proxmox VE node, when new VM will be created
         * required only for C(state=present)
         * for another states will be autodiscovered
         */
        node?: string;
        /**
         * Default: 1000
         *
         * CPU weight for a VM
         */
        cpuunits?: number | string;
        /**
         * the password to authenticate with
         * you can use PROXMOX_PASSWORD environment variable
         */
        api_password?: string;
        /**
         * the instance root password
         * required only for C(state=present)
         */
        password?: string;
        /**
         * specifies the address the container will be assigned
         */
        ip_address?: string;
        /**
         * Proxmox VE resource pool
         */
        pool?: string;
        /**
         * the host of the Proxmox VE cluster
         */
        api_host: string;
        /**
         * specifies network interfaces for the container. As a hash/dictionary defining interfaces.
         */
        netif?: {
          [k: string]: unknown;
        };
        /**
         * the instance id
         * if not set, the next available VM ID will be fetched from ProxmoxAPI.
         * if not set, will be fetched from PromoxAPI based on the hostname
         */
        vmid?: string;
        /**
         * Default: 30
         *
         * timeout for operations
         */
        timeout?: number | string;
        /**
         * specifies additional mounts (separate disks) for the container. As a hash/dictionary defining mount points
         */
        mounts?: {
          [k: string]: unknown;
        };
        /**
         * Default: 1
         *
         * Specify number of cores per socket.
         */
        cores?: number | string;
        /**
         * sets DNS server IP address for a container
         */
        nameserver?: string;
        /**
         * Default: no
         *
         * enable / disable https certificate verification
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * specifies whether a VM will be started during system bootup
         */
        onboot?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages AFM security firewall policies on a BIG-IP.
       */
      bigip_firewall_policy?: {
        /**
         * Specifies a list of rules that you want associated with this policy. The order of this list is the order they will be evaluated by BIG-IP. If the specified rules do not exist (for example when creating a new policy) then they will be created.
         * Rules specified here, if they do not exist, will be created with "default deny" behavior. It is expected that you follow-up this module with the actual configuration for these rules.
         * The C(bigip_firewall_rule) module can be used to also create, as well as edit, existing and new rules.
         */
        rules?: string;
        /**
         * Default: present
         *
         * When C(state) is C(present), ensures that the policy exists.
         * When C(state) is C(absent), ensures that the policy is removed.
         */
        state?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * The name of the policy to create.
         */
        name?: string;
        /**
         * The description to attach to the policy.
         * This parameter is only supported on versions of BIG-IP >= 12.1.0. On earlier versions it will simply be ignored.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Migrate a VMK interface from VSS to VDS
       */
      vmware_migrate_vmk?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates/modified or removes Windows scheduled tasks.
       */
      win_scheduled_task?: {
        /**
         * The priority level (0-10) of the task.
         * When creating a new task the default if C(7).
         * See U(https://msdn.microsoft.com/en-us/library/windows/desktop/aa383512.aspx) for details on the priority levels.
         */
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage packages for FreeBSD using 'portinstall'.
       */
      portinstall?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage a firewall policy for an Ontap Cluster
       */
      na_ontap_firewall_policy?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages BGP Address-family configurations on HUAWEI CloudEngine switches.
       */
      ce_bgp_af?: {
        /**
         * ID of a router that is in IPv4 address format. The value is a string of 0 to 255 characters. The value is in dotted decimal notation.
         */
        router_id?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the function to advertise supernetwork unicast routes is enabled. If the value is false, the function to advertise supernetwork unicast routes is disabled.
         */
        supernet_uni_adv?: "no_use" | "true" | "false";
        /**
         * Ingress lsp policy name.
         */
        ingress_lsp_policy_name?: string;
        /**
         * Default: no_use
         *
         * If the value is true, VPN BGP instances are enabled to automatically select router IDs. If the value is false, VPN BGP instances are disabled from automatically selecting router IDs.
         */
        vrf_rid_auto_sel?: "no_use" | "true" | "false";
        /**
         * Process ID of an imported routing protocol. The value is an integer ranging from 0 to 4294967295.
         */
        import_process_id?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the route reflector is enabled to modify route path attributes based on an export policy. If the value is false, the route reflector is disabled from modifying route path attributes based on an export policy.
         */
        reflect_chg_path?: "no_use" | "true" | "false";
        /**
         * Set the protocol priority of a local BGP route. The value is an integer ranging from 1 to 255.
         */
        preference_local?: string;
        /**
         * Set the protocol priority of EBGP routes. The value is an integer ranging from 1 to 255.
         */
        preference_external?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the router ID attribute is ignored when BGP selects the optimal route. If the value is false, the router ID attribute is not ignored when BGP selects the optimal route.
         */
        router_id_neglect?: "no_use" | "true" | "false";
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set the Local-Preference attribute. The value is an integer. The value is an integer ranging from 0 to 4294967295.
         */
        default_local_pref?: string;
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Set a cluster ipv4 address. The value is expressed in the format of an IPv4 address.
         */
        reflector_cluster_ipv4?: string;
        /**
         * Set a routing policy to filter routes so that a configured priority is applied to the routes that match the specified policy. The value is a string of 1 to 40 characters.
         */
        prefrence_policy_name?: string;
        /**
         * Specify the name of a route-policy for route iteration. The value is a string of 1 to 40 characters.
         */
        nhp_relay_route_policy_name?: string;
        /**
         * Set a cluster ID. Configuring multiple RRs in a cluster can enhance the stability of the network. The value is an integer ranging from 1 to 4294967295.
         */
        reflector_cluster_id?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the AS path attribute is ignored when BGP selects an optimal route. If the value is false, the AS path attribute is not ignored when BGP selects an optimal route. An AS path with a smaller length has a higher priority.
         */
        as_path_neglect?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, BGP auto FRR is enabled. If the value is false, BGP auto FRR is disabled.
         */
        auto_frr_enable?: "no_use" | "true" | "false";
        /**
         * Specify the mask length of an IP address. The value is an integer ranging from 0 to 128.
         */
        mask_len?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the next hop of an advertised route is changed to the advertiser itself in IBGP load-balancing scenarios. If the value is false, the next hop of an advertised route is not changed to the advertiser itself in IBGP load-balancing scenarios.
         */
        ibgp_ecmp_nexthop_changed?: "no_use" | "true" | "false";
        /**
         * Address family type of a BGP instance.
         */
        af_type: "ipv4uni" | "ipv4multi" | "ipv4vpn" | "ipv6uni" | "ipv6vpn" | "evpn";
        /**
         * Default: no_use
         *
         * If the value is true, the third-party next hop function is enabled. If the value is false, the third-party next hop function is disabled.
         */
        nexthop_third_party?: "no_use" | "true" | "false";
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Specify the Multi-Exit-Discriminator (MED) of BGP routes. The value is an integer ranging from 0 to 4294967295.
         */
        default_med?: string;
        /**
         * Number of Add-Path routes. The value is an integer ranging from 2 to 64.
         */
        add_path_sel_num?: string;
        /**
         * Default: no_use
         *
         * If the value is true, when BGP selects an optimal route, the system uses 4294967295 as the MED value of a route if the route's attribute does not carry a MED value. If the value is false, the system uses 0 as the MED value of a route if the route's attribute does not carry a MED value.
         */
        med_none_as_maximum?: "no_use" | "true" | "false";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: no_use
         *
         * If the value is true, the next hop of an advertised route is changed to the advertiser itself in BGP load-balancing scenarios. If the value is false, the next hop of an advertised route is not changed to the advertiser itself in BGP load-balancing scenarios.
         */
        ecmp_nexthop_changed?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, enable reduce priority to advertise route. If the value is false, disable reduce priority to advertise route.
         */
        lowest_priority?: "no_use" | "true" | "false";
        /**
         * Set the number of the extended community filter supported by an RR group. The value is a string of 1 to 51 characters.
         */
        rr_filter_number?: string;
        /**
         * Set the protocol priority of IBGP routes. The value is an integer ranging from 1 to 255.
         */
        preference_internal?: string;
        username?: string;
        /**
         * Default: no_use
         *
         * If the value is true, BGP deterministic-MED is enabled. If the value is false, BGP deterministic-MED is disabled.
         */
        determin_med?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * Load balancing as path ignore.
         */
        load_balancing_as_path_ignore?: "no_use" | "true" | "false";
        /**
         * Specify the maximum number of equal-cost routes in the BGP routing table. The value is an integer ranging from 1 to 65535.
         */
        maximum_load_balance?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the MEDs of routes learned from peers in different autonomous systems are compared when BGP selects an optimal route. If the value is false, the MEDs of routes learned from peers in different autonomous systems are not compared when BGP selects an optimal route.
         */
        always_compare_med?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * Allow routes with BGP origin AS validation result Invalid to be selected. If the value is true, invalid routes can participate in route selection. If the value is false, invalid routes cannot participate in route selection.
         */
        allow_invalid_as?: "no_use" | "true" | "false";
        /**
         * Specify the name of a routing policy. The value is a string of 1 to 40 characters.
         */
        rib_only_policy_name?: string;
        /**
         * Default: no_use
         *
         * If the value is true, relay delay enable. If the value is false, relay delay disable.
         */
        relay_delay_enable?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, the function to advertise supernetwork label is enabled. If the value is false, the function to advertise supernetwork label is disabled.
         */
        supernet_label_adv?: "no_use" | "true" | "false";
        host?: string;
        /**
         * Specify the maximum number of equal-cost EBGP routes. The value is an integer ranging from 1 to 65535.
         */
        max_load_ebgp_num?: string;
        /**
         * Routing protocol from which routes can be imported.
         */
        import_protocol?: "direct" | "ospf" | "isis" | "static" | "rip" | "ospfv3" | "ripng";
        /**
         * Default: no_use
         *
         * If the value is true, after the fast EBGP interface awareness function is enabled, EBGP sessions on an interface are deleted immediately when the interface goes Down. If the value is false, after the fast EBGP interface awareness function is enabled, EBGP sessions on an interface are not deleted immediately when the interface goes Down.
         */
        ebgp_if_sensitive?: "no_use" | "true" | "false";
        password?: string;
        /**
         * Specify the IP address advertised by BGP. The value is a string of 0 to 255 characters.
         */
        network_address?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the metrics of next-hop IGP routes are not compared when BGP selects an optimal route. If the value is false, the metrics of next-hop IGP routes are not compared when BGP selects an optimal route. A route with a smaller metric has a higher priority.
         */
        igp_metric_ignore?: "no_use" | "true" | "false";
        ssh_keyfile?: string;
        /**
         * Default: default
         *
         * Next hop select depend type.
         */
        next_hop_sel_depend_type?: "default" | "dependTunnel" | "dependIp";
        /**
         * Default: no_use
         *
         * If the value is true, importing default routes to the BGP routing table is allowed. If the value is false, importing default routes to the BGP routing table is not allowed.
         */
        default_rt_import_enable?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * Originator prior.
         */
        originator_prior?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, BGP is enabled to advertise only optimal routes in the RM to peers. If the value is false, BGP is not enabled to advertise only optimal routes in the RM to peers.
         */
        active_route_advertise?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, route reflection is enabled between clients. If the value is false, route reflection is disabled between clients.
         */
        reflect_between_client?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, VPN-Target filtering function is performed for received VPN routes. If the value is false, VPN-Target filtering function is not performed for received VPN routes.
         */
        policy_vpn_target?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, automatic aggregation is enabled for locally imported routes. If the value is false, automatic aggregation is disabled for locally imported routes.
         */
        summary_automatic?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, BGP routes cannot be advertised to the IP routing table. If the value is false, Routes preferred by BGP are advertised to the IP routing table.
         */
        rib_only_enable?: "no_use" | "true" | "false";
        /**
         * Specify the maximum number of equal-cost IBGP routes. The value is an integer ranging from 1 to 65535.
         */
        max_load_ibgp_num?: string;
        /**
         * Route selection delay. The value is an integer ranging from 0 to 3600.
         */
        route_sel_delay?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the next hop of an advertised route is changed to the advertiser itself in EBGP load-balancing scenarios. If the value is false, the next hop of an advertised route is not changed to the advertiser itself in EBGP load-balancing scenarios.
         */
        ebgp_ecmp_nexthop_changed?: "no_use" | "true" | "false";
        /**
         * Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created. The value is a string of 1 to 31 case-sensitive characters.
         */
        vrf_name: string;
        timeout?: number | string;
        /**
         * Default: no_use
         *
         * If the value is true, modifying extended community attributes is allowed. If the value is false, modifying extended community attributes is not allowed.
         */
        policy_ext_comm_enable?: "no_use" | "true" | "false";
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create or delete log_group in CloudWatchLogs.
       */
      cloudwatchlogs_log_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * A named resource representing the stream of messages from a single, specific topic, to be delivered to the subscribing application.
       */
      gcp_pubsub_subscription?: {
        /**
         * This value is the maximum time after a subscriber receives a message before the subscriber should acknowledge the message. After message delivery but before the ack deadline expires and before the message is acknowledged, it is an outstanding message and will not be delivered again during that time (on a best-effort basis).
         * For pull subscriptions, this value is used as the initial value for the ack deadline. To override this value for a given message, call subscriptions.modifyAckDeadline with the corresponding ackId if using pull. The minimum custom deadline you can specify is 10 seconds. The maximum custom deadline you can specify is 600 seconds (10 minutes).
         * If this parameter is 0, a default value of 10 seconds is used.
         * For push delivery, this value is also used to set the request timeout for the call to the push endpoint.
         * If the subscriber never acknowledges the message, the Pub/Sub system will eventually redeliver the message.
         */
        ack_deadline_seconds?: number | string;
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the subscription.
         */
        name?: string;
        service_account_email?: string;
        /**
         * If push delivery is used with this subscription, this field is used to configure it. An empty pushConfig signifies that the subscriber will pull and ack messages using API methods.
         */
        push_config?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        project?: string;
        /**
         * A reference to a Topic resource.
         */
        topic?: {
          [k: string]: unknown;
        };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Create and manage AWS Datapipelines. Creation is not idempotent in AWS, so the I(uniqueId) is created by hashing the options (minus objects) given to the datapipeline.
       * The pipeline definition must be in the format given here U(http://docs.aws.amazon.com/datapipeline/latest/APIReference/API_PutPipelineDefinition.html#API_PutPipelineDefinition_RequestSyntax).
       * Also operations will wait for a configurable amount of time to ensure the pipeline is in the requested state.
       */
      data_pipeline?: {
        /**
         * The name of the Datapipeline to create/modify/delete.
         */
        name?: string;
        /**
         * A list of parameter objects (dicts) in the pipeline definition.
         */
        parameters?: string;
        /**
         * A dict of key:value pair(s) to add to the pipeline.
         */
        tags?: string;
        /**
         * Default: present
         *
         * The requested state of the pipeline.
         */
        state?: string;
        /**
         * A list of pipeline object definitions, each of which is a dict that takes the keys C(id), C(name) and C(fields).
         */
        objects?: string;
        /**
         * A list of parameter values (dicts) in the pipeline definition. Each dict takes the keys C(id) and C(stringValue) both of which are strings.
         */
        values?: string;
        /**
         * Default: 300
         *
         * Time in seconds to wait for the pipeline to transition to the requested state, fail otherwise.
         */
        timeout?: string;
        /**
         * An optional description for the pipeline being created.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Configures VSANs on Cisco UCS Manager.
       * Examples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).
       */
      ucs_vsans?: {
        /**
         * The name assigned to the VSAN.
         * This name can be between 1 and 32 alphanumeric characters.
         * You cannot use spaces or any special characters other than - (hyphen), "_" (underscore), : (colon), and . (period).
         * You cannot change this name after the VSAN is created.
         */
        name?: string;
        /**
         * The unique identifier assigned to the VSAN.
         * The ID can be a string between '1' and '4078', or between '4080' and '4093'. '4079' is a reserved VSAN ID.
         * In addition, if you plan to use FC end-host mode, the range between '3840' to '4079' is also a reserved VSAN ID range.
         * Optional if state is absent.
         */
        vsan_id?: string;
        /**
         * Default: disabled
         *
         * Fibre Channel zoning configuration for the Cisco UCS domain.
         * Fibre Channel zoning can be set to one of the following values:
         * disabled  The upstream switch handles Fibre Channel zoning, or Fibre Channel zoning is not implemented for the Cisco UCS domain.
         * enabled  Cisco UCS Manager configures and controls Fibre Channel zoning for the Cisco UCS domain.
         * If you enable Fibre Channel zoning, do not configure the upstream switch with any VSANs that are being used for Fibre Channel zoning.
         */
        fc_zoning?: string;
        /**
         * Default: present
         *
         * If C(present), will verify VSANs are present and will create if needed.
         * If C(absent), will verify VSANs are absent and will delete if needed.
         */
        state?: string;
        /**
         * The unique string identifier assigned to the VLAN used for Fibre Channel connections.
         * Note that Cisco UCS Manager uses VLAN '4048'.  See the UCS Manager configuration guide if you want to assign '4048' to a VLAN.
         * Optional if state is absent.
         */
        vlan_id?: string;
        /**
         * Default: common
         *
         * The fabric configuration of the VSAN.  This can be one of the following:
         * common - The VSAN maps to the same VSAN ID in all available fabrics.
         * A - The VSAN maps to the a VSAN ID that exists only in fabric A.
         * B - The VSAN maps to the a VSAN ID that exists only in fabric B.
         */
        fabric?: string;
        [k: string]: unknown;
      };
      /**
       * You can wait for BIG-IP to be "ready". By "ready", we mean that BIG-IP is ready to accept configuration.
       * This module can take into account situations where the device is in the middle of rebooting due to a configuration change.
       */
      bigip_wait?: {
        [k: string]: unknown;
      };
      /**
       * Manages OpenWrt packages
       */
      opkg?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * This module prints statements during execution and can be useful for debugging variables or expressions without necessarily halting the playbook. Useful for debugging together with the 'when:' directive.
       * This module is also supported for Windows targets.
       */
      debug?: {
        active_connection_states?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        connect_timeout?: number | string;
        delay?: number | string;
        search_regex?: string;
        state?: "absent" | "drained" | "present" | "started" | "stopped";
        sleep?: number | string;
        timeout?: number | string;
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: Hello world!
         *
         * The customized message that is printed. If omitted, prints a generic message.
         */
        msg?: string;
        path?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Represents a TargetPool resource, used for Load Balancing.
       */
      gcp_compute_target_pool?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A reference to a HttpHealthCheck resource.
         * A member instance in this pool is considered healthy if and only if the health checks pass. If not specified it means all member instances will be considered healthy at all times.
         */
        health_check?: {
          [k: string]: unknown;
        };
        /**
         * This field is applicable only when the containing target pool is serving a forwarding rule as the primary pool (i.e., not as a backup pool to some other target pool). The value of the field must be in [0, 1].
         * If set, backupPool must also be set. They together define the fallback behavior of the primary target pool: if the ratio of the healthy instances in the primary pool is at or below this number, traffic arriving at the load-balanced IP will be directed to the backup pool.
         * In case where failoverRatio is not set or all the instances in the backup pool are unhealthy, the traffic will be directed back to the primary pool in the "force" mode, where traffic will be spread to the healthy instances with the best effort, or to all instances when no instance is healthy.
         */
        failover_ratio?: string;
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        service_account_email?: string;
        /**
         * The region where the target pool resides.
         */
        region: string;
        /**
         * This field is applicable only when the containing target pool is serving a forwarding rule as the primary pool, and its failoverRatio field is properly set to a value between [0, 1].
         * backupPool and failoverRatio together define the fallback behavior of the primary target pool: if the ratio of the healthy instances in the primary pool is at or below failoverRatio, traffic arriving at the load-balanced IP will be directed to the backup pool.
         * In case where failoverRatio and backupPool are not set, or all the instances in the backup pool are unhealthy, the traffic will be directed back to the primary pool in the "force" mode, where traffic will be spread to the healthy instances with the best effort, or to all instances when no instance is healthy.
         */
        backup_pool?: {
          [k: string]: unknown;
        };
        project?: string;
        /**
         * A list of virtual machine instances serving this pool.
         * They must live in zones contained in the same region as this pool.
         */
        instances?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        /**
         * Session affinity option. Must be one of these values:  - NONE: Connections from the same client IP may go to any instance in   the pool.
         * - CLIENT_IP: Connections from the same client IP will go to the same   instance in the pool while that instance remains healthy.
         * - CLIENT_IP_PROTO: Connections from the same client IP with the same   IP protocol will go to the same instance in the pool while that   instance remains healthy.
         */
        session_affinity?: "NONE" | "CLIENT_IP" | "CLIENT_IP_PROTO";
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * An optional description of this resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete an Azure Container Registry.
       */
      azure_rm_containerregistry?: {
        profile?: string;
        /**
         * Default: Standard
         *
         * Specifies the SKU to use. Currently can be either Basic, Standard or Premium.
         */
        sku?: "Basic" | "Standard" | "Premium";
        /**
         * Name of the Container Registry.
         */
        name: string;
        /**
         * Name of a resource group where the Container Registry exists or will be created.
         */
        resource_group: string;
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        /**
         * If enabled, you can use the registry name as username and admin user access key as password to docker login to your container registry.
         */
        admin_user_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        secret?: string;
        /**
         * Default: present
         *
         * Assert the state of the container registry. Use 'present' to create or update an container registry and 'absent' to delete it.
         */
        state?: "absent" | "present";
        /**
         * Valid azure location. Defaults to location of the resource group.
         */
        location?: string;
        client_id?: string;
        cert_validation_mode?: "validate" | "ignore";
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        api_profile?: string;
        [k: string]: unknown;
      };
      /**
       * Create, start, stop and delete servers on the cloudscale.ch IaaS service.
       * All operations are performed using the cloudscale.ch public API v1.
       * For details consult the full API documentation: U(https://www.cloudscale.ch/en/api/v1).
       * A valid API token is required for all operations. You can create as many tokens as you like using the cloudscale.ch control panel at U(https://control.cloudscale.ch).
       */
      cloudscale_server?: {
        /**
         * UUID of another server to create an anti-affinity group with.
         */
        anti_affinity_with?: string;
        /**
         * UUID of the server.
         * Either C(name) or C(uuid) are required. These options are mutually exclusive.
         */
        uuid?: string;
        /**
         * Default: True
         *
         * Attach a public network interface to the server.
         */
        use_public_network?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Image used to create the server.
         */
        image?: string;
        /**
         * Default: 30
         *
         * Timeout in seconds for calls to the cloudscale.ch API.
         */
        api_timeout?: number | string;
        /**
         * cloudscale.ch API token.
         * This can also be passed in the CLOUDSCALE_API_TOKEN environment variable.
         */
        api_token: string;
        /**
         * Cloud-init configuration (cloud-config) data to use for the server.
         */
        user_data?: string;
        /**
         * Size of the bulk storage volume in GB.
         * No bulk storage volume if not set.
         */
        bulk_volume_size_gb?: number | string;
        /**
         * Default: 10
         *
         * Size of the root volume in GB.
         */
        volume_size_gb?: number | string;
        /**
         * Attach a private network interface to the server.
         */
        use_private_network?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: running
         *
         * State of the server
         */
        state?: "running" | "stopped" | "absent";
        /**
         * Default: True
         *
         * Enable IPv6 on the public network interface.
         */
        use_ipv6?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Flavor of the server.
         */
        flavor?: string;
        /**
         * List of SSH public keys.
         * Use the full content of your .pub file here.
         */
        ssh_keys?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the Server.
         * Either C(name) or C(uuid) are required. These options are mutually exclusive.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * The M(proxysql_scheduler) module adds or removes schedules using the proxysql admin interface.
       */
      proxysql_scheduler?: {
        /**
         * Text field that can be used for any purposed defined by the user.
         */
        comment?: string;
        login_port?: number | string;
        config_file?: string;
        /**
         * Default: present
         *
         * When C(present) - adds the schedule, when C(absent) - removes the schedule.
         */
        state?: "present" | "absent";
        /**
         * Argument that can be passed to the job.
         */
        arg1?: string;
        login_user?: string;
        /**
         * Argument that can be passed to the job.
         */
        arg2?: string;
        /**
         * Argument that can be passed to the job.
         */
        arg3?: string;
        /**
         * Argument that can be passed to the job.
         */
        arg4?: string;
        /**
         * Argument that can be passed to the job.
         */
        arg5?: string;
        /**
         * Full path of the executable to be executed.
         */
        filename: string;
        login_unix_socket?: string;
        /**
         * By default we avoid deleting more than one schedule in a single batch, however if you need this behaviour and you're not concerned about the schedules deleted, you can set I(force_delete) to C(True).
         */
        force_delete?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 10000
         *
         * How often (in millisecond) the job will be started. The minimum value for I(interval_ms) is 100 milliseconds.
         */
        interval_ms?: number | string;
        load_to_runtime?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        login_password?: string;
        /**
         * Default: True
         *
         * A schedule with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures.
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        save_to_disk?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        login_host?: string;
        [k: string]: unknown;
      };
      /**
       * Manages Homebrew casks.
       */
      homebrew_cask?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Power on / Power off / Restart a virtual machine.
       */
      vmware_guest_powerstate?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific availability set or all availability sets.
       */
      azure_rm_availabilityset_facts?: {
        profile?: string;
        /**
         * Limit results to a specific availability set
         */
        name?: string;
        /**
         * The resource group to search for the desired availability set
         */
        resource_group?: string;
        /**
         * List of tags to be matched
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Create and remove instance groups.
       */
      cs_instancegroup?: {
        /**
         * Account the instance group is related to.
         */
        account?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Project the instance group is related to.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the instance group.
         */
        state?: "present" | "absent";
        /**
         * Domain the instance group is related to.
         */
        domain?: string;
        api_key?: string;
        /**
         * Name of the instance group.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, remove and revert VM from snapshots.
       */
      cs_vmsnapshot?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Execute vrouter-bgp-add, vrouter-bgp-remove, vrouter-bgp-modify command.
       * Each fabric, cluster, standalone switch, or virtual network (VNET) can provide its tenants with a vRouter service that forwards traffic between networks and implements Layer 4 protocols.
       */
      pn_vrouterbgp?: {
        /**
         * Specify a neighbor IP address to use for BGP.
         * Required for vrouter-bgp-add.
         */
        pn_neighbor?: string;
        /**
         * Specify a name for the vRouter service.
         */
        pn_vrouter_name: string;
        /**
         * Specify if you want a soft reconfiguration of inbound traffic.
         */
        pn_soft_reconfig?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify a value for external BGP to accept or attempt BGP connections to external peers, not directly connected, on the network. This is a value between 1 and 255.
         */
        pn_ebgp?: number | string;
        /**
         * Specify if a route reflector client is used.
         */
        pn_route_reflector?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify BGP neighbor keepalive interval in seconds.
         */
        pn_keepalive?: string;
        /**
         * Specify a multi-protocol for BGP.
         */
        pn_multiprotocol?: "ipv4-unicast" | "ipv6-unicast";
        /**
         * State the action to perform. Use 'present' to add bgp, 'absent' to remove bgp and 'update' to modify bgp.
         */
        state: "present" | "absent" | "update";
        /**
         * Target switch(es) to run the cli on.
         */
        pn_cliswitch?: string;
        /**
         * Specify the maximum number of prefixes.
         */
        pn_max_prefix?: number | string;
        /**
         * Specify outbound route map for neighbor.
         */
        pn_route_mapout?: string;
        /**
         * Specify if you want BFD protocol support for fault detection.
         */
        pn_bfd?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify inbound route map for neighbor.
         */
        pn_route_mapin?: string;
        /**
         * Specify if you want to override capability.
         */
        pn_override_capability?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the prefix list to filter traffic inbound.
         */
        pn_prefix_listin?: string;
        /**
         * Specify a password, if desired.
         */
        pn_password?: string;
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Specify if you want announce default routes to the neighbor or not.
         */
        pn_default_originate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Specify a default weight value between 0 and 65535 for the neighbor routes.
         */
        pn_weight?: number | string;
        /**
         * Specify the prefix list to filter traffic outbound.
         */
        pn_prefix_listout?: string;
        /**
         * Specify the remote Autonomous System(AS) number. This value is between 1 and 4294967295.
         * Required for vrouter-bgp-add.
         */
        pn_remote_as?: string;
        /**
         * Specify if you want a warning message when the maximum number of prefixes is exceeded.
         */
        pn_max_prefix_warn?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify BGP neighbor holdtime in seconds.
         */
        pn_holdtime?: string;
        /**
         * Specify if the next-hop is the same router or not.
         */
        pn_next_hop_self?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Interfaces on Cisco IOS XR network devices.
       */
      iosxr_interface?: {
        username?: string;
        /**
         * Default: 10
         *
         * Time in seconds to wait before checking for the operational state on remote device. This wait is applicable for operational state argument which are I(state) with values C(up)/C(down), I(tx_rate) and I(rx_rate).
         */
        delay?: number | string;
        ssh_keyfile?: string;
        /**
         * Description of Interface being configured.
         */
        description?: string;
        /**
         * Configures the interface duplex mode. Default is auto-negotiation when not configured.
         */
        duplex?: "full" | "half";
        /**
         * Default: True
         *
         * Removes the shutdown configuration, which removes the forced administrative down on the interface, enabling it to move to an up or down state.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * State of the Interface configuration, C(up) means present and operationally up and C(down) means present and operationally C(down)
         */
        state?: "present" | "absent" | "up" | "down";
        /**
         * Sets the MTU value for the interface. Range is between 64 and 65535'
         */
        mtu?: string;
        /**
         * Receiver rate in bits per second (bps).
         * This is state check parameter only.
         * Supports conditionals, see L(Conditionals in Networking Modules,../network/user_guide/network_working_with_command_output.html)
         */
        rx_rate?: string;
        /**
         * List of Interface definitions. Include multiple interface configurations together, one each on a separate line
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: active
         *
         * Whether the interface is C(active) or C(preconfigured). Preconfiguration allows you to configure modular services cards before they are inserted into the router. When the cards are inserted, they are instantly configured. Active cards are the ones already inserted.
         */
        active?: "active" | "preconfigure";
        password?: string;
        /**
         * Configure the speed for an interface. Default is auto-negotiation when not configured.
         */
        speed?: "10" | "100" | "1000";
        port?: number | string;
        /**
         * Transmit rate in bits per second (bps).
         * This is state check parameter only.
         * Supports conditionals, see L(Conditionals in Networking Modules,../network/user_guide/network_working_with_command_output.html)
         */
        tx_rate?: string;
        /**
         * Name of the interface to configure in C(type + path) format. e.g. C(GigabitEthernet0/0/0/0)
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Policy objects form the match criteria for policy rules and many other functions in PAN-OS. These may include address object, address groups, service objects, service groups, and tag.
       */
      panos_object?: {
        /**
         * Default: admin
         *
         * Username credentials to use for authentication.
         */
        username?: string;
        /**
         * A group of service objects.
         */
        servicegroup?: string;
        /**
         * The type of address object definition.  Valid types are I(ip-netmask) and I(ip-range).
         */
        address_type?: "ip-netmask" | "ip-range" | "fqdn";
        /**
         * A group of address objects to be used in an addressgroup definition.
         */
        static_value?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The description of the object.
         */
        description?: string;
        /**
         * - The color of the tag object.  Valid values are I(red, green, blue, yellow, copper, orange, purple, gray, light green, cyan, light gray, blue gray, lime, black, gold, and brown).
         *
         *
         * Possible choices:
         * red
         * green
         * blue
         * yellow
         * copper
         * orange
         * purple
         * gray
         * light green
         * cyan
         * light gray
         * blue gray
         * lime
         * black
         * gold
         * brown
         */
        color?: string;
        /**
         * The filter match criteria to be used in a dynamic addressgroup definition.
         */
        dynamic_value?: string;
        /**
         * The IP protocol to be used in a service object definition.  Valid values are I(tcp) or I(udp).
         */
        protocol?: "tcp" | "udp";
        /**
         * A static group of address objects or dynamic address group.
         */
        addressgroup?: string;
        /**
         * The name of the address object.
         */
        addressobject?: string;
        /**
         * The source port to be used in a service object definition.
         */
        source_port?: string;
        /**
         * The name of an object or rule tag.
         */
        tag_name?: string;
        /**
         * The name of the service object.
         */
        serviceobject?: string;
        /**
         * API key that can be used instead of I(username)/I(password) credentials.
         */
        api_key?: string;
        /**
         * The IP address of the host or network in CIDR notation.
         */
        address?: string;
        /**
         * The group of service objects used in a servicegroup definition.
         */
        services?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * - The name of the Panorama device group. The group must exist on Panorama. If device group is not defined it is assumed that we are contacting a firewall.
         *
         */
        devicegroup?: string;
        /**
         * The operation to be performed.  Supported values are I(add)/I(delete)/I(find).
         */
        operation: "add" | "update" | "delete" | "find";
        /**
         * Password credentials to use for authentication.
         */
        password?: string;
        /**
         * IP address (or hostname) of PAN-OS device or Panorama management console being configured.
         */
        ip_address: string;
        /**
         * The destination port to be used in a service object definition.
         */
        destination_port?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows you to work with switch configurations. It provides a way to back up the running or startup configurations of a switch to a remote server. This is achieved by periodically saving a copy of the startup or running configuration of the network device to a remote server using FTP, SFTP, TFTP, or SCP. The first step is to create a directory from where the remote server can be reached. The next step is to provide the full file path of the location where the configuration will be backed up. Authentication details required by the remote server must be provided as well. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run.
       */
      cnos_backup?: {
        /**
         * Specify the password for the server relating to the protocol used.
         */
        serverpassword?: string;
        username?: string;
        outputfile: string;
        /**
         * This refers to the protocol used by the network device to interact with the remote server to where to upload the backup configuration. The choices are FTP, SFTP, TFTP, or SCP. Any other protocols will result in error. If this parameter is not specified, there is no default value to be used.
         */
        protocol: string;
        serverip: string;
        /**
         * This specifies what type of configuration will be backed up. The choices are the running or startup configurations. There is no default value, so it will result in an error if the input is incorrect.
         */
        configType: string;
        host?: string;
        deviceType: string;
        /**
         * Specify the username for the server relating to the protocol used.
         */
        serverusername?: string;
        password?: string;
        enablePassword?: string;
        /**
         * This specifies the full file path where the configuration file will be copied on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.
         */
        rcpath: string;
        [k: string]: unknown;
      };
      /**
       * Adds and/or removes instances of A record objects from Infoblox NIOS servers.  This module manages NIOS C(record:a) objects using the Infoblox WAPI interface over REST.
       */
      nios_a_record?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or Remove a subnet to an OpenStack network
       */
      os_subnet?: {
        /**
         * A list of host route dictionaries for the subnet.
         */
        host_routes?: string;
        /**
         * Default: no
         *
         * The gateway IP would not be assigned for this subnet
         */
        no_gateway_ip?: string;
        /**
         * Default: no
         *
         * Use the default subnetpool for I(ip_version) to obtain a CIDR.
         */
        use_default_subnetpool?: string;
        /**
         * Default: yes
         *
         * Whether DHCP should be enabled for this subnet.
         */
        enable_dhcp?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * List of DNS nameservers for this subnet.
         */
        dns_nameservers?: string;
        /**
         * The ip that would be assigned to the gateway for this subnet
         */
        gateway_ip?: string;
        /**
         * Project name or ID containing the subnet (name admin-only)
         */
        project?: string;
        /**
         * IPv6 router advertisement mode
         */
        ipv6_ra_mode?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: string;
        /**
         * From the subnet pool the starting address from which the IP should be allocated.
         */
        allocation_pool_start?: string;
        /**
         * Dictionary with extra key/value pairs passed to the API
         */
        extra_specs?: string;
        /**
         * Default: 4
         *
         * The IP version of the subnet 4 or 6
         */
        ip_version?: string;
        /**
         * IPv6 address mode
         */
        ipv6_address_mode?: string;
        /**
         * The CIDR representation of the subnet that should be assigned to the subnet. Required when I(state) is 'present' and a subnetpool is not specified.
         */
        cidr?: string;
        /**
         * Name of the network to which the subnet should be attached
         * Required when I(state) is 'present'
         */
        network_name?: string;
        /**
         * From the subnet pool the last IP that should be assigned to the virtual machines.
         */
        allocation_pool_end?: string;
        /**
         * The name of the subnet that should be created. Although Neutron allows for non-unique subnet names, this module enforces subnet name uniqueness.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of the local usernames configured on Arista EOS devices.  It allows playbooks to manage either individual usernames or the collection of usernames in the current running config.  It also supports purging usernames from the configuration that are not explicitly defined.
       */
      eos_user?: {
        [k: string]: unknown;
      };
      /**
       * Allows to revoke certificates issued by a CA supporting the L(ACME protocol,https://tools.ietf.org/html/rfc8555), such as L(Let's Encrypt,https://letsencrypt.org/).
       */
      acme_certificate_revoke?: {
        [k: string]: unknown;
      };
      /**
       * Create/delete an SSH key in Packet host.
       * API is documented at U(https://www.packet.net/help/api/#page:ssh-keys,header:ssh-keys-ssh-keys-post).
       */
      packet_sshkey?: {
        [k: string]: unknown;
      };
      /**
       * Manage the network devices. Create, modify and manage various connection and device type e.g., ethernet, teams, bonds, vlans etc.
       * On CentOS and Fedora like systems, install dependencies as 'yum/dnf install -y python-gobject NetworkManager-glib'
       * On Ubuntu and Debian like systems, install dependencies as 'apt-get install -y libnm-glib-dev'
       */
      nmcli?: {
        /**
         * Where conn_name will be the name used to call the connection. when not provided a default name is generated: <type>[-<ifname>][-<num>]
         */
        conn_name: string;
        /**
         * This is only used with VLAN - VLAN ingress priority mapping
         */
        ingress?: string;
        /**
         * Default: 32
         *
         * This is only used with 'bridge-slave' - [<0-63>] - STP priority of this slave
         */
        slavepriority?: string;
        /**
         * Default: 100
         *
         * This is only used with 'bridge-slave' - [<1-65535>] - STP port cost for destinations via this slave
         */
        path_cost?: string;
        /**
         * This is only used with VLAN - parent device this VLAN is on, can use ifname
         */
        vlandev?: string;
        /**
         * Default: 15
         *
         * This is only used with bridge - [forward-delay <2-30>] STP forwarding delay, in seconds
         */
        forwarddelay?: string;
        /**
         * This is only used with bond and is the primary interface name (for "active-backup" mode), this is the usually the 'ifname'
         */
        primary?: string;
        /**
         * Default: yes
         *
         * This is only used with 'bridge-slave' - 'hairpin mode' for the slave, which allows frames to be sent back out through the slave the frame was received on.
         */
        hairpin?: string;
        /**
         * This is only used with VLAN - VLAN egress priority mapping
         */
        egress?: string;
        /**
         * Default: 300
         *
         * This is only used with bridge - [ageing-time <0-1000000>] the Ethernet MAC address aging time, in seconds
         */
        ageingtime?: string;
        /**
         * A list of upto 3 dns servers, ipv4 format e.g. To add two IPv4 DNS server addresses: "192.0.2.53 198.51.100.53"
         */
        dns4?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A list of DNS search domains.
         */
        dns4_search?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 2
         *
         * This is only used with bridge - [hello-time <1-10>] STP hello time, in seconds
         */
        hellotime?: string;
        /**
         * DHCP Client Identifier sent to the DHCP server.
         */
        dhcp_client_id?: string;
        /**
         * Default: 20
         *
         * This is only used with bridge - [max-age <6-42>] STP maximum message age, in seconds
         */
        maxage?: string;
        /**
         * This is only used with VLAN - VLAN ID in range <0-4095>
         */
        vlanid?: string;
        /**
         * Default: 128
         *
         * This is only used with 'bridge' - sets STP priority
         */
        priority?: string;
        /**
         * The IPv4 gateway for this interface using this format ie: "192.0.2.1"
         */
        gw4?: string;
        /**
         * Whether the device should exist or not, taking action if the state is different from what is stated.
         */
        state: "present" | "absent";
        /**
         * The IPv6 gateway for this interface using this format ie: "2001:db8::1"
         */
        gw6?: string;
        /**
         * master <master (ifname, or connection UUID or conn_name) of bridge, team, bond master connection profile.
         */
        master?: string;
        /**
         * This is only used with bridge and controls whether Spanning Tree Protocol (STP) is enabled for this bridge
         */
        stp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: conn_name
         *
         * Where IFNAME will be the what we call the interface name.
         * interface to bind the connection to. The connection will only be applicable to this interface name.
         * A special value of "*" can be used for interface-independent connections.
         * The ifname argument is mandatory for all connection types except bond, team, bridge and vlan.
         */
        ifname?: string;
        /**
         * This is the type of device or network connection that you wish to create or modify.
         * type C(generic) is added in version 2.5.
         */
        type?:
          | "ethernet"
          | "team"
          | "team-slave"
          | "bond"
          | "bond-slave"
          | "bridge"
          | "bridge-slave"
          | "vlan"
          | "generic";
        /**
         * Default: 100
         *
         * This is only used with bond - miimon
         */
        miimon?: string;
        /**
         * This is only used with bond - ARP IP target
         */
        arp_ip_target?: string;
        /**
         * This is only used with bond - downdelay
         */
        downdelay?: string;
        /**
         * This is only used with bridge - MAC address of the bridge (note: this requires a recent kernel feature, originally introduced in 3.15 upstream kernel)
         *
         */
        mac?: string;
        /**
         * The IPv6 address to this interface using this format ie: "abbe::cafe"
         */
        ip6?: string;
        /**
         * The IPv4 address to this interface using this format ie: "192.0.2.24/24"
         */
        ip4?: string;
        /**
         * Default: True
         *
         * Whether the connection should start on boot.
         * Whether the connection profile can be automatically activated
         */
        autoconnect?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A list of DNS search domains.
         */
        dns6_search?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A list of upto 3 dns servers, ipv6 format e.g. To add two IPv6 DNS server addresses: "2001:4860:4860::8888 2001:4860:4860::8844"
         */
        dns6?: string;
        /**
         * Default: 1500
         *
         * The connection MTU, e.g. 9000. This can't be applied when creating the interface and is done once the interface has been created.
         * Can be used when modifying Team, VLAN, Ethernet (Future plans to implement wifi, pppoe, infiniband)
         */
        mtu?: string;
        /**
         * This is only used with bond - ARP interval
         */
        arp_interval?: string;
        /**
         * This is only used with VLAN - flags
         */
        flags?: string;
        /**
         * Default: balance-rr
         *
         * This is the type of device or network connection that you wish to create for a bond, team or bridge.
         */
        mode?: "balance-rr" | "active-backup" | "balance-xor" | "broadcast" | "802.3ad" | "balance-tlb" | "balance-alb";
        /**
         * This is only used with bond - updelay
         */
        updelay?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure IpamDnsProviderProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_ipamdnsproviderprofile?: {
        /**
         * Field introduced in 17.1.1.
         */
        proxy_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Provider details if type is infoblox.
         */
        infoblox_profile?: {
          [k: string]: unknown;
        };
        /**
         * Provider details if type is avi.
         */
        internal_profile?: {
          [k: string]: unknown;
        };
        /**
         * Provider details if type is custom.
         * Field introduced in 17.1.1.
         */
        custom_profile?: {
          [k: string]: unknown;
        };
        /**
         * Provider details if type is aws.
         */
        aws_profile?: {
          [k: string]: unknown;
        };
        /**
         * Uuid of the ipam/dns provider profile.
         */
        uuid?: string;
        /**
         * Provider details if type is google cloud.
         */
        gcp_profile?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Provider type for the ipam/dns provider profile.
         * Enum options - IPAMDNS_TYPE_INFOBLOX, IPAMDNS_TYPE_AWS, IPAMDNS_TYPE_OPENSTACK, IPAMDNS_TYPE_GCP, IPAMDNS_TYPE_INFOBLOX_DNS, IPAMDNS_TYPE_CUSTOM,
         * IPAMDNS_TYPE_CUSTOM_DNS, IPAMDNS_TYPE_AZURE, IPAMDNS_TYPE_INTERNAL, IPAMDNS_TYPE_INTERNAL_DNS, IPAMDNS_TYPE_AWS_DNS, IPAMDNS_TYPE_AZURE_DNS.
         */
        type: string;
        api_version?: string;
        username?: string;
        /**
         * Provider details if type is microsoft azure.
         * Field introduced in 17.2.1.
         */
        azure_profile?: {
          [k: string]: unknown;
        };
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * If this flag is set, only allocate ip from networks in the virtual service vrf.
         * Applicable for avi vantage ipam only.
         * Field introduced in 17.2.4.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        allocate_ip_in_vrf?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Provider details if type is openstack.
         */
        openstack_profile?: {
          [k: string]: unknown;
        };
        /**
         * Name for the ipam/dns provider profile.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * maintains ec2 security groups. This module has a dependency on python-boto >= 2.5
       */
      ec2_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Adds, updates and removes project hooks
       */
      gitlab_hooks?: {
        /**
         * The url that you want GitLab to post to, this is used as the primary key for updates and deletion.
         */
        hook_url: string;
        /**
         * Default: no
         *
         * Trigger hook on job events
         */
        job_events?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Whether GitLab will do SSL verification when triggering the hook
         */
        enable_ssl_verification?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Trigger hook on tag push events
         */
        tag_push_events?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The oauth key provided by GitLab. One of access_token or private_token is required. See https://docs.gitlab.com/ee/api/oauth2.html
         */
        access_token?: string;
        /**
         * Default: no
         *
         * Trigger hook on note events
         */
        note_events?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * When C(present) the hook will be updated to match the input or created if it doesn't exist. When C(absent) it will be deleted if it exists.
         */
        state?: "present" | "absent";
        /**
         * Numeric project id or name of project in the form of group/name
         */
        project: string;
        /**
         * Default: no
         *
         * Trigger hook on issues events
         */
        issues_events?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Secret token to validate hook messages at the receiver.
         * If this is present it will always result in a change as it cannot be retrieved from GitLab.
         * Will show up in the X-Gitlab-Token HTTP request header
         */
        token?: string;
        /**
         * Default: yes
         *
         * Trigger hook on push events
         */
        push_events?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Personal access token to use. One of private_token or access_token is required. See https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html
         */
        private_token?: string;
        /**
         * Default: no
         *
         * Trigger hook on merge requests events
         */
        merge_requests_events?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Trigger hook on pipeline events
         */
        pipeline_events?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Trigger hook on wiki events
         */
        wiki_page_events?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * GitLab API url, e.g. https://gitlab.example.com/api
         */
        api_url: string;
        [k: string]: unknown;
      };
      /**
       * This module allows you to work with port channel related configurations. The operators used are overloaded to ensure control over switch port channel configurations. Apart from the regular device connection related attributes, there are five LAG arguments which are overloaded variables that will perform further configurations. They are interfaceArg1, interfaceArg2, interfaceArg3, interfaceArg4, and interfaceArg5. For more details on how to use these arguments, see[Overloaded Variables]. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run.
       */
      cnos_portchannel?: {
        username?: string;
        password?: string;
        outputfile: string;
        host?: string;
        deviceType: string;
        /**
         * This specifies the interface range in which the port channel is envisaged
         */
        interfaceRange?: string;
        /**
         * This is an overloaded Port Channel fourth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg4?: string;
        /**
         * This is an overloaded Port Channel fifth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg5?: string;
        /**
         * This is an overloaded Port Channel sixth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg6?: string;
        /**
         * This is an overloaded Port Channel seventh argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg7?: string;
        enablePassword?: string;
        /**
         * This is an overloaded Port Channel first argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg1: string;
        /**
         * This is an overloaded Port Channel second argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg2?: string;
        /**
         * This is an overloaded Port Channel third argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg3?: string;
        [k: string]: unknown;
      };
      /**
       * Create, destroy, or update volumes on SolidFire
       */
      sf_volume_manager?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage AAA user certificates on Cisco ACI fabrics.
       */
      aci_aaa_user_certificate?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage switch policy leaf profiles on Cisco ACI fabrics.
       */
      aci_switch_policy_leaf_profile?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * This module provides declarative management of node system attributes on network devices.  It provides an option to configure host system parameters or remove those parameters from the device active configuration.
       */
      net_system?: {
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * State of the configuration values in the device's current active configuration.  When set to I(present), the values should be configured in the device active configuration and when set to I(absent) the values should not be in the device active configuration
         */
        state?: "present" | "absent";
        name?: string;
        vlan_id?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages configuration of an OSPF interface instanceon HUAWEI CloudEngine switches.
       */
      ce_interface_ospf?: {
        /**
         * Specifies the authentication type.
         */
        auth_mode?: "none" | "null" | "hmac-sha256" | "md5" | "hmac-md5" | "simple";
        /**
         * Specifies a password for simple authentication. The value is a string of 1 to 8 characters.
         */
        auth_text_simple?: string;
        /**
         * The cost associated with this interface. Valid values are an integer in the range from 1 to 65535.
         */
        cost?: string;
        /**
         * Time between sending successive hello packets. Valid values are an integer in the range from 1 to 65535.
         */
        hello_interval?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Ospf area associated with this ospf process. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer between 1 and 4294967295.
         */
        area: string;
        /**
         * Authentication key id when C(auth_mode) is 'hmac-sha256', 'md5' or 'hmac-md5. Valid value is an integer is in the range from 1 to 255.
         */
        auth_key_id?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        host?: string;
        /**
         * Specifies a process ID. The value is an integer ranging from 1 to 4294967295.
         */
        process_id: string;
        /**
         * Full name of interface, i.e. 40GE1/0/10.
         */
        interface: string;
        password?: string;
        ssh_keyfile?: string;
        /**
         * Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer in the range from 1 to 235926000.
         */
        dead_interval?: string;
        /**
         * Default: no
         *
         * Setting to true will prevent this interface from receiving HELLO packets. Valid values are 'true' and 'false'.
         */
        silent_interface?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        timeout?: number | string;
        /**
         * Specifies a password for MD5, HMAC-MD5, or HMAC-SHA256 authentication. The value is a string of 1 to 255 case-sensitive characters, spaces not supported.
         */
        auth_text_md5?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module creates and manages CloudWatch event rules and targets.
       */
      cloudwatchevent_rule?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows users to manage their objects/buckets in Google Cloud Storage.  It allows upload and download operations and can set some canned permissions. It also allows retrieval of URLs for objects for use in playbooks, and retrieval of string contents of objects.  This module requires setting the default project in GCS prior to playbook usage.  See U(https://developers.google.com/storage/docs/reference/v1/apiversion1) for information about setting the default project.
       */
      gc_storage?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of priority flow control (PFC) on interfaces of Mellanox ONYX network devices.
       */
      onyx_pfc_interface?: {
        /**
         * Purge interfaces not defined in the aggregate parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of interfaces PFC should be configured on.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: enabled
         *
         * State of the PFC configuration.
         */
        state?: "enabled" | "disabled";
        /**
         * Name of the interface PFC should be configured on.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manage LLDP interface policies on Cisco ACI fabrics.
       */
      aci_interface_policy_lldp?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Manage the state of a policy in RabbitMQ.
       */
      rabbitmq_policy?: {
        /**
         * Default: rabbit
         *
         * Erlang node name of the rabbit we wish to configure.
         */
        node?: string;
        /**
         * The name of the policy to manage.
         */
        name: string;
        /**
         * A dict or string describing the policy.
         */
        tags: {
          [k: string]: unknown;
        };
        /**
         * A regex of queues to apply the policy to.
         */
        pattern: string;
        /**
         * The priority of the policy.
         */
        priority?: string;
        /**
         * Default: /
         *
         * The name of the vhost to apply to.
         */
        vhost?: string;
        /**
         * Default: present
         *
         * The state of the policy.
         */
        state?: "present" | "absent";
        /**
         * Default: all
         *
         * What the policy applies to. Requires RabbitMQ 3.2.0 or later.
         */
        apply_to?: "all" | "exchanges" | "queues";
        [k: string]: unknown;
      };
      /**
       * Gets various details related to Route53 zone, record set or health check details
       */
      route53_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or Delete a network VLAN
       */
      na_ontap_net_vlan?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Similar to the kubectl scale command. Use to set the number of replicas for a Deployment, ReplicatSet, or Replication Controller, or the parallelism attribute of a Job. Supports check mode.
       */
      k8s_scale?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or delete a Rackspace Cloud Monitoring notification plan by associating existing rax_mon_notifications with severity levels. Rackspace monitoring module flow | rax_mon_entity -> rax_mon_check -> rax_mon_notification -> *rax_mon_notification_plan* -> rax_mon_alarm
       */
      rax_mon_notification_plan?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage BIG-IP module provisioning. This module will only provision at the standard levels of Dedicated, Nominal, and Minimum.
       */
      bigip_provision?: {
        /**
         * Default: present
         *
         * The state of the provisioned module on the system. When C(present), guarantees that the specified module is provisioned at the requested level provided that there are sufficient resources on the device (such as physical RAM) to support the provisioned module. When C(absent), de-provision the module.
         */
        state?: string;
        /**
         * The module to provision in BIG-IP.
         */
        module?: string;
        /**
         * Default: nominal
         *
         * Sets the provisioning level for the requested modules. Changing the level for one module may require modifying the level of another module. For example, changing one module to C(dedicated) requires setting all others to C(none). Setting the level of a module to C(none) means that the module is not activated.
         * This parameter is not relevant to C(cgnat) and will not be applied to the C(cgnat) module.
         */
        level?: string;
        [k: string]: unknown;
      };
      /**
       * Manage cache clusters in Amazon Elasticache.
       * Returns information about the specified cache cluster.
       */
      elasticache?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Apstra AOS Rack Type module let you manage your Rack Type easily. You can create create and delete Rack Type by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.
       */
      aos_rack_type?: {
        /**
         * Datastructure of the Rack Type to create. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).
         */
        content?: string;
        /**
         * Default: present
         *
         * Indicate what is the expected state of the Rack Type (present or not).
         */
        state?: "present" | "absent";
        /**
         * An existing AOS session as obtained by M(aos_login) module.
         */
        session: {
          [k: string]: unknown;
        };
        /**
         * AOS Id of the Rack Type to manage (can't be used to create a new Rack Type), Only one of I(name), I(id) or I(content) can be set.
         */
        id?: string;
        /**
         * Name of the Rack Type to manage. Only one of I(name), I(id) or I(content) can be set.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Install new images on a BIG-IP.
       */
      bigip_software_install?: {
        [k: string]: unknown;
      };
      /**
       * Add or remove an APT repositories in Ubuntu and Debian.
       */
      apt_repository?: {
        [k: string]: unknown;
      };
      /**
       * VPN tunnel resource.
       */
      gcp_compute_vpn_tunnel?: {
        /**
         * Default: 2
         *
         * IKE protocol version to use when establishing the VPN tunnel with peer VPN gateway.
         * Acceptable IKE versions are 1 or 2. Default version is 2.
         */
        ike_version?: number | string;
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Remote traffic selector to use when establishing the VPN tunnel with peer VPN gateway. The value should be a CIDR formatted string, for example `192.168.0.0/16`. The ranges should be disjoint.
         * Only IPv4 is supported.
         */
        remote_traffic_selector?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * An optional description of this resource.
         */
        description?: string;
        service_account_email?: string;
        /**
         * The region where the tunnel is located.
         */
        region: string;
        /**
         * Labels to apply to this VpnTunnel.
         */
        labels?: {
          [k: string]: unknown;
        };
        /**
         * IP address of the peer VPN gateway. Only IPv4 is supported.
         */
        peer_ip: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * URL of the Target VPN gateway with which this VPN tunnel is associated.
         */
        target_vpn_gateway: {
          [k: string]: unknown;
        };
        /**
         * Shared secret used to set the secure session between the Cloud VPN gateway and the peer VPN gateway.
         */
        shared_secret: string;
        /**
         * URL of router resource to be used for dynamic routing.
         */
        router?: string;
        service_account_file?: string;
        /**
         * Local traffic selector to use when establishing the VPN tunnel with peer VPN gateway. The value should be a CIDR formatted string, for example `192.168.0.0/16`. The ranges should be disjoint.
         * Only IPv4 is supported.
         */
        local_traffic_selector?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * Name of the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * The BucketAccessControls resource represents the Access Control Lists (ACLs) for buckets within Google Cloud Storage. ACLs let you specify who has access to your data and to what extent.
       * There are three roles that can be assigned to an entity:  READERs can get the bucket, though no acl property will be returned, and list the bucket's objects.  WRITERs are READERs, and they can insert objects into the bucket and delete the bucket's objects.  OWNERs are WRITERs, and they can get the acl property of a bucket, update a bucket, and call all BucketAccessControls methods on the bucket.  For more information, see Access Control, with the caveat that this API uses READER, WRITER, and OWNER instead of READ, WRITE, and FULL_CONTROL.
       */
      gcp_storage_bucket_access_control?: {
        /**
         * The project team associated with the entity.
         */
        project_team?: {
          [k: string]: unknown;
        };
        /**
         * The ID for the entity.
         */
        entity_id?: string;
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * The name of the bucket.
         */
        bucket: {
          [k: string]: unknown;
        };
        /**
         * The entity holding the permission, in one of the following forms: user-userId user-email group-groupId group-email domain-domain project-team-projectId allUsers allAuthenticatedUsers Examples: The user liz@example.com would be user-liz@example.com.
         * The group example@googlegroups.com would be   group-example@googlegroups.com.
         * To refer to all members of the Google Apps for Business domain   example.com, the entity would be domain-example.com.
         */
        entity: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * The access permission for the entity.
         */
        role?: "OWNER" | "READER" | "WRITER";
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Create, update or delete ECS container instance attributes.
       */
      ecs_attribute?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Represents an Instance Group resource. Instance groups are self-managed and can contain identical or different instances. Instance groups do not use an instance template. Unlike managed instance groups, you must create and add instances to an instance group manually.
       */
      gcp_compute_instance_group?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: string;
        /**
         * A reference to the zone where the instance group resides.
         */
        zone: string;
        service_account_email?: string;
        /**
         * The region where the instance group is located (for regional resources).
         */
        region?: string;
        project?: string;
        /**
         * Assigns a name to a port number.
         * For example: {name: "http", port: 80}.
         * This allows the system to reference ports by the assigned name instead of a port number. Named ports can also contain multiple ports.
         * For example: [{name: "http", port: 80},{name: "http", port: 8080}]  Named ports apply to all instances in this instance group.
         */
        named_ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * The subnetwork to which all instances in the instance group belong.
         */
        subnetwork?: {
          [k: string]: unknown;
        };
        /**
         * The network to which all instances in the instance group belong.
         */
        network?: {
          [k: string]: unknown;
        };
        /**
         * The name of the instance group.
         * The name must be 1-63 characters long, and comply with RFC1035.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Add, modify and delete an IPA host using IPA API
       */
      ipa_host?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Provides an interface to manage Logical Interconnect Group resources. Can create, update, or delete.
       */
      oneview_logical_interconnect_group?: {
        username?: string;
        image_streamer_hostname?: string;
        hostname?: string;
        config?: string;
        validate_etag?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Indicates the desired state for the Logical Interconnect Group resource. C(absent) will remove the resource from OneView, if it exists. C(present) will ensure data properties are compliant with OneView.
         */
        state?: "absent" | "present";
        password?: string;
        /**
         * List with the Logical Interconnect Group properties.
         */
        data: {
          [k: string]: unknown;
        };
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Ensure that a Windows Server 2012+ host is configured as a domain controller or demoted to member server. This module may require subsequent use of the M(win_reboot) action if changes are made.
       */
      win_domain_controller?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Upload files to a vCenter datastore
       */
      vsphere_copy?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Controls services on remote hosts. Supported init systems include BSD init, OpenRC, SysV, Solaris SMF, systemd, upstart.
       * For Windows targets, use the M(win_service) module instead.
       */
      service?: {
        [k: string]: unknown;
      };
      /**
       * Create, delete an autoscale setting.
       */
      azure_rm_autoscale?: {
        /**
         * resource group of the resource.
         */
        resource_group: string;
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        /**
         * location of the resource.
         */
        location?: string;
        subscription_id?: string;
        profile?: string;
        tags?: {
          [k: string]: unknown;
        };
        /**
         * the collection of notifications.
         */
        notifications?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Assert the state of the virtual network. Use 'present' to create or update and 'absent' to delete.
         */
        state?: "present" | "absent";
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        tenant?: string;
        /**
         * The identifier of the resource to apply autoscale setting.
         * It could be the resource id string.
         * It also could be a dict contains the C(name), C(subscription_id), C(namespace), C(types), C(resource_group) of the resource.
         */
        target?: string;
        /**
         * name of the resource.
         */
        name: string;
        /**
         * Default: True
         *
         * Specifies whether automatic scaling is enabled for the resource.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The collection of automatic scaling profiles that specify different scaling parameters for different time periods.
         * A maximum of 20 profiles can be specified.
         */
        profiles?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP TargetSslProxy
       */
      gcp_compute_target_ssl_proxy_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Create, update, or destroy Ansible Tower workflows. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_workflow_template?: {
        /**
         * The description to use for the workflow.
         */
        description?: string;
        /**
         * If enabled, simultaneous runs of this job template will be allowed.
         */
        allow_simultaneous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Extra variables used by Ansible in YAML or key=value format.
         *
         */
        extra_vars?: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * The definition of the survey associated to the workflow.
         */
        survey?: string;
        tower_password?: string;
        tower_username?: string;
        /**
         * The organization the workflow is linked to.
         */
        organization?: string;
        /**
         * The schema is a JSON- or YAML-formatted string defining the hierarchy structure that connects the nodes. Refer to Tower documentation for more information.
         *
         */
        schema?: string;
        tower_host?: string;
        /**
         * Setting that variable will prompt the user for job type on the workflow launch.
         */
        survey_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name to use for the workflow.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module allows the management of AWS Batch Job Definitions. It is idempotent and supports "Check" mode.  Use module M(aws_batch_compute_environment) to manage the compute environment, M(aws_batch_job_queue) to manage job queues, M(aws_batch_job_definition) to manage job definitions.
       */
      aws_batch_job_definition?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about a one or more OpenStack projects
       */
      os_project_facts?: {
        /**
         * Name or ID of the domain containing the project if the cloud supports domains
         */
        domain?: string;
        /**
         * Name or ID of the project
         */
        name?: string;
        /**
         * A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
         */
        filters?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * creates / deletes a Rackspace Public Cloud isolated network.
       */
      rax_network?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Adds and/or removes instances of SRV record objects from Infoblox NIOS servers.  This module manages NIOS C(record:srv) objects using the Infoblox WAPI interface over REST.
       */
      nios_srv_record?: {
        [k: string]: unknown;
      };
      /**
       * Manages AAA server host configuration on HUAWEI CloudEngine switches.
       */
      ce_aaa_server_host?: {
        /**
         * Configured server port for a particular server. The value is an integer ranging from 1 to 65535.
         */
        radius_server_port?: string;
        /**
         * Server IPv6 address. Must be a valid unicast IP address. The total length is 128 bits.
         */
        hwtacacs_server_ipv6?: string;
        /**
         * The type of local user login through, such as ftp ssh snmp telnet.
         */
        local_service_type?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * IPv6 address of configured server. The total length is 128 bits.
         */
        radius_server_ipv6?: string;
        /**
         * Type of Radius Server.
         */
        radius_server_type?: "Authentication" | "Accounting";
        transport?: "cli" | "netconf";
        /**
         * Server IPv4 address. Must be a valid unicast IP address. The value is a string of 0 to 255 characters, in dotted decimal notation.
         */
        hwtacacs_server_ip?: string;
        /**
         * Name of the user group where the user belongs. The user inherits all the rights of the user group. The value is a string of 1 to 32 characters.
         */
        local_user_group?: string;
        /**
         * Login level of a local user. The value is an integer ranging from 0 to 15.
         */
        local_user_level?: string;
        /**
         * Set VPN instance. The value is a string of 1 to 31 case-sensitive characters.
         */
        radius_vpn_name?: string;
        /**
         * VPN instance name.
         */
        hwtacacs_vpn_name?: string;
        /**
         * Hwtacacs server host name.
         */
        hwtacacs_server_host_name?: string;
        port?: number | string;
        /**
         * Login password of a user. The password can contain letters, numbers, and special characters. The value is a string of 1 to 255 characters.
         */
        local_password?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Name of a local user. The value is a string of 1 to 253 characters.
         */
        local_user_name?: string;
        /**
         * IPv4 address of configured server. The value is a string of 0 to 255 characters, in dotted decimal notation.
         */
        radius_server_ip?: string;
        username?: string;
        /**
         * Hostname of configured server. The value is a string of 0 to 255 case-sensitive characters.
         */
        radius_server_name?: string;
        host?: string;
        /**
         * Configured primary or secondary server for a particular server.
         */
        radius_server_mode?: "Secondary-server" | "Primary-server";
        /**
         * Hwtacacs server type.
         */
        hwtacacs_server_type?: "Authentication" | "Authorization" | "Accounting" | "Common";
        password?: string;
        ssh_keyfile?: string;
        /**
         * FTP user directory. The value is a string of 1 to 255 characters.
         */
        local_ftp_dir?: string;
        /**
         * RADIUS server group's name. The value is a string of 1 to 32 case-insensitive characters.
         */
        radius_group_name?: string;
        /**
         * Name of a HWTACACS template. The value is a string of 1 to 32 case-insensitive characters.
         */
        hwtacacs_template?: string;
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Whether the server is secondary.
         */
        hwtacacs_is_secondary_server?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Set the public-net.
         */
        hwtacacs_is_public_net?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Use variables to create new hosts and groups in inventory for use in later plays of the same playbook. Takes variables so you can define the new hosts more fully.
       * This module is also supported for Windows targets.
       */
      add_host?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage limits of resources for domains, accounts and projects.
       */
      cs_resourcelimit?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Gather facts for GCP Subnetwork
       */
      gcp_compute_subnetwork_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * URL of the GCP region for this subnetwork.
         */
        region: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        service_account_file?: string;
        [k: string]: unknown;
      };
      /**
       * Manages global VPC configuration
       */
      nxos_vpc?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * VPC domain
         */
        domain: string;
        /**
         * Default: management
         *
         * VRF used for peer keepalive link
         */
        pkl_vrf?: string;
        /**
         * manages delay restore command and config value in seconds
         */
        delay_restore?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        /**
         * Enables/Disables peer gateway
         */
        peer_gw?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        auth_pass?: string;
        /**
         * Manages desired state of the resource
         */
        state?: "present" | "absent";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Destination (remote) IP address used for peer keepalive link
         */
        pkl_dest?: string;
        /**
         * Source IP address used for peer keepalive link
         */
        pkl_src?: string;
        username?: string;
        /**
         * Enables/Disables auto recovery
         */
        auto_recovery?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        password?: string;
        ssh_keyfile?: string;
        /**
         * System priority device.  Remember they must match between peers.
         */
        system_priority?: string;
        /**
         * Role priority for device. Remember lower is better.
         */
        role_priority?: string;
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module manages the members of an existing storage group.
       */
      emc_vnx_sg_member?: {
        sp_password?: string;
        /**
         * Name of the Storage group to manage.
         */
        name: string;
        sp_user?: string;
        sp_address: string;
        /**
         * Default: present
         *
         * Indicates the desired lunid state.
         * C(present) ensures specified lunid is present in the Storage Group.
         * C(absent) ensures specified lunid is absent from Storage Group.
         */
        state?: "present" | "absent";
        /**
         * Lun id to be added.
         */
        lunid: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages remote roles on a BIG-IP. Remote roles are used in situations where user authentication is handled off-box. Local access control to the BIG-IP is controlled by the defined remote role. Where-as authentication (and by extension, assignment to the role) is handled off-box.
       */
      bigip_remote_role?: {
        [k: string]: unknown;
      };
      /**
       * Create, start, stop and delete Solaris zones. This module doesn't currently allow changing of options for a zone that's already been created.
       */
      solaris_zone?: {
        /**
         * Default: empty string
         *
         * Extra options to the zoneadm(1M) install command. To automate Solaris 11 zone creation, use this to specify the profile XML file, e.g. install_options="-c sc_profile.xml"
         */
        install_options?: string;
        /**
         * Default: 600
         *
         * Timeout, in seconds, for zone to boot.
         */
        timeout?: number | string;
        /**
         * Default: empty string
         *
         * Extra options to the zonecfg(1M) create command.
         */
        create_options?: string;
        /**
         * Default: present
         *
         * C(present), configure and install the zone.
         * C(installed), synonym for C(present).
         * C(running), if the zone already exists, boot it, otherwise, configure and install the zone first, then boot it.
         * C(started), synonym for C(running).
         * C(stopped), shutdown a zone.
         * C(absent), destroy the zone.
         * C(configured), configure the ready so that it's to be attached.
         * C(attached), attach a zone, but do not boot it.
         * C(detached), shutdown and detach a zone
         */
        state?:
          | "absent"
          | "attached"
          | "configured"
          | "detached"
          | "installed"
          | "present"
          | "running"
          | "started"
          | "stopped";
        /**
         * The password hash for the root account. If not specified, the zone's root account will not have a password.
         */
        root_password?: string;
        /**
         * Default: no
         *
         * Whether to create a sparse (C(true)) or whole root (C(false)) zone.
         */
        sparse?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The path where the zone will be created. This is required when the zone is created, but not used otherwise.
         */
        path?: string;
        /**
         * Default: empty string
         *
         * The zonecfg configuration commands for this zone. See zonecfg(1M) for the valid options and syntax. Typically this is a list of options separated by semi-colons or new lines, e.g. "set auto-boot=true;add net;set physical=bge0;set address=10.1.1.1;end"
         */
        config?: string;
        /**
         * Default: empty string
         *
         * Extra options to the zoneadm attach command. For example, this can be used to specify whether a minimum or full update of packages is required and if any packages need to be deleted. For valid values, see zoneadm(1M)
         */
        attach_options?: string;
        /**
         * Zone name.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Creates, modifies or removes groups in Active Directory.
       * For local groups, use the M(win_group) module instead.
       */
      win_domain_group?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Get facts for a Azure specific Traffic Manager profile or all Traffic Manager profiles.
       */
      azure_rm_trafficmanagerprofile_facts?: {
        profile?: string;
        /**
         * Limit results to a specific Traffic Manager profile.
         */
        name?: string;
        /**
         * The resource group to search for the desired Traffic Manager profile
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Allows for creation, management, and visibility into organizations within Meraki.
       */
      meraki_organization?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage HTTP profiles on a BIG-IP.
       */
      bigip_profile_http?: {
        [k: string]: unknown;
      };
      /**
       * Migrates a virtual machine from a standard vswitch to distributed
       */
      vmware_vm_vss_dvs_migrate?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage VLAN pools on Cisco ACI fabrics.
       */
      aci_vlan_pool?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manages F5 BIG-IP GTM http monitors.
       */
      bigip_gtm_monitor_http?: {
        /**
         * Default: always
         *
         * C(always) will update passwords if the C(target_password) is specified.
         * C(on_create) will only set the password for newly created monitors.
         */
        update_password?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Instructs the system to mark the target resource down when the test is successful. This setting is useful, for example, if the content on your web site home page is dynamic and changes frequently, you may want to set up a reverse ECV service check that looks for the string Error.
         * A match for this string means that the web server was down.
         * To use this option, you must specify values for C(send) and C(receive).
         */
        reverse?: string;
        /**
         * Default: /Common/http
         *
         * The parent template of this monitor template. Once this value has been set, it cannot be changed. By default, this value is the C(tcp) parent on the C(Common) partition.
         */
        parent?: string;
        /**
         * The receive string for the monitor call.
         */
        receive?: string;
        /**
         * IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
         * If this value is an IP address, then a C(port) number must be specified.
         */
        ip?: string;
        /**
         * The interval specifying how frequently the monitor instance of this template will run.
         * If this parameter is not provided when creating a new monitor, then the default value will be 30.
         * This value B(must) be less than the C(timeout) value.
         */
        interval?: string;
        /**
         * The send string for the monitor call.
         * When creating a new monitor, if this parameter is not provided, the default of C(GET /\r\n) will be used.
         */
        send?: string;
        /**
         * Specifies the user name, if the monitored target requires authentication.
         */
        target_username?: string;
        /**
         * Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
         */
        port?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the monitor exists.
         * When C(absent), ensures the monitor is removed.
         */
        state?: string;
        /**
         * Specifies that the monitor allows more than one probe attempt per interval.
         * When C(yes), specifies that the monitor ignores down responses for the duration of the monitor timeout. Once the monitor timeout is reached without the system receiving an up response, the system marks the object down.
         * When C(no), specifies that the monitor immediately marks an object down when it receives a down response.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(no).
         */
        ignore_down_response?: string;
        /**
         * The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second.
         * If this parameter is not provided when creating a new monitor, then the default value will be 120.
         */
        timeout?: string;
        /**
         * Specifies the password, if the monitored target requires authentication.
         */
        target_password?: string;
        /**
         * Specifies the number of seconds after which the system times out the probe request to the system.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(5).
         */
        probe_timeout?: string;
        /**
         * Specifies whether the monitor operates in transparent mode.
         * A monitor in transparent mode directs traffic through the associated pool members or nodes (usually a router or firewall) to the aliased destination (that is, it probes the C(ip)-C(port) combination specified in the monitor).
         * If the monitor cannot successfully reach the aliased destination, the pool member or node through which the monitor traffic was sent is marked down.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(no).
         */
        transparent?: string;
        /**
         * Monitor name.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows you to copy the running configuration of a switch over its startup configuration. It is recommended to use this module shortly after any major configuration changes so they persist after a switch restart. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run.
       */
      cnos_save?: {
        username?: string;
        outputfile: string;
        host?: string;
        deviceType: string;
        password?: string;
        enablePassword?: string;
        [k: string]: unknown;
      };
      /**
       * PanOS module that allows changes to the user account passwords by doing API calls to the Firewall using pan-api as the protocol.
       */
      panos_admin?: {
        username?: string;
        /**
         * Default: admin
         *
         * username for admin user
         */
        admin_username?: string;
        /**
         * role for admin user
         */
        role?: string;
        /**
         * password for admin user
         */
        admin_password?: string;
        /**
         * Default: yes
         *
         * commit if changed
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        ip_address?: string;
        [k: string]: unknown;
      };
      /**
       * Configures vNIC templates on Cisco UCS Manager.
       * Examples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).
       */
      ucs_vnic_template?: {
        /**
         * Default: none
         *
         * The Redundancy Type used for vNIC redundancy pairs during fabric failover.
         * This can be one of the following:
         * primary  Creates configurations that can be shared with the Secondary template.
         * secondary  All shared configurations are inherited from the Primary template.
         * none - Legacy vNIC template behavior. Select this option if you do not want to use redundancy.
         */
        redundancy_type?: string;
        /**
         * A user-defined description of the vNIC template.
         * Enter up to 256 characters.
         * You can use any characters or spaces except the following:
         * ` (accent mark),  (backslash), ^ (carat), " (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).
         */
        description?: string;
        /**
         * Default: default
         *
         * The statistics collection policy that vNICs created from this vNIC template should use.
         */
        stats_policy?: string;
        /**
         * The network control policy that vNICs created from this vNIC template should use.
         */
        network_control_policy?: string;
        /**
         * List of VLANs used by the vNIC template.
         * Each list element has the following suboptions:
         * = name
         *   The name of the VLAN (required).
         * - native
         *   Designates the VLAN as a native VLAN.  Only one VLAN in the list can be a native VLAN.
         *   [choices: 'no', 'yes']
         *   [Default: 'no']
         * - state
         *   If present, will verify VLAN is present on template.
         *   If absent, will verify VLAN is absent on template.
         *   choices: [present, absent]
         *   default: present
         */
        vlans_list?: string;
        /**
         * Default: org-root
         *
         * Org dn (distinguished name)
         */
        org_dn?: string;
        /**
         * The Peer Redundancy Template.
         * The name of the vNIC template sharing a configuration with this template.
         * If the redundancy_type is primary, the name of the secondary template should be provided.
         * If the redundancy_type is secondary, the name of the primary template should be provided.
         * Secondary templates can only configure non-shared properties (name, description, and mac_pool).
         */
        peer_redundancy_template?: string;
        /**
         * The name of the vNIC template.
         * This name can be between 1 and 16 alphanumeric characters.
         * You cannot use spaces or any special characters other than - (hyphen), "_" (underscore), : (colon), and . (period).
         * You cannot change this name after the template is created.
         */
        name?: string;
        /**
         * Default: initial-template
         *
         * The Template Type field.
         * This can be one of the following:
         * initial-template  vNICs created from this template are not updated if the template changes.
         * updating-template - vNICs created from this template are updated if the template changes.
         */
        template_type?: string;
        /**
         * Default: present
         *
         * If C(present), will verify vNIC templates are present and will create if needed.
         * If C(absent), will verify vNIC templates are absent and will delete if needed.
         */
        state?: string;
        /**
         * Default: A
         *
         * The Fabric ID field specifying the fabric interconnect associated with vNICs created from this template.
         * If you want fabric failover enabled on vNICs created from this template, use of of the following:"
         * A-B to use Fabric A by default with failover enabled.
         * B-A to use Fabric B by default with failover enabled.
         * Do not enable vNIC fabric failover under the following circumstances:
         * - If the Cisco UCS domain is running in Ethernet switch mode. vNIC fabric failover is not supported in that mode.
         * - If you plan to associate one or more vNICs created from this template to a server with an adapter that does not support fabric failover.
         */
        fabric?: string;
        /**
         * The MAC address pool that vNICs created from this vNIC template should use.
         */
        mac_pool?: string;
        /**
         * Default: adapter
         *
         * The possible target for vNICs created from this template.
         * The target determines whether or not Cisco UCS Manager automatically creates a VM-FEX port profile with the appropriate settings for the vNIC template.
         * This can be one of the following:
         * adapter  The vNICs apply to all adapters. No VM-FEX port profile is created if you choose this option.
         * vm - The vNICs apply to all virtual machines. A VM-FEX port profile is created if you choose this option.
         */
        target?: string;
        /**
         * The LAN pin group that vNICs created from this vNIC template should use.
         */
        pin_group?: string;
        /**
         * Default: vnic-name
         *
         * CDN Source field.
         * This can be one of the following options:
         * vnic-name - Uses the vNIC template name of the vNIC instance as the CDN name. This is the default option.
         * user-defined - Uses a user-defined CDN name for the vNIC template. If this option is chosen, cdn_name must also be provided.
         */
        cdn_source?: string;
        /**
         * The quality of service (QoS) policy that vNICs created from this vNIC template should use.
         */
        qos_policy?: string;
        /**
         * Default: 1500
         *
         * The MTU field.
         * The maximum transmission unit, or packet size, that vNICs created from this vNIC template should use.
         * Enter a string between '1500' and '9000'.
         * If the vNIC template has an associated QoS policy, the MTU specified here must be equal to or less than the MTU specified in the QoS system class.
         */
        mtu?: string;
        /**
         * CDN Name used when cdn_source is set to user-defined.
         */
        cdn_name?: string;
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific resource group or all resource groups.
       */
      azure_rm_resourcegroup_facts?: {
        profile?: string;
        /**
         * Limit results to a specific resource group.
         */
        name?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Manipulate remote syslog settings on a BIG-IP.
       */
      bigip_remote_syslog?: {
        /**
         * Default: present
         *
         * When C(present), guarantees that the remote syslog exists with the provided attributes.
         * When C(absent), removes the remote syslog from the system.
         */
        state?: string;
        /**
         * Specifies the local IP address of the system that is logging. To provide no local IP, specify the value C(none). When creating a remote syslog, if this parameter is not specified, the default value C(none) is used.
         */
        local_ip?: string;
        /**
         * Specifies the IP address, or hostname, for the remote system to which the system sends log messages.
         */
        remote_host?: string;
        /**
         * Specifies the port that the system uses to send messages to the remote logging server. When creating a remote syslog, if this parameter is not specified, the default value C(514) is used.
         */
        remote_port?: string;
        [k: string]: unknown;
      };
      /**
       * Manages Citrix NetScaler server and service entities.
       */
      netscaler?: {
        /**
         * Default: hostname
         *
         * Name of the entity.
         */
        name?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates for the target url will not be validated.
         * This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: https
         *
         * Protocol used to access netscaler.
         */
        nsc_protocol?: string;
        /**
         * Hostname or ip of your netscaler.
         */
        nsc_host: string;
        /**
         * Username.
         */
        user: string;
        /**
         * Default: disable
         *
         * The action you want to perform on the entity.
         */
        action?: "disable" | "enable";
        /**
         * Password.
         */
        password: string;
        /**
         * Default: server
         *
         * Type of the entity.
         */
        type?: "server" | "service";
        [k: string]: unknown;
      };
      /**
       * Run system-cli commands on ONTAP
       */
      na_ontap_command?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Creates and deletes Azure DNS zones.
       */
      azure_rm_dnszone?: {
        profile?: string;
        /**
         * name of the DNS Zone.
         */
        name: string;
        /**
         * name of resource group.
         */
        resource_group: string;
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        /**
         * Default: present
         *
         * Assert the state of the zone. Use 'present' to create or update and 'absent' to delete.
         */
        state?: "absent" | "present";
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Sends an arbitrary set of commands to an JUNOS node and returns the results read from the device.  This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      junos_command?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Module to manage virtual machine templates in oVirt/RHV.
       */
      ovirt_template?: {
        [k: string]: unknown;
      };
      /**
       * Enables or disables a specified module of the Apache2 webserver.
       */
      apache2_module?: {
        /**
         * Default: present
         *
         * Desired state of the module.
         */
        state?: "present" | "absent";
        /**
         * Identifier of the module as listed by C(apache2ctl -M). This is optional and usually determined automatically by the common convention of appending C(_module) to I(name) as well as custom exception for popular modules.
         */
        identifier?: string;
        /**
         * Force disabling of default modules and override Debian warnings.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the module to enable/disable as given to C(a2enmod/a2dismod).
         */
        name: string;
        /**
         * Ignore configuration checks about inconsistent module configuration. Especially for mpm_* modules.
         */
        ignore_configcheck?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Management of LXC containers
       */
      lxc_container?: {
        /**
         * Create zfs under given zfsroot.
         */
        zfs_root?: string;
        /**
         * Default: no
         *
         * Name of the new cloned server. This is only used when state is clone.
         */
        clone_name?: string;
        /**
         * list of 'key=value' options to use when configuring a container.
         */
        container_config?: string;
        /**
         * Default: ext4
         *
         * Create fstype TYPE.
         */
        fs_type?: string;
        /**
         * Default: no
         *
         * Create an archive of a container. This will create a tarball of the running container.
         */
        archive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Enable a container log for host actions to the container.
         */
        container_log?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: started
         *
         * Define the state of a container. If you clone a container using `clone_name` the newly cloned container created in a stopped state. The running container will be stopped while the clone operation is happening and upon completion of the clone the original container state will be restored.
         */
        state?: "absent" | "restarted" | "started" | "clone" | "frozen" | "stopped";
        /**
         * Default: ubuntu
         *
         * Name of the template to use within an LXC create.
         */
        template?: string;
        /**
         * Path to the LXC configuration file.
         */
        config?: string;
        /**
         * Path the save the archived container. If the path does not exist the archive method will attempt to create it.
         */
        archive_path?: string;
        /**
         * Default: INFO
         *
         * Set the log level for a container where *container_log* was set.
         */
        container_log_level?: "info" | "INFO" | "Info" | "debug" | "DEBUG" | "Debug" | "error" | "ERROR" | "Error";
        /**
         * Template options when building the container.
         */
        template_options?: string;
        /**
         * Run a command within a container.
         */
        container_command?: string;
        /**
         * Place container under PATH
         */
        lxc_path?: string;
        /**
         * Default: gzip
         *
         * Type of compression to use when creating an archive of a running container.
         */
        archive_compression?: "gzip" | "bzip2" | "none";
        /**
         * Use LVM thin pool called TP.
         */
        thinpool?: string;
        /**
         * Default: no
         *
         * Create a snapshot a container when cloning. This is not supported by all container storage backends. Enabling this may fail if the backing store does not support snapshots.
         */
        clone_snapshot?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of a container.
         */
        name: string;
        /**
         * Default: $CONTAINER_NAME
         *
         * Name of the logical volume, defaults to the container name.
         */
        lv_name?: string;
        /**
         * Default: 5G
         *
         * File system Size.
         */
        fs_size?: string;
        /**
         * Default: dir
         *
         * Backend storage type for the container.
         */
        backing_store?: "dir" | "lvm" | "loop" | "btrfs" | "overlayfs" | "zfs";
        /**
         * Default: lxc
         *
         * If Backend store is lvm, specify the name of the volume group.
         */
        vg_name?: string;
        /**
         * Place rootfs directory under DIR.
         */
        directory?: string;
        [k: string]: unknown;
      };
      /**
       * Use to enable or disable eAPI access, and set the port and state of http, https, local_http and unix-socket servers.
       * When enabling eAPI access the default is to enable HTTP on port 80, enable HTTPS on port 443, disable local HTTP, and disable Unix socket server. Use the options listed below to override the default configuration.
       * Requires EOS v4.12 or greater.
       */
      eos_eapi?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates (empty) files, updates file modification stamps of existing files, and can create or remove directories.
       * Unlike M(file), does not modify ownership, permissions or manipulate links.
       * For non-Windows targets, use the M(file) module instead.
       */
      win_file?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about DigitalOcean provided tags.
       */
      digital_ocean_tag_facts?: {
        [k: string]: unknown;
      };
      /**
       * creates / deletes a Rackspace Public Cloud instance and optionally waits for it to be 'running'.
       */
      rax?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Acquires and associates a public IP to an account or project.
       * Due to API limitations this is not an idempotent call, so be sure to only conditionally call this when C(state=present).
       * Tagging the IP address can also make the call idempotent.
       */
      cs_ip_address?: {
        [k: string]: unknown;
      };
      /**
       * Manages interface specific VPN configuration of HUAWEI CloudEngine switches.
       */
      ce_vrf_interface?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * An interface that can binding VPN instance, i.e. 40GE1/0/22, Vlanif10. Must be fully qualified interface name. Interface types, such as 10GE, 40GE, 100GE, LoopBack, MEth, Tunnel, Vlanif....
         */
        vpn_interface: string;
        host?: string;
        /**
         * VPN instance, the length of vrf name is 1 ~ 31, i.e. "test", but can not be C(_public_).
         */
        vrf: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Gather facts about internet gateways in AWS.
       */
      ec2_vpc_igw_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Run Pester tests on Windows hosts.
       * Test files have to be available on the remote host.
       */
      win_pester?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Add or remove Zypper repositories on SUSE and openSUSE
       */
      zypper_repository?: {
        [k: string]: unknown;
      };
      /**
       * Obtain the AOS server session token by providing the required username and password credentials.  Upon successful authentication, this module will return the session-token that is required by all subsequent AOS module usage. On success the module will automatically populate ansible facts with the variable I(aos_session) This module is not idempotent and do not support check mode.
       */
      aos_login?: {
        /**
         * Default: admin
         *
         * Password to use when connecting to the AOS server.
         */
        passwd?: string;
        /**
         * Address of the AOS Server on which you want to open a connection.
         */
        server: string;
        /**
         * Default: 443
         *
         * Port number to use when connecting to the AOS server.
         */
        port?: number | string;
        /**
         * Default: admin
         *
         * Login username to use when connecting to the AOS server.
         */
        user?: string;
        [k: string]: unknown;
      };
      /**
       * Manage SPAN source groups on Cisco ACI fabrics.
       */
      aci_tenant_span_src_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Adds and/or removes instances of network view objects from Infoblox NIOS servers.  This module manages NIOS C(networkview) objects using the Infoblox WAPI interface over REST.
       * Updates instances of network view object from Infoblox NIOS servers.
       */
      nios_network_view?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Setting the Timestamp Format of Logs. Configuring the Device to Output Logs to the Log Buffer.
       */
      ce_info_center_log?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Specifies a log severity.
         */
        log_level?:
          | "emergencies"
          | "alert"
          | "critical"
          | "error"
          | "warning"
          | "notification"
          | "informational"
          | "debugging";
        /**
         * Specifies the name of a module. The value is a module name in registration logs.
         */
        module_name?: string;
        /**
         * Default: no_use
         *
         * Indicates whether log filtering is enabled.
         */
        log_enable?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * Enables the Switch to send logs to the log buffer.
         */
        log_buff_enable?: "no_use" | "true" | "false";
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * Specifies the maximum number of logs in the log buffer. The value is an integer that ranges from 0 to 10240. If logbuffer-size is 0, logs are not displayed.
         */
        log_buff_size?: string;
        /**
         * Specifies a channel ID. The value is an integer ranging from 0 to 9.
         */
        channel_id?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Sets the timestamp format of logs.
         */
        log_time_stamp?:
          | "date_boot"
          | "date_second"
          | "date_tenthsecond"
          | "date_millisecond"
          | "shortdate_second"
          | "shortdate_tenthsecond"
          | "shortdate_millisecond"
          | "formatdate_second"
          | "formatdate_tenthsecond"
          | "formatdate_millisecond";
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Manage ssl cerificate keys.
       */
      netscaler_ssl_certkey?: {
        /**
         * Issue an alert when the certificate is about to expire.
         */
        expirymonitor?: "enabled" | "disabled";
        nitro_protocol?: "http" | "https";
        /**
         * Pass phrase used to encrypt the private-key. Required when adding an encrypted private-key in PEM format.
         * Minimum length = 1
         */
        passplain?: string;
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nsip: string;
        /**
         * Input format of the certificate and the private-key files. The three formats supported by the appliance are:
         * PEM - Privacy Enhanced Mail
         * DER - Distinguished Encoding Rule
         * PFX - Personal Information Exchange.
         */
        inform?: "DER" | "PEM" | "PFX";
        /**
         * Name of and, optionally, path to the X509 certificate file that is used to form the certificate-key pair. The certificate file should be present on the appliance's hard-disk drive or solid-state drive. Storing a certificate in any location other than the default might cause inconsistency in a high availability setup. /nsconfig/ssl/ is the default path.
         * Minimum length = 1
         */
        cert?: string;
        state?: "present" | "absent";
        nitro_user: string;
        /**
         * Name of and, optionally, path to the private-key file that is used to form the certificate-key pair. The certificate file should be present on the appliance's hard-disk drive or solid-state drive. Storing a certificate in any location other than the default might cause inconsistency in a high availability setup. /nsconfig/ssl/ is the default path.
         * Minimum length = 1
         */
        key?: string;
        /**
         * Time, in number of days, before certificate expiration, at which to generate an alert that the certificate is about to expire.
         * Minimum value = C(10)
         * Maximum value = C(100)
         */
        notificationperiod?: number;
        /**
         * Name for the certificate and private-key pair. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the certificate-key pair is created.
         * The following requirement applies only to the NetScaler CLI:
         * If the name includes one or more spaces, enclose the name in double or single quotation marks (for example, "my cert" or 'my cert').
         * Minimum length = 1
         */
        certkey?: string;
        nitro_pass: string;
        /**
         * Passphrase that was used to encrypt the private-key. Use this option to load encrypted private-keys in PEM format.
         */
        password?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_timeout?: number;
        [k: string]: unknown;
      };
      /**
       * Provides Windows product information.
       */
      win_product_facts?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * The C(win_wakeonlan) module sends magic Wake-on-LAN (WoL) broadcast packets.
       */
      win_wakeonlan?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 7
         *
         * UDP port to use for magic Wake-on-LAN packet.
         */
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Module to manage external providers in oVirt/RHV
       */
      ovirt_external_provider?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create or destroy or modify(path) cifs-share on ONTAP
       */
      na_ontap_cifs?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Can create or delete AWS Autoscaling Configurations
       * Works with the ec2_asg module to manage Autoscaling Groups
       */
      ec2_lc?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * creates / deletes or resize a Rackspace Cloud Databases instance and optionally waits for it to be 'running'. The name option needs to be unique since it's used to identify the instance.
       */
      rax_cdb?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Runs one or more commands on remote devices running VyOS. This module can also be introspected to validate key parameters before returning successfully.
       */
      vyos_system?: {
        [k: string]: unknown;
      };
      /**
       * Each row in mysql_replication_hostgroups represent a pair of writer_hostgroup and reader_hostgroup. ProxySQL will monitor the value of read_only for all the servers in specified hostgroups, and based on the value of read_only will assign the server to the writer or reader hostgroups.
       */
      proxysql_replication_hostgroups?: {
        /**
         * Text field that can be used for any purposed defined by the user.
         */
        comment?: string;
        login_port?: number | string;
        /**
         * Id of the reader hostgroup.
         */
        reader_hostgroup: number | string;
        config_file?: string;
        login_user?: string;
        login_host?: string;
        login_password?: string;
        /**
         * Id of the writer hostgroup.
         */
        writer_hostgroup: number | string;
        login_unix_socket?: string;
        /**
         * Default: present
         *
         * When C(present) - adds the replication hostgroup, when C(absent) - removes the replication hostgroup.
         */
        state?: "present" | "absent";
        load_to_runtime?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        save_to_disk?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Sends an arbitrary command to an HUAWEI CloudEngine node and returns the results read from the device.  The ce_command module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      ce_command?: {
        username?: string;
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed.  The command is run on the target device every retry and evaluated against the I(wait_for) conditionals.
         */
        retries?: number | string;
        /**
         * The commands to send to the remote HUAWEI CloudEngine device over the configured provider.  The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ssh_keyfile?: string;
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command.  If the command does not pass the specified conditional, the interval indicates how to long to wait before trying the command again.
         */
        interval?: number | string;
        /**
         * Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the I(wait_for) must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: "any" | "all";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Creates AWS Direct Connect Gateway
       * Deletes AWS Direct Connect Gateway
       * Attaches Virtual Gateways to Direct Connect Gateway
       * Detaches Virtual Gateways to Direct Connect Gateway
       */
      aws_direct_connect_gateway?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update, disable, lock, enable and remove users.
       */
      cs_user?: {
        /**
         * Username of the user.
         */
        username: string;
        /**
         * If API keys of the user should be generated.
         * Note: Keys can not be removed by the API again.
         */
        keys_registered?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: ROOT
         *
         * Domain the user is related to.
         */
        domain?: string;
        /**
         * Last name of the user.
         * Required on C(state=present).
         */
        last_name?: string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Account the user will be created under.
         * Required on C(state=present).
         */
        account?: string;
        api_region?: string;
        api_key?: string;
        /**
         * Default: present
         *
         * State of the user.
         * C(unlocked) is an alias for C(enabled).
         */
        state?: "present" | "absent" | "enabled" | "disabled" | "locked" | "unlocked";
        /**
         * First name of the user.
         * Required on C(state=present).
         */
        first_name?: string;
        /**
         * Timezone of the user.
         */
        timezone?: string;
        /**
         * Password of the user to be created.
         * Required on C(state=present).
         * Only considered on creation and will not be updated if user exists.
         */
        password?: string;
        /**
         * Email of the user.
         * Required on C(state=present).
         */
        email?: string;
        [k: string]: unknown;
      };
      /**
       * The C(grove) module sends a message for a service to a Grove.io channel.
       */
      grove?: {
        /**
         * Default: ansible
         *
         * Name of the service (displayed as the "user" in the message)
         */
        service?: string;
        /**
         * Service URL for the web client
         */
        url?: string;
        /**
         * Icon for the service
         */
        icon_url?: string;
        /**
         * Token of the channel to post to.
         */
        channel_token: string;
        /**
         * Message content
         */
        message: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module is used to configure TrafficCloneProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_trafficcloneprofile?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Uuid of the traffic clone profile.
         * Field introduced in 17.1.1.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.1.1.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * It is a reference to an object of type cloud.
         * Field introduced in 17.1.1.
         */
        cloud_ref?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Field introduced in 17.1.1.
         */
        clone_servers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        /**
         * Specifies if client ip needs to be preserved to clone destination.
         * Field introduced in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        preserve_client_ip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Name for the traffic clone profile.
         * Field introduced in 17.1.1.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages the assignment of utility licenses on a BIG-IQ. Assignment means that the license is assigned to a BIG-IP, or, it needs to be assigned to a BIG-IP. Additionally, this module supported revoking the assignments from BIG-IP devices.
       */
      bigiq_utility_license_assignment?: {
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about an ESXi host's portgroup configuration when ESXi hostname or Cluster name is given.
       */
      vmware_portgroup_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Represents a Cloud SQL instance. Cloud SQL instances are SQL databases hosted in Google's cloud. The Instances resource provides methods for common configuration and management tasks.
       */
      gcp_sql_instance?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The IPv6 address assigned to the instance. This property is applicable only to First Generation instances.
         */
        ipv6_address?: string;
        /**
         * * FIRST_GEN: First Generation instance. MySQL only.
         * * SECOND_GEN: Second Generation instance or PostgreSQL instance.
         * * EXTERNAL: A database server that is not managed by Google.
         */
        backend_type?: "FIRST_GEN" | "SECOND_GEN" | "EXTERNAL";
        /**
         * Name of the Cloud SQL instance. This does not include the project ID.
         */
        name: string;
        /**
         * The name of the instance which will act as master in the replication setup.
         */
        master_instance_name?: string;
        /**
         * The user settings.
         */
        settings?: {
          [k: string]: unknown;
        };
        service_account_email?: string;
        /**
         * The geographical region. Defaults to us-central or us-central1 depending on the instance type (First Generation or Second Generation/PostgreSQL).
         */
        region?: string;
        /**
         * Connection name of the Cloud SQL instance used in connection strings.
         */
        connection_name?: string;
        /**
         * The maximum disk size of the instance in bytes.
         */
        max_disk_size?: number | string;
        project?: string;
        /**
         * The instance type. This can be one of the following.
         * * CLOUD_SQL_INSTANCE: A Cloud SQL instance that is not replicating   from a master.
         * * ON_PREMISES_INSTANCE: An instance running on the customer's   premises.
         * * READ_REPLICA_INSTANCE: A Cloud SQL instance configured as a   read-replica.
         */
        instance_type?: "CLOUD_SQL_INSTANCE" | "ON_PREMISES_INSTANCE" | "READ_REPLICA_INSTANCE";
        /**
         * Configuration specific to failover replicas and read replicas.
         */
        replica_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        /**
         * The name and status of the failover replica. This property is applicable only to Second Generation instances.
         */
        failover_replica?: {
          [k: string]: unknown;
        };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * The database engine type and version. For First Generation instances, can be MYSQL_5_5, or MYSQL_5_6. For Second Generation instances, can be MYSQL_5_6 or MYSQL_5_7. Defaults to MYSQL_5_6.
         * PostgreSQL instances: POSTGRES_9_6  The databaseVersion property can not be changed after instance creation.
         */
        database_version?: "MYSQL_5_5" | "MYSQL_5_6" | "MYSQL_5_7" | "POSTGRES_9_6";
        [k: string]: unknown;
      };
      /**
       * Get facts for virtual machine images.
       */
      azure_rm_virtualmachineimage_facts?: {
        profile?: string;
        /**
         * Image offering SKU. Combine with offer to see a list of available versions.
         */
        sku?: string;
        /**
         * Name of an image offering. Combine with sku to see a list of available image versions.
         */
        offer?: string;
        cloud_environment?: string;
        /**
         * Name of an image publisher. List image offerings associated with a particular publisher.
         */
        publisher?: string;
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        /**
         * Specific version number of an image.
         */
        version?: string;
        /**
         * Azure location value (ie. westus, eastus, eastus2, northcentralus, etc.). Supplying only a location value will yield a list of available publishers for the location.
         */
        location: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about the Scaleway security groups available.
       */
      scaleway_security_group_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * The manageiq_tags module supports adding, updating and deleting tags in ManageIQ.
       */
      manageiq_tags?: {
        manageiq_connection?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * absent - tags should not exist,
         * present - tags should exist,
         * list - list current tags.
         */
        state?: "absent" | "present" | "list";
        /**
         * the relevant resource name in manageiq
         */
        resource_name: string;
        /**
         * the relevant resource type in manageiq
         *
         * Possible choices:
         * provider
         * host
         * vm
         * blueprint
         * category
         * cluster
         * data store
         * group
         * resource pool
         * service
         * service template
         * template
         * tenant
         * user
         */
        resource_type: string;
        /**
         * tags - list of dictionaries, each includes 'name' and 'category' keys.
         * required if state is present or absent.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Provides direct access to the Cisco IMC REST API.
       * Perform any configuration changes and actions that the Cisco IMC supports.
       * More information about the IMC REST API is available from U(http://www.cisco.com/c/en/us/td/docs/unified_computing/ucs/c/sw/api/3_0/b_Cisco_IMC_api_301.html)
       */
      imc_rest?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        };
      /**
       * Represents a SQL database inside the Cloud SQL instance, hosted in Google's cloud.
       */
      gcp_sql_database?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The name of the database in the Cloud SQL instance.
         * This does not include the project ID or instance name.
         */
        name?: string;
        service_account_email?: string;
        /**
         * The MySQL charset value.
         */
        charset?: string;
        project?: string;
        /**
         * The name of the Cloud SQL instance. This does not include the project ID.
         */
        instance: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * The MySQL collation value.
         */
        collation?: string;
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Controls runit services on remote hosts using the sv utility.
       */
      runit?: {
        dist?: string;
        /**
         * Name of the service to manage.
         */
        name: string;
        /**
         * Whether the service is enabled or not, if disabled it also implies stopped.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: /var/service
         *
         * directory runsv watches for services
         */
        service_dir?: string;
        /**
         * C(started)/C(stopped) are idempotent actions that will not run commands unless necessary.  C(restarted) will always bounce the service (sv restart) and C(killed) will always bounce the service (sv force-stop). C(reloaded) will send a HUP (sv reload). C(once) will run a normally downed sv once (sv once), not really an idempotent operation.
         */
        state?: "killed" | "once" | "reloaded" | "restarted" | "started" | "stopped";
        /**
         * Default: /etc/sv
         *
         * directory where services are defined, the source of symlinks to service_dir.
         */
        service_src?: string;
        [k: string]: unknown;
      };
      /**
       * Manages updates and bundles with the swupd bundle manager, which is used by the Clear Linux Project for Intel Architecture.
       */
      swupd?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Bind EPGs to Contracts on Cisco ACI fabrics.
       */
      aci_epg_to_contract?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Gather facts about the Scaleway organizations available.
       */
      scaleway_organization_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create and update a virtual machine scale set.
       */
      azure_rm_virtualmachine_scaleset?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Represents a SSL policy. SSL policies give you the ability to control the features of SSL that your SSL proxy or HTTPS load balancer negotiates.
       */
      gcp_compute_ssl_policy?: {
        /**
         * Profile specifies the set of SSL features that can be used by the load balancer when negotiating SSL with clients. This can be one of `COMPATIBLE`, `MODERN`, `RESTRICTED`, or `CUSTOM`. If using `CUSTOM`, the set of SSL features to enable must be specified in the `customFeatures` field.
         */
        profile?: "COMPATIBLE" | "MODERN" | "RESTRICTED" | "CUSTOM";
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        /**
         * The minimum version of SSL protocol that can be used by the clients to establish a connection with the load balancer. This can be one of `TLS_1_0`, `TLS_1_1`, `TLS_1_2`.
         */
        min_tls_version?: "TLS_1_0" | "TLS_1_1" | "TLS_1_2";
        service_account_email?: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * A list of features enabled when the selected profile is CUSTOM. The method returns the set of features that can be specified in this list. This field must be empty if the profile is not CUSTOM.
         */
        custom_features?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * An optional description of this resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP GTM wide ip.
       */
      bigip_gtm_wide_ip?: {
        /**
         * Wide IP name. This name must be formatted as a fully qualified domain name (FQDN). You can also use the alias C(wide_ip) but this is deprecated and will be removed in a future Ansible version.
         */
        name?: string;
        /**
         * Specifies the load balancing method used to select a pool in this wide IP. This setting is relevant only when multiple pools are configured for a wide IP.
         * The C(round_robin) value is deprecated and will be removed in Ansible 2.9.
         * The C(global_availability) value is deprecated and will be removed in Ansible 2.9.
         */
        pool_lb_method?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * List of rules to be applied.
         * If you want to remove all existing iRules, specify a single empty value; C(""). See the documentation for an example.
         */
        irules?: string;
        /**
         * Default: present
         *
         * When C(present) or C(enabled), ensures that the Wide IP exists and is enabled.
         * When C(absent), ensures that the Wide IP has been removed.
         * When C(disabled), ensures that the Wide IP exists and is disabled.
         */
        state?: string;
        /**
         * The pools that you want associated with the Wide IP.
         * If C(ratio) is not provided when creating a new Wide IP, it will default to 1.
         */
        pools?: string;
        /**
         * Specifies the type of wide IP. GTM wide IPs need to be keyed by query type in addition to name, since pool members need different attributes depending on the response RDATA they are meant to supply. This value is required if you are using BIG-IP versions >= 12.0.0.
         */
        type?: string;
        /**
         * Specifies alternate domain names for the web site content you are load balancing.
         * You can use the same wildcard characters for aliases as you can for actual wide IP names.
         */
        aliases?: string;
        [k: string]: unknown;
      };
      /**
       * Allows one to run different config-sync actions. These actions allow you to manually sync your configuration across multiple BIG-IPs when those devices are in an HA pair.
       */
      bigip_configsync_action?: {
        /**
         * Indicates that the sync operation overwrites the configuration on the target.
         */
        overwrite_config?: string;
        /**
         * Specifies that the system synchronizes configuration data from this device to other members of the device group. In this case, the device will do a "push" to all the other devices in the group. This option is mutually exclusive with the C(sync_group_to_device) option.
         */
        sync_device_to_group?: string;
        /**
         * Specifies that the system synchronizes configuration data from the device with the most recent configuration. In this case, the device will do a "pull" from the most recently updated device. This option is mutually exclusive with the C(sync_device_to_group) options.
         */
        sync_most_recent_to_device?: string;
        /**
         * The device group that you want to perform config-sync actions on.
         */
        device_group?: string;
        [k: string]: unknown;
      };
      /**
       * Uses Layman to manage an additional repositories for the Portage package manager on Gentoo Linux. Please note that Layman must be installed on a managed node prior using this module.
       */
      layman?: {
        [k: string]: unknown;
      };
      /**
       * Manages VLAN configurations on Huawei CloudEngine switches.
       */
      ce_vlan?: {
        username?: string;
        /**
         * Range of VLANs such as C(2-10) or C(2,5,10-15), etc.
         */
        vlan_range?: string;
        ssh_keyfile?: string;
        /**
         * Specify VLAN description, minimum of 1 character, maximum of 80 characters.
         */
        description?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * Single VLAN ID, in the range from 1 to 4094.
         */
        vlan_id?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Name of VLAN, minimum of 1 character, maximum of 31 characters.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Create a new Swarm cluster.
       * Add/Remove nodes or managers to an existing cluster.
       */
      docker_swarm?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Iptables is used to set up, maintain, and inspect the tables of IP packet filter rules in the Linux kernel.
       * This module does not handle the saving and/or loading of rules, but rather only manipulates the current rules that are present in memory. This is the same as the behaviour of the C(iptables) and C(ip6tables) command which this module uses internally.
       */
      iptables?: {
        /**
         * This specifies a comment that will be added to the rule.
         */
        comment?: string;
        /**
         * TCP flags specification.
         * C(tcp_flags) expects a dict with the two keys C(flags) and C(flags_set).
         */
        tcp_flags?: {
          [k: string]: unknown;
        };
        /**
         * Specifies a log text for the rule. Only make sense with a LOG jump.
         */
        log_prefix?: string;
        /**
         * This enables the administrator to initialize the packet and byte counters of a rule (during INSERT, APPEND, REPLACE operations).
         */
        set_counters?: string;
        /**
         * Chain to operate on.
         * This option can either be the name of a user defined chain or any of the builtin chains: 'INPUT', 'FORWARD', 'OUTPUT', 'PREROUTING', 'POSTROUTING', 'SECMARK', 'CONNSECMARK'.
         */
        chain?: string;
        /**
         * Name of an interface via which a packet is going to be sent (for packets entering the FORWARD, OUTPUT and POSTROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.
         */
        out_interface?: string;
        /**
         * Specifies the maximum burst before the above limit kicks in.
         */
        limit_burst?: string;
        /**
         * C(ctstate) is a list of the connection states to match in the conntrack module. Possible states are: 'INVALID', 'NEW', 'ESTABLISHED', 'RELATED', 'UNTRACKED', 'SNAT', 'DNAT'
         */
        ctstate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * This specifies the target of the rule; i.e., what to do if the packet matches it. The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below).  If this option is omitted in a rule (and the goto parameter is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented.
         */
        jump?: string;
        /**
         * This specifies a destination port or range of ports to use: without this, the destination port is never altered. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.
         */
        to_ports?: string;
        /**
         * Flushes the specified table and chain of all rules.
         * If no chain is specified then the entire table is purged.
         * Ignores all other parameters.
         */
        flush?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The protocol of the rule or of the packet to check.
         * The specified protocol can be one of tcp, udp, udplite, icmp, esp, ah, sctp or the special keyword "all", or it can be a numeric value, representing one of these protocols or a different one. A protocol name from /etc/protocols is also allowed. A "!" argument before the protocol inverts the test.  The number zero is equivalent to all. "all" will match with all protocols and is taken as default when this option is omitted.
         */
        protocol?: string;
        /**
         * This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'
         */
        icmp_type?: string;
        /**
         * This specifies a destination address to use with DNAT.
         * Without this, the destination address is never altered.
         */
        to_destination?: string;
        /**
         * Default: append
         *
         * Whether the rule should be appended at the bottom or inserted at the top.
         * If the rule already exists the chain won't be modified.
         */
        action?: "append" | "insert";
        /**
         * Specifies the UID or username to use in match by owner rule. From Ansible 2.6 when the C(!) argument is prepended then the it inverts the rule to apply instead to all users except that one specified.
         */
        uid_owner?: string;
        /**
         * This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark.
         * Mutually exclusive with C(set_dscp_mark).
         */
        set_dscp_mark_class?: string;
        /**
         * Destination specification.
         * Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address.
         * Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea.
         * The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A "!" argument before the address specification inverts the sense of the address.
         */
        destination?: string;
        /**
         * Default: present
         *
         * Whether the rule should be absent or present.
         */
        state?: "absent" | "present";
        /**
         * Source specification.
         * Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address.
         * Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea.
         * The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A "!" argument before the address specification inverts the sense of the address.
         */
        source?: string;
        /**
         * This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value.
         * Mutually exclusive with C(set_dscp_mark_class).
         */
        set_dscp_mark?: string;
        /**
         * Set the policy for the chain to the given target.
         * Only built-in chains can have policies.
         * This parameter requires the C(chain) parameter.
         * Ignores all other parameters.
         */
        policy?: "ACCEPT" | "DROP" | "QUEUE" | "RETURN";
        /**
         * Specifies a match to use, that is, an extension module that tests for a specific property. The set of matches make up the condition under which a target is invoked. Matches are evaluated first to last if specified as an array and work in short-circuit fashion, i.e. if one extension yields false, evaluation will stop.
         */
        match?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * This specifies that the processing should continue in a user specified chain. Unlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump.
         */
        goto?: string;
        /**
         * This means that the rule only refers to second and further fragments of fragmented packets. Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them. When the "!" argument precedes fragment argument, the rule will only match head fragments, or unfragmented packets.
         */
        fragment?: string;
        /**
         * This specifies a source address to use with SNAT.
         * Without this, the source address is never altered.
         */
        to_source?: string;
        /**
         * Default: ignore
         *
         * This allows matching packets that have the SYN bit set and the ACK and RST bits unset.
         * When negated, this matches all packets with the RST or the ACK bits set.
         */
        syn?: "ignore" | "match" | "negate";
        /**
         * Source port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.
         */
        source_port?: string;
        /**
         * Insert the rule as the given rule number. This works only with action = 'insert'.
         */
        rule_num?: string;
        /**
         * Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.
         */
        destination_port?: string;
        /**
         * Default: filter
         *
         * This option specifies the packet matching table which the command should operate on. If the kernel is configured with automatic module loading, an attempt will be made to load the appropriate module for that table if it is not already there.
         */
        table?: "filter" | "nat" | "mangle" | "raw" | "security";
        /**
         * Specifies the error packet type to return while rejecting. It implies "jump: REJECT"
         */
        reject_with?: string;
        /**
         * Specifies the maximum average number of matches to allow per second.
         * The number can specify units explicitly, using `/second', `/minute', `/hour' or `/day', or parts of them (so `5/second' is the same as `5/s').
         */
        limit?: string;
        /**
         * Default: ipv4
         *
         * Which version of the IP protocol this rule should apply to.
         */
        ip_version?: "ipv4" | "ipv6";
        /**
         * Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.
         */
        in_interface?: string;
        [k: string]: unknown;
      };
      /**
       * Manage Fabric interface policy leaf profile interface selectors on Cisco ACI fabrics.
       */
      aci_access_port_to_interface_policy_leaf_profile?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Create or delete a Rackspace Cloud Monitoring entity, which represents a device to monitor. Entities associate checks and alarms with a target system and provide a convenient, centralized place to store IP addresses. Rackspace monitoring module flow | *rax_mon_entity* -> rax_mon_check -> rax_mon_notification -> rax_mon_notification_plan -> rax_mon_alarm
       */
      rax_mon_entity?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * The command module allows running one or more commands on remote devices running VyOS.  This module can also be introspected to validate key parameters before returning successfully.  If the conditional statements are not met in the wait period, the task fails.
       * Certain C(show) commands in VyOS produce many lines of output and use a custom pager that can cause this module to hang.  If the value of the environment variable C(ANSIBLE_VYOS_TERMINAL_LENGTH) is not set, the default number of 10000 is used.
       */
      vyos_command?: {
        [k: string]: unknown;
      };
      /**
       * Create, modify, destroy the network interface group
       */
      na_ontap_net_ifgrp?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Add or remove a database on a Webfaction host. Further documentation at https://github.com/quentinsf/ansible-webfaction.
       */
      webfaction_db?: {
        /**
         * The name of the database
         */
        name: string;
        /**
         * The machine name to use (optional for accounts with only one machine)
         */
        machine?: string;
        /**
         * Default: present
         *
         * Whether the database should exist
         */
        state?: "present" | "absent";
        /**
         * The webfaction password to use
         */
        login_password: string;
        /**
         * The password for the new database user.
         */
        password?: string;
        /**
         * The type of database to create.
         */
        type: "mysql" | "postgresql";
        /**
         * The webfaction account to use
         */
        login_name: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, remove snapshot volumes for NetApp E/EF-Series storage arrays.
       */
      netapp_e_snapshot_volume?: {
        /**
         * storage array ID
         */
        ssid: string;
        /**
         * The identifier of the snapshot image used to create the new snapshot volume.
         * Note: You'll likely want to use the M(netapp_e_facts) module to find the ID of the image you want.
         */
        snapshot_image_id: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * Whether to create or remove the snapshot volume
         */
        state: "absent" | "present";
        /**
         * Default: 20
         *
         * The size of the view in relation to the size of the base volume
         */
        repo_percentage?: number | string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * Default: 85
         *
         * The repository utilization warning threshold percentage
         */
        full_threshold?: number | string;
        /**
         * The snapshot volume access mode
         */
        view_mode?: "readOnly" | "readWrite" | "modeUnknown" | "__Undefined";
        /**
         * Name of the storage pool on which to allocate the repository volume.
         */
        storage_pool_name: string;
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name you wish to give the snapshot volume
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module allows one to (re)generate OpenSSL certificate signing requests. It uses the pyOpenSSL python library to interact with openssl. This module supports the subjectAltName, keyUsage, extendedKeyUsage, basicConstraints and OCSP Must Staple extensions.
       */
      openssl_csr?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage LTM virtual servers on a BIG-IP.
       */
      bigip_virtual_server?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Retrieve facts about one or more oVirt/RHV users.
       */
      ovirt_user_facts?: {
        /**
         * Search term which is accepted by oVirt/RHV search backend.
         * For example to search user X use following pattern: name=X
         */
        pattern?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP Disk
       */
      gcp_compute_disk_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A reference to the zone where the disk resides.
         */
        zone: string;
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Templates are processed by the Jinja2 templating language (U(http://jinja.pocoo.org/docs/)) - documentation on the template formatting can be found in the Template Designer Documentation (U(http://jinja.pocoo.org/docs/templates/)).
       * Six additional variables can be used in templates: C(ansible_managed) (configurable via the C(defaults) section of C(ansible.cfg)) contains a string which can be used to describe the template name, host, modification time of the template file and the owner uid, C(template_host) contains the node name of the template's machine, C(template_uid) the owner, C(template_path) the absolute path of the template, C(template_fullpath) is the absolute path of the template, and C(template_run_date) is the date that the template was rendered. Note that including a string that uses a date in the template will result in the template being marked 'changed' each time.
       */
      win_template?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Apply patch files using the GNU patch tool.
       */
      patch?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Retrieve facts about one or more networks from OpenStack.
       */
      os_networks_facts?: {
        /**
         * Name or ID of the Network
         */
        name?: string;
        /**
         * A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
         */
        filters?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * The manageiq_user module supports adding, updating and deleting users in ManageIQ.
       */
      manageiq_user?: {
        /**
         * Default: always
         *
         * C(always) will update passwords unconditionally.  C(on_create) will only set the password for a newly created user.
         */
        update_password?: "always" | "on_create";
        /**
         * The name of the group to which the user belongs.
         */
        group?: string;
        /**
         * The users' full name.
         */
        name?: string;
        /**
         * The unique userid in manageiq, often mentioned as username.
         */
        userid: string;
        /**
         * Default: present
         *
         * absent - user should not exist, present - user should be.
         */
        state?: "absent" | "present";
        manageiq_connection?: {
          [k: string]: unknown;
        };
        /**
         * The users' password.
         */
        password?: string;
        /**
         * The users' E-mail address.
         */
        email?: string;
        [k: string]: unknown;
      };
      /**
       * This module adds hosts to or removes them from IBM Spectrum Accelerate storage systems.
       */
      ibm_sa_host?: {
        /**
         * The domains the cluster will be attached to. To include more than one domain, separate domain names with commas. To include all existing domains, use an asterisk ("*").
         */
        domain?: string;
        /**
         * The name of the cluster to include the host.
         */
        cluster?: string;
        /**
         * Host name.
         */
        host?: string;
        /**
         * The host's CHAP name identifier
         */
        iscsi_chap_name?: string;
        /**
         * Default: present
         *
         * Host state.
         */
        state?: string;
        /**
         * The password of the initiator used to authenticate to the system when CHAP is enable
         */
        iscsi_chap_secret?: string;
        [k: string]: unknown;
      };
      /**
       * Manages global, zone, account, storage and cluster configurations.
       */
      cs_configuration?: {
        /**
         * Default: ROOT
         *
         * Domain the account is related to.
         * Only considered if C(account) is used.
         */
        domain?: string;
        api_key?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Ensure the value for corresponding storage pool.
         */
        storage?: string;
        api_region?: string;
        /**
         * Value of the configuration.
         */
        value: string;
        /**
         * Ensure the value for corresponding cluster.
         */
        cluster?: string;
        /**
         * Ensure the value for corresponding account.
         */
        account?: string;
        /**
         * Ensure the value for corresponding zone.
         */
        zone?: string;
        /**
         * Name of the configuration.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Allows the addition and removal of local, service and domain users, and domain groups from a local group.
       */
      win_group_membership?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, delete or activate ZFS boot environments.
       * Mount and unmount ZFS boot environments.
       */
      beadm?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manages VPN instance of HUAWEI CloudEngine switches.
       */
      ce_vrf?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Description of the vrf, the string length is 1 - 242 .
         */
        description?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * VPN instance, the length of vrf name is 1 - 31, i.e. "test", but can not be C(_public_).
         */
        vrf: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Discover targets on given portal, (dis)connect targets, mark targets to manually or auto start, return device nodes of connected targets.
       */
      open_iscsi?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage firmware image sources on Cisco ACI fabrics.
       */
      aci_firmware_source?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages a system startup information on HUAWEI CloudEngine switches.
       */
      ce_startup?: {
        /**
         * Position of the device.The value is a string of 1 to 32 characters. The possible value of slot is all, slave-board, or the specific slotID.
         */
        slot?: string;
        username?: string;
        ssh_keyfile?: string;
        /**
         * Default: present
         *
         * Name of the configuration file that is applied for the next startup. The value is a string of 5 to 255 characters.
         */
        cfg_file?: string;
        host?: string;
        /**
         * File name of the system software that is applied for the next startup. The value is a string of 5 to 255 characters.
         */
        software_file?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Display the startup information.
         */
        action?: "display";
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Name of the patch file that is applied for the next startup.
         */
        patch_file?: string;
        [k: string]: unknown;
      };
      /**
       * Reboot a HUAWEI CloudEngine switches.
       */
      ce_reboot?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Safeguard boolean. Set to true if you're sure you want to reboot.
         */
        confirm:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Flag indicating whether to save the configuration.
         */
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * This module fails the progress with a custom message. It can be useful for bailing out when a certain condition is met using C(when).
       * This module is also supported for Windows targets.
       */
      fail?: {
        active_connection_states?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        connect_timeout?: number | string;
        delay?: number | string;
        search_regex?: string;
        state?: "absent" | "drained" | "present" | "started" | "stopped";
        sleep?: number | string;
        timeout?: number | string;
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 'Failed as requested from task'
         *
         * The customized message used for failing execution. If omitted, fail will simply bail out with a generic message.
         */
        msg?: string;
        path?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides support for verifying Cisco NSO configuration is in compliance with specified values.
       */
      nso_verify?: {
        username: string;
        url: string;
        password: string;
        /**
         * NSO data in format as C(| display json) converted to YAML. List entries can be annotated with a C(__state) entry. Set to in-sync/deep-in-sync for services to verify service is in sync with the network. Set to absent in list entries to ensure they are deleted if they exist in NSO.
         *
         */
        data: {
          [k: string]: unknown;
        };
        timeout?: string;
        [k: string]: unknown;
      };
      /**
       * This module gathers facts for a specific system using its HP iLO interface. These facts include hardware and network related information useful for provisioning (e.g. macaddress, uuid).
       * This module requires the hpilo python module.
       */
      hpilo_facts?: {
        /**
         * Default: Administrator
         *
         * The login name to authenticate to the HP iLO interface.
         */
        login?: string;
        /**
         * Default: admin
         *
         * The password to authenticate to the HP iLO interface.
         */
        password?: string;
        /**
         * Default: TLSv1
         *
         * Change the ssl_version used.
         */
        ssl_version?: "SSLv3" | "SSLv23" | "TLSv1" | "TLSv1_1" | "TLSv1_2";
        /**
         * The HP iLO hostname/address that is linked to the physical system.
         */
        host: string;
        [k: string]: unknown;
      };
      /**
       * Manages client SSL profiles on a BIG-IP.
       */
      bigip_profile_client_ssl?: {
        /**
         * Default: /Common/clientssl
         *
         * The parent template of this monitor template. Once this value has been set, it cannot be changed. By default, this value is the C(clientssl) parent on the C(Common) partition.
         */
        parent?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the name of the profile.
         */
        name?: string;
        /**
         * One or more certificates and keys to associate with the SSL profile. This option is always a list. The keys in the list dictate the details of the client/key/chain combination. Note that BIG-IPs can only have one of each type of each certificate/key type. This means that you can only have one RSA, one DSA, and one ECDSA per profile. If you attempt to assign two RSA, DSA, or ECDSA certificate/key combo, the device will reject this.
         * This list is a complex list that specifies a number of keys.
         */
        cert_key_chain?: string;
        /**
         * Specifies the method of secure renegotiations for SSL connections. When creating a new profile, the setting is provided by the parent profile.
         * When C(request) is set the ssystem request secure renegotation of SSL connections.
         * C(require) is a default setting and when set the system permits initial SSL handshakes from clients but terminates renegotiations from unpatched clients.
         * The C(require-strict) setting the system requires strict renegotiation of SSL connections. In this mode the system refuses connections to insecure servers, and terminates existing SSL connections to insecure servers.
         */
        secure_renegotiation?: string;
        /**
         * Specifies the list of ciphers that the system supports. When creating a new profile, the default cipher list is provided by the parent profile.
         */
        ciphers?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the profile exists.
         * When C(absent), ensures the profile is removed.
         */
        state?: string;
        /**
         * Options that the system uses for SSL processing in the form of a list. When creating a new profile, the list is provided by the parent profile.
         * When a C('') or C(none) value is provided all options for SSL processing are disabled.
         */
        options?: string;
        /**
         * Enables or disables acceptance of non-SSL connections.
         * When creating a new profile, the setting is provided by the parent profile.
         */
        allow_non_ssl?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, stop and start a virtual machine. Provide an existing storage account and network interface or allow the module to create these for you. If you choose not to provide a network interface, the resource group must contain a virtual network with at least one subnet.
       * Before Ansible 2.5, this required an image found in the Azure Marketplace which can be discovered with M(azure_rm_virtualmachineimage_facts). In Ansible 2.5 and newer, custom images can be used as well, see the examples for more details.
       */
      azure_rm_virtualmachine?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage action rule profiles on Cisco ACI fabrics.
       */
      aci_tenant_action_rule_profile?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Create, delete, or manage aggregates on ONTAP.
       */
      na_ontap_aggregate?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module is used to configure WafProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_wafprofile?: {
        /**
         * List of data files used for waf rules.
         * Field introduced in 17.2.1.
         */
        files?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Field introduced in 17.2.1.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.2.1.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Field introduced in 17.2.1.
         */
        name: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Config params for waf.
         * Field introduced in 17.2.1.
         */
        config: {
          [k: string]: unknown;
        };
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Field introduced in 17.2.1.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * This module creates or deletes pools to be used on IBM Spectrum Accelerate storage systems.
       */
      ibm_sa_pool?: {
        /**
         * Adds the pool to the specified domain.
         */
        domain?: string;
        /**
         * Assigns a perf_class to the pool.
         */
        perf_class?: string;
        /**
         * Default: present
         *
         * Pool state.
         */
        state?: string;
        /**
         * Pool snapshot size in GB
         */
        snapshot_size?: string;
        /**
         * Pool name.
         */
        pool?: string;
        /**
         * Pool size in GB
         */
        size?: string;
        [k: string]: unknown;
      };
      /**
       * Send a message to an IRC channel. This is a very simplistic implementation.
       */
      irc?: {
        [k: string]: unknown;
      };
      /**
       * Add or remove flavor, volume_type or other resources access from OpenStack.
       */
      os_project_access?: {
        /**
         * Default: present
         *
         * Indicate desired state of the resource.
         */
        state?: string;
        /**
         * The resource name (eg. tiny).
         */
        resource_name?: string;
        /**
         * Project id.
         */
        target_project_id?: string;
        /**
         * The resource type (eg. nova_flavor, cinder_volume_type).
         */
        resource_type?: string;
        /**
         * The availability zone of the resource.
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * Much like the `roles:` keyword, this task loads a role, but it allows you to control it when the role tasks run in between other tasks of the play.
       * Most keywords, loops and conditionals will only be applied to the imported tasks, not to this statement itself. If you want the opposite behavior, use M(include_role) instead. To better understand the difference you can read the L(Including and Importing Guide,../user_guide/playbooks_reuse_includes.html).
       */
      import_role?: {
        active_connection_states?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        connect_timeout?: number | string;
        delay?: number | string;
        search_regex?: string;
        state?: "absent" | "drained" | "present" | "started" | "stopped";
        sleep?: number | string;
        timeout?: number | string;
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        msg?: string;
        path?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages AFM security firewall policies on a BIG-IP.
       */
      bigip_firewall_rule_list?: {
        /**
         * Specifies a list of rules that you want associated with this policy. The order of this list is the order they will be evaluated by BIG-IP. If the specified rules do not exist (for example when creating a new policy) then they will be created.
         * Rules specified here, if they do not exist, will be created with "default deny" behavior. It is expected that you follow-up this module with the actual configuration for these rules.
         * The C(bigip_firewall_rule) module can be used to also create, as well as edit, existing and new rules.
         */
        rules?: string;
        /**
         * Default: present
         *
         * When C(state) is C(present), ensures that the rule list exists.
         * When C(state) is C(absent), ensures that the rule list is removed.
         */
        state?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * The name of the policy to create.
         */
        name?: string;
        /**
         * The description to attach to the policy.
         * This parameter is only supported on versions of BIG-IP >= 12.1.0. On earlier versions it will simply be ignored.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manages Ethernet Virtual Private Network (EVPN) VXLAN Network Identifier (VNI) configurations on HUAWEI CloudEngine switches.
       */
      ce_evpn_bd_vni?: {
        username?: string;
        password?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Add VPN targets to both the import and export VPN target lists of a BD EVPN instance. The format is the same as route_distinguisher.
         */
        vpn_target_both?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Add VPN targets to the import VPN target list of a BD EVPN instance. The format is the same as route_distinguisher.
         */
        vpn_target_import?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Specify an existed bridge domain (BD).The value is an integer ranging from 1 to 16777215.
         */
        bridge_domain_id: string;
        /**
         * Add VPN targets to the export VPN target list of a BD EVPN instance. The format is the same as route_distinguisher.
         */
        vpn_target_export?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Configures a route distinguisher (RD) for a BD EVPN instance. The format of an RD can be as follows
         * 1) 2-byte AS number:4-byte user-defined number, for example, 1:3. An AS number is an integer ranging from 0 to 65535, and a user-defined number is an integer ranging from 0 to 4294967295. The AS and user-defined numbers cannot be both 0s. This means that an RD cannot be 0:0.
         * 2) Integral 4-byte AS number:2-byte user-defined number, for example, 65537:3. An AS number is an integer ranging from 65536 to 4294967295, and a user-defined number is an integer ranging from 0 to 65535.
         * 3) 4-byte AS number in dotted notation:2-byte user-defined number, for example, 0.0:3 or 0.1:0. A 4-byte AS number in dotted notation is in the format of x.y, where x and y are integers ranging from 0 to 65535.
         * 4) A user-defined number is an integer ranging from 0 to 65535. The AS and user-defined numbers cannot be both 0s. This means that an RD cannot be 0.0:0.
         * 5) 32-bit IP address:2-byte user-defined number. For example, 192.168.122.15:1. An IP address ranges from 0.0.0.0 to 255.255.255.255, and a user-defined number is an integer ranging from 0 to 65535.
         * 6) 'auto' specifies the RD that is automatically generated.
         */
        route_distinguisher?: string;
        host?: string;
        ssh_keyfile?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: enable
         *
         * Create or delete an EVPN instance for a VXLAN in BD view.
         */
        evpn?: "enable" | "disable";
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Create, update and delete a Public IP address. Allows setting and updating the address allocation method and domain name label. Use the azure_rm_networkinterface module to associate a Public IP with a network interface.
       */
      azure_rm_publicipaddress?: {
        [k: string]: unknown;
      };
      /**
       * This module will import/delete SSL keys on a BIG-IP. Keys can be imported from key files on the local disk, in PEM format.
       */
      bigip_ssl_key?: {
        /**
         * Sets the contents of a key directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. This must be provided when C(state) is C(present).
         */
        content?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the key is uploaded to the device. When C(absent), ensures that the key is removed from the device. If the key is currently in use, the module will not be able to remove the key.
         */
        state?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * The name of the key.
         */
        name?: string;
        /**
         * Passphrase on key.
         */
        passphrase?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about the Scaleway volumes available.
       */
      scaleway_volume_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages F5 BIG-IP LTM pools via iControl REST API.
       */
      bigip_pool?: {
        /**
         * Load balancing method. When creating a new pool, if this value is not specified, the default of C(round-robin) will be used.
         */
        lb_method?: string;
        /**
         * Monitor quorum value when C(monitor_type) is C(m_of_n).
         * Quorum must be a value of 1 or greater when C(monitor_type) is C(m_of_n).
         */
        quorum?: string;
        /**
         * Pool name
         */
        name?: string;
        /**
         * Specifies whether the system load balances traffic according to the priority number assigned to the pool member.
         * When creating a new pool, if this parameter is not specified, the default of C(0) will be used.
         * To disable this setting, provide the value C(0).
         * Once you enable this setting, you can specify pool member priority when you create a new pool or on a pool member's properties screen.
         * The system treats same-priority pool members as a group.
         * To enable priority group activation, provide a number from C(0) to C(65535) that represents the minimum number of members that must be available in one priority group before the system directs traffic to members in a lower priority group.
         * When a sufficient number of members become available in the higher priority group, the system again directs traffic to the higher priority group.
         */
        priority_group_activation?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Sets the ramp-up time (in seconds) to gradually ramp up the load on newly added or freshly detected up pool members.
         */
        slow_ramp_time?: string;
        /**
         * Sets the action to take when node goes down in pool.
         */
        service_down_action?: string;
        /**
         * Sets the number of times the system tries to contact a pool member after a passive failure.
         */
        reselect_tries?: string;
        /**
         * Monitor rule type when C(monitors) is specified.
         * When creating a new pool, if this value is not specified, the default of 'and_list' will be used.
         * When C(single) ensures that all specified monitors are checked, but additionally includes checks to make sure you only specified a single monitor.
         * When C(and_list) ensures that B(all) monitors are checked.
         * When C(m_of_n) ensures that C(quorum) of C(monitors) are checked. C(m_of_n) B(requires) that a C(quorum) of 1 or greater be set either in the playbook, or already existing on the device.
         * Both C(single) and C(and_list) are functionally identical since BIG-IP considers all monitors as "a list".
         */
        monitor_type?: string;
        /**
         * Default: present
         *
         * When C(present), guarantees that the pool exists with the provided attributes.
         * When C(absent), removes the pool from the system.
         */
        state?: string;
        /**
         * Arbitrary key/value pairs that you can attach to a pool. This is useful in situations where you might want to annotate a pool to me managed by Ansible.
         * Key names will be stored as strings; this includes names that are numbers.
         * Values for all of the keys will be stored as strings; this includes values that are numbers.
         * Data will be persisted, not ephemeral.
         */
        metadata?: string;
        /**
         * Monitor template name list. If the partition is not provided as part of the monitor name, then the C(partition) option will be used instead.
         */
        monitors?: string;
        /**
         * Specifies descriptive text that identifies the pool.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Restart a device
       */
      panos_restart?: {
        username?: string;
        password?: string;
        ip_address?: string;
        [k: string]: unknown;
      };
      /**
       * Allows for management of switchports settings for Meraki MS switches.
       */
      meraki_switchport?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages interface VPC configuration
       */
      nxos_vpc_interface?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        timeout?: number | string;
        /**
         * Default: present
         *
         * Manages desired state of the resource.
         */
        state?: "present" | "absent";
        auth_pass?: string;
        /**
         * Group number of the portchannel that will be configured.
         */
        portchannel: string;
        /**
         * Set to true/false for peer link config on associated portchannel.
         */
        peer_link?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        /**
         * VPC group/id that will be configured on associated portchannel.
         */
        vpc?: string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Deploy to nodes controlled by Ironic.
       */
      os_ironic_node?: {
        /**
         * An integer value representing the number of seconds to wait for the node activation or deactivation to complete.
         */
        timeout?: string;
        /**
         * globally unique identifier (UUID) to be given to the resource.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * A setting to allow power state to be asserted allowing nodes that are not yet deployed to be powered on, and nodes that are deployed to be powered off.
         */
        power?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Default: yes
         *
         * Indicates if the resource should be deployed. Allows for deployment logic to be disengaged and control of the node power or maintenance state to be changed.
         */
        deploy?: string;
        /**
         * If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.
         */
        ironic_url?: string;
        /**
         * A string expression regarding the reason a node is in a maintenance mode.
         */
        maintenance_reason?: string;
        /**
         * Default: present
         *
         * Indicates desired state of the resource
         */
        state?: string;
        /**
         * Default: no
         *
         * A setting to allow the direct control if a node is in maintenance mode.
         */
        maintenance?: string;
        /**
         * Default: no
         *
         * A boolean value instructing the module to wait for node activation or deactivation to complete before returning.
         */
        wait?: string;
        /**
         * Definition of the instance information which is used to deploy the node.  This information is only required when an instance is set to present.
         */
        instance_info?: string;
        /**
         * A configdrive file or HTTP(S) URL that will be passed along to the node.
         */
        config_drive?: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an ios node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(ios_config) to configure IOS devices.
       */
      ios_command?: {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Layer-2 interface on Juniper JUNOS network devices.
       */
      junos_l2_interface?: {
        /**
         * Native VLAN to be configured in trunk port. The value of C(native_vlan) should be vlan id.
         */
        native_vlan?: number | string;
        /**
         * Configure given VLAN in access port. The value of C(access_vlan) should be vlan name.
         */
        access_vlan?: string;
        ssh_keyfile?: string;
        /**
         * Description of Interface.
         */
        description?: string;
        /**
         * Logical interface number. Value of C(unit) should be of type integer.
         */
        unit?: number | string;
        /**
         * Default: present
         *
         * State of the Layer-2 Interface configuration.
         */
        state?: "present" | "absent";
        /**
         * Default: True
         *
         * True if your device has Enhanced Layer 2 Software (ELS).
         */
        enhanced_layer?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        username?: string;
        /**
         * List of Layer-2 interface definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        /**
         * Mode in which interface needs to be configured.
         */
        mode?: "access" | "trunk";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: True
         *
         * Specifies whether or not the configuration is active or deactivated
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        /**
         * List of VLAN names to be configured in trunk port. The value of C(trunk_vlans) should be list of vlan names.
         */
        trunk_vlans?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        transport?: string;
        /**
         * Name of the interface excluding any logical unit number.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to configure VMware DRS Affinity rule for virtual machine in given cluster.
       */
      vmware_vm_vm_drs_rule?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows the user to manage S3 buckets and the objects within them. Includes support for creating and deleting both objects and buckets, retrieving objects as files or strings and generating download links. This module has a dependency on boto3 and botocore.
       */
      aws_s3?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage AAA users on Cisco ACI fabrics.
       */
      aci_aaa_user?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module can be used to gather facts about droplet sizes.
       */
      digital_ocean_size_facts?: {
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about User account.
       */
      digital_ocean_account_facts?: {
        [k: string]: unknown;
      };
      /**
       * Manages CSW packages (SVR4 format) on Solaris 10 and 11.
       * These were the native packages on Solaris <= 10 and are available as a legacy feature in Solaris 11.
       * Pkgutil is an advanced packaging system, which resolves dependency on installation. It is designed for CSW packages.
       */
      pkgutil?: {
        /**
         * Whether to install (C(present)), or remove (C(absent)) a package.
         * The upgrade (C(latest)) operation will update/install the package to the latest version available.
         * Note: The module has a limitation that (C(latest)) only works for one package, not lists of them.
         */
        state: "present" | "absent" | "latest";
        /**
         * Specifies the repository path to install the package from.
         * Its global definition is done in C(/etc/opt/csw/pkgutil.conf).
         */
        site?: string;
        /**
         * Package name, e.g. (C(CSWnrpe))
         */
        name: string;
        /**
         * If you want to refresh your catalog from the mirror, set this to (C(yes)).
         */
        update_catalog?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * The C(win_copy) module copies a file on the local box to remote windows locations.
       * For non-Windows targets, use the M(copy) module instead.
       */
      win_copy?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Add or remove licenses on NetApp ONTAP.
       */
      na_ontap_license?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages BFD session configuration, creates a BFD session or deletes a specified BFD session on HUAWEI CloudEngine devices.
       */
      ce_bfd_session?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Indicates the source IP address carried in BFD packets.
         */
        src_addr?: string;
        /**
         * Default: no
         *
         * Indicates the default multicast IP address that is bound to a BFD session. By default, BFD uses the multicast IP address 224.0.0.184. You can set the multicast IP address by running the default-ip-address command. The value is a bool type.
         */
        use_default_ip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * Specifies the type and number of the interface bound to the BFD session.
         */
        out_if_name?: string;
        /**
         * Specifies the peer IP address type.
         */
        addr_type?: "ipv4";
        host?: string;
        /**
         * Specifies the peer IP address bound to the BFD session.
         */
        dest_addr?: string;
        /**
         * Specifies the name of a Virtual Private Network (VPN) instance that is bound to a BFD session. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value _public_ is reserved and cannot be used as the VPN instance name.
         */
        vrf_name?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * BFD session creation mode, the currently created BFD session only supports static or static auto-negotiation mode.
         */
        create_type?: "static" | "auto";
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies the name of a BFD session. The value is a string of 1 to 15 case-sensitive characters without spaces.
         */
        session_name: string;
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Manage or find Nuage VSP entities, this includes create, update, delete, assign, unassign and find, with all supported properties.
       */
      nuage_vspk?: {
        /**
         * Properties are the key, value pairs of the different properties an entity has.
         * If no I(id) and no I(match_filter) is specified, these are used to find or determine if the entity exists.
         */
        properties?: {
          [k: string]: unknown;
        };
        /**
         * The type of parent the ID is specified for (example Enterprise).
         * This should match the objects CamelCase class name in VSPK-Python.
         * This Class name can be found on U(https://nuagenetworks.github.io/vspkdoc/index.html).
         * If specified, I(parent_id) also needs to be specified.
         */
        parent_type?: string;
        /**
         * Dict with the authentication information required to connect to a Nuage VSP environment.
         * Requires a I(api_username) parameter (example csproot).
         * Requires either a I(api_password) parameter (example csproot) or a I(api_certificate) and I(api_key) parameters, which point to the certificate and key files for certificate based authentication.
         * Requires a I(api_enterprise) parameter (example csp).
         * Requires a I(api_url) parameter (example https://10.0.0.10:8443).
         * Requires a I(api_version) parameter (example v4_0).
         */
        auth: {
          [k: string]: unknown;
        };
        /**
         * The ID of the entity you want to work on.
         * In combination with I(command=find), it will only return the single entity.
         * In combination with I(state), it will either update or delete this entity.
         * Will take precedence over I(match_filter) and I(properties) whenever an entity needs to be found.
         */
        id?: string;
        /**
         * A filter used when looking (both in I(command) and I(state) for entities, in the format the Nuage VSP API expects.
         * If I(match_filter) is defined, it will take precedence over the I(properties), but not on the I(id)
         */
        match_filter?: string;
        /**
         * The ID of the parent of the entity you want to work on.
         * When I(state) is specified, the entity will be gathered from this parent, if it exists, unless an I(id) is specified.
         * When I(command=find) is specified, the entity will be searched for in this parent, unless an I(id) is specified.
         * If specified, I(parent_type) also needs to be specified.
         */
        parent_id?: string;
        /**
         * Specifies the desired state of the entity.
         * If I(state=present), in case the entity already exists, will update the entity if it is needed.
         * If I(state=present), in case the relationship with the parent is a member relationship, will assign the entity as a member of the parent.
         * If I(state=absent), in case the relationship with the parent is a member relationship, will unassign the entity as a member of the parent.
         * Either I(state) or I(command) needs to be defined, both can not be defined at the same time.
         */
        state?: "present" | "absent";
        /**
         * Specifies a command to be executed.
         * With I(command=find), if I(parent_id) and I(parent_type) are defined, it will only search within the parent. Otherwise, if allowed, will search in the root object.
         * With I(command=find), if I(id) is specified, it will only return the single entity matching the id.
         * With I(command=find), otherwise, if I(match_filter) is define, it will use that filter to search.
         * With I(command=find), otherwise, if I(properties) are defined, it will do an AND search using all properties.
         * With I(command=change_password), a password of a user can be changed. Warning - In case the password is the same as the existing, it will throw an error.
         * With I(command=wait_for_job), the module will wait for a job to either have a status of SUCCESS or ERROR. In case an ERROR status is found, the module will exit with an error.
         * With I(command=wait_for_job), the job will always be returned, even if the state is ERROR situation.
         * Either I(state) or I(command) needs to be defined, both can not be defined at the same time.
         */
        command?: "find" | "change_password" | "wait_for_job" | "get_csp_enterprise";
        /**
         * The type of entity you want to work on (example Enterprise).
         * This should match the objects CamelCase class name in VSPK-Python.
         * This Class name can be found on U(https://nuagenetworks.github.io/vspkdoc/index.html).
         */
        type: string;
        /**
         * Can be used to specify a set of child entities.
         * A mandatory property of each child is the I(type).
         * Supported optional properties of each child are I(id), I(properties) and I(match_filter).
         * The function of each of these properties is the same as in the general task definition.
         * This can be used recursively
         * Only useable in case I(state=present).
         */
        children?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP GTM pools.
       */
      bigip_gtm_pool?: {
        /**
         * The load balancing mode that the system tries if the C(preferred_lb_method) is unsuccessful in picking a pool.
         */
        alternate_lb_method?: string;
        /**
         * Name of the GTM pool.
         */
        name?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the IPv4, or IPv6 address of the server to which the system directs requests when it cannot use one of its pools to do so. Note that the system uses the fallback IP only if you select the C(fallback_ip) load balancing method.
         */
        fallback_ip?: string;
        /**
         * Default: present
         *
         * Pool state. When C(present), ensures that the pool is created and enabled. When C(absent), ensures that the pool is removed from the system. When C(enabled) or C(disabled), ensures that the pool is enabled or disabled (respectively) on the remote device.
         */
        state?: string;
        /**
         * The load balancing mode that the system tries if both the C(preferred_lb_method) and C(alternate_lb_method)s are unsuccessful in picking a pool.
         */
        fallback_lb_method?: string;
        /**
         * Specifies, if you activate more than one health monitor, the number of health monitors that must receive successful responses in order for the link to be considered available.
         */
        availability_requirements?: string;
        /**
         * Members to assign to the pool.
         * The order of the members in this list is the order that they will be listed in the pool.
         */
        members?: string;
        /**
         * The load balancing mode that the system tries first.
         */
        preferred_lb_method?: string;
        /**
         * The type of GTM pool that you want to create. On BIG-IP releases prior to version 12, this parameter is not required. On later versions of BIG-IP, this is a required parameter.
         */
        type?: string;
        /**
         * Specifies the health monitors that the system currently uses to monitor this resource.
         * When C(availability_requirements.type) is C(require), you may only have a single monitor in the C(monitors) list.
         */
        monitors?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove an I(apt) key, optionally downloading it.
       */
      apt_key?: {
        key?: string;
        /**
         * The keyserver to retrieve key from.
         */
        keyserver?: string;
        /**
         * The URL to retrieve key from.
         */
        url?: string;
        /**
         * The keyfile contents to add to the keyring.
         */
        data?: string;
        /**
         * The full path to specific keyring file in /etc/apt/trusted.gpg.d/
         */
        keyring?: string;
        /**
         * Default: present
         *
         * Ensures that the key is present (added) or absent (revoked).
         */
        state?: "absent" | "present";
        /**
         * The path to a keyfile on the remote server to add to the keyring.
         */
        file?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The identifier of the key.
         * Including this allows check mode to correctly report the changed state.
         * If specifying a subkey's id be aware that apt-key does not understand how to remove keys via a subkey id.  Specify the primary key's id instead.
         * This parameter is required when C(state) is set to C(absent).
         */
        id?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV groups.
       */
      ovirt_group_facts?: {
        /**
         * Search term which is accepted by oVirt/RHV search backend.
         * For example to search group X use following pattern: name=X
         */
        pattern?: string;
        [k: string]: unknown;
      };
      /**
       * Used to test the management connection to the cluster.
       * The test pings the MVIP and SVIP, and executes a simple API method to verify connectivity.
       */
      sf_check_connections?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * When the group does not exist in Gitlab, it will be created.
       * When the group does exist and state=absent, the group will be deleted.
       * As of Ansible version 2.7, this module make use of a different python module and thus some arguments are deprecated.
       */
      gitlab_group?: {
        [k: string]: unknown;
      };
      /**
       * Used to manage Chocolatey config settings as well as unset the values.
       */
      win_chocolatey_config?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides support for querying data from Cisco NSO using XPath.
       */
      nso_query?: {
        /**
         * XPath selection relative to the root.
         */
        xpath: string;
        username: string;
        url: string;
        /**
         * List of fields to select from matching nodes.
         *
         */
        fields:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: string;
        password: string;
        [k: string]: unknown;
      };
      /**
       * Executes a low-down and dirty telnet command, not going through the module subsystem.
       * This is mostly to be used for enabling ssh on devices that only have telnet enabled by default.
       */
      telnet?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * M(onepassword_facts) wraps the C(op) command line utility to fetch data about one or more 1password items and return as Ansible facts.
       * A fatal error occurs if any of the items being searched for can not be found.
       * Recommend using with the C(no_log) option to avoid logging the values of the secrets being retrieved.
       */
      onepassword_facts?: {
        /**
         * Default: op
         *
         * Used to specify the exact path to the C(op) command line interface
         */
        cli_path?: string;
        /**
         * A list of one or more search terms.
         * Each search term can either be a simple string or it can be a dictionary for more control.
         * When passing a simple string, I(field) is assumed to be C(password).
         * When passing a dictionary, the following fields are available.
         */
        search_terms:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A dictionary containing authentication details. If this is set, M(onepassword_facts) will attempt to login to 1password automatically.
         * The required values can be stored in Ansible Vault, and passed to the module securely that way.
         * Without this option, you must have already logged in via the 1Password CLI before running Ansible.
         */
        auto_login?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Configure gslb vserver entities in Netscaler.
       */
      netscaler_gslb_vserver?: {
        /**
         * Any comments that you might want to associate with the GSLB virtual server.
         */
        comment?: string;
        domainname?: string;
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * When set to C(yes) the GSLB Vserver state will be set to C(disabled).
         * When set to C(no) the GSLB Vserver state will be set to C(enabled).
         * Note that due to limitations of the underlying NITRO API a C(disabled) state change alone does not cause the module result to report a changed status.
         */
        disabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_protocol?: "http" | "https";
        /**
         * Protocol used by services bound to the virtual server.
         *
         */
        servicetype?:
          | "HTTP"
          | "FTP"
          | "TCP"
          | "UDP"
          | "SSL"
          | "SSL_BRIDGE"
          | "SSL_TCP"
          | "NNTP"
          | "ANY"
          | "SIP_UDP"
          | "SIP_TCP"
          | "SIP_SSL"
          | "RADIUS"
          | "RDP"
          | "RTSP"
          | "MYSQL"
          | "MSSQL"
          | "ORACLE";
        /**
         * List of bindings for gslb services bound to this gslb virtual server.
         */
        service_bindings?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        state?: "present" | "absent";
        nitro_user: string;
        /**
         * Include multiple IP addresses in the DNS responses sent to clients.
         */
        mir?: "enabled" | "disabled";
        /**
         * Site selection tolerance, in milliseconds, for implementing the RTT load balancing method. If a site's RTT deviates from the lowest RTT by more than the specified tolerance, the site is not considered when the NetScaler appliance makes a GSLB decision. The appliance implements the round robin method of global server load balancing between sites whose RTT values are within the specified tolerance. If the tolerance is 0 (zero), the appliance always sends clients the IP address of the site with the lowest RTT.
         * Minimum value = C(0)
         * Maximum value = C(100)
         */
        tolerance?: number;
        nitro_timeout?: number;
        /**
         * Threshold at which spillover occurs. Specify an integer for the CONNECTION spillover method, a bandwidth value in kilobits per second for the BANDWIDTH method (do not enter the units), or a percentage for the HEALTH method (do not enter the percentage symbol).
         * Minimum value = C(1)
         * Maximum value = C(4294967287)
         */
        sothreshold?: number;
        /**
         * If spillover occurs, maintain source IP address based persistence for both primary and backup GSLB virtual servers.
         */
        sopersistence?: "enabled" | "disabled";
        /**
         * Enable logging appflow flow information.
         */
        appflowlog?: "enabled" | "disabled";
        /**
         * The persistence ID for the GSLB virtual server. The ID is a positive integer that enables GSLB sites to identify the GSLB virtual server, and is required if source IP address based or spill over based persistence is enabled on the virtual server.
         * Minimum value = C(0)
         * Maximum value = C(65535)
         */
        persistenceid?: number;
        /**
         * Action to be performed if spillover is to take effect, but no backup chain to spillover is usable or exists.
         */
        sobackupaction?: "DROP" | "ACCEPT" | "REDIRECT";
        /**
         * List of bindings for domains for this glsb vserver.
         */
        domain_bindings?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * DNS record type to associate with the GSLB virtual server's domain name.
         * Default value: A
         * Possible values = A, AAAA, CNAME, NAPTR
         */
        dnsrecordtype?: "A" | "AAAA" | "CNAME" | "NAPTR";
        /**
         * If the primary state of all bound GSLB services is DOWN, consider the effective states of all the GSLB services, obtained through the Metrics Exchange Protocol (MEP), when determining the state of the GSLB virtual server. To consider the effective state, set the parameter to STATE_ONLY. To disregard the effective state, set the parameter to NONE.
         * The effective state of a GSLB service is the ability of the corresponding virtual server to serve traffic. The effective state of the load balancing virtual server, which is transferred to the GSLB service, is UP even if only one virtual server in the backup chain of virtual servers is in the UP state.
         */
        considereffectivestate?: "NONE" | "STATE_ONLY";
        /**
         * IPv4 network mask for use in the SOURCEIPHASH load balancing method.
         * Minimum length = 1
         */
        netmask?: string;
        /**
         * Number of bits to consider, in an IPv6 source IP address, for creating the hash that is required by the C(SOURCEIPHASH) load balancing method.
         * Default value: C(128)
         * Minimum value = C(1)
         * Maximum value = C(128)
         */
        v6netmasklen?: number;
        /**
         * Use source IP address based persistence for the virtual server.
         * After the load balancing method selects a service for the first packet, the IP address received in response to the DNS query is used for subsequent requests from the same client.
         */
        persistencetype?: "SOURCEIP" | "NONE";
        /**
         * Name for the GSLB virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the virtual server is created.
         * Minimum length = 1
         */
        name?: string;
        /**
         * Continue to direct traffic to the backup chain even after the primary GSLB virtual server returns to the UP state. Used when spillover is configured for the virtual server.
         */
        disableprimaryondown?: "enabled" | "disabled";
        cookie_domain?: string;
        /**
         * Backup load balancing method. Becomes operational if the primary load balancing method fails or cannot be used. Valid only if the primary method is based on either round-trip time (RTT) or static proximity.
         */
        backuplbmethod?:
          | "ROUNDROBIN"
          | "LEASTCONNECTION"
          | "LEASTRESPONSETIME"
          | "SOURCEIPHASH"
          | "LEASTBANDWIDTH"
          | "LEASTPACKETS"
          | "STATICPROXIMITY"
          | "RTT"
          | "CUSTOMLOAD";
        /**
         * Specify if the appliance should consider the service count, service weights, or ignore both when using weight-based load balancing methods. The state of the number of services bound to the virtual server help the appliance to select the service.
         */
        dynamicweight?: "SERVICECOUNT" | "SERVICEWEIGHT" | "DISABLED";
        /**
         * Type of threshold that, when exceeded, triggers spillover. Available settings function as follows:
         * * C(CONNECTION) - Spillover occurs when the number of client connections exceeds the threshold.
         * * C(DYNAMICCONNECTION) - Spillover occurs when the number of client connections at the GSLB virtual server exceeds the sum of the maximum client (Max Clients) settings for bound GSLB services. Do not specify a spillover threshold for this setting, because the threshold is implied by the Max Clients settings of the bound GSLB services.
         * * C(BANDWIDTH) - Spillover occurs when the bandwidth consumed by the GSLB virtual server's incoming and outgoing traffic exceeds the threshold.
         * * C(HEALTH) - Spillover occurs when the percentage of weights of the GSLB services that are UP drops below the threshold. For example, if services gslbSvc1, gslbSvc2, and gslbSvc3 are bound to a virtual server, with weights 1, 2, and 3, and the spillover threshold is 50%, spillover occurs if gslbSvc1 and gslbSvc3 or gslbSvc2 and gslbSvc3 transition to DOWN.
         * * C(NONE) - Spillover does not occur.
         */
        somethod?: "CONNECTION" | "DYNAMICCONNECTION" | "BANDWIDTH" | "HEALTH" | "NONE";
        /**
         * Load balancing method for the GSLB virtual server.
         * Default value: LEASTCONNECTION
         * Possible values = ROUNDROBIN, LEASTCONNECTION, LEASTRESPONSETIME, SOURCEIPHASH, LEASTBANDWIDTH, LEASTPACKETS, STATICPROXIMITY, RTT, CUSTOMLOAD
         */
        lbmethod?:
          | "ROUNDROBIN"
          | "LEASTCONNECTION"
          | "LEASTRESPONSETIME"
          | "SOURCEIPHASH"
          | "LEASTBANDWIDTH"
          | "LEASTPACKETS"
          | "STATICPROXIMITY"
          | "RTT"
          | "CUSTOMLOAD";
        /**
         * Timeout for spillover persistence, in minutes.
         * Default value: C(2)
         * Minimum value = C(2)
         * Maximum value = C(1440)
         */
        sopersistencetimeout?: number;
        nsip: string;
        /**
         * The optional IPv4 network mask applied to IPv4 addresses to establish source IP address based persistence.
         * Minimum length = 1
         */
        persistmask?: string;
        /**
         * Idle time, in minutes, after which a persistence entry is cleared.
         * Default value: C(2)
         * Minimum value = C(2)
         * Maximum value = C(1440)
         */
        timeout?: number;
        /**
         * Number of bits to consider in an IPv6 source IP address when creating source IP address based persistence sessions.
         * Default value: C(128)
         * Minimum value = C(1)
         * Maximum value = C(128)
         */
        v6persistmasklen?: number;
        nitro_pass: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module manages locally configured user accounts on remote network devices running the JUNOS operating system.  It provides a set of arguments for creating, removing and updating locally defined accounts
       */
      junos_user?: {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure Gslb object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_gslb?: {
        /**
         * This field disables the configuration operations on the leader for all federated objects.
         * Cud operations on gslb, gslbservice, gslbgeodbprofile and other federated objects will be rejected.
         * The rest-api disabling helps in upgrade scenarios where we don't want configuration sync operations to the gslb member when the member is being
         * upgraded.
         * This configuration programmatically blocks the leader from accepting new gslb configuration when member sites are undergoing upgrade.
         * Field introduced in 17.2.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        maintenance_mode?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Select avi site member belonging to this gslb.
         */
        sites?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Uuid of the gslb object.
         */
        uuid?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Group to specify if the client ip addresses are public or private.
         * Field introduced in 17.1.2.
         */
        client_ip_addr_group?: {
          [k: string]: unknown;
        };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Third party site member belonging to this gslb.
         * Field introduced in 17.1.1.
         */
        third_party_sites?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_version?: string;
        username?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * The view-id is used in change-leader mode to differentiate partitioned groups while they have the same gslb namespace.
         * Each partitioned group will be able to operate independently by using the view-id.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         */
        view_id?: number | string;
        controller?: string;
        /**
         * Sub domain configuration for the gslb.
         * Gslb service's fqdn must be a match one of these subdomains.
         */
        dns_configs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Mark this site as leader of gslb configuration.
         * This site is the one among the avi sites.
         */
        leader_cluster_uuid: string;
        password?: string;
        tenant?: string;
        /**
         * Name for the gslb object.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * This field indicates that this object is replicated across gslb federation.
         * Field introduced in 17.1.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        is_federated?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Max retries after which the remote site is treated as a fresh start.
         * In fresh start all the configs are downloaded.
         * Allowed values are 1-1024.
         * Default value when not specified in API or module is interpreted by Avi Controller as 20.
         */
        clear_on_max_retries?: number | string;
        /**
         * Frequency with which group members communicate.
         * Allowed values are 1-3600.
         * Default value when not specified in API or module is interpreted by Avi Controller as 15.
         * Units(SEC).
         */
        send_interval?: number | string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to perform various operations related to backup, restore and reset of ESXi host configuration.
       */
      vmware_cfg_backup?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can manage a pacemaker cluster and nodes from Ansible using the pacemaker cli.
       */
      pacemaker_cluster?: {
        /**
         * Specify which node of the cluster you want to manage. None == the cluster status itself, 'all' == check the status of all nodes.
         */
        node?: string;
        /**
         * Indicate desired state of the cluster
         */
        state?: string;
        /**
         * Default: yes
         *
         * Force the change of the cluster state
         */
        force?: string;
        /**
         * Default: 300
         *
         * Timeout when the module should considered that the action has failed
         */
        timeout?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP Address
       */
      gcp_compute_address_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * URL of the region where the regional address resides.
         * This field is not applicable to global addresses.
         */
        region: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        service_account_file?: string;
        [k: string]: unknown;
      };
      /**
       * This module manages AWS Config delivery locations for rule checks and configuration info
       */
      aws_config_delivery_channel?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages tunnels on a BIG-IP. Tunnels are usually based upon a tunnel profile which defines both default arguments and constraints for the tunnel.
       * Due to this, this module exposes a number of settings that may or may not be related to the type of tunnel you are working with. It is important that you take this into consideration when declaring your tunnel config.
       * If a specific tunnel does not support the parameter you are considering, the documentation of the parameter will usually make mention of this. Otherwise, when configuring that parameter on the device, the device will notify you.
       */
      bigip_tunnel?: {
        [k: string]: unknown;
      };
      /**
       * Manages locales by editing /etc/locale.gen and invoking locale-gen.
       */
      locale_gen?: {
        /**
         * Default: present
         *
         * Whether the locale shall be present.
         */
        state?: "absent" | "present";
        /**
         * Name and encoding of the locale, such as "en_GB.UTF-8".
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and remove domains.
       */
      cs_domain?: {
        api_key?: string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Clean up all domain resources like child domains and accounts.
         * Considered on C(state=absent).
         */
        clean_up?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * State of the domain.
         */
        state?: "present" | "absent";
        /**
         * Path of the domain.
         * Prefix C(ROOT/) or C(/ROOT/) in path is optional.
         */
        path: string;
        /**
         * Network domain for networks in the domain.
         */
        network_domain?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of MAGP protocol on vlan interface of Mellanox ONYX network devices.
       */
      onyx_magp?: {
        /**
         * VLAN Interface name.
         */
        interface: string;
        /**
         * MAGP router MAC address.
         */
        router_mac?: string;
        /**
         * Default: present
         *
         * MAGP state.
         */
        state?: "present" | "absent" | "enabled" | "disabled";
        /**
         * MAGP router IP address.
         */
        router_ip?: string;
        /**
         * MAGP instance number 1-255
         */
        magp_id: number | string;
        [k: string]: unknown;
      };
      /**
       * Creates, removes, or updates GitHub access keys.
       */
      github_key?: {
        /**
         * SSH public key value. Required when C(state=present).
         */
        pubkey?: string;
        /**
         * GitHub Access Token with permission to list and create public keys.
         */
        token: string;
        /**
         * Default: yes
         *
         * The default is C(yes), which will replace the existing remote key if it's different than C(pubkey). If C(no), the key will only be set if no key with the given C(name) exists.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * SSH key name
         */
        name: string;
        /**
         * Default: present
         *
         * Whether to remove a key, ensure that it exists, or update its value.
         */
        state?: "present" | "absent";
        [k: string]: unknown;
      };
      /**
       * Register templates from an URL.
       * Create templates from a ROOT volume of a stopped VM or its snapshot.
       * Update (since version 2.7), extract and delete templates.
       */
      cs_template?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, delete or modify protection groups on Pure Storage FlashArrays.
       */
      purefa_pg?: {
        /**
         * Default: yes
         *
         * Define whether to enabled snapshots for the protection group.
         */
        enabled?: string;
        /**
         * Default: present
         *
         * Define whether the protection group should exist or not.
         */
        state?: string;
        /**
         * List of existing hostgroups to add to protection group.
         */
        hostgroup?: string;
        /**
         * List of existing volumes to add to protection group.
         */
        volume?: string;
        /**
         * List of existing hosts to add to protection group.
         */
        host?: string;
        /**
         * The name of the protection group.
         */
        pgroup?: string;
        /**
         * Default: no
         *
         * Define whether to eradicate the protection group on delete and leave in trash.
         */
        eradicate?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve an auth token from an OpenStack Cloud
       */
      os_auth?: {
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * This module transfers files via SCP from or to remote devices running Junos.
       */
      junos_scp?: {
        username?: string;
        /**
         * The C(src) argument takes a single path, or a list of paths to be transfered. The argument C(recursive) must be C(true) to transfer directories.
         */
        src:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ssh_keyfile?: string;
        /**
         * Default: no
         *
         * The C(recursive) argument enables recursive transfer of files and directories.
         */
        recursive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * The C(remote_src) argument enables the download of files (I(scp get)) from the remote device. The default behavior is to upload files (I(scp put)) to the remote device.
         */
        remote_src?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: .
         *
         * The C(dest) argument specifies the path in which to receive the files.
         */
        dest?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Manages SNMP target host configurations on HUAWEI CloudEngine switches.
       */
      ce_snmp_target_host?: {
        /**
         * VPN instance Name.
         */
        vpn_name?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * UDP Port number used by network management to receive alarm messages.
         */
        recv_port?: string;
        /**
         * Security Model.
         */
        security_model?: "v1" | "v2c" | "v3";
        /**
         * Security Name.
         */
        security_name?: string;
        /**
         * Default: no_use
         *
         * To enable or disable Public Net-manager for target Host.
         */
        is_public_net?: "no_use" | "true" | "false";
        state?: "present" | "absent";
        /**
         * Version(s) Supported by SNMP Engine.
         */
        version?: "none" | "v1" | "v2c" | "v3" | "v1v2c" | "v1v3" | "v2cv3" | "all";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Name of the interface to send the trap message.
         */
        interface_name?: string;
        username?: string;
        /**
         * Security Name V3.
         */
        security_name_v3?: string;
        /**
         * Security level indicating whether to use authentication and encryption.
         */
        security_level?: "noAuthNoPriv" | "authentication" | "privacy";
        host?: string;
        /**
         * Network Address.
         */
        address?: string;
        password?: string;
        ssh_keyfile?: string;
        /**
         * Udp port used by SNMP agent to connect the Network management.
         */
        connect_port?: string;
        /**
         * Unique name to identify target host entry.
         */
        host_name?: string;
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * To configure notify type as trap or inform.
         */
        notify_type?: "trap" | "inform";
        [k: string]: unknown;
      };
      /**
       * Add and delete an IPA service using IPA API
       */
      ipa_service?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module is used to configure SSLKeyAndCertificate object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_sslkeyandcertificate?: {
        username?: string;
        /**
         * It is a reference to an object of type hardwaresecuritymodulegroup.
         */
        hardwaresecuritymodulegroup_ref?: string;
        /**
         * Sslkeyparams settings for sslkeyandcertificate.
         */
        key_params?: {
          [k: string]: unknown;
        };
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Sslcertificate settings for sslkeyandcertificate.
         */
        certificate: {
          [k: string]: unknown;
        };
        /**
         * Name of the encrypted private key (e.g.
         * Those generated by an hsm such as thales nshield).
         */
        enckey_name?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Creator name.
         */
        created_by?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Enum options - ssl_certificate_type_virtualservice, ssl_certificate_type_system, ssl_certificate_type_ca.
         * Default value when not specified in API or module is interpreted by Avi Controller as SSL_CERTIFICATE_TYPE_VIRTUALSERVICE.
         */
        type?: string;
        api_version?: string;
        /**
         * Enum options - ssl_certificate_finished, ssl_certificate_pending.
         * Default value when not specified in API or module is interpreted by Avi Controller as SSL_CERTIFICATE_FINISHED.
         */
        status?: string;
        /**
         * It is a reference to an object of type certificatemanagementprofile.
         */
        certificate_management_profile_ref?: string;
        controller?: string;
        /**
         * Private key.
         */
        key?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * Encrypted private key corresponding to the private key (e.g.
         * Those generated by an hsm such as thales nshield).
         */
        enckey_base64?: string;
        /**
         * Name of the object.
         */
        name: string;
        /**
         * Dynamic parameters needed for certificate management profile.
         */
        dynamic_params?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Ca certificates in certificate chain.
         */
        ca_certs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Run targets in a Makefile.
       */
      make?: {
        /**
         * cd into this directory before running make
         */
        chdir: string;
        /**
         * Any extra parameters to pass to make
         */
        params?: {
          [k: string]: unknown;
        };
        /**
         * The target to run
         */
        target?: string;
        /**
         * Use file as a Makefile
         */
        file?: string;
        [k: string]: unknown;
      };
      /**
       * Create a dynamic address group object in the firewall used for policy rules
       */
      panos_dag?: {
        username?: string;
        /**
         * name of the dynamic address group
         */
        dag_name: string;
        /**
         * Default: yes
         *
         * commit if changed
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password: string;
        ip_address: string;
        /**
         * dynamic filter user by the dynamic address group
         */
        dag_filter: string;
        [k: string]: unknown;
      };
      /**
       * Create a VMware portgroup on given host/s or hosts of given cluster
       */
      vmware_portgroup?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, Retrieve and remove certificates DigitalOcean.
       */
      digital_ocean_certificate?: {
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather information about VMware server to which user is trying to connect.
       */
      vmware_about_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or Remove a pool from the OpenStack load-balancer service.
       */
      os_pool?: {
        /**
         * Default: ROUND_ROBIN
         *
         * The load balancing algorithm for the pool.
         */
        lb_algorithm?: string;
        /**
         * Default: HTTP
         *
         * The protocol for the pool.
         */
        protocol?: string;
        /**
         * Name that has to be given to the pool
         */
        name?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * The name or id of the listener that this pool belongs to. Either loadbalancer or listener must be specified for pool creation.
         */
        listener?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: 180
         *
         * The amount of time the module should wait for the pool to get into ACTIVE state.
         */
        timeout?: string;
        /**
         * The name or id of the load balancer that this pool belongs to. Either loadbalancer or listener must be specified for pool creation.
         */
        loadbalancer?: string;
        /**
         * Default: yes
         *
         * If the module should wait for the pool to be ACTIVE.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure GslbService object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_gslbservice?: {
        /**
         * Enable or disable the gslb service.
         * If the gslb service is enabled, then the vips are sent in the dns responses based on reachability and configured algorithm.
         * If the gslb service is disabled, then the vips are no longer available in the dns response.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Fully qualified domain name of the gslb service.
         */
        domain_names?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * This field indicates that this object is replicated across gslb federation.
         * Field introduced in 17.1.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        is_federated?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Ttl value (in seconds) for records served for this gslb service by the dns service.
         * Allowed values are 1-86400.
         * Units(SEC).
         */
        ttl?: number | string;
        /**
         * Health monitor probe can be executed for all the members or it can be executed only for third-party members.
         * This operational mode is useful to reduce the number of health monitor probes in case of a hybrid scenario.
         * In such a case, avi members can have controller derived status while non-avi members can be probed by via health monitor probes in dataplane.
         * Enum options - GSLB_SERVICE_HEALTH_MONITOR_ALL_MEMBERS, GSLB_SERVICE_HEALTH_MONITOR_ONLY_NON_AVI_MEMBERS.
         * Default value when not specified in API or module is interpreted by Avi Controller as GSLB_SERVICE_HEALTH_MONITOR_ALL_MEMBERS.
         */
        health_monitor_scope?: string;
        /**
         * Uuid of the gslb service.
         */
        uuid?: string;
        /**
         * Response to the client query when the gslb service is down.
         */
        down_response?: {
          [k: string]: unknown;
        };
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Creator name.
         * Field introduced in 17.1.2.
         */
        created_by?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        /**
         * Enable site-persistence for the gslbservice.
         * Field introduced in 17.2.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        site_persistence_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_version?: string;
        username?: string;
        /**
         * The federated application persistence associated with gslbservice site persistence functionality.
         * It is a reference to an object of type applicationpersistenceprofile.
         * Field introduced in 17.2.1.
         */
        application_persistence_profile_ref?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * Enable wild-card match of fqdn  if an exact match is not found in the dns table, the longest match is chosen by wild-carding the fqdn in the dns
         * request.
         * Default is false.
         * Field introduced in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        wildcard_match?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Use the client ip subnet from the edns option as source ipaddress for client geo-location and consistent hash algorithm.
         * Default is true.
         * Field introduced in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        use_edns_client_subnet?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Select list of pools belonging to this gslb service.
         */
        groups?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Gs member's overall health status is derived based on a combination of controller and datapath health-status inputs.
         * Note that the datapath status is determined by the association of health monitor profiles.
         * Only the controller provided status is determined through this configuration.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        controller_health_status_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name for the gslb service.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        controller?: string;
        /**
         * Verify vs health by applying one or more health monitors.
         * Active monitors generate synthetic traffic from dns service engine and to mark a vs up or down based on the response.
         * It is a reference to an object of type healthmonitor.
         */
        health_monitor_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Number of ip addresses of this gslb service to be returned by the dns service.
         * Enter 0 to return all ip addresses.
         * Allowed values are 1-20.
         * Special values are 0- 'return all ip addresses'.
         */
        num_dns_ip?: number | string;
        /**
         * The load balancing algorithm will pick a gslb pool within the gslb service list of available pools.
         * Enum options - GSLB_SERVICE_ALGORITHM_PRIORITY, GSLB_SERVICE_ALGORITHM_GEO.
         * Field introduced in 17.2.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as GSLB_SERVICE_ALGORITHM_PRIORITY.
         */
        pool_algorithm?: string;
        tenant_uuid?: string;
        /**
         * The minimum number of members to distribute traffic to.
         * Allowed values are 1-65535.
         * Special values are 0 - 'disable'.
         * Field introduced in 17.2.4.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         */
        min_members?: number | string;
        [k: string]: unknown;
      };
      /**
       * Represents an Address resource.
       * Each virtual machine instance has an ephemeral internal IP address and, optionally, an external IP address. To communicate between instances on the same network, you can use an instance's internal IP address. To communicate with the Internet and instances outside of the same network, you must specify the instance's external IP address.
       * Internal IP addresses are ephemeral and only belong to an instance for the lifetime of the instance; if the instance is deleted and recreated, the instance is assigned a new internal IP address, either by Compute Engine or by you. External IP addresses can be either ephemeral or static.
       */
      gcp_compute_address?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * An optional description of this resource.
         */
        description?: string;
        service_account_email?: string;
        /**
         * URL of the region where the regional address resides.
         * This field is not applicable to global addresses.
         */
        region: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        /**
         * The static external IP address represented by this resource. Only IPv4 is supported. An address may only be specified for INTERNAL address types. The IP address must be inside the specified subnetwork, if any.
         */
        address?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * Default: EXTERNAL
         *
         * The type of address to reserve, either INTERNAL or EXTERNAL.
         * If unspecified, defaults to EXTERNAL.
         */
        address_type?: "INTERNAL" | "EXTERNAL";
        /**
         * The URL of the subnetwork in which to reserve the address. If an IP address is specified, it must be within the subnetwork's IP range.
         * This field can only be used with INTERNAL type with GCE_ENDPOINT/DNS_RESOLVER purposes.
         */
        subnetwork?: {
          [k: string]: unknown;
        };
        /**
         * Name of the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Add, update and remove network ACL rules.
       */
      cs_network_acl_rule?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Gather facts about EC2 Elastic Load Balancers in AWS
       */
      elb_classic_lb_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Read the AWS documentation for WAF U(https://aws.amazon.com/documentation/waf/)
       */
      aws_waf_condition?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Configures MAC address pools and MAC address blocks on Cisco UCS Manager.
       * Examples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).
       */
      ucs_mac_pool?: {
        /**
         * The name of the MAC pool.
         * This name can be between 1 and 32 alphanumeric characters.
         * You cannot use spaces or any special characters other than - (hyphen), "_" (underscore), : (colon), and . (period).
         * You cannot change this name after the MAC pool is created.
         */
        name?: string;
        /**
         * The last MAC address in the block of addresses.
         * This is the To field in the UCS Manager Add MAC Blocks menu.
         */
        last_addr?: string;
        /**
         * Default: org-root
         *
         * The distinguished name (dn) of the organization where the resource is assigned.
         */
        org_dn?: string;
        /**
         * The first MAC address in the block of addresses.
         * This is the From field in the UCS Manager MAC Blocks menu.
         */
        first_addr?: string;
        /**
         * A description of the MAC pool.
         * Enter up to 256 characters.
         * You can use any characters or spaces except the following:
         * ` (accent mark),  (backslash), ^ (carat), " (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).
         */
        descrption?: string;
        /**
         * Default: present
         *
         * If C(present), will verify MAC pool is present and will create if needed.
         * If C(absent), will verify MAC pool is absent and will delete if needed.
         */
        state?: string;
        /**
         * Default: default
         *
         * The Assignment Order field.
         * This can be one of the following:
         * default - Cisco UCS Manager selects a random identity from the pool.
         * sequential - Cisco UCS Manager selects the lowest available identity from the pool.
         */
        order?: string;
        [k: string]: unknown;
      };
      /**
       * Manage contexts or VRFs on Cisco ACI fabrics.
       * Each context is a private network associated to a tenant, i.e. VRF.
       */
      aci_vrf?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Configure Sampled Flow (sFlow) to monitor traffic on an interface in real time, detect abnormal traffic, and locate the source of attack traffic, ensuring stable running of the network.
       */
      ce_sflow?: {
        /**
         * Configures the sFlow packets sent by the switch not to carry routing information.
         */
        export_route?: "enable" | "disable";
        /**
         * Specifies the source IPv4/IPv6 address of sFlow packets.
         */
        source_ip?: string;
        /**
         * Specifies the maximum length of sFlow packets sent from an sFlow agent to an sFlow collector. The value is an integer, in bytes. It ranges from 1024 to 8100. The default value is 1400.
         */
        collector_datagram_size?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Enables flow sampling in the inbound or outbound direction.
         */
        sample_direction?: "inbound" | "outbound" | "both";
        /**
         * Specifies the name of a VPN instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.
         */
        collector_ip_vpn?: string;
        /**
         * Enable the Embedded Network Processor (ENP) chip function. The switch uses the ENP chip to perform sFlow sampling, and the maximum sFlow sampling interval is 65535. If you set the sampling interval to be larger than 65535, the switch automatically restores it to 65535. The value is an integer or 'all'.
         */
        forward_enp_slot?: string;
        /**
         * Specifies the IPv4/IPv6 address of the sFlow collector.
         */
        collector_ip?: string;
        /**
         * Full name of interface for Flow Sampling or Counter. It must be a physical interface, Eth-Trunk, or Layer 2 subinterface.
         */
        sflow_interface?: string;
        /**
         * Configures the device to send sFlow packets through service interfaces, enhancing the sFlow packet forwarding capability. The enhanced parameter is optional. No matter whether you configure the enhanced mode, the switch determines to send sFlow packets through service cards or management port based on the routing information on the collector. When the value is meth, the device forwards sFlow packets at the control plane. When the value is enhanced, the device forwards sFlow packets at the forwarding plane to enhance the sFlow packet forwarding capacity.
         */
        collector_meth?: "meth" | "enhanced";
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * Specifies the ID of an sFlow collector. This ID is used when you specify the collector in subsequent sFlow configuration.
         */
        collector_id?: "1" | "2";
        /**
         * Indicates the counter sampling interval. The value is an integer that ranges from 10 to 4294967295, in seconds. The default value is 20.
         */
        counter_interval?: string;
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * Specifies the IPv4/IPv6 address of an sFlow agent.
         */
        agent_ip?: string;
        /**
         * Indicates the ID list of the counter collector.
         */
        counter_collector?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Specifies the slot where the rate of output sFlow packets is limited. If this parameter is not specified, the rate of sFlow packets sent from all cards to the control plane is limited. The value is an integer or a string of characters.
         */
        rate_limit_slot?: string;
        /**
         * Specifies the UDP destination port number of sFlow packets. The value is an integer that ranges from 1 to 65535. The default value is 6343.
         */
        collector_udp_port?: string;
        host?: string;
        /**
         * Indicates the ID list of the collector.
         */
        sample_collector?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        ssh_keyfile?: string;
        /**
         * Specifies the rate of sFlow packets sent from a card to the control plane. The value is an integer that ranges from 100 to 1500, in pps.
         */
        rate_limit?: string;
        /**
         * Specifies the maximum length of sampled packets. The value is an integer and ranges from 18 to 512, in bytes. The default value is 128.
         */
        sample_length?: string;
        /**
         * Specifies the flow sampling rate in the format 1/rate. The value is an integer and ranges from 1 to 4294967295. The default value is 8192.
         */
        sample_rate?: string;
        timeout?: number | string;
        /**
         * Specifies the description of an sFlow collector. The value is a string of 1 to 255 case-sensitive characters without spaces.
         */
        collector_description?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages UDLD interface configuration params.
       */
      nxos_udld_interface?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * Manages UDLD mode for an interface.
         */
        mode: "enabled" | "disabled" | "aggressive";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * FULL name of the interface, i.e. Ethernet1/1-
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * PanOS module that will commit firewall's candidate configuration on
       * the device. The new configuration will become active immediately.
       */
      panos_commit?: {
        username?: string;
        /**
         * Default: 0.5
         *
         * interval for checking commit job
         */
        interval?: string;
        /**
         * Default: yes
         *
         * if commit should be synchronous
         */
        sync?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * timeout for commit job
         */
        timeout?: string;
        password?: string;
        ip_address?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove a website on a Webfaction host.  Further documentation at https://github.com/quentinsf/ansible-webfaction.
       */
      webfaction_site?: {
        /**
         * A mapping of URLs to apps
         */
        site_apps?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Whether the website should exist
         */
        state?: "present" | "absent";
        /**
         * A list of subdomains associated with this site.
         */
        subdomains?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The webfaction host on which the site should be created.
         */
        host: string;
        /**
         * Default: no
         *
         * Whether or not to use HTTPS
         */
        https?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The webfaction password to use
         */
        login_password: string;
        /**
         * The webfaction account to use
         */
        login_name: string;
        /**
         * The name of the website
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Add, modify and delete an IPA DNS Record using IPA API.
       */
      ipa_dnsrecord?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Add or Remove load balancer from the OpenStack load-balancer service.
       */
      os_loadbalancer?: {
        /**
         * Name that has to be given to the load balancer
         */
        name?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * The name or id of the network for the virtual IP of the load balancer. One of vip_network, vip_subnet, or vip_port must be specified.
         */
        vip_network?: string;
        /**
         * Default: 180
         *
         * The amount of time the module should wait for the load balancer to get into ACTIVE state.
         */
        timeout?: string;
        /**
         * IP address of the load balancer virtual IP.
         */
        vip_address?: string;
        /**
         * The name or id of the subnet for the virtual IP of the load balancer. One of vip_network, vip_subnet, or vip_port must be specified.
         */
        vip_subnet?: string;
        /**
         * The name or id of the load balancer virtual IP port. One of vip_network, vip_subnet, or vip_port must be specified.
         */
        vip_port?: string;
        /**
         * Default: yes
         *
         * If the module should wait for the load balancer to be created.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to add, remove and update custom attributes for the given virtual machine.
       */
      vmware_guest_custom_attributes?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure CertificateManagementProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_certificatemanagementprofile?: {
        username?: string;
        /**
         * List of customparams.
         */
        script_params?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Script_path of certificatemanagementprofile.
         */
        script_path: string;
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Name of the pki profile.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create and delete snapshots images on snapshot groups for NetApp E-series storage arrays.
       * Only the oldest snapshot image can be deleted so consistency is preserved.
       * Related: Snapshot volumes are created from snapshot images.
       */
      netapp_e_snapshot_images?: {
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url?: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password?: string;
        /**
         * Whether a new snapshot image should be created or oldest be deleted.
         */
        state?: string;
        /**
         * The name of the snapshot group in which you want to create a snapshot image.
         */
        snapshot_group?: string;
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username?: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?: string;
        [k: string]: unknown;
      };
      /**
       * This module completes a given chain of certificates in PEM format by finding intermediate certificates from a given set of certificates, until it finds a root certificate in another given set of certificates.
       * This can for example be used to find the root certificate for a certificate chain returned by M(acme_certificate).
       * Note that this module does I(not) check for validity of the chains. It only checks that issuer and subject match, and that the signature is correct. It ignores validity dates and key usage completely. If you need to verify that a generated chain is valid, please use C(openssl verify ...).
       */
      certificate_complete_chain?: {
        /**
         * A list of filenames or directories.
         * A filename is assumed to point to a file containing one or more certificates in PEM format. All certificates in this file will be added to the set of root certificates.
         * If a directory name is given, all files in the directory and its subdirectories will be scanned and tried to be parsed as concatenated certificates in PEM format.
         * Symbolic links will be followed.
         */
        root_certificates:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A list of filenames or directories.
         * A filename is assumed to point to a file containing one or more certificates in PEM format. All certificates in this file will be added to the set of root certificates.
         * If a directory name is given, all files in the directory and its subdirectories will be scanned and tried to be parsed as concatenated certificates in PEM format.
         * Symbolic links will be followed.
         */
        intermediate_certificates?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A concatenated set of certificates in PEM format forming a chain.
         * The module will try to complete this chain.
         */
        input_chain: string;
        [k: string]: unknown;
      };
      /**
       * Adds XML fragments formatted as strings to existing XML on remote servers.
       */
      win_xml?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Creates a maintenance window for status.io
       * Deletes a maintenance window for status.io
       */
      statusio_maintenance?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Use this module to manage order of boot devices
       */
      ipmi_boot?: {
        /**
         * Set boot device to use on next reboot
         */
        bootdev: "network" | "hd" | "floppy" | "safe" | "optical" | "setup" | "default";
        /**
         * Hostname or ip address of the BMC.
         */
        name: string;
        /**
         * Default: no
         *
         * If set, ask that system firmware uses this device beyond next boot. Be aware many systems do not honor this.
         */
        persistent?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * If set, request UEFI boot explicitly. Strictly speaking, the spec suggests that if not set, the system should BIOS boot and offers no "don't care" option. In practice, this flag not being set does not preclude UEFI boot on any system I've encountered.
         */
        uefiboot?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Whether to ensure that boot devices is desired.
         */
        state?: "present" | "absent";
        /**
         * Username to use to connect to the BMC.
         */
        user: string;
        /**
         * Password to connect to the BMC.
         */
        password: string;
        /**
         * Default: 623
         *
         * Remote RMCP port.
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP Network
       */
      gcp_compute_network_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Create, update and remove ssh keys.
       */
      vultr_ssh_key?: {
        api_retries?: number | string;
        /**
         * Name of the ssh key.
         */
        name: string;
        api_timeout?: number | string;
        /**
         * SSH public key.
         * Required if C(state=present).
         */
        ssh_key?: string;
        api_endpoint?: string;
        /**
         * Default: present
         *
         * State of the ssh key.
         */
        state?: "present" | "absent";
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Allows you to create/delete/stop Qemu(KVM) Virtual Machines in Proxmox VE cluster.
       */
      proxmox_kvm?: {
        /**
         * Target storage for full clone.
         */
        storage?: string;
        /**
         * Allow to force stop VM.
         * Can be used only with states C(stopped), C(restarted).
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Revert a pending change.
         */
        revert?: string;
        /**
         * A hash/dictionaries of NUMA topology. C(numa='{"key":"value", "key":"value"}').
         * Keys allowed are - C(numa[n]) where 0  n  N.
         * Values allowed are - C("cpu="<id[-id];...>",hostnodes="<id[-id];...>",memory="number",policy="(bind|interleave|preferred)"").
         * C(cpus) CPUs accessing this NUMA node.
         * C(hostnodes) Host NUMA nodes to use.
         * C(memory) Amount of memory this NUMA node provides.
         * C(policy) NUMA allocation policy.
         */
        numa?: {
          [k: string]: unknown;
        };
        /**
         * Specifies the SCSI controller model.
         */
        scsihw?: "lsi" | "lsi53c810" | "virtio-scsi-pci" | "virtio-scsi-single" | "megasas" | "pvscsi";
        /**
         * Startup and shutdown behavior. C([[order=]\d+] [,up=\d+] [,down=\d+]).
         * Order is a non-negative number defining the general startup order.
         * Shutdown in done with reverse ordering.
         */
        startup?: string;
        /**
         * Sets maximum speed (in MB/s) for migrations.
         * A value of 0 is no limit.
         */
        migrate_speed?: number | string;
        /**
         * Specify if PVE should freeze CPU at startup (use 'c' monitor command to start execution).
         */
        freeze?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Create a full copy of all disk. This is always done when you clone a normal VM.
         * For VM templates, we try to create a linked clone by default.
         * Used only with clone
         */
        full?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Sets the keyboard layout for VNC server.
         */
        keyboard?: string;
        /**
         * Ignore locks
         * Only root is allowed to use this option.
         */
        skiplock?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Creates a virtual hardware watchdog device.
         */
        watchdog?: string;
        /**
         * A hash/dictionary of serial device to create inside the VM. C('{"key":"value", "key":"value"}').
         * Keys allowed are - serial[n](str; required) where 0  n  3.
         * Values allowed are - C((/dev/.+|socket)).
         * /!\ If you pass through a host serial device, it is no longer possible to migrate such machines - use with special care.
         */
        serial?: {
          [k: string]: unknown;
        };
        numa_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * Sets the number of CPU sockets. (1 - N).
         */
        sockets?: number | string;
        /**
         * Specify if to prevent changes if current configuration file has different SHA1 digest.
         * This can be used to prevent concurrent modifications.
         */
        digest?: string;
        /**
         * Specify the description for the VM. Only used on the configuration web interface.
         * This is saved as comment inside the configuration file.
         */
        description?: string;
        /**
         * Sets the initial date of the real time clock.
         * Valid format for date are C('now') or C('2016-09-25T16:01:21') or C('2016-09-25').
         */
        startdate?: string;
        /**
         * Default: no
         *
         * Enables/disables the USB tablet device.
         */
        tablet?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the BIOS implementation.
         */
        bios?: "seabios" | "ovmf";
        /**
         * Default: kvm64
         *
         * Specify emulated CPU type.
         */
        cpu?: string;
        /**
         * Specify the amount of RAM for the VM in MB.
         * Using zero disables the balloon driver.
         */
        balloon?: number | string;
        /**
         * Default: qcow2
         *
         * Target drive's backing file's data format.
         * Used only with clone
         */
        format?: "cloop" | "cow" | "qcow" | "qcow2" | "qed" | "raw" | "vmdk";
        /**
         * Default: cnd
         *
         * Specify the boot order -> boot on floppy C(a), hard disk C(c), CD-ROM C(d), or network C(n).
         * You can combine to set order.
         */
        boot?: string;
        /**
         * Default: std
         *
         * Select VGA type. If you want to use high resolution modes (>= 1280x1024x16) then you should use option 'std' or 'vmware'.
         */
        vga?:
          | "std"
          | "cirrus"
          | "vmware"
          | "qxl"
          | "serial0"
          | "serial1"
          | "serial2"
          | "serial3"
          | "qxl2"
          | "qxl3"
          | "qxl4";
        /**
         * Rets amount of memory shares for auto-ballooning. (0 - 50000).
         * The larger the number is, the more memory this VM gets.
         * The number is relative to weights of all other running VMs.
         * Using 0 disables auto-ballooning, this means no limit.
         */
        shares?: number | string;
        /**
         * Specifies the Qemu machine type.
         * type => C((pc|pc(-i440fx)?-\d+\.\d+(\.pxe)?|q35|pc-q35-\d+\.\d+(\.pxe)?))
         */
        machine?: string;
        /**
         * Specify a hash/dictionary of map host pci devices into guest. C(hostpci='{"key":"value", "key":"value"}').
         * Keys allowed are - C(hostpci[n]) where 0  n  N.
         * Values allowed are -  C("host="HOSTPCIID[;HOSTPCIID2...]",pcie="1|0",rombar="1|0",x-vga="1|0"").
         * The C(host) parameter is Host PCI device pass through. HOSTPCIID syntax is C(bus:dev.func) (hexadecimal numbers).
         * C(pcie=boolean) I(default=0) Choose the PCI-express bus (needs the q35 machine model).
         * C(rombar=boolean) I(default=1) Specify whether or not the device's ROM will be visible in the guest's memory map.
         * C(x-vga=boolean) I(default=0) Enable vfio-vga device support.
         * /!\ This option allows direct access to host hardware. So it is no longer possible to migrate such machines - use with special care.
         */
        hostpci?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Indicates desired state of the instance.
         * If C(current), the current state of the VM will be fecthed. You can access it with C(results.status)
         */
        state?: "present" | "started" | "absent" | "stopped" | "restarted" | "current";
        /**
         * Default: no
         *
         * Specify if the VM should be automatically restarted after crash (currently ignored in PVE API).
         */
        autostart?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 512
         *
         * Memory size in MB for instance.
         */
        memory?: number | string;
        /**
         * A hash/dictionary of network interfaces for the VM. C(net='{"key":"value", "key":"value"}').
         * Keys allowed are - C(net[n]) where 0  n  N.
         * Values allowed are - C("model="XX:XX:XX:XX:XX:XX",brigde="value",rate="value",tag="value",firewall="1|0",trunks="vlanid"").
         * Model is one of C(e1000 e1000-82540em e1000-82544gc e1000-82545em i82551 i82557b i82559er ne2k_isa ne2k_pci pcnet rtl8139 virtio vmxnet3).
         * C(XX:XX:XX:XX:XX:XX) should be an unique MAC address. This is automatically generated if not specified.
         * The C(bridge) parameter can be used to automatically add the interface to a bridge device. The Proxmox VE standard bridge is called 'vmbr0'.
         * Option C(rate) is used to limit traffic bandwidth from and to this interface. It is specified as floating point number, unit is 'Megabytes per second'.
         * If you specify no bridge, we create a kvm 'user' (NATed) network device, which provides DHCP and DNS services.
         */
        net?: {
          [k: string]: unknown;
        };
        /**
         * Target node. Only allowed if the original VM is on shared storage.
         * Used only with clone
         */
        target?: string;
        /**
         * Sets maximum tolerated downtime (in seconds) for migrations.
         */
        migrate_downtime?: number | string;
        /**
         * Sets the real time clock to local time.
         * This is enabled by default if ostype indicates a Microsoft OS.
         */
        localtime?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Proxmox VE node, where the new VM will be created.
         * Only required for C(state=present).
         * For other states, it will be autodiscovered.
         */
        node?: string;
        /**
         * Specify if the QEMU Guest Agent should be enabled/disabled.
         */
        agent?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A hash/dictionary of volume used as VIRTIO hard disk. C(virtio='{"key":"value", "key":"value"}').
         * Keys allowed are - C(virto[n]) where 0  n  15.
         * Values allowed are -  C("storage:size,format=value").
         * C(storage) is the storage identifier where to create the disk.
         * C(size) is the size of the disk in GB.
         * C(format) is the drive's backing file's data format. C(qcow2|raw|subvol).
         */
        virtio?: {
          [k: string]: unknown;
        };
        /**
         * Default: no
         *
         * Enables/disables the template.
         */
        template?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1000
         *
         * Specify CPU weight for a VM.
         * You can disable fair-scheduler configuration by setting this to 0
         */
        cpuunits?: number | string;
        /**
         * Name of VM to be cloned. If C(vmid) is setted, C(clone) can take arbitrary value but required for intiating the clone.
         */
        clone?: string;
        /**
         * Default: -serial unix:/var/run/qemu-server/VMID.serial,server,nowait
         *
         * Pass arbitrary arguments to kvm.
         * This option is for experts only!
         */
        args?: string;
        /**
         * Specify the password to authenticate with.
         * You can use C(PROXMOX_PASSWORD) environment variable.
         */
        api_password?: string;
        /**
         * The name of the snapshot. Used only with clone.
         */
        snapname?: string;
        /**
         * Enables/disables time drift fix.
         */
        tdf?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Enable/disable KVM hardware virtualization.
         */
        kvm?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A hash/dictionary of volume used as sata hard disk or CD-ROM. C(sata='{"key":"value", "key":"value"}').
         * Keys allowed are - C(sata[n]) where 0  n  5.
         * Values allowed are -  C("storage:size,format=value").
         * C(storage) is the storage identifier where to create the disk.
         * C(size) is the size of the disk in GB.
         * C(format) is the drive's backing file's data format. C(qcow2|raw|subvol).
         */
        sata?: {
          [k: string]: unknown;
        };
        /**
         * Enable/disable the protection flag of the VM. This will enable/disable the remove VM and remove disk operations.
         */
        protection?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Allow reboot. If set to C(yes), the VM exit on reboot.
         */
        reboot?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Selectively enable hotplug features.
         * This is a comma separated list of hotplug features C('network', 'disk', 'cpu', 'memory' and 'usb').
         * Value 0 disables hotplug completely and value 1 is an alias for the default C('network,disk,usb').
         */
        hotplug?: string;
        /**
         * Specify the user to authenticate with.
         */
        api_user: string;
        /**
         * A hash/dictionary of map host parallel devices. C(parallel='{"key":"value", "key":"value"}').
         * Keys allowed are - (parallel[n]) where 0  n  2.
         * Values allowed are - C("/dev/parport\d+|/dev/usb/lp\d+").
         */
        parallel?: {
          [k: string]: unknown;
        };
        /**
         * Add the new VM to the specified pool.
         */
        pool?: string;
        /**
         * Specify the target host of the Proxmox VE cluster.
         */
        api_host: string;
        /**
         * Lock/unlock the VM.
         */
        lock?: "migrate" | "backup" | "snapshot" | "rollback";
        /**
         * Specify if CPU usage will be limited. Value 0 indicates no CPU limit.
         * If the computer has 2 CPUs, it has total of '2' CPU time
         */
        cpulimit?: number | string;
        /**
         * Specifies the VM name. Only used on the configuration web interface.
         * Required only for C(state=present).
         */
        name?: string;
        /**
         * Default: no
         *
         * If C(yes), the VM will be update with new value.
         * Cause of the operations of the API and security reasons, I have disabled the update of the following parameters
         * C(net, virtio, ide, sata, scsi). Per example updating C(net) update the MAC address and C(virtio) create always new disk...
         */
        update?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies the VM ID. Instead use I(name) parameter.
         * If vmid is not set, the next available VM ID will be fetched from ProxmoxAPI.
         */
        vmid?: number | string;
        /**
         * Enable/disable hugepages memory.
         */
        hugepages?: "any" | "2" | "1024";
        /**
         * Enable booting from specified disk. C((ide|sata|scsi|virtio)\d+)
         */
        bootdisk?: string;
        /**
         * Default: yes
         *
         * Specify if ACPI should be enabled/disabled.
         */
        acpi?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Sets number of hotplugged vcpus.
         */
        vcpus?: number | string;
        /**
         * VMID for the clone. Used only with clone.
         * If newid is not set, the next available VM ID will be fetched from ProxmoxAPI.
         */
        newid?: number | string;
        /**
         * Default: 30
         *
         * Timeout for operations.
         */
        timeout?: number | string;
        /**
         * Specifies SMBIOS type 1 fields.
         */
        smbios?: string;
        /**
         * Default: l26
         *
         * Specifies guest operating system. This is used to enable special optimization/features for specific operating systems.
         * The l26 is Linux 2.6/3.X Kernel.
         */
        ostype?: "other" | "wxp" | "w2k" | "w2k3" | "w2k8" | "wvista" | "win7" | "win8" | "l24" | "l26" | "solaris";
        /**
         * Default: 1
         *
         * Specify number of cores per socket.
         */
        cores?: number | string;
        /**
         * A hash/dictionary of volume used as SCSI hard disk or CD-ROM. C(scsi='{"key":"value", "key":"value"}').
         * Keys allowed are - C(sata[n]) where 0  n  13.
         * Values allowed are -  C("storage:size,format=value").
         * C(storage) is the storage identifier where to create the disk.
         * C(size) is the size of the disk in GB.
         * C(format) is the drive's backing file's data format. C(qcow2|raw|subvol).
         */
        scsi?: {
          [k: string]: unknown;
        };
        /**
         * A hash/dictionary of volume used as IDE hard disk or CD-ROM. C(ide='{"key":"value", "key":"value"}').
         * Keys allowed are - C(ide[n]) where 0  n  3.
         * Values allowed are - C("storage:size,format=value").
         * C(storage) is the storage identifier where to create the disk.
         * C(size) is the size of the disk in GB.
         * C(format) is the drive's backing file's data format. C(qcow2|raw|subvol).
         */
        ide?: {
          [k: string]: unknown;
        };
        /**
         * Default: no
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Specifies whether a VM will be started during system bootup.
         */
        onboot?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify a list of settings you want to delete.
         */
        delete?: string;
        [k: string]: unknown;
      };
      /**
       * Create or delete AWS Dynamo DB tables.
       * Can update the provisioned throughput on existing tables.
       * Returns the status of the specified table.
       */
      dynamodb_table?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and delete instance of Firewall Rule.
       */
      azure_rm_sqlfirewallrule?: {
        profile?: string;
        /**
         * The start IP address of the firewall rule. Must be IPv4 format. Use value C(0.0.0.0) to represent all Azure-internal IP addresses.
         */
        start_ip_address?: string;
        /**
         * The name of the firewall rule.
         */
        name: string;
        /**
         * The name of the server.
         */
        server_name: string;
        cloud_environment?: string;
        /**
         * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
         */
        resource_group: string;
        ad_user?: string;
        secret?: string;
        /**
         * Default: present
         *
         * Assert the state of the SQL Database. Use 'present' to create or update an SQL Database and 'absent' to delete it.
         */
        state?: "absent" | "present";
        tenant?: string;
        client_id?: string;
        cert_validation_mode?: "validate" | "ignore";
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        /**
         * The end IP address of the firewall rule. Must be IPv4 format. Must be greater than or equal to startIpAddress. Use value C(0.0.0.0) to represe nt all Azure-internal IP addresses.
         */
        end_ip_address?: string;
        api_profile?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about the Scaleway snapshot available.
       */
      scaleway_snapshot_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Use facts to create ad-hoc groups that can be used later in a playbook.
       * This module is also supported for Windows targets.
       */
      group_by?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manages F5 BIG-IP GTM https monitors.
       */
      bigip_gtm_monitor_https?: {
        /**
         * Default: always
         *
         * C(always) will update passwords if the C(target_password) is specified.
         * C(on_create) will only set the password for newly created monitors.
         */
        update_password?: string;
        /**
         * Specifies the list of ciphers for this monitor.
         * The items in the cipher list are separated with the colon C(:) symbol.
         * When creating a new monitor, if this parameter is not specified, the default list is C(DEFAULT:+SHA:+3DES:+kEDH).
         */
        cipher_list?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Instructs the system to mark the target resource down when the test is successful. This setting is useful, for example, if the content on your web site home page is dynamic and changes frequently, you may want to set up a reverse ECV service check that looks for the string Error.
         * A match for this string means that the web server was down.
         * To use this option, you must specify values for C(send) and C(receive).
         */
        reverse?: string;
        /**
         * Default: /Common/https
         *
         * The parent template of this monitor template. Once this value has been set, it cannot be changed. By default, this value is the C(tcp) parent on the C(Common) partition.
         */
        parent?: string;
        /**
         * The receive string for the monitor call.
         */
        receive?: string;
        /**
         * IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
         * If this value is an IP address, then a C(port) number must be specified.
         */
        ip?: string;
        /**
         * The interval specifying how frequently the monitor instance of this template will run.
         * If this parameter is not provided when creating a new monitor, then the default value will be 30.
         * This value B(must) be less than the C(timeout) value.
         */
        interval?: string;
        /**
         * The send string for the monitor call.
         * When creating a new monitor, if this parameter is not provided, the default of C(GET /\r\n) will be used.
         */
        send?: string;
        /**
         * Specifies, when enabled, that the SSL options setting (in OpenSSL) is set to B(all).
         * When creating a new monitor, if this value is not specified, the default is C(yes)
         */
        compatibility?: string;
        /**
         * Specifies the user name, if the monitored target requires authentication.
         */
        target_username?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the monitor exists.
         * When C(absent), ensures the monitor is removed.
         */
        state?: string;
        /**
         * Specifies that the monitor allows more than one probe attempt per interval.
         * When C(yes), specifies that the monitor ignores down responses for the duration of the monitor timeout. Once the monitor timeout is reached without the system receiving an up response, the system marks the object down.
         * When C(no), specifies that the monitor immediately marks an object down when it receives a down response.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(no).
         */
        ignore_down_response?: string;
        /**
         * The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second.
         * If this parameter is not provided when creating a new monitor, then the default value will be 120.
         */
        timeout?: string;
        /**
         * Specifies a fully-qualified path for a client certificate that the monitor sends to the target SSL server.
         */
        client_cert?: string;
        /**
         * Specifies the password, if the monitored target requires authentication.
         */
        target_password?: string;
        /**
         * Specifies the number of seconds after which the system times out the probe request to the system.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(5).
         */
        probe_timeout?: string;
        /**
         * Monitor name.
         */
        name?: string;
        /**
         * Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.
         */
        port?: string;
        /**
         * Specifies whether the monitor operates in transparent mode.
         * A monitor in transparent mode directs traffic through the associated pool members or nodes (usually a router or firewall) to the aliased destination (that is, it probes the C(ip)-C(port) combination specified in the monitor).
         * If the monitor cannot successfully reach the aliased destination, the pool member or node through which the monitor traffic was sent is marked down.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(no).
         */
        transparent?: string;
        /**
         * Specifies a key for a client certificate that the monitor sends to the target SSL server.
         */
        client_key?: string;
        [k: string]: unknown;
      };
      /**
       * This module will let you start and pause Uptime Robot Monitoring
       */
      uptimerobot?: {
        /**
         * ID of the monitor to check.
         */
        monitorid: string;
        /**
         * Define whether or not the monitor should be running or paused.
         */
        state: "started" | "paused";
        /**
         * Uptime Robot API key.
         */
        apikey: string;
        [k: string]: unknown;
      };
      /**
       * Management of LXD profiles
       */
      lxd_profile?: {
        /**
         * A new name of a profile.
         * If this parameter is specified a profile will be renamed to this name. See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-11)
         */
        new_name?: string;
        /**
         * Description of the profile.
         */
        description?: string;
        /**
         * Default: unix:/var/lib/lxd/unix.socket
         *
         * The unix domain socket path or the https URL for the LXD server.
         */
        url?: string;
        /**
         * The config for the container (e.g. {"limits.memory": "4GB"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)
         * If the profile already exists and its "config" value in metadata obtained from GET /1.0/profiles/<name> U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#get-19) are different, they this module tries to apply the configurations.
         * Not all config values are supported to apply the existing profile. Maybe you need to delete and recreate a profile.
         */
        config?: {
          [k: string]: unknown;
        };
        /**
         * Default: "{}/.config/lxc/client.crt" .format(os.environ["HOME"])
         *
         * The client certificate file path.
         */
        cert_file?: string;
        /**
         * The devices for the profile (e.g. {"rootfs": {"path": "/dev/kvm", "type": "unix-char"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)
         */
        devices?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Define the state of a profile.
         */
        state?: "present" | "absent";
        /**
         * Default: "{}/.config/lxc/client.key" .format(os.environ["HOME"])
         *
         * The client certificate key file path.
         */
        key_file?: string;
        /**
         * The client trusted password.
         * You need to set this password on the LXD server before running this module using the following command. lxc config set core.trust_password <some random password> See U(https://www.stgraber.org/2016/04/18/lxd-api-direct-interaction/)
         * If trust_password is set, this module send a request for authentication before sending any requests.
         */
        trust_password?: string;
        /**
         * Name of a profile.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure SSLProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_sslprofile?: {
        /**
         * Prefer the ssl cipher ordering presented by the client during the ssl handshake over the one specified in the ssl profile.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        prefer_client_cipher_ordering?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set of versions accepted by the server.
         */
        accepted_versions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The amount of time before an ssl session expires.
         * Default value when not specified in API or module is interpreted by Avi Controller as 86400.
         * Units(SEC).
         */
        ssl_session_timeout?: number | string;
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Enable ssl session re-use.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        enable_ssl_session_reuse?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Send 'close notify' alert message for a clean shutdown of the ssl connection.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        send_close_notify?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tenant?: string;
        /**
         * Dh parameters used in ssl.
         * At this time, it is not configurable and is set to 2048 bits.
         */
        dhparam?: string;
        /**
         * Ssl profile type.
         * Enum options - SSL_PROFILE_TYPE_APPLICATION, SSL_PROFILE_TYPE_SYSTEM.
         * Field introduced in 17.2.8.
         * Default value when not specified in API or module is interpreted by Avi Controller as SSL_PROFILE_TYPE_APPLICATION.
         */
        type?: string;
        api_version?: string;
        username?: string;
        /**
         * Ciphers suites represented as defined by U(http://www.openssl.org/docs/apps/ciphers.html).
         * Default value when not specified in API or module is interpreted by Avi Controller as AES:3DES:RC4.
         */
        accepted_ciphers?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * List of tag.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        controller?: string;
        /**
         * Enum options - tls_ecdhe_ecdsa_with_aes_128_gcm_sha256, tls_ecdhe_ecdsa_with_aes_256_gcm_sha384, tls_ecdhe_rsa_with_aes_128_gcm_sha256,
         * tls_ecdhe_rsa_with_aes_256_gcm_sha384, tls_ecdhe_ecdsa_with_aes_128_cbc_sha256, tls_ecdhe_ecdsa_with_aes_256_cbc_sha384,
         * tls_ecdhe_rsa_with_aes_128_cbc_sha256, tls_ecdhe_rsa_with_aes_256_cbc_sha384, tls_rsa_with_aes_128_gcm_sha256, tls_rsa_with_aes_256_gcm_sha384,
         * tls_rsa_with_aes_128_cbc_sha256, tls_rsa_with_aes_256_cbc_sha256, tls_ecdhe_ecdsa_with_aes_128_cbc_sha, tls_ecdhe_ecdsa_with_aes_256_cbc_sha,
         * tls_ecdhe_rsa_with_aes_128_cbc_sha, tls_ecdhe_rsa_with_aes_256_cbc_sha, tls_rsa_with_aes_128_cbc_sha, tls_rsa_with_aes_256_cbc_sha,
         * tls_rsa_with_3des_ede_cbc_sha, tls_rsa_with_rc4_128_sha.
         */
        cipher_enums?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Name of the object.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Sslrating settings for sslprofile.
         */
        ssl_rating?: {
          [k: string]: unknown;
        };
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Create or delete a Rackspace Cloud Monitoring check associated with an existing rax_mon_entity. A check is a specific test or measurement that is performed, possibly from different monitoring zones, on the systems you monitor. Rackspace monitoring module flow | rax_mon_entity -> *rax_mon_check* -> rax_mon_notification -> rax_mon_notification_plan -> rax_mon_alarm
       */
      rax_mon_check?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage ACI Fiber Channel interface policies on Cisco ACI fabrics.
       */
      aci_interface_policy_fc?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Create or destroy or rename export-policies on ONTAP
       */
      na_ontap_export_policy?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module uses rabbitMQ REST APIs to create / delete bindings.
       */
      rabbitmq_binding?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module provides declarative management of link aggregation groups on VyOS network devices.
       */
      vyos_linkagg?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Name of the link aggregation group.
         */
        name?: string;
        /**
         * Default: present
         *
         * State of the link aggregation group.
         */
        state?: "present" | "absent" | "up" | "down";
        /**
         * List of members of the link aggregation group.
         */
        members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        /**
         * Mode of the link aggregation group.
         */
        mode?:
          | "802.3ad"
          | "active-backup"
          | "broadcast"
          | "round-robin"
          | "transmit-load-balance"
          | "adaptive-load-balance"
          | "xor-hash"
          | "on";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of link aggregation definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages VLAN configurations on NX-OS switches.
       */
      nxos_vlan?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vlan interfaces on device it will result in failure.
         */
        associated_interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        /**
         * Single VLAN ID.
         */
        vlan_id?: number | string;
        /**
         * Range of VLANs such as 2-10 or 2,5,10-15, etc.
         */
        vlan_range?: string;
        auth_pass?: string;
        /**
         * Default: 10
         *
         * Time in seconds to wait before checking for the operational state on remote device. This wait is applicable for operational state arguments.
         */
        delay?: number | string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        transport?: "cli" | "nxapi";
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * Default: active
         *
         * Manage the vlan operational state of the VLAN
         */
        vlan_state?: "active" | "suspend";
        /**
         * List of interfaces that should be associated to the VLAN or keyword 'default'.
         */
        interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        /**
         * Default: up
         *
         * Manage the VLAN administrative state of the VLAN equivalent to shut/no shut in VLAN config mode.
         */
        admin_state?: "up" | "down";
        /**
         * List of VLANs definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        ssh_keyfile?: string;
        /**
         * Name of VLAN or keyword 'default'.
         */
        name?: string;
        /**
         * The Virtual Network Identifier (VNI) ID that is mapped to the VLAN. Valid values are integer and keyword 'default'. Range 4096-16773119.
         */
        mapped_vni?: string;
        /**
         * Default: no
         *
         * Purge VLANs not defined in the I(aggregate) parameter. This parameter can be used without aggregate as well.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set VLAN mode to classical ethernet or fabricpath. This is a valid option for Nexus 5000 and 7000 series.
         */
        mode?: "ce" | "fabricpath";
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages interface specific VRF configuration.
       */
      nxos_vrf_interface?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manages desired state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * Name of VRF to be managed.
         */
        vrf: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Full name of interface to be managed, i.e. Ethernet1/1.
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Manages configuration of an ospf instance.
       */
      nxos_ospf?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Name of the ospf instance.
         */
        ospf: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Allow the user to configure several of the global settings associated with an E-Series storage-system
       */
      netapp_e_global?: {
        [k: string]: unknown;
      };
      /**
       * Notify BigPanda when deployments start and end (successfully or not). Returns a deployment object containing all the parameters for future module calls.
       */
      bigpanda?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about an ESXi host's firewall configuration information when ESXi hostname or Cluster name is given.
       */
      vmware_host_firewall_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage the checks that should be run on a machine by I(Sensu).
       * Most options do not have a default and will not be added to the check definition unless specified.
       * All defaults except I(path), I(state), I(backup) and I(metric) are not managed by this module,
       * they are simply specified for your convenience.
       */
      sensu_check?: {
        /**
         * Default: no
         *
         * Whether the check is a metric
         */
        metric?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * When to disable handling of check failures
         */
        subdue_begin?: string;
        /**
         * Default: 1
         *
         * Number of event occurrences before the handler should take action
         */
        occurrences?: number | string;
        /**
         * The low threshold for flap detection
         */
        low_flap_threshold?: number | string;
        /**
         * Time to live in seconds until the check is considered stale
         */
        ttl?: number | string;
        /**
         * List of handlers to notify when the check fails
         */
        handlers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: yes
         *
         * Whether the check should be scheduled at all.
         * You can still issue it via the sensu api
         */
        publish?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A hash/dictionary of custom parameters for mixing to the configuration.
         * You can't rewrite others module parameters using this
         */
        custom?: {
          [k: string]: unknown;
        };
        /**
         * The check source, used to create a JIT Sensu client for an external resource (e.g. a network switch).
         */
        source?: string;
        /**
         * Default: present
         *
         * Whether the check should be present or not
         */
        state?: "present" | "absent";
        /**
         * When to enable handling of check failures
         */
        subdue_end?: string;
        /**
         * Default: yes
         *
         * Whether the check should be handled or not
         */
        handle?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Other checks this check depends on, if dependencies fail,
         * handling of this check will be disabled
         */
        dependencies?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List of subscribers/channels this check should run for
         * See sensu_subscribers to subscribe a machine to a channel
         */
        subscribers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: no
         *
         * Classifies the check as an aggregate check,
         * making it available via the aggregate API
         */
        aggregate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: /etc/sensu/conf.d/checks.json
         *
         * Path to the json file of the check to be added/removed.
         * Will be created if it does not exist (unless I(state=absent)).
         * The parent folders need to exist when I(state=present), otherwise an error will be thrown
         */
        path?: string;
        /**
         * The name of the check
         * This is the key that is used to determine whether a check exists
         */
        name: string;
        /**
         * Default: no
         *
         * Whether the check should be scheduled by the sensu client or server
         * This option obviates the need for specifying the I(subscribers) option
         */
        standalone?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Check interval in seconds
         */
        interval?: number | string;
        /**
         * Number of seconds handlers should wait before taking second action
         */
        refresh?: number | string;
        /**
         * Path to the sensu check to run (not required when I(state=absent))
         */
        command?: string;
        /**
         * The high threshold for flap detection
         */
        high_flap_threshold?: number | string;
        /**
         * Default: 10
         *
         * Timeout for the check
         */
        timeout?: number | string;
        /**
         * Default: no
         *
         * Create a backup file (if yes), including the timestamp information so
         * you can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module can be used for updating the password of a user.
       * This module is useful for setting up admin password for Controller bootstrap.
       */
      avi_useraccount?: {
        username?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Old password for update password or default password for bootstrap.
         */
        old_password: string;
        controller?: string;
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        [k: string]: unknown;
      };
      /**
       * Manage I(bzr) branches to deploy files or software.
       */
      bzr?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module controls the VDO dedupe and compression device. VDO, or Virtual Data Optimizer, is a device-mapper target that provides inline block-level deduplication, compression, and thin provisioning capabilities to primary storage.
       */
      vdo?: {
        /**
         * The "activate" status for a VDO volume.  If this is set to "no", the VDO volume cannot be started, and it will not start on system startup.  However, on initial creation, a VDO volume with "activated" set to "off" will be running, until stopped.  This is the default behavior of the "vdo create" command; it provides the user an opportunity to write a base amount of metadata (filesystem, LVM headers, etc.) to the VDO volume prior to stopping the volume, and leaving it deactivated until ready to use.
         */
        activated?: "yes" | "no";
        /**
         * Enables 512-byte emulation mode, allowing drivers or filesystems to access the VDO volume at 512-byte granularity, instead of the default 4096-byte granularity. Default is 'disabled'; only recommended when a driver or filesystem requires 512-byte sector level access to a device.  This option is only available when creating a new volume, and cannot be changed for an existing volume.
         */
        emulate512?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies the amount of index memory in gigabytes.  The default is 0.25.  The special decimal values 0.25, 0.5, and 0.75 can be used, as can any positive integer. This option is only available when creating a new volume, and cannot be changed for an existing volume.
         */
        indexmem?: string;
        /**
         * The amount of memory allocated for caching block map pages, in megabytes (or may be issued with an LVM-style suffix of K, M, G, or T).  The default (and minimum) value is 128M.  The value specifies the size of the cache; there is a 15% memory usage overhead. Each 1.25G of block map covers 1T of logical blocks, therefore a small amount of block map cache memory can cache a significantly large amount of block map data.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
         */
        blockmapcachesize?: string;
        /**
         * Specifies the write policy of the VDO volume.  The 'sync' mode acknowledges writes only after data is on stable storage.  The 'async' mode acknowledges writes when data has been cached for writing to stable storage.  The default (and highly recommended) 'auto' mode checks the storage device to determine whether it supports flushes.  Devices that support flushes will result in a VDO volume in 'async' mode, while devices that do not support flushes will run in sync mode. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
         */
        writepolicy?: "auto" | "sync" | "async";
        /**
         * Configures whether compression is enabled.  The default for a created volume is 'enabled'.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
         */
        compression?: "enabled" | "disabled";
        /**
         * Configures whether deduplication is enabled.  The default for a created volume is 'enabled'.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
         */
        deduplication?: "enabled" | "disabled";
        /**
         * Whether this VDO volume should be "present" or "absent". If a "present" VDO volume does not exist, it will be created.  If a "present" VDO volume already exists, it will be modified, by updating the configuration, which will take effect when the VDO volume is restarted. Not all parameters of an existing VDO volume can be modified; the "statusparamkeys" list contains the parameters that can be modified after creation. If an "absent" VDO volume does not exist, it will not be removed.
         */
        state?: "present" | "absent";
        /**
         * The logical size of the VDO volume (in megabytes, or LVM suffix format).  If not specified for a new volume, this defaults to the same size as the underlying storage device, which is specified in the 'device' parameter. Existing volumes will maintain their size if the logicalsize parameter is not specified, or is smaller than or identical to the current size.  If the specified size is larger than the current size, a growlogical operation will be performed.
         */
        logicalsize?: string;
        /**
         * Specifies the extra VDO device read cache size in megabytes.  This is in addition to a system-defined minimum.  Using a value with a suffix of K, M, G, or T is optional.  The default value is 0.  1.125 MB of memory per bio thread will be used per 1 MB of read cache specified (for example, a VDO volume configured with 4 bio threads will have a read cache memory usage overhead of 4.5 MB per 1 MB of read cache specified). Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
         */
        readcachesize?: string;
        /**
         * Specifies the number of threads to use for acknowledging completion of requested VDO I/O operations. Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
         */
        ackthreads?: string;
        /**
         * Specifies the number of threads to use for submitting I/O operations to the storage device.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 4. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
         */
        biothreads?: string;
        /**
         * Specifies the index mode of the Albireo index.  The default is 'dense', which has a deduplication window of 1 GB of index memory per 1 TB of incoming data, requiring 10 GB of index data on persistent storage. The 'sparse' mode has a deduplication window of 1 GB of index memory per 10 TB of incoming data, but requires 100 GB of index data on persistent storage.  This option is only available when creating a new volume, and cannot be changed for an existing volume.
         */
        indexmode?: "dense" | "sparse";
        /**
         * Whether this VDO volume is running.  A VDO volume must be activated in order to be started.
         */
        running?: "yes" | "no";
        /**
         * Enables or disables the read cache.  The default is 'disabled'.  Choosing 'enabled' enables a read cache which may improve performance for workloads of high deduplication, read workloads with a high level of compression, or on hard disk storage.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
         */
        readcache?: "enabled" | "disabled";
        /**
         * Specifies the number of threads to use for CPU-intensive work such as hashing or compression.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 2. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
         */
        cputhreads?: string;
        /**
         * The full path of the device to use for VDO storage. This is required if "state" is "present".
         */
        device?: string;
        /**
         * Specifies the number of threads across which to subdivide parts of the VDO processing based on physical block addresses.  Valid values are integer values from 1 to 16 (lower numbers are preferable due to overhead). The physical space used by the VDO volume must be larger than (slabsize * physicalthreads).  The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
         */
        physicalthreads?: string;
        /**
         * The name of the VDO volume.
         */
        name: string;
        /**
         * Specifies whether to attempt to execute a growphysical operation, if there is enough unused space on the device.  A growphysical operation will be executed if there is at least 64 GB of free space, relative to the previous physical size of the affected VDO volume.
         */
        growphysical?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The size of the increment by which the physical size of a VDO volume is grown, in megabytes (or may be issued with an LVM-style suffix of K, M, G, or T).  Must be a power of two between 128M and 32G.  The default is 2G, which supports volumes having a physical size up to 16T. The maximum, 32G, supports a physical size of up to 256T. This option is only available when creating a new volume, and cannot be changed for an existing volume.
         */
        slabsize?: string;
        /**
         * Specifies the number of threads across which to subdivide parts of the VDO processing based on logical block addresses.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead). The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.
         */
        logicalthreads?: string;
        [k: string]: unknown;
      };
      /**
       * Manage OpenStack Identity users. Users can be created, updated or deleted using this module. A user will be updated if I(name) matches an existing user and I(state) is present. The value for I(name) cannot be updated without deleting and re-creating the user.
       */
      os_user?: {
        /**
         * Default: always
         *
         * C(always) will attempt to update password.  C(on_create) will only set the password for newly created users.
         */
        update_password?: string;
        /**
         * Description about the user
         */
        description?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Default: yes
         *
         * Is the user enabled
         */
        enabled?: string;
        /**
         * Project name or ID that the user should be associated with by default
         */
        default_project?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Domain to create the user in if the cloud supports domains
         */
        domain?: string;
        /**
         * Password for the user
         */
        password?: string;
        /**
         * Email address for the user
         */
        email?: string;
        /**
         * Username for the user
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used for fetching UCS files from remote machines and storing them locally in a file tree, organized by hostname. Note that this module is written to transfer UCS files that might not be present, so a missing remote UCS won't be an error unless fail_on_missing is set to 'yes'.
       */
      bigip_ucs_fetch?: {
        /**
         * The name of the UCS file to create on the remote server for downloading
         */
        src?: string;
        /**
         * Default: True
         *
         * If C(no), the file will only be transferred if the destination does not exist.
         */
        force?: string;
        /**
         * Password to use to encrypt the UCS file if desired
         */
        encryption_password?: string;
        /**
         * A directory to save the UCS file into.
         */
        dest?: string;
        /**
         * Make the module fail if the UCS file on the remote system is missing.
         */
        fail_on_missing?: string;
        /**
         * Default: True
         *
         * Creates the UCS based on the value of C(src) if the file does not already exist on the remote system.
         */
        create_on_missing?: string;
        /**
         * Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?: string;
        [k: string]: unknown;
      };
      /**
       * If behind NAT and need to know the public IP of your internet gateway.
       */
      ipify_facts?: {
        /**
         * Default: yes
         *
         * When set to C(NO), SSL certificates will not be validated.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: https://api.ipify.org
         *
         * URL of the ipify.org API service.
         * C(?format=json) will be appended per default.
         */
        api_url?: string;
        /**
         * Default: 10
         *
         * HTTP connection timeout in seconds.
         */
        timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, destroy, or update volumes on ElementSW
       */
      na_elementsw_volume?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Allows for creation, management, and visibility into administrators within Meraki.
       */
      meraki_admin?: {
        [k: string]: unknown;
      };
      /**
       * This module allows one to (re)generate OpenSSL DH-params. This module uses file common arguments to specify generated file permissions.
       */
      openssl_dhparam?: {
        /**
         * Name of the file in which the generated parameters will be saved.
         */
        path: string;
        /**
         * Default: present
         *
         * Whether the parameters should exist or not, taking action if the state is different from what is stated.
         */
        state?: "present" | "absent";
        /**
         * Should the parameters be regenerated even it it already exists
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 4096
         *
         * Size (in bits) of the generated DH-params
         */
        size?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create/modify/remove networking bandwidth and associated resources for a type of traffic on a particular link.
       */
      flowadm?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Adds and/or removes instances of txt record objects from Infoblox NIOS servers.  This module manages NIOS C(record:txt) objects using the Infoblox WAPI interface over REST.
       */
      nios_txt_record?: {
        [k: string]: unknown;
      };
      /**
       * Manages NetStream template configuration on HUAWEI CloudEngine switches.
       */
      ce_netstream_template?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Configure the name of netstream record. The value is a string of 1 to 32 case-insensitive characters.
         */
        record_name?: string;
        /**
         * Configure the description of netstream record. The value is a string of 1 to 80 case-insensitive characters.
         */
        description?: string;
        /**
         * Configure the type of netstream record.
         */
        type: "ip" | "vxlan";
        /**
         * Configure the number of packets and bytes that are included in the flexible flow statistics sent to NSC.
         */
        collect_counter?: "bytes" | "packets";
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * Configure the input or output interface that are included in the flexible flow statistics sent to NSC.
         */
        collect_interface?: "input" | "output";
        /**
         * Configure flexible flow statistics template keywords.
         */
        match?: "destination-address" | "destination-port" | "tos" | "protocol" | "source-address" | "source-port";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Manages BIG-IQ applications used for load balancing a UDP-based application with a FastL4 profile.
       */
      bigiq_application_fastl4_udp?: {
        [k: string]: unknown;
      };
      /**
       * This module can be used to create / delete / update VMware tags.
       * Tag feature is introduced in vSphere 6 version, so this module is not supported in the earlier versions of vSphere.
       * All variables and VMware object names are case sensitive.
       */
      vmware_tag?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module returns information about the account and user / role from which the AWS access tokens originate.
       * The primary use of this is to get the account id for templating into ARNs or similar to avoid needing to specify this information in inventory.
       */
      aws_caller_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Get facts for Container Registry.
       */
      azure_rm_containerregistry_facts?: {
        profile?: string;
        /**
         * The name of the container registry.
         */
        name?: string;
        /**
         * The name of the resource group to which the container registry belongs.
         */
        resource_group: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        /**
         * Retrieve credentials for container registry.
         */
        retrieve_credentials?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Add or Remove a Stack to an OpenStack Heat
       */
      os_stack?: {
        /**
         * Default: yes
         *
         * Rollback stack creation
         */
        rollback?: string;
        /**
         * Name of the stack that should be created, name could be char and digit, no space
         */
        name?: string;
        /**
         * Dictionary of parameters for the stack creation
         */
        parameters?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * List of environment files that should be used for the stack creation
         */
        environment?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: string;
        /**
         * Tag for the stack that should be created, name could be char and digit, no space
         */
        tag?: string;
        /**
         * Default: 3600
         *
         * Maximum number of seconds to wait for the stack creation
         */
        timeout?: string;
        /**
         * Path of the template file to use for the stack creation
         */
        template?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about server instances from OpenStack.
       */
      os_server_facts?: {
        /**
         * Default: no
         *
         * when true, return additional detail about servers at the expense of additional API calls.
         */
        detailed?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * restrict results to servers with names or UUID matching this glob expression (e.g., <web*>).
         */
        server?: string;
        [k: string]: unknown;
      };
      /**
       * Bind Bridge Domain to L3 Out on Cisco ACI fabrics.
       */
      aci_bd_to_l3out?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Security policies allow you to enforce rules and take action, and can be as general or specific as needed. The policy rules are compared against the incoming traffic in sequence, and because the first rule that matches the traffic is applied, the more specific rules must precede the more general ones.
       */
      panos_security_policy?: {
        /**
         * Name of the already defined wildfire_analysis profile.
         */
        wildfire_analysis?: string;
        /**
         * Name of the already defined spyware profile.
         */
        spyware?: string;
        /**
         * Default: any
         *
         * If you are using GlobalProtect with host information profile (HIP) enabled, you can also base the policy on information collected by GlobalProtect. For example, the user access level can be determined HIP that notifies the firewall about the user's local configuration.
         *
         */
        hip_profiles?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the already defined file_blocking profile.
         */
        file_blocking?: string;
        /**
         * Administrative tags that can be added to the rule. Note, tags must be already defined.
         */
        tag?: string;
        /**
         * Whether to log at session start.
         */
        log_start?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the already defined data_filtering profile.
         */
        data_filtering?: string;
        category?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: any
         *
         * List of destination zones.
         */
        to_zone?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: application-default
         *
         * List of services.
         */
        service?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: any
         *
         * List of applications.
         */
        application?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: any
         *
         * List of destination addresses.
         */
        destination?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: any
         *
         * List of source zones.
         */
        from_zone?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: any
         *
         * Use users to enforce policy for individual users or a group of users.
         */
        source_user?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the already defined url_filtering profile.
         */
        url_filtering?: string;
        /**
         * Security profile group that is already defined in the system. This property supersedes antivirus, vulnerability, spyware, url_filtering, file_blocking, data_filtering, and wildfire_analysis properties.
         *
         */
        group_profile?: string;
        /**
         * API key that can be used instead of I(username)/I(password) credentials.
         */
        api_key?: string;
        /**
         * Default: admin
         *
         * Username credentials to use for auth unless I(api_key) is set.
         */
        username?: string;
        /**
         * Device groups are used for the Panorama interaction with Firewall(s). The group must exists on Panorama. If device group is not define we assume that we are contacting Firewall.
         *
         */
        devicegroup?: string;
        /**
         * Description for the security rule.
         */
        description?: string;
        /**
         * Name of the already defined antivirus profile.
         */
        antivirus?: string;
        /**
         * Name of the security rule.
         */
        rule_name: string;
        /**
         * Password credentials to use for auth unless I(api_key) is set.
         */
        password?: string;
        /**
         * IP address (or hostname) of PAN-OS device being configured.
         */
        ip_address: string;
        /**
         * Default: universal
         *
         * Type of security rule (version 6.1 of PanOS and above).
         */
        rule_type?: string;
        /**
         * Name of the already defined vulnerability profile.
         */
        vulnerability?: string;
        /**
         * Default: any
         *
         * List of source addresses.
         */
        source?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: allow
         *
         * Action to apply once rules maches.
         */
        action?: string;
        /**
         * Default: True
         *
         * Commit configuration if changed.
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: True
         *
         * Whether to log at session end.
         */
        log_end?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Adds or removes Vertica database user and, optionally, assigns roles.
       * A user will not be removed until all the dependencies have been dropped.
       * In such a situation, if the module tries to remove the user it will fail and only remove roles granted to the user.
       */
      vertica_user?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Create, update, or destroy Ansible Tower credentials. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_credential?: {
        /**
         * Default: no
         *
         * Should use authorize for net type.
         */
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Domain for openstack type.
         */
        domain?: string;
        /**
         * Vault password. Use ASK for prompting.
         */
        vault_password?: string;
        tower_username?: string;
        /**
         * Become username. Use ASK for prompting.
         */
        become_username?: string;
        /**
         * Become method to Use for privledge escalation.
         */
        become_method?: string;
        /**
         * Secret token for azure_rm type.
         */
        secret?: string;
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Unlock password for ssh_key. Use ASK for prompting.
         */
        ssh_key_unlock?: string;
        /**
         * Password for net credentials that require authorize.
         */
        authorize_password?: string;
        /**
         * Username for this credential. access_key for AWS.
         */
        username?: string;
        /**
         * The description to use for the credential.
         */
        description?: string;
        tower_host?: string;
        /**
         * Host for this credential.
         */
        host?: string;
        /**
         * User that should own this credential.
         */
        user?: string;
        /**
         * Become password. Use ASK for prompting.
         */
        become_password?: string;
        tower_password?: string;
        tower_config_file?: string;
        /**
         * Password for this credential. Use ASK for prompting. secret_key for AWS. api_key for RAX.
         */
        password?: string;
        /**
         * Tenant ID for azure_rm type.
         */
        tenant?: string;
        /**
         * Subscription ID for azure_rm type.
         */
        subscription?: string;
        /**
         * Type of credential being added.  The ssh choice refers to a Tower Machine credential.
         */
        kind:
          | "ssh"
          | "vault"
          | "net"
          | "scm"
          | "aws"
          | "vmware"
          | "satellite6"
          | "cloudforms"
          | "gce"
          | "azure_rm"
          | "openstack"
          | "rhv"
          | "insights"
          | "tower";
        /**
         * The name to use for the credential.
         */
        name: string;
        /**
         * STS token for aws type.
         */
        security_token?: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Project that should for this credential.
         */
        project?: string;
        /**
         * Client or application ID for azure_rm type.
         */
        client?: string;
        /**
         * Path to SSH private key.
         */
        ssh_key_data?: string;
        /**
         * Team that should own this credential.
         */
        team?: string;
        /**
         * Organization that should own the credential.
         */
        organization: string;
        [k: string]: unknown;
      };
      /**
       * Module to manage groups in oVirt/RHV
       */
      ovirt_group?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module is able to configure a FortiGate or FortiOS by allowing the user to configure webfilter feature. For now it is able to handle url and content filtering capabilities. The module uses FortiGate REST API internally to configure the device.
       */
      fortios_webfilter?: {
        /**
         * FortiOS or FortiGate username.
         */
        username: string;
        /**
         * Container for a group of content-filtering entries that the FortiGate must act upon
         */
        webfilter_content?: {
          [k: string]: unknown;
        };
        /**
         * Container for a group of url entries that the FortiGate must act upon
         */
        webfilter_url?: {
          [k: string]: unknown;
        };
        /**
         * FortiOS or FortiGate ip adress.
         */
        host: string;
        /**
         * FortiOS or FortiGate password.
         */
        password?: string;
        /**
         * Default: root
         *
         * Virtual domain, among those defined previously. A vdom is a virtual instance of the FortiGate that can be configured and used as a different unit.
         */
        vdom?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or delete any Azure resource using Azure REST API.
       * This module gives access to resources that are not supported via Ansible modules.
       * Refer to https://docs.microsoft.com/en-us/rest/api/ regarding details related to specific resource REST API.
       */
      azure_rm_resource?: {
        /**
         * The body of the http request/response to the web service.
         */
        body?: string;
        /**
         * Resource group to be used.
         * Required if URL is not specified.
         */
        resource_group?: string;
        /**
         * Default: [200, 201, 202]
         *
         * A valid, numeric, HTTP status code that signifies success of the request. Can also be comma separated list of status codes.
         */
        status_code?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * If enabled, idempotency check will be done by using GET method first and then comparing with I(body)
         */
        idempotency?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        /**
         * Provider type.
         * Required if URL is not specified.
         */
        provider?: string;
        subscription_id?: string;
        /**
         * Default: PUT
         *
         * The HTTP method of the request or response. It MUST be uppercase.
         */
        method?: "GET" | "PUT" | "POST" | "HEAD" | "PATCH" | "DELETE" | "MERGE";
        /**
         * Specific API version to be used.
         */
        api_version: string;
        profile?: string;
        /**
         * Resource name.
         * Required if URL Is not specified.
         */
        resource_name?: string;
        /**
         * Default: present
         *
         * Assert the state of the resource. Use C(present) to create or update resource or C(absent) to delete resource.
         */
        state?: "absent" | "present";
        cloud_environment?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        tenant?: string;
        /**
         * List of subresources
         */
        subresource?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Azure RM Resource URL.
         */
        url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        /**
         * Resource type.
         * Required if URL is not specified.
         */
        resource_type?: string;
        [k: string]: unknown;
      };
      /**
       * Issue Nitro API requests to a Netscaler instance.
       * This is intended to be a short hand for using the uri Ansible module to issue the raw HTTP requests directly.
       * It provides consistent return values and has no other dependencies apart from the base Ansible runtime environment.
       * This module is intended to run either on the Ansible control node or a bastion (jumpserver) with access to the actual Netscaler instance
       */
      netscaler_nitro_request?: {
        /**
         * The name of the target Netscaler instance when issuing a Nitro request through a MAS proxy.
         */
        instance_name?: string;
        /**
         * The type of resource we are operating on.
         * It is required for all I(operation) values except C(mas_login) and C(save_config).
         */
        resource?: string;
        /**
         * The name of the resource we are operating on.
         * It is required for the following I(operation) values: C(update), C(get), C(delete).
         */
        name?: string;
        /**
         * Default: [0]
         *
         * A list of numeric values that signify that the operation was successful.
         */
        expected_nitro_errorcode?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A dictionary which defines the filter with which to refine the Nitro objects returned by the C(get_filtered) I(operation).
         */
        filter?: {
          [k: string]: unknown;
        };
        /**
         * A dictionary which defines the key arguments by which we will select the Nitro object to operate on.
         * It is required for the following I(operation) values: C(get_by_args), C('delete_by_args').
         */
        args?: {
          [k: string]: unknown;
        };
        /**
         * The id of the target Netscaler instance when issuing a Nitro request through a MAS proxy.
         */
        instance_id?: string;
        /**
         * Default: http
         *
         * Which protocol to use when accessing the Nitro API objects.
         */
        nitro_protocol?: "http" | "https";
        /**
         * The IP address of the Netscaler or MAS instance where the Nitro API calls will be made.
         * The port can be specified with the colon C(:). E.g. C(192.168.1.1:555).
         */
        nsip?: string;
        /**
         * The username with which to authenticate to the Netscaler node.
         */
        nitro_user?: string;
        /**
         * The attributes of the Nitro object we are operating on.
         * It is required for the following I(operation) values: C(add), C(update), C(action).
         */
        attributes?: {
          [k: string]: unknown;
        };
        /**
         * The action to perform when the I(operation) value is set to C(action).
         * Some common values for this parameter are C(enable), C(disable), C(rename).
         */
        action?: string;
        /**
         * The IP address of the target Netscaler instance when issuing a Nitro request through a MAS proxy.
         */
        instance_ip?: string;
        /**
         * Define the Nitro operation that we want to perform.
         */
        operation:
          | "add"
          | "update"
          | "get"
          | "get_by_args"
          | "get_filtered"
          | "get_all"
          | "delete"
          | "delete_by_args"
          | "count"
          | "mas_login"
          | "save_config"
          | "action";
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The password with which to authenticate to the Netscaler node.
         */
        nitro_pass?: string;
        /**
         * The authentication token provided by the C(mas_login) operation. It is required when issuing Nitro API calls through a MAS proxy.
         */
        nitro_auth_token?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Interfaces on Mellanox ONYX network devices.
       */
      onyx_interface?: {
        /**
         * Purge Interfaces not defined in the aggregate parameter. This applies only for logical interface.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Description of Interface.
         */
        description?: string;
        /**
         * Interface link status.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Maximum size of transmit packet.
         */
        mtu?: number | string;
        /**
         * Receiver rate in bits per second (bps).
         * This is state check parameter only.
         * Supports conditionals, see L(Conditionals in Networking Modules,../network/user_guide/network_working_with_command_output.html)
         */
        rx_rate?: string;
        /**
         * Default: present
         *
         * State of the Interface configuration, C(up) means present and operationally up and C(down) means present and operationally C(down)
         */
        state?: "present" | "absent" | "up" | "down";
        /**
         * Default: 10
         *
         * Time in seconds to wait before checking for the operational state on remote device. This wait is applicable for operational state argument which are I(state) with values C(up)/C(down).
         */
        delay?: number | string;
        /**
         * List of Interfaces definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Interface link speed.
         */
        speed?: "1G" | "10G" | "25G" | "40G" | "50G" | "56G" | "100G";
        /**
         * Transmit rate in bits per second (bps).
         * This is state check parameter only.
         * Supports conditionals, see L(Conditionals in Networking Modules,../network/user_guide/network_working_with_command_output.html)
         */
        tx_rate?: string;
        /**
         * Name of the Interface.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Set the location settings of a Windows Server.
       * Set the format settings of a Windows Server.
       * Set the unicode language settings of a Windows Server.
       * Copy across these settings to the default profile.
       */
      win_region?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Add and remove domain from the list of permissive domain.
       */
      selinux_permissive?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Creates or terminates azure instances. When created optionally waits for it to be 'running'.
       */
      azure?: {
        /**
         * Default: 22
         *
         * a comma-separated list of TCP ports to expose on the virtual machine (e.g., "22,80")
         */
        endpoints?: string;
        /**
         * Default: Small
         *
         * azure role size for the new virtual machine (e.g., Small, ExtraLarge, A6). You have to pay attention to the fact that instances of type G and DS are not available in all regions (locations). Make sure if you selected the size and type of instance available in your chosen location.
         */
        role_size?:
          | "ExtraSmall"
          | "Small"
          | "Medium"
          | "Large"
          | "ExtraLarge"
          | "A5"
          | "A6"
          | "A7"
          | "A8"
          | "A9"
          | "Basic_A0"
          | "Basic_A1"
          | "Basic_A2"
          | "Basic_A3"
          | "Basic_A4"
          | "Standard_D1"
          | "Standard_D2"
          | "Standard_D3"
          | "Standard_D4"
          | "Standard_D11"
          | "Standard_D12"
          | "Standard_D13"
          | "Standard_D14"
          | "Standard_D1_v2"
          | "Standard_D2_v2"
          | "Standard_D3_v2"
          | "Standard_D4_v2"
          | "Standard_D5_v2"
          | "Standard_D11_v2"
          | "Standard_D12_v2"
          | "Standard_D13_v2"
          | "Standard_D14_v2"
          | "Standard_DS1"
          | "Standard_DS2"
          | "Standard_DS3"
          | "Standard_DS4"
          | "Standard_DS11"
          | "Standard_DS12"
          | "Standard_DS13"
          | "Standard_DS14"
          | "Standard_G1"
          | "Standard_G2"
          | "Standard_G3"
          | "Standard_G4"
          | "Standard_G5";
        /**
         * name of the virtual machine and associated cloud service.
         */
        name?: string;
        /**
         * the azure location to use (e.g. 'East US')
         *
         * Possible choices:
         * South Central US
         * Central US
         * East US 2
         * East US
         * West US
         * North Central US
         * North Europe
         * West Europe
         * East Asia
         * Southeast Asia
         * Japan West
         * Japan East
         * Brazil South
         */
        location?: string;
        /**
         * Name of virtual network.
         */
        virtual_network_name?: string;
        /**
         * system image for creating the virtual machine (e.g., b39f27a8b8c64d52b05eac6a62ebad85__Ubuntu_DAILY_BUILD-precise-12_04_3-LTS-amd64-server-20131205-en-us-30GB)
         */
        image?: string;
        /**
         * hostname to write /etc/hostname. Defaults to <name>.cloudapp.net.
         */
        hostname?: string;
        /**
         * Default: yes
         *
         * Enable winrm on Windows Machines
         */
        enable_winrm?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * create or terminate instances
         */
        state?: string;
        /**
         * Default: 300
         *
         * how long before wait gives up for redirects, in seconds
         */
        wait_timeout_redirects?: string;
        /**
         * path to an azure management certificate associated with the subscription id. Overrides the AZURE_CERT_PATH environment variable.
         */
        management_cert_path?: string;
        /**
         * path to an X509 certificate containing the public ssh key to install in the virtual machine. See http://www.windowsazure.com/en-us/manage/linux/tutorials/intro-to-linux/ for more details.
         * if this option is specified, password-based ssh authentication will be disabled.
         */
        ssh_cert_path?: string;
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: string;
        /**
         * the unix username for the new virtual machine.
         */
        user?: string;
        /**
         * Default: no
         *
         * Enable Auto Updates on Windows Machines
         */
        auto_updates?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * the azure storage account in which to store the data disks.
         */
        storage_account?: string;
        /**
         * Default: linux
         *
         * The type of the os that is gettings provisioned
         */
        os_type?: "windows" | "linux";
        /**
         * the unix password for the new virtual machine.
         */
        password?: string;
        /**
         * azure subscription id. Overrides the AZURE_SUBSCRIPTION_ID environment variable.
         */
        subscription_id?: string;
        /**
         * Default: no
         *
         * wait for the instance to be in state 'running' before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Creates or deletes instances of task definitions.
       */
      ecs_task?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Will install, upgrade and remove packages with swdepot package manager (HP-UX)
       */
      swdepot?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Allows creating and removing managed IAM policies
       */
      iam_managed_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage DNS records on Rackspace Cloud DNS
       */
      rax_dns_record?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Get facts for one Azure Function App or all Function Apps within a resource group
       */
      azure_rm_functionapp_facts?: {
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM tcp half-open monitors.
       */
      bigip_monitor_tcp_half_open?: {
        [k: string]: unknown;
      };
      /**
       * This module can create and destroy unformatted GCE persistent disks U(https://developers.google.com/compute/docs/disks#persistentdisks). It also supports attaching and detaching disks from running instances. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.
       */
      gce_pd?: {
        /**
         * Default: no
         *
         * If C(yes), deletes the volume when instance is terminated
         */
        delete_on_termination?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 10
         *
         * whole integer size of disk (in GB) to create, default is 10 GB
         */
        size_gb?: string;
        /**
         * your GCE project ID
         */
        project_id?: string;
        /**
         * name of the disk
         */
        name: string;
        /**
         * Default: us-central1-b
         *
         * zone in which to create the disk
         */
        zone?: string;
        /**
         * service account email
         */
        service_account_email?: string;
        image_family?: string;
        /**
         * path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
         */
        pem_file?: string;
        /**
         * instance name if you wish to attach or detach the disk
         */
        instance_name?: string;
        /**
         * Default: present
         *
         * desired state of the persistent disk
         */
        state?: string;
        external_projects?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: no
         *
         * do not destroy the disk, merely detach it from an instance
         */
        detach_only?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * path to the JSON file associated with the service account email
         */
        credentials_file?: string;
        /**
         * the source snapshot to use for the disk
         */
        snapshot?: string;
        /**
         * Default: pd-standard
         *
         * type of disk provisioned
         */
        disk_type?: string;
        /**
         * the source image to use for the disk
         */
        image?: string;
        /**
         * Default: READ_ONLY
         *
         * GCE mount mode of disk, READ_ONLY (default) or READ_WRITE
         */
        mode?: "READ_WRITE" | "READ_ONLY";
        [k: string]: unknown;
      };
      /**
       * Create, update, or destroy Ansible Tower users. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_user?: {
        /**
         * The username of the user.
         */
        username: string;
        /**
         * Default: no
         *
         * User is a system wide administator.
         */
        superuser?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * First name of the user.
         */
        first_name?: string;
        /**
         * Last name of the user.
         */
        last_name?: string;
        tower_host?: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Default: no
         *
         * User is a system wide auditor.
         */
        auditor?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_password?: string;
        tower_username?: string;
        /**
         * Password of the user.
         */
        password?: string;
        /**
         * Email address of the user.
         */
        email: string;
        [k: string]: unknown;
      };
      /**
       * Copies AMI from a source region to a destination region. B(Since version 2.3 this module depends on boto3.)
       */
      ec2_ami_copy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can be used to create new virtual machines from templates or other virtual machines, manage power state of virtual machine such as power on, power off, suspend, shutdown, reboot, restart etc., modify various virtual machine components like network, disk, customization etc., rename a virtual machine and remove a virtual machine with associated components.
       *
       */
      vmware_guest?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module works like M(fetch). It is used for fetching a base64- encoded blob containing the data in a remote file.
       * This module is also supported for Windows targets.
       */
      slurp?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Toggles SELinux booleans.
       */
      seboolean?: {
        /**
         * Desired boolean value
         */
        state:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Set to C(yes) if the boolean setting should survive a reboot.
         */
        persistent?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the boolean to configure.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Reboot a network device.
       */
      nxos_reboot?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Safeguard boolean. Set to true if you're sure you want to reboot.
         */
        confirm?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        auth_pass?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Create/remove Docker volumes.
       * Performs largely the same function as the "docker volume" CLI subcommand.
       */
      docker_volume?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * This module can be used to add, remove and update a VMware Standard Switch to an ESXi host.
       */
      vmware_vswitch?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Gather facts about Network ACLs in an AWS VPC
       */
      ec2_vpc_nacl_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or remove volumes (standard and thin) for NetApp E/EF-series storage arrays.
       */
      netapp_e_volume?: {
        /**
         * Default: 512
         *
         * The segment size of the new volume
         */
        segment_size_kb?: number | string;
        ssid: string;
        /**
         * Whether an existing SSD cache should be enabled on the volume (fails if no SSD cache defined)
         * The default value is to ignore existing SSD cache setting.
         */
        ssd_cache_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url: string;
        /**
         * Default: no
         *
         * If data assurance should be enabled for the volume
         */
        data_assurance_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Whether the volume should be thin provisioned.  Thin volumes can only be created on disk pools (raidDiskPool).
         */
        thin_provision?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        log_path?: string;
        api_password: string;
        /**
         * Default: gb
         *
         * The unit used to interpret the size parameter
         */
        size_unit?: "bytes" | "b" | "kb" | "mb" | "gb" | "tb" | "pb" | "eb" | "zb" | "yb";
        /**
         * Whether the specified volume should exist or not.
         */
        state: "present" | "absent";
        /**
         * Required only when requested state is 'present'.  The name of the storage pool the volume should exist on.
         */
        storage_pool_name?: string;
        /**
         * Default: same as size (in size_unit)
         *
         * Maximum size that the thin volume repository volume will automatically expand to
         */
        thin_volume_max_repo_size?: number | string;
        api_username: string;
        /**
         * Initial size of the thin volume repository volume (in size_unit)
         */
        thin_volume_repo_size?: number | string;
        /**
         * Required only when state = 'present'.  The size of the volume in (size_unit).
         */
        size?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the volume to manage
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * create, destroy or rename Igroups and add or remove initiator in igroups.
       */
      na_ontap_igroup?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create, update, or destroy Ansible Tower groups. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_group?: {
        /**
         * Credential to use for the group.
         */
        credential?: string;
        /**
         * Override variables from source with variables from this field.
         */
        source_vars?: string;
        /**
         * Inventory script to be used when group type is C(custom).
         */
        source_script?: string;
        /**
         * The description to use for the group.
         */
        description?: string;
        /**
         * Override vars in child groups and hosts with those from external source.
         */
        overwrite_vars?: string;
        /**
         * Regions for cloud provider.
         */
        source_regions?: string;
        /**
         * Inventory the group should be made a member of.
         */
        inventory: string;
        tower_host?: string;
        /**
         * Comma-separated list of filter expressions for matching hosts.
         */
        instance_filters?: string;
        /**
         * Limit groups automatically created from inventory source.
         */
        group_by?: string;
        tower_config_file?: string;
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Default: no
         *
         * Refresh inventory data from its source each time a job is run.
         */
        update_on_launch?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The source to use for this group.
         */
        source?:
          | "manual"
          | "file"
          | "ec2"
          | "rax"
          | "vmware"
          | "gce"
          | "azure"
          | "azure_rm"
          | "openstack"
          | "satellite6"
          | "cloudforms"
          | "custom";
        tower_password?: string;
        tower_username?: string;
        /**
         * Variables to use for the group, use C(@) for a file.
         */
        variables?: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Delete child groups and hosts not found in source.
         */
        overwrite?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name to use for the group.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Locates and consolidates fragmented files on local volumes to improve system performance.
       * More information regarding C(win_defrag) is available from: U(https://technet.microsoft.com/en-us/library/cc731650(v=ws.11).aspx)
       */
      win_defrag?: {
        /**
         * Default: low
         *
         * Run the operation at low or normal priority.
         */
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Add and remove local groups.
       * For non-Windows targets, please use the M(group) module instead.
       */
      win_group?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module creates, deletes or modifies hosts on Infinibox.
       */
      infini_host?: {
        /**
         * Volume name to map to the host
         */
        volume?: string;
        /**
         * Default: present
         *
         * Creates/Modifies Host when present or removes when absent
         */
        state?: string;
        /**
         * Host Name
         */
        name?: string;
        /**
         * List of wwns of the host
         */
        wwns?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows the management of AWS Lambda function event source mappings such as DynamoDB and Kinesis stream events via the Ansible framework. These event source mappings are relevant only in the AWS Lambda pull model, where AWS Lambda invokes the function. It is idempotent and supports "Check" mode.  Use module M(lambda) to manage the lambda function itself and M(lambda_alias) to manage function aliases.
       */
      lambda_event?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage LTM virtual addresses on a BIG-IP.
       */
      bigip_virtual_address?: {
        /**
         * Specifies whether the system accepts ARP requests.
         * When C(no), specifies that the system does not accept ARP requests.
         * When C(yes), then the packets are dropped.
         * Note that both ARP and ICMP Echo must be disabled in order for forwarding virtual servers using that virtual address to forward ICMP packets.
         * When creating a new virtual address, if this parameter is not specified, the default value is C(yes).
         */
        arp?: string;
        /**
         * The traffic group for the virtual address. When creating a new address, if this value is not specified, the default of C(/Common/traffic-group-1) will be used.
         */
        traffic_group?: string;
        /**
         * Specifies how the systems sends responses to (ICMP) echo requests on a per-virtual address basis for enabling route advertisement. When C(enabled), the BIG-IP system intercepts ICMP echo request packets and responds to them directly. When C(disabled), the BIG-IP system passes ICMP echo requests through to the backend servers. When (selective), causes the BIG-IP system to internally enable or disable responses based on virtual server state; C(when_any_available), C(when_all_available, or C(always), regardless of the state of any virtual servers.
         */
        icmp_echo?: string;
        /**
         * Name of the virtual address.
         * If this parameter is not provided, then the value of C(address) will be used.
         */
        name?: string;
        /**
         * Default: present
         *
         * The virtual address state. If C(absent), an attempt to delete the virtual address will be made. This will only succeed if this virtual address is not in use by a virtual server. C(present) creates the virtual address and enables it. If C(enabled), enable the virtual address if it exists. If C(disabled), create the virtual address if needed, and set state to C(disabled).
         */
        state?: string;
        /**
         * Specifies whether the system automatically deletes the virtual address with the deletion of the last associated virtual server. When C(disabled), specifies that the system leaves the virtual address even when all associated virtual servers have been deleted. When creating the virtual address, the default value is C(enabled).
         * C(enabled) and C(disabled) are deprecated and will be removed in Ansible 2.11. Instead, use known Ansible booleans such as C(yes) and C(no)
         */
        auto_delete?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the number of concurrent connections that the system allows on this virtual address.
         */
        connection_limit?: string;
        /**
         * Default: 255.255.255.255
         *
         * Netmask of the provided virtual address. This value cannot be modified after it is set.
         */
        netmask?: string;
        /**
         * Specifies what routes of the virtual address the system advertises. When C(when_any_available), advertises the route when any virtual server is available. When C(when_all_available), advertises the route when all virtual servers are available. When (always), always advertises the route regardless of the virtual servers available.
         */
        availability_calculation?: string;
        /**
         * The route domain of the C(address) that you want to use.
         * This value cannot be modified after it is set.
         */
        route_domain?: string;
        /**
         * Specifies whether the system accepts ARP requests. When (disabled), specifies that the system does not accept ARP requests. Note that both ARP and ICMP Echo must be disabled in order for forwarding virtual servers using that virtual address to forward ICMP packets. If (enabled), then the packets are dropped.
         * Deprecated. Use the C(arp) parameter instead.
         * When creating a new virtual address, if this parameter is not specified, the default value is C(enabled).
         */
        arp_state?: string;
        /**
         * Specifies whether the system uses route advertisement for this virtual address.
         * When disabled, the system does not advertise routes for this virtual address.
         * Deprecated. Use the C(route_advertisement) parameter instead.
         */
        use_route_advertisement?: string;
        /**
         * Virtual address. This value cannot be modified after it is set.
         * If you never created a virtual address, but did create virtual servers, then a virtual address for each virtual server was created automatically. The name of this virtual address is its IP address value.
         */
        address?: string;
        /**
         * Enables all BIG-IP systems in a device group to listen for and process traffic on the same virtual address.
         * Spanning for a virtual address occurs when you enable the C(spanning) option on a device and then sync the virtual address to the other members of the device group.
         * Spanning also relies on the upstream router to distribute application flows to the BIG-IP systems using ECMP routes. ECMP defines a route to the virtual address using distinct Floating self-IP addresses configured on each BIG-IP system.
         * You must also configure MAC masquerade addresses and disable C(arp) on the virtual address when Spanning is enabled.
         * When creating a new virtual address, if this parameter is not specified, the default valus is C(no).
         */
        spanning?: string;
        /**
         * Specifies whether the system uses route advertisement for this virtual address.
         * When disabled, the system does not advertise routes for this virtual address.
         * The majority of these options are only supported on versions 13.0.0-HF1 or higher. On versions less than this, all choices expect C(disabled) will translate to C(enabled).
         * When C(always), the BIG-IP system will always advertise the route for the virtual address, regardless of availability status. This requires an C(enabled) virtual address.
         * When C(enabled), the BIG-IP system will advertise the route for the available virtual address, based on the calculation method in the availability calculation.
         * When C(disabled), the BIG-IP system will not advertise the route for the virtual address, regardless of the availability status.
         * When C(selective), you can also selectively enable ICMP echo responses, which causes the BIG-IP system to internally enable or disable responses based on virtual server state. Either C(any) virtual server, C(all) virtual servers, or C(always), regardless of the state of any virtual server.
         * When C(any), the BIG-IP system will advertise the route for the virtual address when any virtual server is available.
         * When C(all), the BIG-IP system will advertise the route for the virtual address when all virtual servers are available.
         */
        route_advertisement?: string;
        [k: string]: unknown;
      };
      /**
       * Creates and removes firewall rules.
       */
      cs_firewall?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages collaborators for Heroku apps.
       * If set to C(present) and heroku user is already collaborator, then do nothing.
       * If set to C(present) and heroku user is not collaborator, then add user to app.
       * If set to C(absent) and heroku user is collaborator, then delete user from app.
       */
      heroku_collaborator?: {
        /**
         * Default: present
         *
         * Create or remove the heroku collaborator
         */
        state?: "present" | "absent";
        /**
         * Heroku API key
         */
        api_key?: string;
        /**
         * List of Heroku App names
         */
        apps:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: no
         *
         * Suppress email invitation when creating collaborator
         */
        suppress_invitation?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * User ID or e-mail
         */
        user: string;
        [k: string]: unknown;
      };
      /**
       * NodePool contains the name and configuration for a cluster's node pool.
       * Node pools are a set of nodes (i.e. VM's), with a common configuration and specification, under the control of the cluster master. They may have a set of Kubernetes labels applied to them, which may be used to reference them during pod scheduling. They may also be resized up or down, to accommodate the workload.
       */
      gcp_container_node_pool?: {
        /**
         * The initial node count for the pool. You must ensure that your Compute Engine resource quota is sufficient for this number of instances. You must also have available firewall and routes quota.
         */
        initial_node_count: number | string;
        /**
         * Management configuration for this NodePool.
         */
        management?: {
          [k: string]: unknown;
        };
        /**
         * The name of the node pool.
         */
        name?: string;
        /**
         * The zone where the node pool is deployed.
         */
        zone: string;
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * Autoscaler configuration for this NodePool. Autoscaler is enabled only if a valid configuration is present.
         */
        autoscaling?: {
          [k: string]: unknown;
        };
        project?: string;
        /**
         * The cluster this node pool belongs to.
         */
        cluster: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        /**
         * The node configuration of the pool.
         */
        config?: {
          [k: string]: unknown;
        };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Add or remove LDAP attribute values.
       */
      ldap_attr?: {
        dn: string;
        /**
         * The name of the attribute to modify.
         */
        name: string;
        server_uri?: string;
        start_tls?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        bind_dn?: string;
        /**
         * Default: present
         *
         * The state of the attribute values. If C(present), all given values will be added if they're missing. If C(absent), all given values will be removed if present. If C(exact), the set of values will be forced to exactly those provided and no others. If I(state=exact) and I(value) is an empty list, all values for this attribute will be removed.
         */
        state?: "present" | "absent" | "exact";
        /**
         * The value(s) to add or remove. This can be a string or a list of strings. The complex argument format is required in order to pass a list of strings (see examples).
         */
        values: string;
        bind_pw?: string;
        params?: {
          [k: string]: unknown;
        };
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an aireos node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(aireos_config) to configure WLC devices.
       */
      aireos_command?: {
        [k: string]: unknown;
      };
      /**
       * This module can be used to gathers facts like CPU, memory, datastore, network and system etc. about ESXi host system.
       * Please specify hostname or IP address of ESXi host system as C(hostname).
       * If hostname or IP address of vCenter is provided as C(hostname), then information about first ESXi hostsystem is returned.
       * VSAN facts added in 2.7 version.
       */
      vmware_host_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows for addition or deletion of services and ports either tcp or udp in either running or permanent firewalld rules.
       */
      firewalld?: {
        /**
         * Default: system-default(public)
         *
         * The firewalld zone to add/remove to/from (NOTE: default zone can be configured per system but "public" is default from upstream. Available choices can be extended based on per-system configs, listed here are "out of the box" defaults).
         *
         */
        zone?: string;
        /**
         * Name of a service to add/remove to/from firewalld - service must be listed in output of firewall-cmd --get-services.
         */
        service?: string;
        /**
         * The masquerade setting you would like to enable/disable to/from zones within firewalld
         */
        masquerade?: string;
        /**
         * Default: no
         *
         * Should this configuration be applied immediately, if set as permanent
         */
        immediate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The source/network you would like to add/remove to/from firewalld
         */
        source?: string;
        /**
         * Enable or disable a setting. For ports: Should this port accept(enabled) or reject(disabled) connections. The states "present" and "absent" can only be used in zone level operations (i.e. when no other parameters but zone and state are set).
         *
         */
        state: "enabled" | "disabled" | "present" | "absent";
        /**
         * Should this configuration be in the running firewalld configuration or persist across reboots. As of Ansible version 2.3, permanent operations can operate on firewalld configs when it's not running (requires firewalld >= 3.0.9). (NOTE: If this is false, immediate is assumed true.)
         *
         */
        permanent?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The amount of time the rule should be in effect for when non-permanent.
         */
        timeout?: number | string;
        /**
         * The interface you would like to add/remove to/from a zone in firewalld
         */
        interface?: string;
        offline?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of a port or port range to add/remove to/from firewalld. Must be in the form PORT/PROTOCOL or PORT-PORT/PROTOCOL for port ranges.
         */
        port?: string;
        /**
         * Rich rule to add/remove to/from firewalld.
         */
        rich_rule?: string;
        [k: string]: unknown;
      };
      /**
       * Managing device groups allows you to create HA pairs and clusters of BIG-IP devices. Usage of this module should be done in conjunction with the C(bigip_configsync_actions) to sync configuration across the pair or cluster if auto-sync is disabled.
       */
      bigip_device_group?: {
        /**
         * Specifies the name of the device group.
         */
        name?: string;
        /**
         * Indicates whether configuration synchronization occurs manually or automatically.
         * When creating a new device group, this option will default to C(no).
         */
        auto_sync?: string;
        /**
         * Specifies the size of the changes cache for incremental sync.
         * For example, using the default, if you make more than 1024 KB worth of incremental changes, the system performs a full synchronization operation.
         * Using incremental synchronization operations can reduce the per-device sync/load time for configuration changes.
         * This setting is relevant only when C(full_sync) is C(no).
         */
        max_incremental_sync_size?: string;
        /**
         * When performing an auto-sync, specifies whether the configuration will be saved or not.
         * When C(no), only the running configuration will be changed on the device(s) being synced to.
         * When creating a new device group, this option will default to C(no).
         */
        save_on_auto_sync?: string;
        /**
         * Default: present
         *
         * When C(state) is C(present), ensures the device group exists.
         * When C(state) is C(absent), ensures that the device group is removed.
         */
        state?: string;
        /**
         * Specifies whether the system synchronizes the entire configuration during synchronization operations.
         * When C(no), the system performs incremental synchronization operations, based on the cache size specified in C(max_incremental_sync_size).
         * Incremental configuration synchronization is a mechanism for synchronizing a device-group's configuration among its members, without requiring a full configuration load for each configuration change.
         * In order for this to work, all devices in the device-group must initially agree on the configuration. Typically this requires at least one full configuration load to each device.
         * When creating a new device group, this option will default to C(no).
         */
        full_sync?: string;
        /**
         * Indicates whether failover occurs over the network or is hard-wired.
         * This parameter is only valid for C(type)'s that are C(sync-failover).
         */
        network_failover?: string;
        /**
         * Specifies that the type of group.
         * A C(sync-failover) device group contains devices that synchronize their configuration data and fail over to one another when a device becomes unavailable.
         * A C(sync-only) device group has no such failover. When creating a new device group, this option will default to C(sync-only).
         * This setting cannot be changed once it has been set.
         */
        type?: string;
        /**
         * Description of the device group.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about account balance, charges and payments.
       */
      vultr_account_facts?: {
        api_retries?: number | string;
        api_timeout?: number | string;
        api_endpoint?: string;
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Represents an Image resource.
       * Google Compute Engine uses operating system images to create the root persistent disks for your instances. You specify an image when you create an instance. Images contain a boot loader, an operating system, and a root file system. Linux operating system images are also capable of running containers on Compute Engine.
       * Images can be either public or custom.
       * Public images are provided and maintained by Google, open-source communities, and third-party vendors. By default, all projects have access to these images and can use them to create instances.  Custom images are available only to your project. You can create a custom image from root persistent disks and other images. Then, use the custom image to create an instance.
       */
      gcp_compute_image?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Refers to a gcompute_disk object You must provide either this property or the rawDisk.source property but not both to create an image.
         */
        source_disk?: {
          [k: string]: unknown;
        };
        /**
         * Size of the image when restored onto a persistent disk (in GB).
         */
        disk_size_gb?: number | string;
        /**
         * Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        /**
         * The name of the image family to which this image belongs. You can create disks by specifying an image family instead of a specific image name. The image family always returns its latest image that is not deprecated. The name of the image family must comply with RFC1035.
         */
        family?: string;
        /**
         * The ID value of the disk used to create this image. This value may be used to determine whether the image was taken from the current or a previous instance of a given disk name.
         */
        source_disk_id?: string;
        service_account_email?: string;
        /**
         * A list of features to enable on the guest OS. Applicable for bootable images only. Currently, only one feature can be enabled, VIRTIO_SCSI_MULTIQUEUE, which allows each virtual CPU to have its own queue. For Windows images, you can only enable VIRTIO_SCSI_MULTIQUEUE on images with driver version 1.2.0.1621 or higher. Linux images with kernel versions 3.17 and higher will support VIRTIO_SCSI_MULTIQUEUE.
         * For new Windows images, the server might also populate this field with the value WINDOWS, to indicate that this is a Windows image.
         * This value is purely informational and does not enable or disable any features.
         */
        guest_os_features?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Encrypts the image using a customer-supplied encryption key.
         * After you encrypt an image with a customer-supplied key, you must provide the same key if you use the image later (e.g. to create a disk from the image) .
         */
        image_encryption_key?: {
          [k: string]: unknown;
        };
        /**
         * The parameters of the raw disk image.
         */
        raw_disk?: {
          [k: string]: unknown;
        };
        project?: string;
        /**
         * The type of the image used to create this disk. The default and only value is RAW .
         */
        source_type?: "RAW";
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * The customer-supplied encryption key of the source disk. Required if the source disk is protected by a customer-supplied encryption key.
         */
        source_disk_encryption_key?: {
          [k: string]: unknown;
        };
        /**
         * Any applicable license URI.
         */
        licenses?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Add, modify and delete user within IPA server
       */
      ipa_user?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Adds or removes a user from a MongoDB database.
       */
      mongodb_user?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * This module can be used to gather facts about canonical (NAA) from an ESXi host based on SCSI target ID.
       */
      vmware_target_canonical_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage Open vSwitch ports
       */
      openvswitch_port?: {
        /**
         * Name of bridge to manage
         */
        bridge: string;
        /**
         * Set a single property on a port.
         */
        set?: string;
        /**
         * Default: present
         *
         * Whether the port should exist
         */
        state?: "present" | "absent";
        /**
         * VLAN tag for this port. Must be a value between 0 and 4095.
         */
        tag?: string;
        /**
         * Default: 5
         *
         * How long to wait for ovs-vswitchd to respond
         */
        timeout?: number | string;
        /**
         * Dictionary of external_ids applied to a port.
         */
        external_ids?: {
          [k: string]: unknown;
        };
        /**
         * Name of port to manage on the bridge
         */
        port: string;
        [k: string]: unknown;
      };
      /**
       * Create and remove a bigmon out-of-band policy.
       */
      bigmon_policy?: {
        /**
         * Description of policy.
         */
        policy_description?: string;
        /**
         * The name of the policy.
         */
        name: string;
        /**
         * Bigmon access token. If this isn't set, the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.
         */
        access_token?: string;
        /**
         * Default: ansible_date_time.iso8601
         *
         * Date the policy becomes active
         */
        start_time?: string;
        /**
         * The controller address.
         */
        controller: string;
        /**
         * Default: 100
         *
         * A priority associated with this policy. The higher priority policy takes precedence over a lower priority.
         */
        priority?: number | string;
        /**
         * Default: forward
         *
         * Forward matching packets to delivery interfaces, Drop is for measure rate of matching packets, but do not forward to delivery interfaces, capture packets and write to a PCAP file, or enable NetFlow generation.
         */
        action?: "forward" | "drop" | "capture" | "flow-gen";
        /**
         * Default: present
         *
         * Whether the policy should be present or absent.
         */
        state?: "present" | "absent";
        /**
         * Run policy for duration duration or until delivery_packet_count packets are delivered, whichever comes first.
         */
        duration?: number | string;
        /**
         * Default: True
         *
         * If C(false), SSL certificates will not be validated. This should only be used on personally controlled devices using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Run policy until delivery_packet_count packets are delivered.
         */
        delivery_packet_count?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to manage NTP configuration information about an ESXi host.
       * User can specify an ESXi hostname or Cluster name. In case of cluster name, all ESXi hosts are updated.
       */
      vmware_host_ntp?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Represents a GlobalForwardingRule resource. Global forwarding rules are used to forward traffic to the correct load balancer for HTTP load balancing. Global forwarding rules can only be used for HTTP load balancing.
       * For more information, see U(https://cloud.google.com/compute/docs/load-balancing/http/) .
       */
      gcp_compute_global_forwarding_rule?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * This signifies what the ForwardingRule will be used for and can only take the following values: INTERNAL, EXTERNAL The value of INTERNAL means that this will be used for Internal Network Load Balancing (TCP, UDP). The value of EXTERNAL means that this will be used for External Load Balancing (HTTP(S) LB, External TCP/UDP LB, SSL Proxy) .
         */
        load_balancing_scheme?: "INTERNAL" | "EXTERNAL";
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: string;
        service_account_email?: string;
        /**
         * The IP protocol to which this rule applies. Valid options are TCP, UDP, ESP, AH, SCTP or ICMP.
         * When the load balancing scheme is INTERNAL, only TCP and UDP are valid.
         */
        ip_protocol?: "TCP" | "UDP" | "ESP" | "AH" | "SCTP" | "ICMP";
        /**
         * This field is used along with the backend_service field for internal load balancing.
         * When the load balancing scheme is INTERNAL, a single port or a comma separated list of ports can be configured. Only packets addressed to these ports will be forwarded to the backends configured with this forwarding rule.
         * You may specify a maximum of up to 5 ports.
         */
        ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        project?: string;
        /**
         * This field is used along with the target field for TargetHttpProxy, TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway, TargetPool, TargetInstance.
         * Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets addressed to ports in the specified range will be forwarded to target.
         * Forwarding rules with the same [IPAddress, IPProtocol] pair must have disjoint port ranges.
         * Some types of forwarding target have constraints on the acceptable ports:  * TargetHttpProxy: 80, 8080 * TargetHttpsProxy: 443 * TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,                   1883, 5222 * TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,                   1883, 5222 * TargetVpnGateway: 500, 4500 .
         */
        port_range?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * A reference to a BackendService to receive the matched traffic.
         * This is used for internal load balancing.
         * (not used for external load balancing) .
         */
        backend_service?: {
          [k: string]: unknown;
        };
        /**
         * For internal load balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
         * This field is not used for external load balancing.
         */
        network?: {
          [k: string]: unknown;
        };
        /**
         * This target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object.
         * Valid types: HTTP_PROXY, HTTPS_PROXY, SSL_PROXY, TCP_PROXY .
         */
        target?: string;
        /**
         * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for a global forwarding rule.
         */
        ip_version?: "IPV4" | "IPV6";
        service_account_file?: string;
        /**
         * The IP address that this forwarding rule is serving on behalf of.
         * Addresses are restricted based on the forwarding rule's load balancing scheme (EXTERNAL or INTERNAL) and scope (global or regional).
         * When the load balancing scheme is EXTERNAL, for global forwarding rules, the address must be a global IP, and for regional forwarding rules, the address must live in the same region as the forwarding rule. If this field is empty, an ephemeral IPv4 address from the same scope (global or regional) will be assigned. A regional forwarding rule supports IPv4 only. A global forwarding rule supports either IPv4 or IPv6.
         * When the load balancing scheme is INTERNAL, this can only be an RFC 1918 IP address belonging to the network/subnet configured for the forwarding rule. By default, if this field is empty, an ephemeral internal IP address will be automatically allocated from the IP range of the subnet or network configured for this forwarding rule.
         * An address can be specified either by a literal IP address or a URL reference to an existing Address resource. The following examples are all valid:  * 100.1.2.3 * U(https://www.googleapis.com/compute/v1/projects/project/regions/region/addresses/address) * projects/project/regions/region/addresses/address * regions/region/addresses/address * global/addresses/address * address .
         */
        ip_address?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * A reference to a subnetwork.
         * For internal load balancing, this field identifies the subnetwork that the load balanced IP should belong to for this Forwarding Rule.
         * If the network specified is in auto subnet mode, this field is optional. However, if the network is in custom subnet mode, a subnetwork must be specified.
         * This field is not used for external load balancing.
         */
        subnetwork?: {
          [k: string]: unknown;
        };
        /**
         * Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Persistent disks are durable storage devices that function similarly to the physical disks in a desktop or a server. Compute Engine manages the hardware behind these devices to ensure data redundancy and optimize performance for you. Persistent disks are available as either standard hard disk drives (HDD) or solid-state drives (SSD).
       * Persistent disks are located independently from your virtual machine instances, so you can detach or move persistent disks to keep your data even after you delete your instances. Persistent disk performance scales automatically with size, so you can resize your existing persistent disks or add more persistent disks to an instance to meet your performance and storage space requirements.
       * Add a persistent disk to your instance when you need reliable and affordable storage with consistent performance characteristics.
       */
      gcp_compute_disk?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Size of the persistent disk, specified in GB. You can specify this field when creating a persistent disk using the sourceImage or sourceSnapshot parameter, or specify it alone to create an empty persistent disk.
         * If you specify this field along with sourceImage or sourceSnapshot, the value of sizeGb must not be less than the size of the sourceImage or the size of the snapshot.
         */
        size_gb?: number | string;
        /**
         * URL of the disk type resource describing which disk type to use to create the disk. Provide this when creating the disk.
         */
        type?: string;
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        /**
         * A reference to the zone where the disk resides.
         */
        zone: string;
        /**
         * Encrypts the disk using a customer-supplied encryption key.
         * After you encrypt a disk with a customer-supplied key, you must provide the same key if you use the disk later (e.g. to create a disk snapshot or an image, or to attach the disk to a virtual machine).
         * Customer-supplied encryption keys do not protect access to metadata of the disk.
         * If you do not provide an encryption key when creating the disk, then the disk will be encrypted using an automatically generated key and you do not need to provide a key to use the disk later.
         */
        disk_encryption_key?: {
          [k: string]: unknown;
        };
        /**
         * The source snapshot used to create this disk. You can provide this as a partial or full URL to the resource. For example, the following are valid values: * `U(https://www.googleapis.com/compute/v1/projects/project/global/snapshots/snapshot`) * `projects/project/global/snapshots/snapshot` * `global/snapshots/snapshot` .
         */
        source_snapshot?: {
          [k: string]: unknown;
        };
        /**
         * The customer-supplied encryption key of the source snapshot. Required if the source snapshot is protected by a customer-supplied encryption key.
         */
        source_snapshot_encryption_key?: {
          [k: string]: unknown;
        };
        /**
         * Labels to apply to this disk.  A list of key->value pairs.
         */
        labels?: {
          [k: string]: unknown;
        };
        /**
         * The source image used to create this disk. If the source image is deleted, this field will not be set.
         * To create a disk with one of the public operating system images, specify the image by its family name. For example, specify family/debian-8 to use the latest Debian 8 image:  projects/debian-cloud/global/images/family/debian-8  Alternatively, use a specific version of a public operating system image:  projects/debian-cloud/global/images/debian-8-jessie-vYYYYMMDD  To create a disk with a private image that you created, specify the image name in the following format:  global/images/my-private-image  You can also specify a private image by its image family, which returns the latest version of the image in that family. Replace the image name with family/family-name:  global/images/family/my-private-family .
         */
        source_image?: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_email?: string;
        /**
         * Any applicable publicly visible licenses.
         */
        licenses?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        /**
         * The customer-supplied encryption key of the source image. Required if the source image is protected by a customer-supplied encryption key.
         */
        source_image_encryption_key?: {
          [k: string]: unknown;
        };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * This module will manage LTM policy rules on a BIG-IP.
       */
      bigip_policy_rule?: {
        /**
         * Description of the policy rule.
         */
        description?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * The actions that you want the policy rule to perform.
         * The available attributes vary by the action, however, each action requires that a C(type) be specified.
         * These conditions can be specified in any order. Despite them being a list, the BIG-IP does not treat their order as anything special.
         */
        actions?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the key is uploaded to the device. When C(absent), ensures that the key is removed from the device. If the key is currently in use, the module will not be able to remove the key.
         */
        state?: string;
        /**
         * The name of the policy that you want to associate this rule with.
         */
        policy?: string;
        /**
         * A list of attributes that describe the condition.
         * See suboptions for details on how to construct each list entry.
         * The ordering of this list is important, the module will ensure the order is kept when modifying the task.
         * The suboption options listed below are not required for all condition types, read the description for more details.
         * These conditions can be specified in any order. Despite them being a list, the BIG-IP does not treat their order as anything special.
         */
        conditions?: string;
        /**
         * The name of the rule.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module configures the timezone setting, both of the system clock and of the hardware clock. If you want to set up the NTP, use M(service) module.
       * It is recommended to restart C(crond) after changing the timezone, otherwise the jobs may run at the wrong time.
       * Several different tools are used depending on the OS/Distribution involved. For Linux it can use C(timedatectl) or edit C(/etc/sysconfig/clock) or C(/etc/timezone) and C(hwclock). On SmartOS, C(sm-set-timezone), for macOS, C(systemsetup), for BSD, C(/etc/localtime) is modified.
       * As of version 2.3 support was added for SmartOS and BSDs.
       * As of version 2.4 support was added for macOS.
       * Windows, AIX and HPUX are not supported, please let us know if you find any other OS/distro in which this fails.
       */
      timezone?: {
        [k: string]: unknown;
      };
      /**
       * Cisco IOS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with IOS configuration sections in a deterministic way.
       */
      ios_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage BIG-IP server configuration. This module is able to manipulate the server definitions in a BIG-IP.
       */
      bigip_gtm_server?: {
        /**
         * Specifies whether the system auto-discovers the links for this server. When creating a new GTM server, if this parameter is not specified, the default value C(disabled) is used.
         * If you set this parameter to C(enabled) or C(enabled-no-delete), you must also ensure that the C(virtual_server_discovery) parameter is also set to C(enabled) or C(enabled-no-delete).
         */
        link_discovery?: string;
        /**
         * The name of the server.
         */
        name?: string;
        /**
         * Specifies the server type. The server type determines the metrics that the system can collect from the server. When creating a new GTM server, the default value C(bigip) is used.
         */
        server_type?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Lists the self IP addresses and translations for each device. When creating a new GTM server, this value is required. This list is a complex list that specifies a number of keys.
         * The C(name) key specifies a name for the device. The device name must be unique per server. This key is required.
         * The C(address) key contains an IP address, or list of IP addresses, for the destination server. This key is required.
         * The C(translation) key contains an IP address to translate the C(address) value above to. This key is optional.
         * Specifying duplicate C(name) fields is a supported means of providing device addresses. In this scenario, the addresses will be assigned to the C(name)'s list of addresses.
         */
        devices?: string;
        /**
         * Default: present
         *
         * The server state. If C(absent), an attempt to delete the server will be made. This will only succeed if this server is not in use by a virtual server. C(present) creates the server and enables it. If C(enabled), enable the server if it exists. If C(disabled), create the server if needed, and set state to C(disabled).
         */
        state?: string;
        /**
         * Specifies whether the system auto-discovers the virtual servers for this server. When creating a new GTM server, if this parameter is not specified, the default value C(disabled) is used.
         */
        virtual_server_discovery?: string;
        /**
         * Specifies whether the Global Traffic Manager uses this BIG-IP system to conduct a variety of probes before delegating traffic to it.
         */
        iquery_options?: string;
        /**
         * Data center the server belongs to. When creating a new GTM server, this value is required.
         */
        datacenter?: string;
        [k: string]: unknown;
      };
      /**
       * Packs an archive. It is the opposite of M(unarchive). By default, it assumes the compression source exists on the target. It will not copy the source file from the local system to the target before archiving. Source files can be deleted after archival by specifying I(remove=True).
       */
      archive?: {
        /**
         * The file name of the destination archive. This is required when C(path) refers to multiple files by either specifying a glob, a directory or multiple paths in a list.
         */
        dest?: string;
        /**
         * Remote absolute path, glob, or list of paths or globs for the file or files to compress or archive.
         */
        path:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Remote absolute path, glob, or list of paths or globs for the file or files to exclude from the archive
         */
        exclude_path?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: no
         *
         * Remove any added source files and trees after adding to archive.
         */
        remove?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: gz
         *
         * The type of compression to use.
         * Support for xz was added in version 2.5.
         */
        format?: "bz2" | "gz" | "tar" | "xz" | "zip";
        [k: string]: unknown;
      };
      /**
       * This module allows the user to manage verified email and domain identity for SES.
       * This covers verifying and removing identities as well as setting up complaint, bounce and delivery notification settings.
       */
      aws_ses_identity?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of LLDP interfaces configuration on Mellanox ONYX network devices.
       */
      onyx_lldp_interface?: {
        /**
         * Purge interfaces not defined in the aggregate parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of interfaces LLDP should be configured on.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * State of the LLDP configuration.
         */
        state?: "present" | "absent" | "enabled" | "disabled";
        /**
         * Name of the interface LLDP should be configured on.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure ApplicationProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_applicationprofile?: {
        /**
         * Specifies if we need to preserve client port while preseving client ip for backend connections.
         * Field introduced in 17.2.7.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        preserve_client_port?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies various security related controls for virtual service.
         */
        dos_rl_profile?: {
          [k: string]: unknown;
        };
        /**
         * Specifies if client ip needs to be preserved for backend connection.
         * Not compatible with connection multiplexing.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        preserve_client_ip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies the tcp application proxy profile parameters.
         */
        tcp_app_profile?: {
          [k: string]: unknown;
        };
        /**
         * Uuid of the application profile.
         */
        uuid?: string;
        /**
         * Specifies various dns service related controls for virtual service.
         */
        dns_service_profile?: {
          [k: string]: unknown;
        };
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Specifies which application layer proxy is enabled for the virtual service.
         * Enum options - APPLICATION_PROFILE_TYPE_L4, APPLICATION_PROFILE_TYPE_HTTP, APPLICATION_PROFILE_TYPE_SYSLOG, APPLICATION_PROFILE_TYPE_DNS,
         * APPLICATION_PROFILE_TYPE_SSL.
         */
        type: string;
        api_version?: string;
        username?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * Specifies the http application proxy profile parameters.
         */
        http_profile?: {
          [k: string]: unknown;
        };
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * The name of the application profile.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * This module will search through every target group in a region to find which ones have registered a given instance ID or IP.
       */
      elb_target_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module will search a file for a line, and ensure that it is present or absent.
       * This is primarily useful when you want to change a single line in a file only.
       */
      win_lineinfile?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Adds, modifies and removes nodes from a Rackspace Cloud Load Balancer
       */
      rax_clb_nodes?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of VRFs on CISCO NXOS network devices.
       */
      nxos_vrf?: {
        [k: string]: unknown;
      };
      /**
       * Manages VRF AF
       */
      nxos_vrf_af?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Address-Family Identifier (AFI).
         */
        afi: "ipv4" | "ipv6";
        /**
         * Sub Address-Family Identifier (SAFI).
         * Deprecated in 2.4
         */
        safi?: "unicast" | "multicast";
        auth_pass?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * Enable/Disable the EVPN route-target 'auto' setting for both import and export target communities.
         */
        route_target_both_auto_evpn?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the VRF.
         */
        vrf: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Create or Remove compute instances from OpenStack.
       */
      os_server?: {
        /**
         * Availability zone in which to create the server.
         */
        availability_zone?: string;
        /**
         * The name or id of the base image to boot.
         */
        image?: string;
        /**
         * Text to use to filter image names, for the case, such as HP, where there are multiple image names matching the common identifying portions. image_exclude is a negative match filter - it is text that may not exist in the image name. Defaults to "(deprecated)"
         */
        image_exclude?: string;
        /**
         * Text to use to filter flavor names, for the case, such as Rackspace, where there are multiple flavors that have the same ram count. flavor_include is a positive match filter - it must exist in the flavor name.
         */
        flavor_include?: string;
        /**
         * A list of key value pairs that should be provided as a metadata to the new instance or a string containing a list of key-value pairs. Eg:  meta: "key1=value1,key2=value2"
         */
        meta?: string;
        /**
         * Default: 1
         *
         * The name or id of the flavor in which the new instance has to be created. Mutually exclusive with flavor_ram
         */
        flavor?: string;
        /**
         * Names of the security groups to which the instance should be added. This may be a YAML list or a comma separated string.
         */
        security_groups?: string;
        /**
         * Arbitrary key/value pairs to the scheduler for custom use
         */
        scheduler_hints?: string;
        /**
         * Default: no
         *
         * Should the instance boot from a persistent volume created based on the image given. Mututally exclusive with boot_volume.
         */
        boot_from_volume?: string;
        /**
         * Opaque blob of data which is made available to the instance
         */
        userdata?: string;
        /**
         * Name or ID of a network to attach this instance to. A simpler version of the nics parameter, only one of network or nics should be supplied.
         */
        network?: string;
        /**
         * A list of networks to which the instance's interface should be attached. Networks may be referenced by net-id/net-name/port-id or port-name.
         * Also this accepts a string containing a list of (net/port)-(id/name) Eg: nics: "net-id=uuid-1,port-name=myport" Only one of network or nics should be supplied.
         */
        nics?: string;
        /**
         * list of valid floating IPs that pre-exist to assign to this node
         */
        floating_ips?: string;
        /**
         * Default: 1
         *
         * The minimum amount of ram in MB that the flavor in which the new instance has to be created must have. Mutually exclusive with flavor.
         */
        flavor_ram?: string;
        /**
         * The size of the volume to create in GB if booting from volume based on an image.
         */
        volume_size?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: yes
         *
         * Ensure instance has public ip however the cloud wants to do that
         */
        auto_ip?: string;
        /**
         * Default: no
         *
         * Whether to boot the server with config drive enabled
         */
        config_drive?: string;
        /**
         * Default: no
         *
         * If C(yes), delete volume when deleting instance (if booted from volume)
         */
        terminate_volume?: string;
        /**
         * The key pair name to be used when creating a instance
         */
        key_name?: string;
        /**
         * Volume name or id to use as the volume to boot from. Implies boot_from_volume. Mutually exclusive with image and boot_from_volume.
         */
        boot_volume?: string;
        /**
         * Default: yes
         *
         * If the module should wait for the instance to be created.
         */
        wait?: string;
        /**
         * Name that has to be given to the instance. It is also possible to specify the ID of the instance instead of its name if I(state) is I(absent).
         */
        name?: string;
        /**
         * Default: 180
         *
         * The amount of time the module should wait for the instance to get into active state.
         */
        timeout?: string;
        /**
         * Default: no
         *
         * When I(state) is absent and this option is true, any floating IP associated with the instance will be deleted along with the instance.
         */
        delete_fip?: string;
        /**
         * A list of preexisting volumes names or ids to attach to the instance
         */
        volumes?: string;
        /**
         * Name of floating IP pool from which to choose a floating IP
         */
        floating_ip_pools?: string;
        /**
         * Default: yes
         *
         * When I(auto_ip) is true and this option is true, the I(auto_ip) code will attempt to re-use unassigned floating ips in the project before creating a new one. It is important to note that it is impossible to safely do this concurrently, so if your use case involves concurrent server creation, it is highly recommended to set this to false and to delete the floating ip associated with a server when the server is deleted using I(delete_fip).
         */
        reuse_ips?: string;
        [k: string]: unknown;
      };
      /**
       * Ensure that the domain named by C(dns_domain_name) exists and is reachable.
       * If the domain is not reachable, the domain is created in a new forest on the target Windows Server 2012R2+ host.
       * This module may require subsequent use of the M(win_reboot) action if changes are made.
       */
      win_domain?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Provides support for managing Serverless Framework (https://serverless.com/) project deployments and stacks.
       */
      serverless?: {
        /**
         * A list of specific functions to deploy. If this is not provided, all functions in the service will be deployed.
         */
        functions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Whether or not to force full deployment, equivalent to serverless `--force` option.
         */
        force?: string;
        /**
         * Shows all stack events during deployment, and display any Stack Output.
         */
        verbose?: string;
        /**
         * Default: True
         *
         * Whether or not to deploy artifacts after building them. When this option is `false` all the functions will be built, but no stack update will be run to send them out. This is mostly useful for generating artifacts to be stored/deployed elsewhere.
         */
        deploy?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: us-east-1
         *
         * AWS region to deploy the service to
         */
        region?: string;
        /**
         * Default: present
         *
         * Goal state of given stage/project
         */
        state?: "present" | "absent";
        /**
         * The path of a serverless framework binary relative to the 'service_path' eg. node_module/.bin/serverless
         */
        serverless_bin_path?: string;
        /**
         * The path to the root of the Serverless Service to be operated on.
         */
        service_path: string;
        /**
         * The name of the serverless framework project stage to deploy to. This uses the serverless framework default "dev".
         */
        stage?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to manage (start, stop, restart) services on a given ESXi host.
       * If cluster_name is provided, specified service will be managed on all ESXi host belonging to that cluster.
       * If specific esxi_hostname is provided, then specified service will be managed on given ESXi host only.
       */
      vmware_host_service_manager?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts about networks available in Vultr.
       */
      vultr_network_facts?: {
        api_retries?: number | string;
        api_timeout?: number | string;
        api_endpoint?: string;
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Update ONTAP software
       */
      na_ontap_software_update?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage OpenStack Identity Roles.
       */
      os_keystone_role?: {
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Role Name
         */
        name?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * Add, modify or remove registry keys and values.
       * More information about the windows registry from Wikipedia U(https://en.wikipedia.org/wiki/Windows_Registry).
       */
      win_regedit?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of logging on Cisco Ios devices.
       */
      ios_logging?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.
         */
        name?: string;
        /**
         * Set logging facility.
         */
        facility?: string;
        /**
         * Destination of the logs.
         */
        dest?: "on" | "host" | "console" | "monitor" | "buffered";
        auth_pass?: string;
        /**
         * Set logging severity levels.
         */
        level?: string;
        /**
         * Default: present
         *
         * State of the logging configuration.
         */
        state?: "present" | "absent";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of logging definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        /**
         * Default: 4096
         *
         * Size of buffer. The acceptable value is in range from 4096 to 4294967295 bytes.
         */
        size?: number | string;
        [k: string]: unknown;
      };
      /**
       * Tests reachability using ping from network device to a remote destination.
       * For Windows targets, use the M(win_ping) module instead.
       * For targets running Python, use the M(ping) module instead.
       */
      net_ping?: {
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Determines if the expected result is success or fail.
         */
        state?: "absent" | "present";
        name?: string;
        vlan_id?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of node system attributes on Cisco IOS devices.  It provides an option to configure host system parameters or remove those parameters from the device active configuration.
       */
      ios_system?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.
         */
        lookup_source?: string;
        /**
         * Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
         */
        domain_search?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_pass?: string;
        /**
         * Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
         */
        domain_name?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        /**
         * Default: present
         *
         * State of the configuration values in the device's current active configuration.  When set to I(present), the values should be configured in the device active configuration and when set to I(absent) the values should not be in the device active configuration
         */
        state?: "present" | "absent";
        /**
         * Configure the device hostname parameter. This option takes an ASCII string value.
         */
        hostname?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.
         */
        name_servers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        /**
         * Administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.
         */
        lookup_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage RabbitMQ plugins.
       */
      win_rabbitmq_plugin?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module offers the ability to be output to the log buffer, log file, console, terminal, or log host on HUAWEI CloudEngine switches.
       */
      ce_info_center_global?: {
        /**
         * Log record tool.
         */
        facility?: "local0" | "local1" | "local2" | "local3" | "local4" | "local5" | "local6" | "local7";
        /**
         * Transport mode. The value is of the enumerated type and case-sensitive.
         */
        transport_mode?: "tcp" | "udp";
        /**
         * Default: console
         *
         * Channel name.The value is a string of 1 to 30 case-sensitive characters. The default value is console.
         */
        channel_cfg_name?: string;
        /**
         * Whether a device is enabled to suppress duplicate statistics. The value is of the Boolean type.
         */
        suppress_enable?: "false" | "true";
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Channel name. The value is a string of 1 to 30 case-sensitive characters.
         */
        channel_name?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Default: 32
         *
         * Maximum size (in MB) of a log file. The default value is 32.
         * The value range for log files is [4, 8, 16, 32], for security files is [1, 4],
         * and for operation files is [1, 4].
         */
        logfile_max_size?: "4" | "8" | "16" | "32";
        /**
         * Number of a port sending logs.The value is an integer ranging from 1 to 65535. For UDP, the default value is 514. For TCP, the default value is 601. For TSL, the default value is 6514.
         */
        server_port?: string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Whether the info-center function is enabled. The value is of the Boolean type.
         */
        info_center_enable?: "true" | "false";
        /**
         * Log server address type, IPv4 or IPv6.
         */
        ip_type?: "ipv4" | "ipv6";
        /**
         * Maximum number of log files of the same type. The default value is 200.
         * The value range for log files is[3, 500], for security files is [1, 3],and for operation files is [1, 7].
         */
        logfile_max_num?: string;
        username?: string;
        /**
         * Log server address, IPv4 or IPv6 type. The value is a string of 0 to 255 characters. The value can be an valid IPv4 or IPv6 address.
         */
        server_ip?: string;
        /**
         * Name of the filtered log. The value is a string of 1 to 63 case-sensitive characters.
         */
        filter_log_name?: string;
        /**
         * SSL policy name. The value is a string of 1 to 23 case-sensitive characters.
         */
        ssl_policy_name?: string;
        /**
         * Log server timestamp. The value is of the enumerated type and case-sensitive.
         */
        timestamp?: "UTC" | "localtime";
        /**
         * Direction of information output.
         */
        channel_out_direct?: "console" | "monitor" | "trapbuffer" | "logbuffer" | "snmp" | "logfile";
        host?: string;
        /**
         * Feature name of the filtered log. The value is a string of 1 to 31 case-insensitive characters.
         */
        filter_feature_name?: string;
        password?: string;
        /**
         * Default: no
         *
         * Use the default VPN or not.
         */
        is_default_vpn?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Server name. The value is a string of 1 to 255 case-sensitive characters.
         */
        server_domain?: string;
        /**
         * Level of logs saved on a log server.
         */
        level?:
          | "emergencies"
          | "alert"
          | "critical"
          | "error"
          | "warning"
          | "notification"
          | "informational"
          | "debugging";
        /**
         * Set the priority of the syslog packet.The value is an integer ranging from 0 to 7. The default value is 0.
         */
        packet_priority?: string;
        /**
         * Log source ip address, IPv4 or IPv6 type. The value is a string of 0 to 255. The value can be an valid IPv4 or IPv6 address.
         */
        source_ip?: string;
        /**
         * Number for channel. The value is an integer ranging from 0 to 9. The default value is 0.
         */
        channel_id?: string;
        /**
         * VPN name on a log server. The value is a string of 1 to 31 case-sensitive characters. The default value is _public_.
         */
        vrf_name?: string;
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Module to manage storage connections in oVirt
       */
      ovirt_storage_connection?: {
        /**
         * This parameter is relevant only when updating a connection.
         * If I(true) the storage domain don't have to be in I(MAINTENANCE) state, so the storage connection is updated.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        fetch_nested?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Option which will be passed when mounting storage.
         */
        mount_options?: string;
        /**
         * Id of the storage connection to manage.
         */
        id?: string;
        /**
         * Name of the storage domain to be used with storage connection.
         */
        storage?: string;
        /**
         * Port of the iSCSI storage server.
         */
        port?: number | string;
        /**
         * Default: present
         *
         * Should the storage connection be present or absent.
         */
        state?: "present" | "absent";
        /**
         * Storage type. For example: I(nfs), I(iscsi), etc.
         */
        type?: string;
        /**
         * A CHAP username for logging into a target.
         */
        username?: string;
        auth: {
          [k: string]: unknown;
        };
        nested_attributes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Address of the storage server. E.g.: myserver.mydomain.com
         */
        address?: string;
        /**
         * The time in tenths of a second to wait for a response before retrying NFS requests. Range 0 to 65535.
         */
        nfs_timeout?: number | string;
        /**
         * Path of the mount point of the storage. E.g.: /path/to/my/data
         */
        path?: string;
        /**
         * A CHAP password for logging into a target.
         */
        password?: string;
        /**
         * NFS version. One of: I(auto), I(v3), I(v4) or I(v4_1).
         */
        nfs_version?: string;
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The target IQN for the storage device.
         */
        target?: string;
        poll_interval?: number | string;
        /**
         * The number of times to retry a request before attempting further recovery actions. Range 0 to 65535.
         */
        nfs_retrans?: number | string;
        timeout?: number | string;
        /**
         * Virtual File System type.
         */
        vfs_type?: string;
        [k: string]: unknown;
      };
      /**
       * Manages MacPorts packages (ports)
       */
      macports?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module manage affinity groups in oVirt/RHV. It can also manage assignments of those groups to VMs.
       */
      ovirt_affinity_group?: {
        /**
         * If I(yes) VM cannot start if it does not satisfy the C(vm_rule).
         */
        vm_enforcing?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Description of the affinity group.
         */
        description?: string;
        /**
         * If I(positive) I(all) VMs in this group should run on the this host.
         * If I(negative) I(no) VMs in this group should run on the this host.
         * This parameter is support since oVirt/RHV 4.1 version.
         */
        host_rule?: "negative" | "positive";
        poll_interval?: number | string;
        /**
         * Default: present
         *
         * Should the affinity group be present or absent.
         */
        state?: "absent" | "present";
        auth: {
          [k: string]: unknown;
        };
        /**
         * Name of the affinity group to manage.
         */
        name: string;
        /**
         * Name of the cluster of the affinity group.
         */
        cluster: string;
        fetch_nested?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of the hosts names, which should have assigned this affinity group.
         * This parameter is support since oVirt/RHV 4.1 version.
         */
        hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        nested_attributes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        /**
         * If I(positive) I(all) VMs in this group should run on the host defined by C(host_rule).
         * If I(negative) I(no) VMs in this group should run on the host defined by C(host_rule).
         * If I(disabled) this affinity group doesn't take effect.
         */
        vm_rule?: "disabled" | "negative" | "positive";
        /**
         * If I(yes) VM cannot start on host if it does not satisfy the C(host_rule).
         * This parameter is support since oVirt/RHV 4.1 version.
         */
        host_enforcing?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of the VMs names, which should have assigned this affinity group.
         */
        vms?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Configures timezone on Cisco UCS Manager.
       * Examples can be used with the L(UCS Platform Emulator,https://communities.cisco.com/ucspe).
       */
      ucs_timezone?: {
        /**
         * The timezone name.
         * Time zone names are from the L(tz database,https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
         * The timezone name is case sensitive.
         * The timezone name can be between 0 and 510 alphanumeric characters.
         * You cannot use spaces or any special characters other than
         * "-" (hyphen), "_" (underscore), "/" (backslash).
         */
        timezone?: string;
        /**
         * Default: present
         *
         * If C(absent), will unset timezone.
         * If C(present), will set or update timezone.
         */
        state?: string;
        /**
         * Default: enabled
         *
         * The admin_state setting
         * The enabled admin_state indicates the timezone confguration is utilized by UCS Manager.
         * The disabled admin_state indicates the timezone confguration is ignored by UCS Manager.
         */
        admin_state?: string;
        /**
         * A user-defined description of the timezone.
         * Enter up to 256 characters.
         * You can use any characters or spaces except the following:
         * ` (accent mark),  (backslash), ^ (carat), " (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * This will configure both login and motd banners on network devices. It allows playbooks to add or remove banner text from the active running configuration.
       */
      net_banner?: {
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Specifies whether or not the configuration is present in the current devices active running configuration.
         */
        state?: "present" | "absent";
        name?: string;
        vlan_id?: number | string;
        [k: string]: unknown;
      };
      /**
       * Add and remove users from groups
       */
      os_user_group?: {
        /**
         * Default: present
         *
         * Should the user be present or absent in the group
         */
        state?: string;
        /**
         * Name or id for the group.
         */
        group?: string;
        /**
         * Name or id for the user
         */
        user?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure ControllerProperties object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_controllerproperties?: {
        /**
         * Number of vs_se_ping_fail.
         * Default value when not specified in API or module is interpreted by Avi Controller as 60.
         * Units(SEC).
         */
        vs_se_ping_fail?: number | string;
        /**
         * Token used for uploading tech-support to portal.
         * Field introduced in 16.4.6,17.1.2.
         */
        portal_token?: string;
        /**
         * Number of cluster_ip_gratuitous_arp_period.
         * Default value when not specified in API or module is interpreted by Avi Controller as 60.
         * Units(MIN).
         */
        cluster_ip_gratuitous_arp_period?: number | string;
        /**
         * Allowed values are 1-1051200.
         * Special values are 0 - 'disabled'.
         * Default value when not specified in API or module is interpreted by Avi Controller as 60.
         * Units(MIN).
         */
        persistence_key_rotate_period?: number | string;
        /**
         * Number of unresponsive_se_reboot.
         * Default value when not specified in API or module is interpreted by Avi Controller as 300.
         * Units(SEC).
         */
        unresponsive_se_reboot?: number | string;
        /**
         * Number of attach_ip_retry_interval.
         * Default value when not specified in API or module is interpreted by Avi Controller as 360.
         * Units(SEC).
         */
        attach_ip_retry_interval?: number | string;
        /**
         * Number of vs_se_vnic_fail.
         * Default value when not specified in API or module is interpreted by Avi Controller as 300.
         * Units(SEC).
         */
        vs_se_vnic_fail?: number | string;
        /**
         * Number of secure_channel_se_token_timeout.
         * Default value when not specified in API or module is interpreted by Avi Controller as 60.
         * Units(MIN).
         */
        secure_channel_se_token_timeout?: number | string;
        /**
         * Number of attach_ip_retry_limit.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.
         */
        attach_ip_retry_limit?: number | string;
        /**
         * Number of se_vnic_cooldown.
         * Default value when not specified in API or module is interpreted by Avi Controller as 120.
         * Units(SEC).
         */
        se_vnic_cooldown?: number | string;
        /**
         * Number of vnic_op_fail_time.
         * Default value when not specified in API or module is interpreted by Avi Controller as 180.
         * Units(SEC).
         */
        vnic_op_fail_time?: number | string;
        /**
         * Maximum number of pcap files stored per tenant.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.
         */
        max_pcap_per_tenant?: number | string;
        /**
         * Enable/disable memory balancer.
         * Field introduced in 17.2.8.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        enable_memory_balancer?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Number of vs_se_bootup_fail.
         * Default value when not specified in API or module is interpreted by Avi Controller as 480.
         * Units(SEC).
         */
        vs_se_bootup_fail?: number | string;
        /**
         * Pool size used for all fabric commands during se upgrade.
         * Default value when not specified in API or module is interpreted by Avi Controller as 20.
         */
        seupgrade_fabric_pool_size?: number | string;
        /**
         * Allowed values are 1-1051200.
         * Special values are 0 - 'disabled'.
         * Default value when not specified in API or module is interpreted by Avi Controller as 60.
         * Units(MIN).
         */
        vs_key_rotate_period?: number | string;
        /**
         * Time to wait before marking segroup upgrade as stuck.
         * Default value when not specified in API or module is interpreted by Avi Controller as 360.
         * Units(SEC).
         */
        seupgrade_segroup_min_dead_timeout?: number | string;
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Number of upgrade_lease_time.
         * Default value when not specified in API or module is interpreted by Avi Controller as 360.
         * Units(SEC).
         */
        upgrade_lease_time?: number | string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Number of se_create_timeout.
         * Default value when not specified in API or module is interpreted by Avi Controller as 900.
         * Units(SEC).
         */
        se_create_timeout?: number | string;
        /**
         * Number of query_host_fail.
         * Default value when not specified in API or module is interpreted by Avi Controller as 180.
         * Units(SEC).
         */
        query_host_fail?: number | string;
        /**
         * Time to wait for the scaled out se to become ready before marking the scaleout done, applies to apic configuration only.
         * Default value when not specified in API or module is interpreted by Avi Controller as 360.
         * Units(SEC).
         */
        vs_apic_scaleout_timeout?: number | string;
        /**
         * Use ansible for se creation in baremetal.
         * Field introduced in 17.2.2.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        bm_use_ansible?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Number of se_offline_del.
         * Default value when not specified in API or module is interpreted by Avi Controller as 172000.
         * Units(SEC).
         */
        se_offline_del?: number | string;
        /**
         * Number of max_dead_se_in_grp.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.
         */
        max_dead_se_in_grp?: number | string;
        /**
         * Time to account for dns ttl during upgrade.
         * This is in addition to vs_scalein_timeout_for_upgrade in se_group.
         * Field introduced in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as 5.
         * Units(SEC).
         */
        upgrade_dns_ttl?: number | string;
        /**
         * Number of fatal_error_lease_time.
         * Default value when not specified in API or module is interpreted by Avi Controller as 120.
         * Units(SEC).
         */
        fatal_error_lease_time?: number | string;
        api_version?: string;
        username?: string;
        /**
         * Field introduced in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        allow_ip_forwarding?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Time to wait before marking attach ip operation on an se as failed.
         * Field introduced in 17.2.2.
         * Default value when not specified in API or module is interpreted by Avi Controller as 3600.
         * Units(SEC).
         */
        vs_se_attach_ip_fail?: number | string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Number of max_seq_vnic_failures.
         * Default value when not specified in API or module is interpreted by Avi Controller as 3.
         */
        max_seq_vnic_failures?: number | string;
        /**
         * Boolean flag to set allow_unauthenticated_nodes.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        allow_unauthenticated_nodes?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Allow unauthenticated access for special apis.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        allow_unauthenticated_apis?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        controller?: string;
        /**
         * Number of vs_awaiting_se_timeout.
         * Default value when not specified in API or module is interpreted by Avi Controller as 60.
         * Units(SEC).
         */
        vs_awaiting_se_timeout?: number | string;
        /**
         * Number of warmstart_se_reconnect_wait_time.
         * Default value when not specified in API or module is interpreted by Avi Controller as 300.
         * Units(SEC).
         */
        warmstart_se_reconnect_wait_time?: number | string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Number of dns_refresh_period.
         * Default value when not specified in API or module is interpreted by Avi Controller as 60.
         * Units(MIN).
         */
        dns_refresh_period?: number | string;
        tenant?: string;
        /**
         * Number of dummy.
         */
        dummy?: number | string;
        /**
         * Maximum number of consecutive attach ip failures that halts vs placement.
         * Field introduced in 17.2.2.
         * Default value when not specified in API or module is interpreted by Avi Controller as 3.
         */
        max_seq_attach_ip_failures?: number | string;
        /**
         * Number of secure_channel_cleanup_timeout.
         * Default value when not specified in API or module is interpreted by Avi Controller as 60.
         * Units(MIN).
         */
        secure_channel_cleanup_timeout?: number | string;
        /**
         * Number of days for ssl certificate expiry warning.
         * Units(DAYS).
         */
        ssl_certificate_expiry_warning_days?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Number of vs_se_vnic_ip_fail.
         * Default value when not specified in API or module is interpreted by Avi Controller as 120.
         * Units(SEC).
         */
        vs_se_vnic_ip_fail?: number | string;
        /**
         * Number of secure_channel_controller_token_timeout.
         * Default value when not specified in API or module is interpreted by Avi Controller as 60.
         * Units(MIN).
         */
        secure_channel_controller_token_timeout?: number | string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Number of vs_se_create_fail.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1500.
         * Units(SEC).
         */
        vs_se_create_fail?: number | string;
        /**
         * Allowed values are 0-1440.
         * Default value when not specified in API or module is interpreted by Avi Controller as 15.
         * Units(MIN).
         */
        api_idle_timeout?: number | string;
        /**
         * Number of crashed_se_reboot.
         * Default value when not specified in API or module is interpreted by Avi Controller as 900.
         * Units(SEC).
         */
        crashed_se_reboot?: number | string;
        /**
         * Export configuration in appviewx compatibility mode.
         * Field introduced in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        appviewx_compat_mode?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Version of the safenet package installed on the controller.
         * Field introduced in 16.5.2,17.2.3.
         */
        safenet_hsm_version?: string;
        /**
         * Interval between attempting failovers to an se.
         * Default value when not specified in API or module is interpreted by Avi Controller as 300.
         * Units(SEC).
         */
        se_failover_attempt_interval?: number | string;
        /**
         * Number of dead_se_detection_timer.
         * Default value when not specified in API or module is interpreted by Avi Controller as 360.
         * Units(SEC).
         */
        dead_se_detection_timer?: number | string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Manages VXLAN Virtual access point on HUAWEI CloudEngine Devices.
       */
      ce_vxlan_vap?: {
        username?: string;
        timeout?: number | string;
        /**
         * When I(encapsulation) is 'qinq', specifies an inner VLAN ID for double-tagged packets to be received by a Layer 2 sub-interface. The value is an integer ranging from 1 to 4094.
         */
        pe_vid?: string;
        /**
         * Specifies an Sub-Interface full name, i.e. "10GE1/0/41.1". The value is a string of 1 to 63 case-insensitive characters, spaces supported.
         */
        l2_sub_interface?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Specifies the VLAN binding to a BD(Bridge Domain). The value is an integer ranging ranging from 1 to 4094.
         */
        bind_vlan_id?: string;
        /**
         * Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.
         */
        bridge_domain_id?: string;
        host?: string;
        ssh_keyfile?: string;
        /**
         * When I(encapsulation) is 'dot1q', specifies a VLAN ID in the outer VLAN tag. When I(encapsulation) is 'qinq', specifies an outer VLAN ID for double-tagged packets to be received by a Layer 2 sub-interface. The value is an integer ranging from 1 to 4094.
         */
        ce_vid?: string;
        /**
         * Specifies an encapsulation type of packets allowed to pass through a Layer 2 sub-interface.
         */
        encapsulation?: "dot1q" | "default" | "untag" | "qinq" | "none";
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * An Ansible module to Create, Delete and Restore server snapshots in CenturyLink Cloud.
       */
      clc_server_snapshot?: {
        /**
         * Default: 7
         *
         * The number of days to keep the server snapshot before it expires.
         */
        expiration_days?: string;
        /**
         * The list of CLC server Ids.
         */
        server_ids:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * The state to insure that the provided resources are in.
         */
        state?: "present" | "absent" | "restore";
        /**
         * Default: True
         *
         * Whether to wait for the provisioning tasks to finish before returning.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Layer-2 interface on network devices.
       */
      net_l2_interface?: {
        [k: string]: unknown;
      };
      /**
       * Represents a VPN gateway running in GCP. This virtual device is managed by Google, but used only by you.
       */
      gcp_compute_target_vpn_gateway?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * An optional description of this resource.
         */
        description?: string;
        service_account_email?: string;
        /**
         * The region this gateway should sit in.
         */
        region: string;
        project?: string;
        /**
         * The network this VPN gateway is accepting traffic for.
         */
        network: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035.  Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * A ForwardingRule resource. A ForwardingRule resource specifies which pool of target virtual machines to forward a packet to if it matches the given [IPAddress, IPProtocol, portRange] tuple.
       */
      gcp_compute_forwarding_rule?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * This signifies what the ForwardingRule will be used for and can only take the following values: INTERNAL, EXTERNAL The value of INTERNAL means that this will be used for Internal Network Load Balancing (TCP, UDP). The value of EXTERNAL means that this will be used for External Load Balancing (HTTP(S) LB, External TCP/UDP LB, SSL Proxy) .
         */
        load_balancing_scheme?: "INTERNAL" | "EXTERNAL";
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: string;
        service_account_email?: string;
        /**
         * A reference to the region where the regional forwarding rule resides.
         * This field is not applicable to global forwarding rules.
         */
        region: string;
        /**
         * This field is used along with the backend_service field for internal load balancing.
         * When the load balancing scheme is INTERNAL, a single port or a comma separated list of ports can be configured. Only packets addressed to these ports will be forwarded to the backends configured with this forwarding rule.
         * You may specify a maximum of up to 5 ports.
         */
        ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The IP protocol to which this rule applies. Valid options are TCP, UDP, ESP, AH, SCTP or ICMP.
         * When the load balancing scheme is INTERNAL, only TCP and UDP are valid.
         */
        ip_protocol?: "TCP" | "UDP" | "ESP" | "AH" | "SCTP" | "ICMP";
        /**
         * Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        project?: string;
        /**
         * This field is used along with the target field for TargetHttpProxy, TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway, TargetPool, TargetInstance.
         * Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets addressed to ports in the specified range will be forwarded to target.
         * Forwarding rules with the same [IPAddress, IPProtocol] pair must have disjoint port ranges.
         * Some types of forwarding target have constraints on the acceptable ports:  * TargetHttpProxy: 80, 8080 * TargetHttpsProxy: 443 * TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,                   1883, 5222 * TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,                   1883, 5222 * TargetVpnGateway: 500, 4500 .
         */
        port_range?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * A reference to a BackendService to receive the matched traffic.
         * This is used for internal load balancing.
         * (not used for external load balancing) .
         */
        backend_service?: {
          [k: string]: unknown;
        };
        /**
         * A reference to a TargetPool resource to receive the matched traffic.
         * For regional forwarding rules, this target must live in the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object.
         * This field is not used for internal load balancing.
         */
        target?: {
          [k: string]: unknown;
        };
        /**
         * The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6. This can only be specified for a global forwarding rule.
         */
        ip_version?: "IPV4" | "IPV6";
        service_account_file?: string;
        /**
         * The IP address that this forwarding rule is serving on behalf of.
         * Addresses are restricted based on the forwarding rule's load balancing scheme (EXTERNAL or INTERNAL) and scope (global or regional).
         * When the load balancing scheme is EXTERNAL, for global forwarding rules, the address must be a global IP, and for regional forwarding rules, the address must live in the same region as the forwarding rule. If this field is empty, an ephemeral IPv4 address from the same scope (global or regional) will be assigned. A regional forwarding rule supports IPv4 only. A global forwarding rule supports either IPv4 or IPv6.
         * When the load balancing scheme is INTERNAL, this can only be an RFC 1918 IP address belonging to the network/subnet configured for the forwarding rule. By default, if this field is empty, an ephemeral internal IP address will be automatically allocated from the IP range of the subnet or network configured for this forwarding rule.
         * An address can be specified either by a literal IP address or a URL reference to an existing Address resource. The following examples are all valid:  * 100.1.2.3 * U(https://www.googleapis.com/compute/v1/projects/project/regions/region/addresses/address) * projects/project/regions/region/addresses/address * regions/region/addresses/address * global/addresses/address * address .
         */
        ip_address?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * A reference to a subnetwork.
         * For internal load balancing, this field identifies the subnetwork that the load balanced IP should belong to for this Forwarding Rule.
         * If the network specified is in auto subnet mode, this field is optional. However, if the network is in custom subnet mode, a subnetwork must be specified.
         * This field is not used for external load balancing.
         */
        subnetwork?: {
          [k: string]: unknown;
        };
        /**
         * For internal load balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.
         * This field is not used for external load balancing.
         */
        network?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Registers services and checks for an agent with a consul cluster. A service is some process running on the agent node that should be advertised by consul's discovery mechanism. It may optionally supply a check definition, a periodic service test to notify the consul cluster of service's health.
       * Checks may also be registered per node e.g. disk usage, or cpu usage and notify the health of the entire node to the cluster. Service level checks do not require a check name or id as these are derived by Consul from the Service name and id respectively by appending 'service:' Node level checks require a check_name and optionally a check_id.
       * Currently, there is no complete way to retrieve the script, interval or ttl metadata for a registered check. Without this metadata it is  not possible to tell if the data supplied with ansible represents a change to a check. As a result this does not attempt to determine changes and will always report a changed occurred. An api method is planned to supply this metadata so at that stage change management will be added.
       * See http://consul.io for more details.
       */
      consul?: {
        /**
         * the address to advertise that the service will be listening on. This value will be passed as the I(Address) parameter to Consul's U(/v1/agent/service/register) API method, so refer to the Consul API documentation for further details.
         */
        service_address?: string;
        /**
         * checks can be registered with an http endpoint. This means that consul will check that the http endpoint returns a successful http status. Interval must also be provided with this option.
         */
        http?: string;
        check_node?: string;
        /**
         * a list of tags that will be attached to the service registration.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * a name for the service check, defaults to the check id. required if standalone, ignored if part of service definition.
         */
        check_name?: string;
        /**
         * Unique name for the service on a node, must be unique per node, required if registering a service. May be omitted if registering a node level check
         */
        service_name?: string;
        /**
         * Notes to attach to check when registering it.
         */
        notes?: string;
        /**
         * the script/command that will be run periodically to check the health of the service. Scripts require an interval and vise versa
         */
        script?: string;
        /**
         * the token key indentifying an ACL rule set. May be required to register services.
         */
        token?: string;
        /**
         * the interval at which the service check will be run. This is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m. Required if the script param is specified.
         */
        interval?: string;
        /**
         * an ID for the service check, defaults to the check name, ignored if part of a service definition.
         */
        check_id?: string;
        /**
         * Default: localhost
         *
         * host of the consul agent defaults to localhost
         */
        host?: string;
        /**
         * register or deregister the consul service, defaults to present
         */
        state?: "present" | "absent";
        /**
         * the port on which the service is listening. Can optionally be supplied for registration of a service, i.e. if service_name or service_id is set
         */
        service_port?: number | string;
        /**
         * A custom HTTP check timeout. The consul default is 10 seconds. Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes, e.g. 15s or 1m.
         */
        timeout?: string;
        /**
         * checks can be registered with a ttl instead of a script and interval this means that the service will check in with the agent before the ttl expires. If it doesn't the check will be considered failed. Required if registering a check and the script an interval are missing Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m
         */
        ttl?: string;
        /**
         * Default: service_name if supplied
         *
         * the ID for the service, must be unique per node, defaults to the service name if the service name is supplied
         */
        service_id?: string;
        /**
         * Default: http
         *
         * the protocol scheme on which the consul agent is running
         */
        scheme?: string;
        /**
         * Default: yes
         *
         * whether to verify the tls certificate of the consul agent
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 8500
         *
         * the port on which the consul agent is running
         */
        port?: number | string;
        check_host?: string;
        [k: string]: unknown;
      };
      /**
       * Manages symbolic links using the 'update-alternatives' tool
       * Useful when multiple programs are installed but provide similar functionality (e.g. different editors).
       */
      alternatives?: {
        /**
         * Default: 50
         *
         * The priority of the alternative
         */
        priority?: number | string;
        /**
         * The path to the real executable that the link should point to.
         */
        path: string;
        /**
         * The path to the symbolic link that should point to the real executable.
         * This option is always required on RHEL-based distributions. On Debian-based distributions this option is required when the alternative I(name) is unknown to the system.
         */
        link?: string;
        /**
         * The generic name of the link.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module can add or remove tags U(https://cloud.google.com/compute/docs/label-or-tag-resources#tags) to/from GCE instances.  Use 'instance_pattern' to update multiple instances in a specify zone.
       */
      gce_tag?: {
        /**
         * Default: us-central1-a
         *
         * The zone of the disk specified by source.
         */
        zone?: string;
        /**
         * Comma-separated list of tags to add or remove.
         */
        tags:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Service account email.
         */
        service_account_email?: string;
        /**
         * Path to the PEM file associated with the service account email.
         */
        pem_file?: string;
        /**
         * The name of the GCE instance to add/remove tags.
         * Required if C(instance_pattern) is not specified.
         */
        instance_name?: string;
        /**
         * Default: present
         *
         * Desired state of the tags.
         */
        state?: "absent" | "present";
        /**
         * The pattern of GCE instance names to match for adding/removing tags.  Full-Python regex is supported. See U(https://docs.python.org/2/library/re.html) for details.
         * If C(instance_name) is not specified, this field is required.
         */
        instance_pattern?: string;
        /**
         * Your GCE project ID.
         */
        project_id?: string;
        [k: string]: unknown;
      };
      /**
       * Manages CLI scripts on a BIG-IP. CLI scripts, otherwise known as tmshell scripts or TMSH scripts allow you to create custom scripts that can run to manage objects within a BIG-IP.
       */
      bigip_cli_script?: {
        [k: string]: unknown;
      };
      /**
       * This module to creates, deletes or modifies pools on Infinibox.
       */
      infini_pool?: {
        /**
         * Default: True
         *
         * Enable/Disable SSD Cache on Pool
         */
        ssd_cache?: string;
        /**
         * Default: present
         *
         * Creates/Modifies Pool when present or removes when absent
         */
        state?: string;
        /**
         * Pool Virtual Capacity in MB, GB or TB units. If pool vsize is not set on pool creation, Virtual Capacity will be equal to Physical Capacity. See examples.
         */
        vsize?: string;
        /**
         * Pool Name
         */
        name?: string;
        /**
         * Pool Physical Capacity in MB, GB or TB units. If pool size is not set on pool creation, size will be equal to 1TB. See examples.
         */
        size?: string;
        [k: string]: unknown;
      };
      /**
       * Manages core NTP configuration.
       */
      nxos_ntp?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Local source address from which NTP messages are sent or keyword 'default'
         */
        source_addr?: string;
        auth_pass?: string;
        /**
         * Makes given NTP server or peer the preferred NTP server or peer for the device.
         */
        prefer?: "enabled" | "disabled";
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Network address of NTP server.
         */
        server?: string;
        /**
         * Local source interface from which NTP messages are sent. Must be fully qualified interface name or keyword 'default'
         */
        source_int?: string;
        /**
         * Authentication key identifier to use with given NTP server or peer or keyword 'default'.
         */
        key_id?: string;
        host?: string;
        /**
         * Makes the device communicate with the given NTP server or peer over a specific VRF or keyword 'default'.
         */
        vrf_name?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Network address of NTP peer.
         */
        peer?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Allows for the initialization, suspension and resumption of an asynchronous mirror group's synchronization for NetApp E-series storage arrays.
       */
      netapp_e_amg_sync?: {
        /**
         * The ID of the storage array containing the AMG you wish to target
         */
        ssid: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * The synchronization action you'd like to take.
         * If C(running) then it will begin syncing if there is no active sync or will resume a suspended sync. If there is already a sync in progress, it will return with an OK status.
         * If C(suspended) it will suspend any ongoing sync action, but return OK if there is no active sync or if the sync is already suspended
         */
        state: "running" | "suspended";
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * Indicates whether the failures point can be deleted on the secondary if necessary to achieve the synchronization.
         * If true, and if the amount of unsynchronized data exceeds the CoW repository capacity on the secondary for any member volume, the last failures point will be deleted and synchronization will continue.
         * If false, the synchronization will be suspended if the amount of unsynchronized data exceeds the CoW Repository capacity on the secondary and the failures point will be preserved.
         * NOTE: This only has impact for newly launched syncs.
         */
        delete_recovery_point?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the async mirror group you wish to target
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about application ELBs in AWS
       */
      elb_application_lb_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Represents a Route resource.
       * A route is a rule that specifies how certain packets should be handled by the virtual network. Routes are associated with virtual machines by tag, and the set of routes for a particular virtual machine is called its routing table. For each packet leaving a virtual machine, the system searches that virtual machine's routing table for a single best matching route.
       * Routes match packets by destination IP address, preferring smaller or more specific ranges over larger ones. If there is a tie, the system selects the route with the smallest priority value. If there is still a tie, it uses the layer three and four packet headers to select just one of the remaining matching routes. The packet is then forwarded as specified by the next_hop field of the winning route -- either to another virtual machine destination, a virtual machine gateway or a Compute Engine-operated gateway. Packets that do not match any route in the sending virtual machine's routing table will be dropped.
       * A Route resource must have exactly one specification of either nextHopGateway, nextHopInstance, nextHopIp, or nextHopVpnTunnel.
       */
      gcp_compute_route?: {
        /**
         * The destination range of outgoing packets that this route applies to.
         * Only IPv4 is supported.
         */
        dest_range: string;
        /**
         * The priority of this route. Priority is used to break ties in cases where there is more than one matching route of equal prefix length.
         * In the case of two routes with equal prefix length, the one with the lowest-numbered priority value wins.
         * Default value is 1000. Valid range is 0 through 65535.
         */
        priority?: number | string;
        /**
         * The network that this route applies to.
         */
        network: {
          [k: string]: unknown;
        };
        /**
         * URL to an instance that should handle matching packets.
         * You can specify this as a full or partial URL. For example:  * U(https://www.googleapis.com/compute/v1/projects/project/zones/zone/) instances/instance * projects/project/zones/zone/instances/instance * zones/zone/instances/instance .
         */
        next_hop_instance?: string;
        /**
         * A list of instance tags to which this route applies.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * URL to a gateway that should handle matching packets.
         * Currently, you can only specify the internet gateway, using a full or partial valid URL:  * U(https://www.googleapis.com/compute/v1/projects/project/global/gateways/default-internet-gateway) * projects/project/global/gateways/default-internet-gateway * global/gateways/default-internet-gateway .
         */
        next_hop_gateway?: string;
        /**
         * Network IP address of an instance that should handle matching packets.
         */
        next_hop_ip?: string;
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035.  Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * URL to a VpnTunnel that should handle matching packets.
         */
        next_hop_vpn_tunnel?: string;
        service_account_file?: string;
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of VRFs on Arista EOS network devices.
       */
      eos_vrf?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * List of VRFs definitions
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the VRF.
         */
        name?: string;
        /**
         * Route distinguisher of the VRF
         */
        rd?: string;
        /**
         * Identifies the set of interfaces that should be configured in the VRF. Interfaces must be routed interfaces in order to be placed into a VRF. The name of interface should be in expanded format and not abbreviated.
         */
        interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of the VRF configuration.
         */
        state?: "present" | "absent";
        /**
         * Default: 10
         *
         * Time in seconds to wait before checking for the operational state on remote device. This wait is applicable for operational state arguments.
         */
        delay?: number | string;
        /**
         * Purge VRFs not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * This is a intent option and checks the operational state of the for given vrf C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vrf interfaces on device it will result in failure.
         */
        associated_interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "eapi";
        [k: string]: unknown;
      };
      /**
       * Bind interface selector profiles to switch policy leaf profiles on Cisco ACI fabrics.
       */
      aci_interface_selector_to_switch_policy_leaf_profile?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Builds Redfish URIs locally and sends them to remote OOB controllers to get information back.
       * Information retrieved is placed in a location specified by the user.
       */
      redfish_facts?: {
        /**
         * Base URI of OOB controller
         */
        baseuri: string;
        /**
         * Default: ['Systems']
         *
         * List of categories to execute on OOB controller
         */
        category?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Password for authentication with OOB controller
         */
        password: string;
        /**
         * List of commands to execute on OOB controller
         */
        command?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * User for authentication with OOB controller
         */
        user: string;
        [k: string]: unknown;
      };
      /**
       * Configures WWNNs or WWPN pools on Cisco UCS Manager.
       * Examples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).
       */
      ucs_wwn_pool?: {
        /**
         * A description of the WWNN or WWPN pool.
         * Enter up to 256 characters.
         * You can use any characters or spaces except the following:
         * ` (accent mark),  (backslash), ^ (carat), " (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).
         */
        description?: string;
        /**
         * The last initiator in the Worlde Wide Name (WWN) block.
         * This is the To field in the UCS Manager Add WWN Blocks menu.
         * For WWxN pools, the pool size must be a multiple of ports-per-node + 1.
         * For example, if there are 7 ports per node, the pool size must be a multiple of 8.
         * If there are 63 ports per node, the pool size must be a multiple of 64.
         */
        last_addr?: string;
        /**
         * Default: org-root
         *
         * Org dn (distinguished name)
         */
        org_dn?: string;
        /**
         * The first initiator in the World Wide Name (WWN) block.
         * This is the From field in the UCS Manager Add WWN Blocks menu.
         */
        first_addr?: string;
        /**
         * Default: present
         *
         * If C(present), will verify WWNNs/WWPNs are present and will create if needed.
         * If C(absent), will verify WWNNs/WWPNs are absent and will delete if needed.
         */
        state?: string;
        /**
         * Specify whether this is a node (WWNN) or port (WWPN) pool.
         * Optional if state is absent.
         */
        purpose?: string;
        /**
         * Default: default
         *
         * The Assignment Order field.
         * This can be one of the following:
         * default - Cisco UCS Manager selects a random identity from the pool.
         * sequential - Cisco UCS Manager selects the lowest available identity from the pool.
         */
        order?: string;
        /**
         * The name of the World Wide Node Name (WWNN) or World Wide Port Name (WWPN) pool.
         * This name can be between 1 and 32 alphanumeric characters.
         * You cannot use spaces or any special characters other than - (hyphen), "_" (underscore), : (colon), and . (period).
         * You cannot change this name after the WWNN or WWPN pool is created.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about dhcp options sets in AWS
       */
      ec2_vpc_dhcp_option_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure GslbHealthMonitor object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_gslbhealthmonitor?: {
        /**
         * Healthmonitorhttp settings for gslbhealthmonitor.
         */
        https_monitor?: {
          [k: string]: unknown;
        };
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Number of continuous successful health checks before server is marked up.
         * Allowed values are 1-50.
         * Default value when not specified in API or module is interpreted by Avi Controller as 2.
         */
        successful_checks?: number | string;
        /**
         * Uuid of the health monitor.
         */
        uuid?: string;
        /**
         * Healthmonitordns settings for gslbhealthmonitor.
         */
        dns_monitor?: {
          [k: string]: unknown;
        };
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Number of continuous failed health checks before the server is marked down.
         * Allowed values are 1-50.
         * Default value when not specified in API or module is interpreted by Avi Controller as 2.
         */
        failed_checks?: number | string;
        /**
         * Healthmonitortcp settings for gslbhealthmonitor.
         */
        tcp_monitor?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Healthmonitorexternal settings for gslbhealthmonitor.
         */
        external_monitor?: {
          [k: string]: unknown;
        };
        /**
         * Type of the health monitor.
         * Enum options - HEALTH_MONITOR_PING, HEALTH_MONITOR_TCP, HEALTH_MONITOR_HTTP, HEALTH_MONITOR_HTTPS, HEALTH_MONITOR_EXTERNAL, HEALTH_MONITOR_UDP,
         * HEALTH_MONITOR_DNS, HEALTH_MONITOR_GSLB.
         */
        type: string;
        api_version?: string;
        username?: string;
        /**
         * A valid response from the server is expected within the receive timeout window.
         * This timeout must be less than the send interval.
         * If server status is regularly flapping up and down, consider increasing this value.
         * Allowed values are 1-300.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.
         */
        receive_timeout?: number | string;
        /**
         * User defined description for the object.
         */
        description?: string;
        controller?: string;
        /**
         * Healthmonitorudp settings for gslbhealthmonitor.
         */
        udp_monitor?: {
          [k: string]: unknown;
        };
        /**
         * Healthmonitorhttp settings for gslbhealthmonitor.
         */
        http_monitor?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * Use this port instead of the port defined for the server in the pool.
         * If the monitor succeeds to this port, the load balanced traffic will still be sent to the port of the server defined within the pool.
         * Allowed values are 1-65535.
         * Special values are 0 - 'use server port'.
         */
        monitor_port?: number | string;
        /**
         * A user friendly name for this health monitor.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Frequency, in seconds, that monitors are sent to a server.
         * Allowed values are 1-3600.
         * Default value when not specified in API or module is interpreted by Avi Controller as 5.
         */
        send_interval?: number | string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Create, destroy, or update accounts on ElementSW
       */
      na_elementsw_snapshot_schedule?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create, destroy, resize luns on NetApp cDOT.
       */
      na_cdot_lun?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages a BIG-IP configuration by allowing TMSH commands that modify running configuration, or merge SCF formatted files into the running configuration. Additionally, this module is of significant importance because it allows you to save your running configuration to disk. Since the F5 module only manipulate running configuration, it is important that you utilize this module to save that running config.
       */
      bigip_config?: {
        /**
         * Loads the default configuration on the device.
         * If this option is specified, the default configuration will be loaded before any commands or other provided configuration is run.
         */
        reset?: string;
        /**
         * Validates the specified configuration to see whether they are valid to replace the running configuration.
         * The running configuration will not be changed.
         * When this parameter is set to C(yes), no change will be reported by the module.
         */
        verify?: string;
        /**
         * Default: True
         *
         * The C(save) argument instructs the module to save the running-config to startup-config.
         * This operation is performed after any changes are made to the current running config. If no changes are made, the configuration is still saved to the startup config.
         * This option will always cause the module to return changed.
         */
        save?: string;
        /**
         * Loads the specified configuration that you want to merge into the running configuration. This is equivalent to using the C(tmsh) command C(load sys config from-terminal merge).
         * If you need to read configuration from a file or template, use Ansible's C(file) or C(template) lookup plugins respectively.
         */
        merge_content?: string;
        [k: string]: unknown;
      };
      /**
       * Upload, download, and delete objects in Rackspace Cloud Files
       */
      rax_files_objects?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or remove rights/permissions for a given user or group for the specified file, folder, registry key or AppPool identifies.
       * If adding ACL's for AppPool identities (available since 2.3), the Windows Feature "Web-Scripting-Tools" must be enabled.
       */
      win_acl?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Represents a TargetHttpsProxy resource, which is used by one or more global forwarding rule to route incoming HTTPS requests to a URL map.
       */
      gcp_compute_target_https_proxy?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        /**
         * A list of SslCertificate resources that are used to authenticate connections between users and the load balancer. Currently, exactly one SSL certificate must be specified.
         */
        ssl_certificates:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Specifies the QUIC override policy for this resource. This determines whether the load balancer will attempt to negotiate QUIC with clients or not. Can specify one of NONE, ENABLE, or DISABLE. If NONE is specified, uses the QUIC policy with no user overrides, which is equivalent to DISABLE. Not specifying this field is equivalent to specifying NONE.
         */
        quic_override?: "NONE" | "ENABLE" | "DISABLE";
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_email?: string;
        service_account_file?: string;
        /**
         * A reference to the UrlMap resource that defines the mapping from URL to the BackendService.
         */
        url_map: {
          [k: string]: unknown;
        };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * An optional description of this resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * This module creates, deletes or modifies volume on Infinibox.
       */
      infini_vol?: {
        /**
         * Default: present
         *
         * Creates/Modifies volume when present or removes when absent
         */
        state?: string;
        /**
         * Volume Name
         */
        name?: string;
        /**
         * Pool that volume will reside on
         */
        pool?: string;
        /**
         * Volume size in MB, GB or TB units. See examples.
         */
        size?: string;
        [k: string]: unknown;
      };
      /**
       * Manages the static routes on HUAWEI CloudEngine switches.
       */
      ce_static_route?: {
        username?: string;
        /**
         * Destination ip address of static route.
         */
        prefix: string;
        /**
         * Destination ip address family type of static route.
         */
        aftype: "v4" | "v6";
        /**
         * Name of the route. Used with the name parameter on the CLI.
         */
        description?: string;
        /**
         * Route tag value (numeric).
         */
        tag?: string;
        /**
         * Preference or administrative difference of route (range 1-255).
         */
        pref?: string;
        /**
         * Destination ip mask of static route.
         */
        mask: string;
        /**
         * VPN instance of next hop ip address.
         */
        destvrf?: string;
        /**
         * Next hop interface full name of static route.
         */
        nhp_interface?: string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Next hop address of static route.
         */
        next_hop?: string;
        /**
         * VPN instance of destination ip address.
         */
        vrf?: string;
        timeout?: number | string;
        ssh_keyfile?: string;
        host?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * This module allows you to work with switch configurations. It provides a way to roll back configurations of a switch from a remote server. This is achieved by using startup or running configurations of the target device that were previously backed up to a remote server using FTP, SFTP, TFTP, or SCP. The first step is to create a directory from where the remote server can be reached. The next step is to provide the full file path of he backup configuration's location. Authentication details required by the remote server must be provided as well. By default, this method overwrites the switch's configuration file with the newly downloaded file. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run.
       */
      cnos_rollback?: {
        /**
         * Specify password for the server relating to the protocol used.
         */
        serverpassword?: string;
        username?: string;
        outputfile: string;
        /**
         * This refers to the protocol used by the network device to interact with the remote server from where to download the backup configuration. The choices are FTP, SFTP, TFTP, or SCP. Any other protocols will result in error. If this parameter is not specified, there is no default value to be used.
         */
        protocol: string;
        serverip: string;
        /**
         * This refers to the type of configuration which will be used for the rolling back process. The choices are the running or startup configurations. There is no default value, so it will result in an error if the input is incorrect.
         */
        configType: string;
        host?: string;
        deviceType: string;
        /**
         * Specify username for the server relating to the protocol used.
         */
        serverusername?: string;
        password?: string;
        enablePassword?: string;
        /**
         * This specifies the full file path of the configuration file located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.
         */
        rcpath: string;
        [k: string]: unknown;
      };
      /**
       * Runs configuration templates, creates workflows and runs workflow actions in Radware vDirect server.
       */
      vdirect_runnable?: {
        /**
         * Default: 2189
         *
         * vDirect server HTTPS port number, may be set as C(VDIRECT_HTTPS_PORT) environment variable.
         */
        vdirect_https_port?: number | string;
        /**
         * vDirect runnable name to run.
         * May be configuration template name, workflow template name or workflow instance name.
         */
        runnable_name: string;
        /**
         * Action parameters dictionary. In case of C(ConfigurationTemplate) runnable type,
         * the device connection details should always be passed as a parameter.
         */
        parameters?: {
          [k: string]: unknown;
        };
        /**
         * Default: 2188
         *
         * vDirect server HTTP port number, may be set as C(VDIRECT_HTTP_PORT) environment variable.
         */
        vdirect_http_port?: number | string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated,
         * may be set as C(VDIRECT_VALIDATE_CERTS) or C(VDIRECT_VERIFY) environment variable.
         * This should only set to C(no) used on personally controlled sites using self-signed certificates.
         */
        vdirect_validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 60
         *
         * Amount of time to wait for async operation completion [seconds],
         * may be set as C(VDIRECT_TIMEOUT) environment variable.
         */
        vdirect_timeout?: number | string;
        /**
         * Default: yes
         *
         * Wait for async operation to complete, may be set as C(VDIRECT_WAIT) environment variable.
         */
        vdirect_wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Primary vDirect server IP address, may be set as C(VDIRECT_IP) environment variable.
         */
        vdirect_ip: string;
        /**
         * Workflow action name to run.
         * Required if I(runnable_type=Workflow).
         */
        action_name?: string;
        /**
         * vDirect server username, may be set as C(VDIRECT_USER) environment variable.
         */
        vdirect_user: string;
        /**
         * vDirect runnable type.
         */
        runnable_type: "ConfigurationTemplate" | "Workflow" | "WorkflowTemplate";
        /**
         * Secondary vDirect server IP address, may be set as C(VDIRECT_SECONDARY_IP) environment variable.
         */
        vdirect_secondary_ip?: string;
        /**
         * Default: yes
         *
         * If C(no), an HTTP connection will be used instead of the default HTTPS connection,
         * may be set as C(VDIRECT_HTTPS) or C(VDIRECT_USE_SSL) environment variable.
         */
        vdirect_use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * vDirect server password, may be set as C(VDIRECT_PASSWORD) environment variable.
         */
        vdirect_password: string;
        [k: string]: unknown;
      };
      /**
       * Returns information about the load balancer.
       * Will be marked changed when called only if state is changed.
       */
      ec2_elb_lb?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allows for the management of server certificates
       */
      iam_cert?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of VLANs on Arista EOS network devices.
       */
      eos_vlan?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * List of VLANs definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the VLAN.
         */
        name?: string;
        /**
         * List of interfaces that should be associated to the VLAN. The name of interface is case sensitive and should be in expanded format and not abbreviated.
         */
        interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of the VLAN configuration.
         */
        state?: "present" | "absent" | "active" | "suspend";
        /**
         * Default: 10
         *
         * Delay the play should wait to check for declarative intent params values.
         */
        delay?: number | string;
        /**
         * Purge VLANs not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        /**
         * ID of the VLAN.
         */
        vlan_id?: number | string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. The name of interface is case sensitive and should be in expanded format and not abbreviated. If the value in the C(associated_interfaces) does not match with the operational state of vlan interfaces on device it will result in failure.
         */
        associated_interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "eapi";
        [k: string]: unknown;
      };
      /**
       * This module is used to configure NetworkSecurityPolicy object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_networksecuritypolicy?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Creator name.
         */
        created_by?: string;
        /**
         * Name of the object.
         */
        name?: string;
        /**
         * List of networksecurityrule.
         */
        rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Checksum of cloud configuration for network sec policy.
         * Internally set by cloud connector.
         */
        cloud_config_cksum?: string;
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Creates or instances in AWS Lightsail and optionally wait for it to be 'running'.
       */
      lightsail?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage the arrays accessible via a NetApp Web Services Proxy for NetApp E-series storage arrays.
       */
      netapp_e_storage_system?: {
        /**
         * The ID of the array to manage. This value must be unique for each array.
         */
        ssid: string;
        /**
         * Optional meta tags to associate to this storage system
         */
        meta_tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url?: string;
        /**
         * The WWN of the array to manage. Only necessary if in-band managing multiple arrays on the same agent host.  Mutually exclusive of controller_addresses parameter.
         */
        array_wwn?: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password?: string;
        array_status_timeout_sec?: number | string;
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username?: string;
        /**
         * Whether the specified array should be configured on the Web Services Proxy or not.
         */
        state: "present" | "absent";
        /**
         * The management password of the array to manage, if set.
         */
        array_password?: string;
        /**
         * Default: no
         *
         * Enable trace logging for SYMbol calls to the storage system.
         */
        enable_trace?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The list addresses for the out-of-band management adapter or the agent host. Mutually exclusive of array_wwn parameter.
         */
        controller_addresses?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * The C(rocketchat) module sends notifications to Rocket Chat via the Incoming WebHook integration
       */
      rocketchat?: {
        /**
         * Default: Ansible
         *
         * This is the sender of the message.
         */
        username?: string;
        /**
         * The domain for your environment without protocol. (i.e. C(example.com) or C(chat.example.com))
         */
        domain: string;
        /**
         * Default: https
         *
         * Specify the protocol used to send notification messages before the webhook url. (i.e. http or https)
         */
        protocol?: "http" | "https";
        /**
         * Define a list of attachments.
         */
        attachments?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: normal
         *
         * Allow text to use default colors - use the default of 'normal' to not send a custom color bar at the start of the message
         */
        color?: "normal" | "good" | "warning" | "danger";
        /**
         * Default: https://www.ansible.com/favicon.ico
         *
         * URL for the message sender's icon.
         */
        icon_url?: string;
        /**
         * Rocket Chat Incoming Webhook integration token.  This provides authentication to Rocket Chat's Incoming webhook for posting messages.
         */
        token: string;
        /**
         * Emoji for the message sender. The representation for the available emojis can be got from Rocket Chat. (for example :thumbsup:) (if I(icon_emoji) is set, I(icon_url) will not be used)
         */
        icon_emoji?: string;
        /**
         * Default: 1
         *
         * Automatically create links for channels and usernames in I(msg).
         */
        link_names?: number | string;
        /**
         * Message to be sent.
         */
        msg?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Channel to send the message to. If absent, the message goes to the channel selected for the I(token) specified during the creation of webhook.
         */
        channel?: string;
        [k: string]: unknown;
      };
      /**
       * Manage SPAN destination groups on Cisco ACI fabrics.
       */
      aci_tenant_span_dst_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Retrieve the facts about one or more of the Fibre Channel Networks from OneView.
       */
      oneview_fc_network_facts?: {
        username?: string;
        image_streamer_hostname?: string;
        /**
         * Fibre Channel Network name.
         */
        name?: string;
        hostname?: string;
        params?: {
          [k: string]: unknown;
        };
        password?: string;
        config?: string;
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages global DLDP configuration on HUAWEI CloudEngine switches.
       */
      ce_dldp?: {
        time_interval?: string;
        username?: string;
        /**
         * Set global DLDP enable state.
         */
        enable?: "enable" | "disable";
        /**
         * Set global DLDP work-mode.
         */
        work_mode?: "enhance" | "normal";
        /**
         * Specifies authentication password. The value is a string of 1 to 16 case-sensitive plaintexts or 24/32/48/108/128 case-sensitive encrypted characters. The string excludes a question mark (?).
         */
        auth_pwd?: string;
        /**
         * Specifies authentication algorithm of DLDP.
         */
        auth_mode?: "md5" | "simple" | "sha" | "hmac-sha256" | "none";
        /**
         * Specify whether reset DLDP state of disabled interfaces.
         */
        reset?: "enable" | "disable";
        host?: string;
        ssh_keyfile?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Manage an AWS Network Elastic Load Balancer. See U(https://aws.amazon.com/blogs/aws/new-network-load-balancer-effortless-scaling-to-millions-of-requests-per-second/) for details.
       */
      elb_network_lb?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * create, delete, start, stop iSCSI service on SVM.
       */
      na_ontap_iscsi?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module has two possible ways of operation.
       * If 7zip is installed on the system, this module extracts files from an ISO into a temporary directory and copies files to a given destination, if needed.
       * If the user has mount-capabilities (CAP_SYS_ADMIN on Linux) this module mounts the ISO image to a temporary location, and copies files to a given destination, if needed.
       */
      iso_extract?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * This module allows the management of AWS Batch Compute Environments. It is idempotent and supports "Check" mode.  Use module M(aws_batch_compute_environment) to manage the compute environment, M(aws_batch_job_queue) to manage job queues, M(aws_batch_job_definition) to manage job definitions.
       */
      aws_batch_compute_environment?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Module to manage power management of hosts in oVirt/RHV.
       */
      ovirt_host_pm?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Templates are processed by the Jinja2 templating language (U(http://jinja.pocoo.org/docs/)) - documentation on the template formatting can be found in the Template Designer Documentation (U(http://jinja.pocoo.org/docs/templates/)).
       * Six additional variables can be used in templates: C(ansible_managed) (configurable via the C(defaults) section of C(ansible.cfg)) contains a string which can be used to describe the template name, host, modification time of the template file and the owner uid. C(template_host) contains the node name of the template's machine. C(template_uid) is the numeric user id of the owner. C(template_path) is the path of the template. C(template_fullpath) is the absolute path of the template. C(template_run_date) is the date that the template was rendered.
       */
      template?: {
        /**
         * Location to render the template to on the remote machine.
         */
        dest: string;
        path?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        exclude_path?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        remove?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        format?: "bz2" | "gz" | "tar" | "xz" | "zip";
        [k: string]: unknown;
      };
      /**
       * Create, update and delete instance of Key Vault.
       */
      azure_rm_keyvault?: {
        /**
         * The name of the Resource Group to which the server belongs.
         */
        resource_group: string;
        cloud_environment?: string;
        /**
         * Name of the vault
         */
        vault_name: string;
        /**
         * Property to specify whether Azure Virtual Machines are permitted to retrieve certificates stored as secrets from the key vault.
         */
        enabled_for_deployment?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * An array of 0 to 16 identities that have access to the key vault. All identities in the array must use the same tenant ID as the key vault's tenant ID.
         */
        access_policies?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * SKU details
         */
        sku?: {
          [k: string]: unknown;
        };
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        /**
         * Property to specify whether Azure Resource Manager is permitted to retrieve secrets from the key vault.
         */
        enabled_for_template_deployment?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        secret?: string;
        /**
         * Resource location. If not set, location from the resource group will be used as default.
         */
        location?: string;
        subscription_id?: string;
        profile?: string;
        /**
         * Default: present
         *
         * Assert the state of the KeyVault. Use 'present' to create or update an KeyVault and 'absent' to delete it.
         */
        state?: "absent" | "present";
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        tenant?: string;
        /**
         * The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault.
         */
        vault_tenant?: string;
        /**
         * Create vault in recovery mode.
         */
        recover_mode?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Property to specify whether Azure Disk Encryption is permitted to retrieve secrets from the vault and unwrap keys.
         */
        enabled_for_disk_encryption?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        /**
         * Property to specify whether the soft delete functionality is enabled for this key vault.
         */
        enable_soft_delete?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create, update, or destroy Ansible Tower inventories. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_inventory?: {
        /**
         * The host_filter field. Only useful when C(kind=smart).
         */
        host_filter?: string;
        /**
         * The kind field. Cannot be modified after created.
         */
        kind?: "" | "smart";
        tower_host?: string;
        /**
         * The description to use for the inventory.
         */
        description?: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        tower_password?: string;
        tower_username?: string;
        /**
         * Organization the inventory belongs to.
         */
        organization: string;
        /**
         * Inventory variables. Use C(@) to get from file.
         */
        variables?: string;
        /**
         * The name to use for the inventory.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages global GTM settings. These settings include general, load balancing, and metrics related settings.
       */
      bigip_gtm_global?: {
        /**
         * Specifies the name of the synchronization group to which the system belongs.
         */
        synchronization_group_name?: string;
        /**
         * Specifies that the system synchronizes Domain Name System (DNS) zone files among the synchronization group members.
         */
        synchronize_zone_files?: string;
        /**
         * Specifies whether this system is a member of a synchronization group.
         * When you enable synchronization, the system periodically queries other systems in the synchronization group to obtain and distribute configuration and metrics collection updates.
         * The synchronization group may contain systems configured as Global Traffic Manager and Link Controller systems.
         */
        synchronization?: string;
        [k: string]: unknown;
      };
      /**
       * Create or delete network namespaces using the ip command.
       */
      ip_netns?: {
        /**
         * Default: present
         *
         * Whether the namespace should exist
         */
        state?: "present" | "absent";
        /**
         * Name of the namespace
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Wait for Ansible Tower job to finish and report success or failure. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_job_wait?: {
        /**
         * Default: 1
         *
         * Minimum interval in seconds, to request an update from Tower.
         */
        min_interval?: number;
        /**
         * ID of the job to monitor.
         */
        job_id: number | string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        /**
         * Default: 30
         *
         * Maximum interval in seconds, to request an update from Tower.
         */
        max_interval?: number;
        /**
         * Maximum time in seconds to wait for a job to finish.
         */
        timeout?: number | string;
        tower_password?: string;
        tower_username?: string;
        tower_host?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about block storage volumes available in Vultr.
       */
      vultr_block_storage_facts?: {
        api_retries?: number | string;
        api_timeout?: number | string;
        api_endpoint?: string;
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV clusters.
       */
      ovirt_cluster_facts?: {
        /**
         * Search term which is accepted by oVirt/RHV search backend.
         * For example to search cluster X from datacenter Y use following pattern: name=X and datacenter=Y
         */
        pattern?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of LLDP interfaces configuration on VyOS network devices.
       */
      vyos_lldp_interface?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Name of the interface LLDP should be configured on.
         */
        name?: string;
        /**
         * Default: present
         *
         * State of the LLDP configuration.
         */
        state?: "present" | "absent" | "enabled" | "disabled";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of interfaces LLDP should be configured on.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Creates, modifies, and deletes Elasticache subnet groups. This module has a dependency on python-boto >= 2.5.
       */
      elasticache_subnet_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, assign and delete floating IPs on the cloudscale.ch IaaS service.
       * All operations are performed using the cloudscale.ch public API v1.
       * For details consult the full API documentation: U(https://www.cloudscale.ch/en/api/v1).
       * A valid API token is required for all operations. You can create as many tokens as you like using the cloudscale.ch control panel at U(https://control.cloudscale.ch).
       */
      cloudscale_floating_ip?: {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of L3 interfaces on slxos network devices.
       */
      slxos_l3_interface?: {
        /**
         * List of L3 interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and a optional C(ipv4) or C(ipv6) address.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * State of the L3 interface configuration. It indicates if the configuration should be present or absent on remote device.
         */
        state?: "present" | "absent";
        /**
         * IPv6 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv6 address>/<mask>, the mask is number in range 0-128 eg. fd5d:12c9:2201:1::1/64
         */
        ipv6?: string;
        /**
         * IPv4 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv4 address>/<mask>, the mask is number in range 0-32 eg. 192.168.0.1/24
         */
        ipv4?: string;
        /**
         * Name of the L3 interface to be configured eg. Ethernet 0/2
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to add / remove / reconnect an ESXi host to / from vCenter.
       */
      vmware_host?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manages SNMP location configurations on HUAWEI CloudEngine switches.
       */
      ce_snmp_location?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * Location information.
         */
        location: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Add or remove domains or subdomains on a Webfaction host. Further documentation at https://github.com/quentinsf/ansible-webfaction.
       */
      webfaction_domain?: {
        /**
         * Default: present
         *
         * Whether the domain should exist
         */
        state?: "present" | "absent";
        /**
         * Any subdomains to create.
         */
        subdomains?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The webfaction account to use
         */
        login_name: string;
        /**
         * The name of the domain
         */
        name: string;
        /**
         * The webfaction password to use
         */
        login_password: string;
        [k: string]: unknown;
      };
      /**
       * This module allows you to manipulate motd on cDOT
       */
      na_ontap_motd?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create, update, delete, export Grafana dashboards via API.
       */
      grafana_dashboard?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        };
      /**
       * Add or remove mailboxes on a Webfaction account. Further documentation at https://github.com/quentinsf/ansible-webfaction.
       */
      webfaction_mailbox?: {
        /**
         * The password for the mailbox
         */
        mailbox_password: string;
        /**
         * Default: present
         *
         * Whether the mailbox should exist
         */
        state?: "present" | "absent";
        /**
         * The webfaction account to use
         */
        login_name: string;
        /**
         * The name of the mailbox
         */
        mailbox_name: string;
        /**
         * The webfaction password to use
         */
        login_password: string;
        [k: string]: unknown;
      };
      /**
       * Collect facts information from a Pure Storage FlashBlade running the Purity//FB operating system. By default, the module will collect basic fact information including hosts, host groups, protection groups and volume counts. Additional fact information can be collected based on the configured set of arguements.
       */
      purefb_facts?: {
        /**
         * Default: minimum
         *
         * When supplied, this argument will define the facts to be collected. Possible values for this include all, minimum, config, performance, capacity, network, subnets, lags, filesystems and snapshots.
         */
        gather_subset?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure VSDataScriptSet object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_vsdatascriptset?: {
        /**
         * Uuid of pools that could be referred by vsdatascriptset objects.
         * It is a reference to an object of type pool.
         */
        pool_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Uuid of pool groups that could be referred by vsdatascriptset objects.
         * It is a reference to an object of type poolgroup.
         */
        pool_group_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Uuid of string groups that could be referred by vsdatascriptset objects.
         * It is a reference to an object of type stringgroup.
         */
        string_group_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Uuid of the virtual service datascript collection.
         */
        uuid?: string;
        /**
         * Uuid of ip groups that could be referred by vsdatascriptset objects.
         * It is a reference to an object of type ipaddrgroup.
         */
        ipgroup_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Creator name.
         * Field introduced in 17.1.11,17.2.4.
         */
        created_by?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        api_version?: string;
        username?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * Datascripts to execute.
         */
        datascript?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name for the virtual service datascript collection.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * The C(sns_topic) module allows you to create, delete, and manage subscriptions for AWS SNS topics. As of 2.6, this module can be use to subscribe and unsubscribe to topics outside of your AWS account.
       */
      sns_topic?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages utility licenses on a BIG-IQ. Utility licenses are one form of licenses that BIG-IQ can distribute. These licenses, unlike regkey licenses, do not require a pool to be created before creation. Additionally, when assigning them, you assign by offering instead of key.
       */
      bigiq_utility_license?: {
        [k: string]: unknown;
      };
      /**
       * Create/Modify/Delete ONTAP snapshots
       */
      na_ontap_snapshot?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Creates, Removes and configures a IIS Web site.
       */
      win_iis_website?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        /**
         * The host header to bind to / use for the new site.
         */
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The port to bind to / use for the new site.
         */
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * After .NET framework is installed/updated, Windows will probably want to recompile things to optimise for the host.
       * This happens via scheduled task, usually at some inopportune time.
       * This module allows you to run this task on your own schedule, so you incur the CPU hit at some more convenient and controlled time.
       * U(http://blogs.msdn.com/b/dotnet/archive/2013/08/06/wondering-why-mscorsvw-exe-has-high-cpu-usage-you-can-speed-it-up.aspx)
       */
      win_dotnet_ngen?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Adds or removes (rpm --import) a gpg key to your rpm database.
       */
      rpm_key?: {
        /**
         * Default: present
         *
         * If the key will be imported or removed from the rpm db.
         */
        state?: "absent" | "present";
        /**
         * Default: yes
         *
         * If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Key that will be modified. Can be a url, a file, or a keyid if the key already exists in the database.
         */
        key: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, or destroy Ansible Tower teams. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_team?: {
        description?: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        tower_password?: string;
        tower_username?: string;
        /**
         * Organization the team should be made a member of.
         */
        organization: string;
        tower_host?: string;
        /**
         * Name to use for the team.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * create/delete/dump zabbix template
       */
      zabbix_template?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Synchronizes the contents of two directories on the remote machine.
       * Under the hood this just calls out to RoboCopy, since that should be available on most modern Windows Systems.
       */
      win_robocopy?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * netact_cm_command can be used to run various configuration management operations. This module requires that the target hosts have Nokia NetAct network management system installed. Module will access the Configurator command line interface in NetAct to upload network configuration to NetAct, run configuration export, plan import and configuration provision operations To set the scope of the operation, define Distinguished Name (DN) or Working Set (WS) or Maintenance Region (MR) as input
       */
      netact_cm_command?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Configures vHBA templates on Cisco UCS Manager.
       * Examples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).
       */
      ucs_vhba_template?: {
        /**
         * Default: none
         *
         * The Redundancy Type used for template pairing from the Primary or Secondary redundancy template.
         * primary  Creates configurations that can be shared with the Secondary template.
         * Any other shared changes on the Primary template are automatically synchronized to the Secondary template.
         * secondary  All shared configurations are inherited from the Primary template.
         * none - Legacy vHBA template behavior. Select this option if you do not want to use redundancy.
         */
        redundancy_type?: string;
        /**
         * The name of the virtual HBA template.
         * This name can be between 1 and 16 alphanumeric characters.
         * You cannot use spaces or any special characters other than - (hyphen), "_" (underscore), : (colon), and . (period).
         * You cannot change this name after the template is created.
         */
        name?: string;
        /**
         * Default: default
         *
         * The statistics collection policy that is associated with vHBAs created from this template.
         */
        stats_policy?: string;
        /**
         * A user-defined description of the template.
         * Enter up to 256 characters.
         * You can use any characters or spaces except the following:
         * ` (accent mark),  (backslash), ^ (carat), " (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).
         */
        description?: string;
        /**
         * Default: org-root
         *
         * Org dn (distinguished name)
         */
        org_dn?: string;
        /**
         * Default: initial-template
         *
         * The Template Type field.
         * This can be one of the following:
         * initial-template  vHBAs created from this template are not updated if the template changes.
         * updating-template - vHBAs created from this template are updated if the template changes.
         */
        template_type?: string;
        /**
         * Default: 2048
         *
         * The Max Data Field Size field.
         * The maximum size of the Fibre Channel frame payload bytes that the vHBA supports.
         * Enter an string between '256' and '2112'.
         */
        max_data?: string;
        /**
         * Default: present
         *
         * If C(present), will verify vHBA templates are present and will create if needed.
         * If C(absent), will verify vHBA templates are absent and will delete if needed.
         */
        state?: string;
        /**
         * Default: default
         *
         * The WWPN pool that a vHBA created from this template uses to derive its WWPN address.
         */
        wwpn_pool?: string;
        /**
         * The SAN pin group that is associated with vHBAs created from this template.
         */
        pin_group?: string;
        /**
         * The QoS policy that is associated with vHBAs created from this template.
         */
        qos_policy?: string;
        /**
         * Default: default
         *
         * The VSAN to associate with vHBAs created from this template.
         */
        vsan?: string;
        /**
         * Default: A
         *
         * The Fabric ID field.
         * The name of the fabric interconnect that vHBAs created with this template are associated with.
         */
        fabric?: string;
        [k: string]: unknown;
      };
      /**
       * View GitHub issue for a given repository.
       */
      github_issue?: {
        /**
         * Default: get_status
         *
         * Get various details about issue depending upon action specified.
         */
        action?: string;
        /**
         * Name of repository from which issue needs to be retrieved.
         */
        repo: string;
        /**
         * Issue number for which information is required.
         */
        issue: string;
        /**
         * Name of the GitHub organization in which the repository is hosted.
         */
        organization: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather VMKernel facts about an ESXi host from given ESXi hostname or cluster name.
       */
      vmware_vmkernel_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Fetch AWS Storage Gateway facts
       */
      aws_sgw_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * A VPC network is a virtual version of the traditional physical networks that exist within and between physical data centers. A VPC network provides connectivity for your Compute Engine virtual machine (VM) instances, Container Engine containers, App Engine Flex services, and other network-related resources.
       * Each GCP project contains one or more VPC networks. Each VPC network is a global entity spanning all GCP regions. This global VPC network allows VM instances and other resources to communicate with each other via internal, private IP addresses.
       * Each VPC network is subdivided into subnets, and each subnet is contained within a single region. You can have more than one subnet in a region for a given VPC network. Each subnet has a contiguous private RFC1918 IP space. You create instances, containers, and the like in these subnets.
       * When you create an instance, you must create it in a subnet, and the instance draws its internal IP address from that subnet.
       * Virtual machine (VM) instances in a VPC network can communicate with instances in all other subnets of the same VPC network, regardless of region, using their RFC1918 private IP addresses. You can isolate portions of the network, even entire subnets, using firewall rules.
       */
      gcp_compute_subnetwork?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * An optional description of this resource. Provide this property when you create the resource. This field can be set only at resource creation time.
         */
        description?: string;
        /**
         * Whether the VMs in this subnet can access Google services without assigned external IP addresses.
         */
        private_ip_google_access?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        service_account_email?: string;
        /**
         * URL of the GCP region for this subnetwork.
         */
        region: string;
        /**
         * The name of the resource, provided by the client when initially creating the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        /**
         * The range of internal addresses that are owned by this subnetwork.
         * Provide this property when you create the subnetwork. For example, 10.0.0.0/8 or 192.168.0.0/16. Ranges must be unique and non-overlapping within a network. Only IPv4 is supported.
         */
        ip_cidr_range: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * The network this subnet belongs to.
         * Only networks that are in the distributed mode can have subnetworks.
         */
        network: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Provides functionality similar to the "docker login" command.
       * Authenticate with a docker registry and add the credentials to your local Docker config file. Adding the credentials to the config files allows future connections to the registry using tools such as Ansible's Docker modules, the Docker CLI and docker-py without needing to provide credentials.
       * Running in check mode will perform the authentication without updating the config file.
       */
      docker_login?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages BGP Address-family configurations on NX-OS switches.
       */
      nxos_bgp_af?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Filters routes rejected by the route-map and does not download them to the RIB.
         */
        table_map_filter?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify max suppress time for route-flap dampening stable route. Valid values are integer and keyword 'default'.
         */
        dampening_max_suppress_time?: string;
        /**
         * Enables the send capability of additional paths for all of the neighbors under this address family for which the capability has not been disabled.
         */
        additional_paths_send?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Install a backup path into the forwarding table and provide prefix independent convergence (PIC) in case of a PE-CE link failure.
         */
        additional_paths_install?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable/disable route-flap dampening.
         */
        dampening_state?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enables the receive capability of additional paths for all of the neighbors under this address family for which the capability has not been disabled.
         */
        additional_paths_receive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Advertises only active routes to peers.
         */
        suppress_inactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify route-map for route-flap dampening. Valid values are a string defining the name of the route-map.
         */
        dampening_routemap?: string;
        port?: number | string;
        transport?: "cli" | "nxapi";
        /**
         * Sets the administrative distance for local BGP routes. Valid values are Integer or keyword 'default'.
         */
        distance_local?: string;
        /**
         * Advertise evpn routes.
         */
        advertise_l2vpn_evpn?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Address Family Identifier.
         */
        afi: "ipv4" | "ipv6" | "vpnv4" | "vpnv6" | "l2vpn";
        auth_pass?: string;
        /**
         * Default information originate.
         */
        default_information_originate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Networks to configure. Valid value is a list of network prefixes to advertise. The list must be in the form of an array. Each entry in the array must include a prefix address and an optional route-map. For example [['10.0.0.0/16', 'routemap_LA'], ['192.168.1.1', 'Chicago'], ['192.168.2.0/24'], ['192.168.3.0/24', 'routemap_NYC']].
         */
        networks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * Configure a route-map for valid nexthops. Valid values are a string defining the name of the route-map.
         */
        next_hop_route_map?: string;
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * Apply table-map to filter routes downloaded into URIB. Valid values are a string.
         */
        table_map?: string;
        /**
         * Sub Address Family Identifier.
         */
        safi: "unicast" | "multicast" | "evpn";
        /**
         * Sets default metrics for routes redistributed into BGP. Valid values are Integer or keyword 'default'
         */
        default_metric?: string;
        /**
         * Configure client-to-client route reflection.
         */
        client_to_client?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify dampen value for IGP metric-related changes, in seconds. Valid values are integer and keyword 'default'.
         */
        dampen_igp_metric?: string;
        /**
         * Sets the administrative distance for iBGP routes. Valid values are Integer or keyword 'default'.
         */
        distance_ibgp?: string;
        host?: string;
        /**
         * Configures the capability of selecting additional paths for a prefix. Valid values are a string defining the name of the route-map.
         */
        additional_paths_selection?: string;
        /**
         * Configures the maximum number of ibgp equal-cost paths for load sharing. Valid value is an integer in the range 1-64.
         */
        maximum_paths_ibgp?: string;
        /**
         * Name of the VRF. The name 'default' is a valid VRF representing the global bgp.
         */
        vrf?: string;
        /**
         * Sets the administrative distance for eBGP routes. Valid values are Integer or keyword 'default'.
         */
        distance_ebgp?: string;
        password?: string;
        /**
         * BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.
         */
        asn: string;
        /**
         * A list of redistribute directives. Multiple redistribute entries are allowed. The list must be in the form of a nested array. the first entry of each array defines the source-protocol to redistribute from; the second entry defines a route-map name. A route-map is highly advised but may be optional on some platforms, in which case it may be omitted from the array list. For example [['direct', 'rm_direct'], ['lisp', 'rm_lisp']].
         */
        redistribute?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ssh_keyfile?: string;
        /**
         * Specify route suppress time for route-flap dampening. Valid values are integer and keyword 'default'.
         */
        dampening_suppress_time?: string;
        /**
         * Configures the maximum number of equal-cost paths for load sharing. Valid value is an integer in the range 1-64.
         */
        maximum_paths?: string;
        /**
         * An array of route-map names which will specify prefixes to inject. Each array entry must first specify the inject-map name, secondly an exist-map name, and optionally the copy-attributes keyword which indicates that attributes should be copied from the aggregate. For example [['lax_inject_map', 'lax_exist_map'], ['nyc_inject_map', 'nyc_exist_map', 'copy-attributes'], ['fsd_inject_map', 'fsd_exist_map']].
         */
        inject_map?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Specify route reuse time for route-flap dampening. Valid values are integer and keyword 'default'.
         */
        dampening_reuse_time?: string;
        timeout?: number | string;
        /**
         * Specify decay half-life in minutes for route-flap dampening. Valid values are integer and keyword 'default'.
         */
        dampening_half_time?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * When the user does not exist in Gitlab, it will be created.
       * When the user does exists and state=absent, the user will be deleted.
       * When changes are made to user, the user will be updated.
       */
      gitlab_user?: {
        [k: string]: unknown;
      };
      /**
       * Manages general policy configuration on a BIG-IP. This module is best used in conjunction with the C(bigip_policy_rule) module. This module can handle general configuration like setting the draft state of the policy, the description, and things unrelated to the policy rules themselves. It is also the first module that should be used when creating rules as the C(bigip_policy_rule) module requires a policy parameter.
       */
      bigip_policy?: {
        /**
         * The description to attach to the policy.
         * This parameter is only supported on versions of BIG-IP >= 12.1.0. On earlier versions it will simply be ignored.
         */
        description?: string;
        /**
         * Specifies a list of rules that you want associated with this policy. The order of this list is the order they will be evaluated by BIG-IP. If the specified rules do not exist (for example when creating a new policy) then they will be created.
         * The C(conditions) for a default rule are C(all).
         * The C(actions) for a default rule are C(ignore).
         * The C(bigip_policy_rule) module can be used to create and edit existing and new rules.
         */
        rules?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the method to determine which actions get executed in the case where there are multiple rules that match. When creating new policies, the default is C(first).
         * This module does not allow you to specify the C(best) strategy to use. It will choose the system default (C(/Common/best-match)) for you instead.
         */
        strategy?: string;
        /**
         * Default: present
         *
         * When C(state) is C(present), ensures that the policy exists and is published. When C(state) is C(absent), ensures that the policy is removed, even if it is currently drafted.
         * When C(state) is C(draft), ensures that the policy exists and is drafted. When modifying rules, it is required that policies first be in a draft.
         * Drafting is only supported on versions of BIG-IP >= 12.1.0. On versions prior to that, specifying a C(state) of C(draft) will raise an error.
         */
        state?: string;
        /**
         * The name of the policy to create.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific DNS Record Set in a Zone, or a specific type in all Zones or in one Zone etc.
       */
      azure_rm_dnsrecordset_facts?: {
        profile?: string;
        /**
         * Limit results by resource group. Required when filtering by name or type.
         */
        resource_group?: string;
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        /**
         * Default: 100
         *
         * Limit the maximum number of record sets to return
         */
        top?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        /**
         * Only show results for a Record Set.
         */
        relative_name?: string;
        /**
         * Limit record sets by record type.
         */
        record_type?: string;
        secret?: string;
        client_id?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        adfs_authority_url?: string;
        /**
         * Limit results by zones. Required when filtering by name or type.
         */
        zone_name?: string;
        subscription_id?: string;
        password?: string;
        tenant?: string;
        api_profile?: string;
        [k: string]: unknown;
      };
      /**
       * This module manages SSH keys on Scaleway account U(https://developer.scaleway.com)
       */
      scaleway_sshkey?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage HTTP compression profiles on a BIG-IP.
       */
      bigip_profile_http_compression?: {
        [k: string]: unknown;
      };
      /**
       * Deploy, start, update, scale, restart, restore, stop and destroy instances.
       */
      cs_instance?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages TCL iApp services on a BIG-IP.
       * If you are looking for the API that is communicated with on the BIG-IP, the one the is used is C(/mgmt/tm/sys/application/service/).
       */
      bigip_iapp_service?: {
        /**
         * Forces the updating of an iApp service even if the parameters to the service have not changed. This option is of particular importance if the iApp template that underlies the service has been updated in-place. This option is equivalent to re-configuring the iApp if that template has changed.
         */
        force?: string;
        /**
         * Description of the iApp service.
         * If this option is specified in the Ansible task, it will take precedence over any similar setting in the iApp Service payload that you provide in the C(parameters) field.
         */
        description?: string;
        /**
         * A hash of all the required template variables for the iApp template. If your parameters are stored in a file (the more common scenario) it is recommended you use either the C(file) or C(template) lookups to supply the expected parameters.
         * These parameters typically consist of the C(lists), C(tables), and C(variables) fields.
         */
        parameters?: string;
        /**
         * Default: True
         *
         * Indicates whether the application service is tied to the template, so when the template is updated, the application service changes to reflect the updates.
         * When C(yes), disallows any updates to the resources that the iApp service has created, if they are not updated directly through the iApp.
         * When C(no), allows updates outside of the iApp.
         * If this option is specified in the Ansible task, it will take precedence over any similar setting in the iApp Service payload that you provide in the C(parameters) field.
         */
        strict_updates?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * The device group for the iApp service.
         * If this option is specified in the Ansible task, it will take precedence over any similar setting in the iApp Service payload that you provide in the C(parameters) field.
         */
        device_group?: string;
        /**
         * The name of the iApp service that you want to deploy.
         */
        name?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the iApp service is created and running. When C(absent), ensures that the iApp service has been removed.
         */
        state?: string;
        /**
         * The iApp template from which to instantiate a new service. This template must exist on your BIG-IP before you can successfully create a service.
         * When creating a new service, this parameter is required.
         */
        template?: string;
        /**
         * The traffic group for the iApp service. When creating a new service, if this value is not specified, the default of C(/Common/traffic-group-1) will be used.
         * If this option is specified in the Ansible task, it will take precedence over any similar setting in the iApp Service payload that you provide in the C(parameters) field.
         */
        traffic_group?: string;
        /**
         * Metadata associated with the iApp service.
         * If this option is specified in the Ansible task, it will take precedence over any similar setting in the iApp Service payload that you provide in the C(parameters) field.
         */
        metadata?: string;
        [k: string]: unknown;
      };
      /**
       * Manages trunks on a BIG-IP.
       */
      bigip_trunk?: {
        /**
         * Specifies the basis for the hash that the system uses as the frame distribution algorithm. The system uses the resulting hash to determine which interface to use for forwarding traffic.
         * When creating a new trunk, if this parameter is not specified, the default is C(source-destination-ip).
         * When C(source-destination-mac), specifies that the system bases the hash on the combined MAC addresses of the source and the destination.
         * When C(destination-mac), specifies that the system bases the hash on the MAC address of the destination.
         * When C(source-destination-ip), specifies that the system bases the hash on the combined IP addresses of the source and the destination.
         */
        frame_distribution_hash?: string;
        /**
         * Specifies the name of the trunk.
         */
        name?: string;
        /**
         * The interfaces that are part of the trunk.
         * To clear the list of interfaces, specify an empty list.
         */
        interfaces?: string;
        /**
         * Specifies the operation mode for link aggregation control protocol (LACP), if LACP is enabled for the trunk.
         * When creating a new trunk, if this parameter is not specified, the default is C(active).
         * When C(active), specifies that the system periodically sends control packets regardless of whether the partner system has issued a request.
         * When C(passive), specifies that the system sends control packets only when the partner system has issued a request.
         */
        lacp_mode?: string;
        /**
         * Specifies, once the trunk is configured, the policy that the trunk uses to determine which member link (interface) can handle new traffic.
         * When creating a new trunk, if this value is not specific, the default is C(auto).
         * When C(auto), specifies that the system automatically determines which interfaces can handle new traffic. For the C(auto) option, the member links must all be the same media type and speed.
         * When C(maximum-bandwidth), specifies that the system determines which interfaces can handle new traffic based on the members' maximum bandwidth.
         */
        link_selection_policy?: string;
        /**
         * Specifies the rate at which the system sends the LACP control packets.
         * When creating a new trunk, if this parameter is not specified, the default is C(long).
         * When C(long), specifies that the system sends an LACP control packet every 30 seconds.
         * When C(short), specifies that the system sends an LACP control packet every 1 seconds.
         */
        lacp_timeout?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the resource exists.
         * When C(absent), ensures the resource is removed.
         */
        state?: string;
        /**
         * Specifies the ether-type value used for the packets handled on this trunk when it is a member in a QinQ vlan.
         * The ether-type can be set to any string containing a valid hexadecimal 16 bits number, or any of the well known ether-types; C(0x8100), C(0x9100), C(0x88a8).
         * This parameter is not supported on Virtual Editions.
         * You should always wrap this value in quotes to prevent Ansible from interpreting the value as a literal hexadecimal number and converting it to an integer.
         */
        qinq_ethertype?: string;
        /**
         * When C(yes), specifies that the system supports the link aggregation control protocol (LACP), which monitors the trunk by exchanging control packets over the member links to determine the health of the links.
         * If LACP detects a failure in a member link, it removes the link from the link aggregation.
         * When creating a new trunk, if this parameter is not specified, LACP is C(no).
         * LACP is disabled by default for backward compatibility. If this does not apply to your network, we recommend that you enable LACP.
         */
        lacp_enabled?: string;
        /**
         * Description of the trunk.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Create and remove DNS domains.
       */
      vultr_dns_domain?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module sends push notifications via Pushbullet to channels or devices.
       */
      pushbullet?: {
        /**
         * Body of the notification, e.g. Details of the fault you're alerting.
         */
        body?: string;
        /**
         * Title of the notification.
         */
        title: string;
        url?: string;
        /**
         * Default: note
         *
         * Thing you wish to push.
         */
        push_type?: "note" | "link";
        /**
         * The device NAME you wish to send a push notification, as seen on the Pushbullet main page.
         */
        device?: string;
        /**
         * Push bullet API token
         */
        api_key: string;
        /**
         * The channel TAG you wish to broadcast a push notification, as seen on the "My Channels" > "Edit your channel" at Pushbullet page.
         */
        channel?: string;
        [k: string]: unknown;
      };
      /**
       * Registers or deregisters ec2 images.
       */
      ec2_ami?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Check if PAN-OS device is ready for being configured (no pending jobs).
       * The check could be done once or multiple times until the device is ready.
       */
      panos_check?: {
        username?: string;
        password: string;
        ip_address: string;
        /**
         * Default: 0
         *
         * timeout of API calls
         */
        timeout?: number | string;
        /**
         * Default: 0
         *
         * time waited between checks
         */
        interval?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage vlan, vxlan, and vsan pools on Cisco ACI fabrics.
       */
      aci_encap_pool?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Module to manage permissions of users/groups in oVirt/RHV.
       */
      ovirt_permission?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manages packages with I(apt-rpm). Both low-level (I(rpm)) and high-level (I(apt-get)) package manager binaries required.
       */
      apt_rpm?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Collect facts from F5 BIG-IP devices.
       */
      bigip_device_facts?: {
        /**
         * When supplied, this argument will restrict the facts returned to a given subset.
         * Can specify a list of values to include a larger subset.
         * Values can also be used with an initial C(!) to specify that a specific subset should not be collected.
         */
        gather_subset?: string;
        [k: string]: unknown;
      };
      /**
       * Gathers information about IAM roles
       */
      iam_role_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages VRRP configuration on NX-OS switches.
       */
      nxos_vrrp?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * VRRP group number.
         */
        group: string;
        /**
         * Default: yes
         *
         * Enable/Disable preempt.
         */
        preempt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * VRRP virtual IP address or 'default' keyword
         */
        vip?: string;
        auth_pass?: string;
        host?: string;
        /**
         * Default: 1
         *
         * Time interval between advertisement or 'default' keyword
         */
        interval?: string;
        /**
         * Default: 100
         *
         * VRRP priority or 'default' keyword
         */
        priority?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Default: shutdown
         *
         * Used to enable or disable the VRRP process.
         *
         * Possible choices:
         * shutdown
         * no shutdown
         * default
         */
        admin_state?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Full name of interface that is being managed for VRRP.
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        /**
         * Clear text authentication string or 'default' keyword
         */
        authentication?: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to a Dell OS10 node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(dellos10_config) to configure Dell OS10 devices.
       */
      dellos10_command?: {
        username?: string;
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should be tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        /**
         * List of commands to send to the remote dellos10 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: "any" | "all";
        [k: string]: unknown;
      };
      /**
       * A trivial test module, this module always returns C(pong) on successful contact. It does not make sense in playbooks, but it is useful from C(/usr/bin/ansible) to verify the ability to login and that a usable python is configured.
       * This is NOT ICMP ping, this is just a trivial test module.
       */
      ping?: {
        data?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure Cloud object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_cloud?: {
        /**
         * Vcloudairconfiguration settings for cloud.
         */
        vca_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Proxyconfiguration settings for cloud.
         */
        proxy_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Dockerconfiguration settings for cloud.
         */
        docker_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Oshiftk8sconfiguration settings for cloud.
         */
        oshiftk8s_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Select the ip address management scheme.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        dhcp_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Rancherconfiguration settings for cloud.
         */
        rancher_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Cloud type.
         * Enum options - CLOUD_NONE, CLOUD_VCENTER, CLOUD_OPENSTACK, CLOUD_AWS, CLOUD_VCA, CLOUD_APIC, CLOUD_MESOS, CLOUD_LINUXSERVER, CLOUD_DOCKER_UCP,
         * CLOUD_RANCHER, CLOUD_OSHIFT_K8S, CLOUD_AZURE.
         * Default value when not specified in API or module is interpreted by Avi Controller as CLOUD_NONE.
         */
        vtype: string;
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Default prefix for all automatically created objects in this cloud.
         * This prefix can be overridden by the se-group template.
         */
        obj_name_prefix?: string;
        /**
         * Custom tags for all avi created resources in the cloud infrastructure.
         * Field introduced in 17.1.5.
         */
        custom_tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Configuration parameters for nsx manager.
         * Field introduced in 17.1.1.
         */
        nsx_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Boolean flag to set apic_mode.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        apic_mode?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Dns profile for the cloud.
         * It is a reference to an object of type ipamdnsproviderprofile.
         */
        dns_provider_ref?: string;
        api_version?: string;
        username?: string;
        /**
         * Mesosconfiguration settings for cloud.
         */
        mesos_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Openstackconfiguration settings for cloud.
         */
        openstack_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Use static routes for vip side network resolution during virtualservice placement.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        enable_vip_static_routes?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        controller?: string;
        /**
         * Dns profile for east-west services.
         * It is a reference to an object of type ipamdnsproviderprofile.
         */
        east_west_dns_provider_ref?: string;
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Ipam profile for the cloud.
         * It is a reference to an object of type ipamdnsproviderprofile.
         */
        ipam_provider_ref?: string;
        /**
         * Cloudstackconfiguration settings for cloud.
         */
        cloudstack_configuration?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * Dns records for vips are added/deleted based on the operational state of the vips.
         * Field introduced in 17.1.12.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        state_based_dns_registration?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Field introduced in 17.2.1.
         */
        azure_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Specifies the default license tier which would be used by new se groups.
         * This field by default inherits the value from system configuration.
         * Enum options - ENTERPRISE_16, ENTERPRISE_18.
         * Field introduced in 17.2.5.
         */
        license_tier?: string;
        /**
         * Name of the object.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Mtu setting for the cloud.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1500.
         * Units(BYTES).
         */
        mtu?: number | string;
        /**
         * Ipam profile for east-west services.
         * Warning - please use virtual subnets in this ipam profile that do not conflict with the underlay networks or any overlay networks in the cluster.
         * For example in aws and gcp, 169.254.0.0/16 is used for storing instance metadata.
         * Hence, it should not be used in this profile.
         * It is a reference to an object of type ipamdnsproviderprofile.
         */
        east_west_ipam_provider_ref?: string;
        /**
         * Linuxserverconfiguration settings for cloud.
         */
        linuxserver_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Apicconfiguration settings for cloud.
         */
        apic_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Prefer static routes over interface routes during virtualservice placement.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        prefer_static_routes?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * If no license type is specified then default license enforcement for the cloud type is chosen.
         * The default mappings are container cloud is max ses, openstack and vmware is cores and linux it is sockets.
         * Enum options - LIC_BACKEND_SERVERS, LIC_SOCKETS, LIC_CORES, LIC_HOSTS, LIC_SE_BANDWIDTH.
         */
        license_type?: string;
        /**
         * Vcenterconfiguration settings for cloud.
         */
        vcenter_configuration?: {
          [k: string]: unknown;
        };
        tenant_uuid?: string;
        /**
         * Awsconfiguration settings for cloud.
         */
        aws_configuration?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Collect facts from F5 BIG-IP devices via iControl SOAP API
       */
      bigip_facts?: {
        [k: string]: unknown;
      };
      /**
       * Create or Remove cinder block storage volumes
       */
      os_volume?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manages Eth-Trunk specific configuration parameters on HUAWEI CloudEngine switches.
       */
      ce_eth_trunk?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Default: no
         *
         * When true it forces Eth-Trunk members to match what is declared in the members param. This can be used to remove members.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Hash algorithm used for load balancing among Eth-Trunk member interfaces.
         */
        hash_type?: "src-dst-ip" | "src-dst-mac" | "enhanced" | "dst-ip" | "dst-mac" | "src-ip" | "src-mac";
        host?: string;
        /**
         * Specifies the working mode of an Eth-Trunk interface.
         */
        mode?: "manual" | "lacp-dynamic" | "lacp-static";
        /**
         * List of interfaces that will be managed in a given Eth-Trunk. The interface name must be full name.
         */
        members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Specifies the minimum number of Eth-Trunk member links in the Up state. The value is an integer ranging from 1 to the maximum number of interfaces that can be added to a Eth-Trunk interface.
         */
        min_links?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Eth-Trunk interface number. The value is an integer. The value range depends on the assign forward eth-trunk mode command. When 256 is specified, the value ranges from 0 to 255. When 512 is specified, the value ranges from 0 to 511. When 1024 is specified, the value ranges from 0 to 1023.
         */
        trunk_id: string;
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Manage SLB (Server Load Balancer) server objects on A10 Networks devices via aXAPIv3.
       */
      a10_server_axapi3?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module allows setting new variables.  Variables are set on a host-by-host basis just like facts discovered by the setup module.
       * These variables will be available to subsequent plays during an ansible-playbook run, but will not be saved across executions even if you use a fact cache.
       * Per the standard Ansible variable precedence rules, many other types of variables have a higher priority, so this value may be overridden. See L(Variable Precedence Guide,../user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable) for more information.
       * This module is also supported for Windows targets.
       */
      set_fact?: {
        active_connection_states?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        connect_timeout?: number | string;
        delay?: number | string;
        search_regex?: string;
        state?: "absent" | "drained" | "present" | "started" | "stopped";
        sleep?: number | string;
        timeout?: number | string;
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        msg?: string;
        path?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Notify newrelic about app deployments (see https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/deployment-notifications#api)
       */
      newrelic_deployment?: {
        /**
         * (one of app_name or application_id are required) The application id, found in the URL when viewing the application in RPM
         */
        application_id?: string;
        /**
         * Text annotation for the deployment - notes for you
         */
        description?: string;
        /**
         * A list of changes for this deployment
         */
        changelog?: string;
        /**
         * Name of the application
         */
        appname?: string;
        /**
         * The environment for this deployment
         */
        environment?: string;
        /**
         * API token, to place in the x-api-key header.
         */
        token: string;
        /**
         * The name of the user/process that triggered this deployment
         */
        user?: string;
        /**
         * (one of app_name or application_id are required) The value of app_name in the newrelic.yml file used by the application
         */
        app_name?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A revision number (e.g., git commit SHA)
         */
        revision?: string;
        [k: string]: unknown;
      };
      /**
       * Manage OpenNebula services
       */
      one_service?: {
        /**
         * Dictionary of key/value custom attributes which will be used when instantiating a new service.
         */
        custom_attrs?: {
          [k: string]: unknown;
        };
        /**
         * Number of VMs for the specified role
         */
        cardinality?: number | string;
        /**
         * Force the new cardinality even if it is outside the limits
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * URL of the OpenNebula OneFlow API server.
         * It is recommended to use HTTPS so that the username/password are not transferred over the network unencrypted.
         * If not set then the value of the ONEFLOW_URL environment variable is used.
         */
        api_url?: string;
        /**
         * Name of service template to use to create a new instace of a service
         */
        template_name?: string;
        /**
         * Name of the user to login into the OpenNebula OneFlow API server. If not set then the value of the C(ONEFLOW_USERNAME) environment variable is used.
         */
        api_username?: string;
        /**
         * Password of the user to login into OpenNebula OneFlow API server. If not set then the value of the C(ONEFLOW_PASSWORD) environment variable is used.
         */
        api_password?: string;
        /**
         * ID of the user which will be set as the owner of the service
         */
        owner_id?: number | string;
        /**
         * ID of a service template to use to create a new instance of a service
         */
        template_id?: number | string;
        /**
         * Default: present
         *
         * C(present) - instantiate a service from a template specified with C(template_id)/C(template_name).
         * C(absent) - terminate an instance of a service specified with C(service_id)/C(service_name).
         */
        state?: "present" | "absent";
        /**
         * Default: 300
         *
         * How long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * Name of the role whose cardinality should be changed
         */
        role?: string;
        /**
         * Set permission mode of a service instance in octet format, e.g. C(600) to give owner C(use) and C(manage) and nothing to group and others.
         */
        mode?: string;
        /**
         * Name of a service instance that you would like to manage
         */
        service_name?: string;
        /**
         * ID of a service instance that you would like to manage
         */
        service_id?: number | string;
        /**
         * Setting C(unique=yes) will make sure that there is only one service instance running with a name set with C(service_name) when
         * instantiating a service from a template specified with C(template_id)/C(template_name). Check examples below.
         */
        unique?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * ID of the group which will be set as the group of the service
         */
        group_id?: number | string;
        /**
         * Wait for the instance to reach RUNNING state after DEPLOYING or COOLDOWN state after SCALING
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages core NTP configuration on HUAWEI CloudEngine switches.
       */
      ce_ntp?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Makes given NTP server or peer the preferred NTP server or peer for the device.
         */
        is_preferred?: "enable" | "disable";
        /**
         * Default: _public_
         *
         * Makes the device communicate with the given NTP server or peer over a specific vpn.
         */
        vpn_name?: string;
        /**
         * Authentication key identifier to use with given NTP server or peer.
         */
        key_id?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Network address of NTP server.
         */
        server?: string;
        /**
         * Local source interface from which NTP messages are sent. Must be fully qualified interface name, i.e. C(40GE1/0/22), C(vlanif10). Interface types, such as C(10GE), C(40GE), C(100GE), C(Eth-Trunk), C(LoopBack), C(MEth), C(NULL), C(Tunnel), C(Vlanif).
         */
        source_int?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Network address of NTP peer.
         */
        peer?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of logging on Vyatta Vyos devices.
       */
      vyos_logging?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.
         */
        name?: string;
        /**
         * Set logging facility.
         */
        facility?: string;
        /**
         * Destination of the logs.
         */
        dest?: "console" | "file" | "global" | "host" | "user";
        /**
         * Set logging severity levels.
         */
        level?: string;
        /**
         * Default: present
         *
         * State of the logging configuration.
         */
        state?: "present" | "absent";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of logging definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * The C(sns) module sends notifications to a topic on your Amazon SNS account
       */
      sns?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module will import/delete SSL certificates on BIG-IP LTM. Certificates can be imported from certificate and key files on the local disk, in PEM format.
       */
      bigip_ssl_certificate?: {
        /**
         * Sets the contents of a certificate directly to the specified value. This is used with lookup plugins or for anything with formatting or
         * C(content) must be provided when C(state) is C(present).
         */
        content?: string;
        /**
         * Issuer certificate used for OCSP monitoring.
         * This parameter is only valid on versions of BIG-IP 13.0.0 or above.
         */
        issuer_cert?: string;
        /**
         * Default: present
         *
         * Certificate state. This determines if the provided certificate and key is to be made C(present) on the device or C(absent).
         */
        state?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * SSL Certificate Name. This is the cert name used when importing a certificate into the F5. It also determines the filenames of the objects on the LTM.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Modify Ansible Tower settings. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_settings?: {
        /**
         * Name of setting to modify
         */
        name: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Value to be modified for given setting.
         */
        value: string;
        tower_config_file?: string;
        tower_password?: string;
        tower_username?: string;
        tower_host?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides a mechanism for enabling and disabling protocols Mellanox on ONYX network devices.
       */
      onyx_protocol?: {
        /**
         * LLDP protocol
         */
        lldp?: "enabled" | "disabled";
        /**
         * LACP protocol
         */
        lacp?: "enabled" | "disabled";
        /**
         * MLAG protocol
         */
        mlag?: "enabled" | "disabled";
        /**
         * MAGP protocol
         */
        magp?: "enabled" | "disabled";
        /**
         * IP routing support
         */
        ip_routing?: "enabled" | "disabled";
        /**
         * BGP protocol
         */
        bgp?: "enabled" | "disabled";
        /**
         * IP L3 support
         */
        ip_l3?: "enabled" | "disabled";
        /**
         * IP IGMP snooping
         */
        igmp_snooping?: "enabled" | "disabled";
        /**
         * DCB priority flow control
         */
        dcb_pfc?: "enabled" | "disabled";
        /**
         * Spanning Tree support
         */
        spanning_tree?: "enabled" | "disabled";
        /**
         * OSPF protocol
         */
        ospf?: "enabled" | "disabled";
        [k: string]: unknown;
      };
      /**
       * Create, delete or extend the capacity of a volume on Pure Storage FlashArray.
       */
      purefa_volume?: {
        /**
         * The name of the target volume, if copying.
         */
        target?: string;
        /**
         * The name of the volume.
         */
        name?: string;
        /**
         * Default: present
         *
         * Define whether the volume should exist or not.
         */
        state?: string;
        /**
         * Volume size in M, G, T or P units.
         */
        size?: string;
        /**
         * Default: no
         *
         * Define whether to overwrite a target volume if it already exisits.
         */
        overwrite?: string;
        /**
         * Default: no
         *
         * Define whether to eradicate the volume on delete or leave in trash.
         */
        eradicate?: string;
        [k: string]: unknown;
      };
      /**
       * Describes a task definition in ecs.
       */
      ecs_taskdefinition_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage End Point (EP) retention protocol policies on Cisco ACI fabrics.
       */
      aci_tenant_ep_retention_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manages BGP address-family's neighbors configurations on NX-OS switches.
       */
      nxos_bgp_neighbor_af?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Activate the default-originate feature.
         */
        default_originate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Router reflector client.
         */
        route_reflector_client?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Weight value. Valid values are an integer value or 'default'.
         */
        weight?: string;
        /**
         * Site-of-origin. Valid values are a string defining a VPN extcommunity or 'default'.
         */
        soo?: string;
        /**
         * Activate the next-hop-third-party feature.
         */
        next_hop_third_party?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * suppress-inactive feature.
         */
        suppress_inactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * unsuppress-map. Valid values are a string defining a route-map name or 'default'.
         */
        unsuppress_map?: string;
        /**
         * Valid values are a string defining a prefix-list name, or 'default'.
         */
        prefix_list_out?: string;
        /**
         * Activate the as-override feature.
         */
        as_override?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        /**
         * Valid values are a string defining a filter-list name, or 'default'.
         */
        filter_list_out?: string;
        /**
         * Valid values are enable for basic command enablement; disable for disabling the command at the neighbor af level (it adds the disable keyword to the basic command); and inherit to remove the command at this level (the command value is inherited from a higher BGP layer).
         */
        additional_paths_send?: "enable" | "disable" | "inherit";
        auth_pass?: string;
        /**
         * Activate allowas-in property
         */
        allowas_in?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Optional warning-only keyword. Requires max_prefix_limit. May not be combined with max_prefix_interval.
         */
        max_prefix_warning?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.
         */
        asn: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the non-exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_non_exist_map']. This command is mutually exclusive with the advertise_map_exist property.
         */
        advertise_map_non_exist?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        username?: string;
        /**
         * Route-map for the default_originate property. Valid values are a string defining a route-map name, or 'default'. This is mutually exclusive with default_originate.
         */
        default_originate_route_map?: string;
        timeout?: number | string;
        /**
         * Sub Address Family Identifier.
         */
        safi: string;
        /**
         * Valid values are a string defining a filter-list name, or 'default'.
         */
        filter_list_in?: string;
        /**
         * Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.
         */
        neighbor: string;
        host?: string;
        /**
         * Valid values are 'enable' for basic command enablement; 'always' to add the always keyword to the basic command; and 'inherit' to remove the command at this level (the command value is inherited from a higher BGP layer).
         */
        soft_reconfiguration_in?: "enable" | "always" | "inherit";
        /**
         * Default: default
         *
         * Name of the VRF. The name 'default' is a valid VRF representing the global bgp.
         */
        vrf?: string;
        /**
         * Activate the next-hop-self feature.
         */
        next_hop_self?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * maximum-prefix limit value. Valid values are an integer value or 'default'.
         */
        max_prefix_limit?: string;
        password?: string;
        /**
         * Optional threshold percentage at which to generate a warning. Valid values are an integer value. Requires max_prefix_limit.
         */
        max_prefix_threshold?: string;
        /**
         * Valid values are a string defining a route-map name, or 'default'.
         */
        route_map_in?: string;
        /**
         * Address Family Identifier.
         */
        afi: string;
        ssh_keyfile?: string;
        /**
         * Optional restart interval. Valid values are an integer. Requires max_prefix_limit. May not be combined with max_prefix_warning.
         */
        max_prefix_interval?: string;
        /**
         * Valid values are a string defining a route-map name, or 'default'.
         */
        route_map_out?: string;
        /**
         * send-community attribute.
         */
        send_community?: "none" | "both" | "extended" | "standard" | "default";
        /**
         * Valid values are a string defining a prefix-list name, or 'default'.
         */
        prefix_list_in?: string;
        /**
         * Disable checking of peer AS-number while advertising
         */
        disable_peer_as_check?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Valid values are enable for basic command enablement; disable for disabling the command at the neighbor af level (it adds the disable keyword to the basic command); and inherit to remove the command at this level (the command value is inherited from a higher BGP layer).
         */
        additional_paths_receive?: "enable" | "disable" | "inherit";
        /**
         * Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_exist_map']. This command is mutually exclusive with the advertise_map_non_exist property.
         */
        advertise_map_exist?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Max-occurrences value for allowas_in. Valid values are an integer value or 'default'. This is mutually exclusive with allowas_in.
         */
        allowas_in_max?: string;
        [k: string]: unknown;
      };
      /**
       * Configure NetStream flow statistics exporting and versions for exported packets on HUAWEI CloudEngine switches.
       */
      ce_netstream_export?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Specifies NetStream feature.
         */
        type: "ip" | "vxlan";
        /**
         * Default: disable
         *
         * Configures the statistics to carry BGP next hop information. Currently, only V9 supports the exported packets carrying BGP next hop information.
         */
        bgp_nexthop?: "enable" | "disable";
        /**
         * Specifies the destination UDP port number of the exported packets. The value is an integer that ranges from 1 to 65535.
         */
        host_port?: string;
        /**
         * Specifies source address which can be IPv6 or IPv4 of the exported NetStream packet.
         */
        source_ip?: string;
        /**
         * Specifies the AS number recorded in the statistics as the original or the peer AS number.
         */
        as_option?: "origin" | "peer";
        /**
         * Specifies destination address which can be IPv6 or IPv4 of the exported NetStream packet.
         */
        host_ip?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Sets the version of exported packets.
         */
        version?: "5" | "9";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        host?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Specifies the VPN instance of the exported packets carrying flow statistics. Ensure the VPN instance has been created on the device.
         */
        host_vpn?: string;
        [k: string]: unknown;
      };
      /**
       * Bind AEPs to Physical or Virtual Domains on Cisco ACI fabrics.
       */
      aci_aep_to_domain?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Manages DNS monitors on a BIG-IP.
       */
      bigip_monitor_dns?: {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure AlertConfig object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_alertconfig?: {
        /**
         * Enable or disable this alert config from generating new alerts.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The object type to which the alert config is associated with.
         * Valid object types are - virtual service, pool, service engine.
         * Enum options - VIRTUALSERVICE, POOL, HEALTHMONITOR, NETWORKPROFILE, APPLICATIONPROFILE, HTTPPOLICYSET, DNSPOLICY, IPADDRGROUP, STRINGGROUP,
         * SSLPROFILE, SSLKEYANDCERTIFICATE, NETWORKSECURITYPOLICY, APPLICATIONPERSISTENCEPROFILE, ANALYTICSPROFILE, VSDATASCRIPTSET, TENANT, PKIPROFILE,
         * AUTHPROFILE, CLOUD, SERVERAUTOSCALEPOLICY, AUTOSCALELAUNCHCONFIG, MICROSERVICEGROUP, IPAMPROFILE, HARDWARESECURITYMODULEGROUP, POOLGROUP,
         * PRIORITYLABELS, POOLGROUPDEPLOYMENTPOLICY, GSLBSERVICE, GSLBSERVICERUNTIME, SCHEDULER, GSLBGEODBPROFILE, GSLBAPPLICATIONPERSISTENCEPROFILE,
         * TRAFFICCLONEPROFILE, VSVIP, WAFPOLICY, WAFPROFILE, ERRORPAGEPROFILE, ERRORPAGEBODY, L4POLICYSET, SERVICEENGINE, DEBUGSERVICEENGINE,
         * DEBUGCONTROLLER, DEBUGVIRTUALSERVICE, SERVICEENGINEGROUP, SEPROPERTIES, NETWORK, CONTROLLERNODE, CONTROLLERPROPERTIES, SYSTEMCONFIGURATION,
         * VRFCONTEXT, USER, ALERTCONFIG, ALERTSYSLOGCONFIG, ALERTEMAILCONFIG, ALERTTYPECONFIG, APPLICATION, ROLE, CLOUDPROPERTIES, SNMPTRAPPROFILE,
         * ACTIONGROUPPROFILE, MICROSERVICE, ALERTPARAMS, ACTIONGROUPCONFIG, CLOUDCONNECTORUSER, GSLB, GSLBDNSUPDATE, GSLBSITEOPS, GLBMGRWARMSTART,
         * IPAMDNSRECORD, GSLBDNSGSSTATUS, GSLBDNSGEOFILEOPS, GSLBDNSGEOUPDATE, GSLBDNSGEOCLUSTEROPS, GSLBDNSCLEANUP, GSLBSITEOPSRESYNC, TCPSTATRUNTIME,
         * UDPSTATRUNTIME, IPSTATRUNTIME, ARPSTATRUNTIME, MBSTATRUNTIME, IPSTKQSTATSRUNTIME, MALLOCSTATRUNTIME, SHMALLOCSTATRUNTIME, CPUUSAGERUNTIME,
         * L7GLOBALSTATSRUNTIME, L7VIRTUALSERVICESTATSRUNTIME, SEAGENTVNICDBRUNTIME, SEAGENTGRAPHDBRUNTIME, SEAGENTSTATERUNTIME, INTERFACERUNTIME,
         * ARPTABLERUNTIME, DISPATCHERSTATRUNTIME, DISPATCHERSTATCLEARRUNTIME, DISPATCHERTABLEDUMPRUNTIME, DISPATCHERREMOTETIMERLISTDUMPRUNTIME,
         * METRICSAGENTMESSAGE, HEALTHMONITORSTATRUNTIME, METRICSENTITYRUNTIME, PERSISTENCEINTERNAL, HTTPPOLICYSETINTERNAL, DNSPOLICYINTERNAL,
         * CONNECTIONDUMPRUNTIME, SHAREDDBSTATS, SHAREDDBSTATSCLEAR, ICMPSTATRUNTIME, ROUTETABLERUNTIME, VIRTUALMACHINE, POOLSERVER, SEVSLIST,
         * MEMINFORUNTIME, RTERINGSTATRUNTIME, ALGOSTATRUNTIME, HEALTHMONITORRUNTIME, CPUSTATRUNTIME, SEVM, HOST, PORTGROUP, CLUSTER, DATACENTER, VCENTER,
         * HTTPPOLICYSETSTATS, DNSPOLICYSTATS, METRICSSESTATS, RATELIMITERSTATRUNTIME, NETWORKSECURITYPOLICYSTATS, TCPCONNRUNTIME, POOLSTATS,
         * CONNPOOLINTERNAL, CONNPOOLSTATS, VSHASHSHOWRUNTIME, SELOGSTATSRUNTIME, NETWORKSECURITYPOLICYDETAIL, LICENSERUNTIME, SERVERRUNTIME,
         * METRICSRUNTIMESUMMARY, METRICSRUNTIMEDETAIL, DISPATCHERSEHMPROBETEMPDISABLERUNTIME, POOLDEBUG, VSLOGMGRMAP, SERUMINSERTIONSTATS, HTTPCACHE,
         * HTTPCACHESTATS, SEDOSSTATRUNTIME, VSDOSSTATRUNTIME, SERVERUPDATEREQ, VSSCALEOUTLIST, SEMEMDISTRUNTIME, TCPCONNRUNTIMEDETAIL, SEUPGRADESTATUS,
         * SEUPGRADEPREVIEW, SEFAULTINJECTEXHAUSTM, SEFAULTINJECTEXHAUSTMCL, SEFAULTINJECTEXHAUSTMCLSMALL, SEFAULTINJECTEXHAUSTCONN, SEHEADLESSONLINEREQ,
         * SEUPGRADE, SEUPGRADESTATUSDETAIL, SERESERVEDVS, SERESERVEDVSCLEAR, VSCANDIDATESEHOSTLIST, SEGROUPUPGRADE, REBALANCE, SEGROUPREBALANCE,
         * SEAUTHSTATSRUNTIME, AUTOSCALESTATE, VIRTUALSERVICEAUTHSTATS, NETWORKSECURITYPOLICYDOS, KEYVALINTERNAL, KEYVALSUMMARYINTERNAL,
         * SERVERSTATEUPDATEINFO, CLTRACKINTERNAL, CLTRACKSUMMARYINTERNAL, MICROSERVICERUNTIME, SEMICROSERVICE, VIRTUALSERVICEANALYSIS, CLIENTINTERNAL,
         * CLIENTSUMMARYINTERNAL, MICROSERVICEGROUPRUNTIME, BGPRUNTIME, REQUESTQUEUERUNTIME, MIGRATEALL, MIGRATEALLSTATUSSUMMARY, MIGRATEALLSTATUSDETAIL,
         * INTERFACESUMMARYRUNTIME, INTERFACELACPRUNTIME, DNSTABLE, GSLBSERVICEDETAIL, GSLBSERVICEINTERNAL, GSLBSERVICEHMONSTAT, SETROLESREQUEST,
         * TRAFFICCLONERUNTIME, GEOLOCATIONINFO, SEVSHBSTATRUNTIME, GEODBINTERNAL, GSLBSITEINTERNAL, WAFSTATS, USERDEFINEDDATASCRIPTCOUNTERS, LLDPRUNTIME,
         * VSESSHARINGPOOL, SEVSSPLACEMENT, L4POLICYSETSTATS, L4POLICYSETINTERNAL, SERESOURCEPROTO, SECONSUMERPROTO, SECREATEPENDINGPROTO, PLACEMENTSTATS,
         * SEVIPPROTO, RMVRFPROTO, VCENTERMAP, VIMGRVCENTERRUNTIME, INTERESTEDVMS, INTERESTEDHOSTS, VCENTERSUPPORTEDCOUNTERS, ENTITYCOUNTERS,
         * TRANSACTIONSTATS, SEVMCREATEPROGRESS, PLACEMENTSTATUS, VISUBFOLDERS, VIDATASTORE, VIHOSTRESOURCES, CLOUDCONNECTOR, VINETWORKSUBNETVMS,
         * VIDATASTORECONTENTS, VIMGRVCENTERCLOUDRUNTIME, VIVCENTERPORTGROUPS, VIVCENTERDATACENTERS, VIMGRHOSTRUNTIME, PLACEMENTGLOBALS, APICCONFIGURATION,
         * CIFTABLE, APICTRANSACTION, VIRTUALSERVICESTATEDBCACHESUMMARY, POOLSTATEDBCACHESUMMARY, SERVERSTATEDBCACHESUMMARY, APICAGENTINTERNAL,
         * APICTRANSACTIONFLAP, APICGRAPHINSTANCES, APICEPGS, APICEPGEPS, APICDEVICEPKGVER, APICTENANTS, APICVMMDOMAINS, NSXCONFIGURATION, NSXSGTABLE,
         * NSXAGENTINTERNAL, NSXSGINFO, NSXSGIPS, NSXAGENTINTERNALCLI, MAXOBJECTS.
         */
        object_type?: string;
        /**
         * Recommendation of alertconfig.
         */
        recommendation?: string;
        /**
         * An alert is created only when the number of events meets or exceeds this number within the chosen time frame.
         * Allowed values are 1-65536.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.
         */
        threshold?: number | string;
        /**
         * Determines whether an alert is raised immediately when event occurs (realtime) or after specified number of events occurs within rolling time
         * window.
         * Enum options - REALTIME, ROLLINGWINDOW, WATERMARK.
         * Default value when not specified in API or module is interpreted by Avi Controller as REALTIME.
         */
        category: string;
        /**
         * An alert is expired and deleted after the expiry time has elapsed.
         * The original event triggering the alert remains in the event's log.
         * Allowed values are 1-31536000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 86400.
         * Units(SEC).
         */
        expiry_time?: number | string;
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Signifies system events or the type of client logsused in this alert configuration.
         * Enum options - CONN_LOGS, APP_LOGS, EVENT_LOGS, METRICS.
         */
        source: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * List of filters matching on events or client logs used for triggering alerts.
         */
        alert_rule: {
          [k: string]: unknown;
        };
        api_version?: string;
        username?: string;
        /**
         * A custom description field.
         */
        description?: string;
        /**
         * This alert config applies to auto scale alerts.
         */
        autoscale_alert?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        controller?: string;
        /**
         * Uuid of the resource for which alert was raised.
         */
        obj_uuid?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        tenant?: string;
        /**
         * Alerts are suppressed (throttled) for this duration of time since the last alert was raised for this alert config.
         * Allowed values are 0-31536000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 600.
         * Units(SEC).
         */
        throttle?: number | string;
        /**
         * Name of the alert configuration.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Summary of reason why alert is generated.
         */
        summary?: string;
        /**
         * Only if the number of events is reached or exceeded within the time window will an alert be generated.
         * Allowed values are 1-31536000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 300.
         * Units(SEC).
         */
        rolling_window?: number | string;
        /**
         * The alert config will trigger the selected alert action, which can send notifications and execute a controlscript.
         * It is a reference to an object of type actiongroupconfig.
         */
        action_group_ref?: string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Manage content switching vserver
       * This module is intended to run either on the ansible  control node or a bastion (jumpserver) with access to the actual netscaler instance
       */
      netscaler_cs_vserver?: {
        /**
         * Information about this virtual server.
         */
        comment?: string;
        /**
         * Oracle server version.
         */
        oracleserverversion?: "10G" | "11G";
        /**
         * Type of precedence to use for both RULE-based and URL-based policies on the content switching virtual server. With the default C(RULE) setting, incoming requests are evaluated against the rule-based content switching policies. If none of the rules match, the URL in the request is evaluated against the URL-based content switching policies.
         */
        precedence?: "RULE" | "URL";
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the HTTP profile containing HTTP configuration settings for the virtual server. The service type of the virtual server should be either C(HTTP) or C(SSL).
         * Minimum length = 1
         * Maximum length = 127
         */
        httpprofilename?: string;
        /**
         * The version of the MSSQL server.
         */
        mssqlserverversion?: "70" | "2000" | "2000SP1" | "2005" | "2008" | "2008R2" | "2012" | "2014";
        /**
         * Default: no
         *
         * When set to C(yes) the cs vserver will be disabled.
         * When set to C(no) the cs vserver will be enabled.
         * Note that due to limitations of the underlying NITRO API a C(disabled) state change alone does not cause the module result to report a changed status.
         */
        disabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_protocol?: "http" | "https";
        /**
         * The protocol version returned by the mysql vserver.
         */
        mysqlprotocolversion?: number;
        /**
         * String specifying the listen policy for the content switching virtual server. Can be either the name of an existing expression or an in-line expression.
         */
        listenpolicy?: string;
        /**
         * Can be active or passive.
         */
        icmpvsrresponse?: "PASSIVE" | "ACTIVE";
        /**
         * Enable state updates for a specific content switching virtual server. By default, the Content Switching virtual server is always UP, regardless of the state of the Load Balancing virtual servers bound to it. This parameter interacts with the global setting as follows:
         * Global Level | Vserver Level | Result
         * enabled enabled enabled
         * enabled disabled enabled
         * disabled enabled enabled
         * disabled disabled disabled
         * If you want to enable state updates for only some content switching virtual servers, be sure to disable the state update parameter.
         */
        stateupdate?: "enabled" | "disabled";
        /**
         * URL to which traffic is redirected if the virtual server becomes unavailable. The service type of the virtual server should be either C(HTTP) or C(SSL).
         * Caution: Make sure that the domain in the URL does not match the domain specified for a content switching policy. If it does, requests are continuously redirected to the unavailable virtual server.
         * Minimum length = 1
         */
        redirecturl?: string;
        /**
         * IP mask, in dotted decimal notation, for the IP Pattern parameter. Can have leading or trailing non-zero octets (for example, C(255.255.240.0) or C(0.0.255.255)). Accordingly, the mask specifies whether the first n bits or the last n bits of the destination IP address in a client request are to be matched with the corresponding bits in the IP pattern. The former is called a forward mask. The latter is called a reverse mask.
         */
        ipmask?: string;
        /**
         * Insert the virtual server's VIP address and port number in the request header. Available values function as follows:
         * C(VIPADDR) - Header contains the vserver's IP address and port number without any translation.
         * C(OFF) - The virtual IP and port header insertion option is disabled.
         * C(V6TOV4MAPPING) - Header contains the mapped IPv4 address corresponding to the IPv6 address of the vserver and the port number. An IPv6 address can be mapped to a user-specified IPv4 address using the set ns ip6 command.
         */
        insertvserveripport?: "OFF" | "VIPADDR" | "V6TOV4MAPPING";
        /**
         * State of port rewrite while performing HTTP redirect.
         */
        redirectportrewrite?: "enabled" | "disabled";
        /**
         * Port number for content switching virtual server.
         * Minimum value = 1
         * Range C(1) - C(65535)
         * * in CLI is represented as 65535 in NITRO API
         */
        port?: number | string;
        /**
         * Idle time, in seconds, after which the client connection is terminated. The default values are:
         * Minimum value = C(0)
         * Maximum value = C(31536000)
         */
        clttimeout?: number;
        /**
         * FQDN of the authentication virtual server. The service type of the virtual server should be either C(HTTP) or C(SSL).
         * Minimum length = 3
         * Maximum length = 252
         */
        authenticationhost?: string;
        /**
         * Protocol used by the virtual server.
         */
        servicetype?:
          | "HTTP"
          | "SSL"
          | "TCP"
          | "FTP"
          | "RTSP"
          | "SSL_TCP"
          | "UDP"
          | "DNS"
          | "SIP_UDP"
          | "SIP_TCP"
          | "SIP_SSL"
          | "ANY"
          | "RADIUS"
          | "RDP"
          | "MYSQL"
          | "MSSQL"
          | "DIAMETER"
          | "SSL_DIAMETER"
          | "DNS_TCP"
          | "ORACLE"
          | "SMPP";
        /**
         * The name of the ssl certificate that is bound to this service.
         * The ssl certificate must already exist.
         * Creating the certificate can be done with the M(netscaler_ssl_certkey) module.
         * This option is only applicable only when C(servicetype) is C(SSL).
         */
        ssl_certkey?: string;
        /**
         * The server capabilities returned by the mysql vserver.
         */
        mysqlservercapabilities?: number;
        /**
         * The server version string returned by the mysql vserver.
         * Minimum length = 1
         * Maximum length = 31
         */
        mysqlserverversion?: string;
        /**
         * The character set returned by the mysql vserver.
         */
        mysqlcharacterset?: number;
        /**
         * Enable HTTP 401-response based authentication.
         */
        authn401?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of virtual server IP and port header, for use with the VServer IP Port Insertion parameter.
         * Minimum length = 1
         */
        vipheader?: string;
        /**
         * Name of the load balancing virtual server, of type C(PUSH) or C(SSL_PUSH), to which the server pushes updates received on the client-facing load balancing virtual server.
         * Minimum length = 1
         */
        pushvserver?: string;
        nsip: string;
        state?: "present" | "absent";
        /**
         * Name of authentication virtual server that authenticates the incoming user requests to this content switching virtual server. .
         * Minimum length = 1
         * Maximum length = 252
         */
        authnvsname?: string;
        nitro_user: string;
        /**
         * The name of the network profile.
         * Minimum length = 1
         * Maximum length = 127
         */
        netprofile?: string;
        /**
         * Allow multiple Web 2.0 connections from the same client to connect to the virtual server and expect updates.
         */
        pushmulticlients?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.
         * Minimum value = 0
         * Maximum value = 4094
         */
        td?: number;
        /**
         * The default Load Balancing virtual server.
         */
        lbvserver?: string;
        nitro_timeout?: number;
        /**
         * A host route is injected according to the setting on the virtual servers
         * * If set to C(PASSIVE) on all the virtual servers that share the IP address, the appliance always injects the hostroute.
         * * If set to C(ACTIVE) on all the virtual servers that share the IP address, the appliance injects even if one virtual server is UP.
         * * If set to C(ACTIVE) on some virtual servers and C(PASSIVE) on the others, the appliance, injects even if one virtual server set to C(ACTIVE) is UP.
         */
        rhistate?: "PASSIVE" | "ACTIVE";
        /**
         * Enable network address translation (NAT) for real-time streaming protocol (RTSP) connections.
         */
        rtspnat?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the authentication profile to be used when authentication is turned on.
         */
        authnprofile?: string;
        /**
         * Maintain source-IP based persistence on primary and backup virtual servers.
         */
        sopersistence?: "enabled" | "disabled";
        /**
         * Enable logging appflow flow information.
         */
        appflowlog?: "enabled" | "disabled";
        /**
         * Action to be performed if spillover is to take effect, but no backup chain to spillover is usable or exists.
         */
        sobackupaction?: "DROP" | "ACCEPT" | "REDIRECT";
        /**
         * Authenticate users who request a connection to the content switching virtual server.
         */
        authentication?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the DB profile.
         * Minimum length = 1
         * Maximum length = 127
         */
        dbprofilename?: string;
        /**
         * Use this option to specify whether a virtual server, used for load balancing or content switching, routes requests to the cache redirection virtual server before sending it to the configured servers.
         */
        cacheable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Depending on the spillover method, the maximum number of connections or the maximum total bandwidth (Kbps) that a virtual server can handle before spillover occurs.
         * Minimum value = C(1)
         * Maximum value = C(4294967287)
         */
        sothreshold?: number;
        /**
         * Use L2 Parameters to identify a connection.
         */
        l2conn?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        policybindings?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        dnsrecordtype?: "A" | "AAAA" | "CNAME" | "NAPTR";
        /**
         * IP address of the content switching virtual server.
         * Minimum length = 1
         */
        ipv46?: string;
        /**
         * Name for the content switching virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters.
         * Cannot be changed after the CS virtual server is created.
         * Minimum length = 1
         */
        name?: string;
        /**
         * IP address pattern, in dotted decimal notation, for identifying packets to be accepted by the virtual server. The IP Mask parameter specifies which part of the destination IP address is matched against the pattern. Mutually exclusive with the IP Address parameter.
         * For example, if the IP pattern assigned to the virtual server is C(198.51.100.0) and the IP mask is C(255.255.240.0) (a forward mask), the first 20 bits in the destination IP addresses are matched with the first 20 bits in the pattern. The virtual server accepts requests with IP addresses that range from 198.51.96.1 to 198.51.111.254. You can also use a pattern such as C(0.0.2.2) and a mask such as C(0.0.255.255) (a reverse mask).
         * If a destination IP address matches more than one IP pattern, the pattern with the longest match is selected, and the associated virtual server processes the request. For example, if the virtual servers, C(vs1) and C(vs2), have the same IP pattern, C(0.0.100.128), but different IP masks of C(0.0.255.255) and C(0.0.224.255), a destination IP address of 198.51.100.128 has the longest match with the IP pattern of C(vs1). If a destination IP address matches two or more virtual servers to the same extent, the request is processed by the virtual server whose port number matches the port number in the request.
         */
        ippattern?: string;
        /**
         * Continue forwarding the traffic to backup virtual server even after the primary server comes UP from the DOWN state.
         */
        disableprimaryondown?: "enabled" | "disabled";
        /**
         * Name of the TCP profile containing TCP configuration settings for the virtual server.
         * Minimum length = 1
         * Maximum length = 127
         */
        tcpprofilename?: string;
        /**
         * Flush all active transactions associated with a virtual server whose state transitions from UP to DOWN. Do not enable this option for applications that must complete their transactions.
         */
        downstateflush?: "enabled" | "disabled";
        /**
         * Expression for extracting the label from the response received from server. This string can be either an existing rule name or an inline expression. The service type of the virtual server should be either C(HTTP) or C(SSL).
         */
        pushlabel?: string;
        /**
         * Time-out value, in minutes, for spillover persistence.
         * Minimum value = C(2)
         * Maximum value = C(1440)
         */
        sopersistencetimeout?: number;
        /**
         * Consider case in URLs (for policies that use URLs instead of RULES). For example, with the C(on) setting, the URLs /a/1.html and /A/1.HTML are treated differently and can have different targets (set by content switching policies). With the C(off) setting, /a/1.html and /A/1.HTML are switched to the same target.
         */
        casesensitive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Number of consecutive IP addresses, starting with the address specified by the IP Address parameter, to include in a range of addresses assigned to this virtual server.
         * Minimum value = C(1)
         * Maximum value = C(254)
         */
        range?: number;
        /**
         * Type of spillover used to divert traffic to the backup virtual server when the primary virtual server reaches the spillover threshold. Connection spillover is based on the number of connections. Bandwidth spillover is based on the total Kbps of incoming and outgoing traffic.
         */
        somethod?: "CONNECTION" | "DYNAMICCONNECTION" | "BANDWIDTH" | "HEALTH" | "NONE";
        /**
         * Process traffic with the push virtual server that is bound to this content switching virtual server (specified by the Push VServer parameter). The service type of the push virtual server should be either C(HTTP) or C(SSL).
         */
        push?: "enabled" | "disabled";
        nitro_pass: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the DNS profile to be associated with the VServer. DNS profile properties will applied to the transactions processed by a VServer. This parameter is valid only for DNS and DNS-TCP VServers.
         * Minimum length = 1
         * Maximum length = 127
         */
        dnsprofilename?: string;
        [k: string]: unknown;
      };
      /**
       * Update a storage array to become the primary or secondary instance in an asynchronous mirror group
       */
      netapp_e_amg_role?: {
        /**
         * The ID of the primary storage array for the async mirror action
         */
        ssid: string;
        /**
         * Whether to force the role reversal regardless of the online-state of the primary
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password?: string;
        /**
         * Whether the array should be the primary or secondary array for the AMG
         */
        role: "primary" | "secondary";
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username?: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Whether to avoid synchronization prior to role reversal
         */
        noSync?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages SVR4 packages on Solaris 10 and 11.
       * These were the native packages on Solaris <= 10 and are available as a legacy feature in Solaris 11.
       * Note that this is a very basic packaging system. It will not enforce dependencies on install or remove.
       */
      svr4pkg?: {
        /**
         * Install/Remove category instead of a single package.
         */
        category?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies the location to install the package from. Required when C(state=present).
         * Can be any path acceptable to the C(pkgadd) command's C(-d) option. e.g.: C(somefile.pkg), C(/dir/with/pkgs), C(http:/server/mypkgs.pkg).
         * If using a file or directory, they must already be accessible by the host. See the M(copy) module for a way to get them there.
         */
        src?: string;
        /**
         * Package name, e.g. C(SUNWcsr)
         */
        name: string;
        /**
         * Default: all
         *
         * Whether to install the package only in the current zone, or install it into all zones.
         * The installation into all zones works only if you are working with the global zone.
         */
        zone?: "current" | "all";
        /**
         * Whether to install (C(present)), or remove (C(absent)) a package.
         * If the package is to be installed, then I(src) is required.
         * The SVR4 package system doesn't provide an upgrade operation. You need to uninstall the old, then install the new package.
         */
        state: "present" | "absent";
        /**
         * HTTP[s] proxy to be used if C(src) is a URL.
         */
        proxy?: string;
        /**
         * Specifies the location of a response file to be used if package expects input on install. (added in Ansible 1.4)
         */
        response_file?: string;
        [k: string]: unknown;
      };
      /**
       * Create, remove, update monitoring policies (and add/remove ports, processes, and servers). This module has a dependency on 1and1 >= 1.0
       */
      oneandone_monitoring_policy?: {
        /**
         * Ports to add to the monitoring policy.
         */
        add_ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Monitoring policy thresholds. Each of the suboptions have warning and critical, which both have alert and value suboptions. Warning is used to set limits for warning alerts, critical is used to set critical alerts. alert enables alert, and value is used to advise when the value is exceeded.
         */
        thresholds?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Set true for using agent.
         */
        agent?: string;
        /**
         * Servers to add to the monitoring policy.
         */
        add_servers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
         */
        api_url?: string;
        /**
         * Default: 5
         *
         * Defines the number of seconds to wait when using the _wait_for methods
         */
        wait_interval?: number | string;
        /**
         * Processes to remove from the monitoring policy.
         */
        remove_processes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Servers to remove from the monitoring policy.
         */
        remove_servers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Define a monitoring policy's state to create, remove, update.
         */
        state?: "present" | "absent" | "update";
        /**
         * Ports to remove from the monitoring policy.
         */
        remove_ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Authenticating API token provided by 1&1.
         */
        auth_token?: string;
        /**
         * Monitoring policy description. maxLength=256
         */
        description?: string;
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * The identifier (id or name) of the monitoring policy used with update state.
         */
        monitoring_policy?: string;
        /**
         * Processes to add to the monitoring policy.
         */
        add_processes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: yes
         *
         * wait for the instance to be in state 'running' before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Array of processes that will be monitoring.
         */
        processes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Monitoring policy name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128
         */
        name?: string;
        /**
         * User's email. maxLength=128
         */
        email?: string;
        /**
         * Processes to be updated on the monitoring policy.
         */
        update_processes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Ports to be updated on the monitoring policy.
         */
        update_ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Array of ports that will be monitoring.
         */
        ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Create and remove firewall rules.
       */
      vultr_firewall_rule?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage presence of groups on a host.
       * For Windows targets, use the M(win_group) module instead.
       */
      group?: {
        /**
         * Default: present
         *
         * Whether the group should be present or not on the remote host.
         */
        state?: "absent" | "present";
        /**
         * Optional I(GID) to set for the group.
         */
        gid?: string;
        /**
         * Default: no
         *
         * Forces the use of "local" command alternatives on platforms that implement it. This is useful in environments that use centralized authentification when you want to manipulate the local groups. I.E. it uses `lgroupadd` instead of `useradd`.
         * This requires that these commands exist on the targeted host, otherwise it will be a fatal error.
         */
        local?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * If I(yes), indicates that the group created is a system group.
         */
        system?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the group to manage.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Provides an interface to manage FCoE Network resources. Can create, update, or delete.
       */
      oneview_fcoe_network?: {
        username?: string;
        image_streamer_hostname?: string;
        hostname?: string;
        config?: string;
        validate_etag?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Indicates the desired state for the FCoE Network resource. C(present) will ensure data properties are compliant with OneView. C(absent) will remove the resource from OneView, if it exists.
         */
        state?: "present" | "absent";
        password?: string;
        /**
         * List with FCoE Network properties.
         */
        data: {
          [k: string]: unknown;
        };
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage installation and uninstallation of Ruby gems.
       */
      gem?: {
        [k: string]: unknown;
      };
      /**
       * Defines an Instance Template resource that provides configuration settings for your virtual machine instances. Instance templates are not tied to the lifetime of an instance and can be used and reused as to deploy virtual machines. You can also use different templates to create different virtual machine configurations. Instance templates are required when you create a managed instance group.
       * Tip: Disks should be set to autoDelete=true so that leftover disks are not left behind on machine deletion.
       */
      gcp_compute_instance_template?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: string;
        service_account_email?: string;
        /**
         * The instance properties for this instance template.
         */
        properties?: {
          [k: string]: unknown;
        };
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        service_account_file?: string;
        /**
         * Name of the resource. The name is 1-63 characters long and complies with RFC1035.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module is useful for sending emails from playbooks.
       * One may wonder why automate sending emails?  In complex environments there are from time to time processes that cannot be automated, either because you lack the authority to make it so, or because not everyone agrees to a common approach.
       * If you cannot automate a specific step, but the step is non-blocking, sending out an email to the responsible party to make them perform their part of the bargain is an elegant way to put the responsibility in someone else's lap.
       * Of course sending out a mail can be equally useful as a way to notify one or more people in a team that a specific action has been (successfully) taken.
       */
      mail?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        };
      /**
       * Retrieve facts about one or more oVirt/RHV datacenters.
       */
      ovirt_datacenter_facts?: {
        /**
         * Search term which is accepted by oVirt/RHV search backend.
         * For example to search datacenter I(X) use following pattern: I(name=X)
         */
        pattern?: string;
        [k: string]: unknown;
      };
      /**
       * Send notifications via pushover, to subscriber list of devices, and email addresses. Requires pushover app on devices.
       */
      pushover?: {
        /**
         * What message you wish to send.
         */
        msg: string;
        /**
         * Pushover issued authentication key for your user.
         */
        user_key: string;
        /**
         * Pushover issued token identifying your pushover app.
         */
        app_token: string;
        /**
         * Message priority (see U(https://pushover.net) for details.)
         */
        pri?: "-2" | "-1" | "0" | "1" | "2";
        [k: string]: unknown;
      };
      /**
       * Set / reset link properties on Solaris/illumos systems.
       */
      dladm_linkprop?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Get facts for a specific DNS zone or all DNS zones within a resource group.
       */
      azure_rm_dnszone_facts?: {
        profile?: string;
        /**
         * Only show results for a specific zone.
         */
        name?: string;
        /**
         * Limit results by resource group. Required when filtering by name.
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Add and remove secondary IPs to and from a NIC of an instance.
       */
      cs_instance_nic_secondaryip?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Execute vlan-create or vlan-delete command.
       * VLANs are used to isolate network traffic at Layer 2.The VLAN identifiers 0 and 4095 are reserved and cannot be used per the IEEE 802.1Q standard. The range of configurable VLAN identifiers is 2 through 4092.
       */
      pn_vlan?: {
        /**
         * Specify a scope for the VLAN.
         * Required for vlan-create.
         */
        pn_scope?: "fabric" | "local";
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Specify a VLAN identifier for the VLAN. This is a value between 2 and 4092.
         */
        pn_vlanid: number | string;
        /**
         * State the action to perform. Use 'present' to create vlan and 'absent' to delete vlan.
         */
        state: "present" | "absent";
        /**
         * Specifies the switch network data port number, list of ports, or range of ports. Port numbers must ne in the range of 1 to 64.
         */
        pn_ports?: string;
        /**
         * Specifies the ports that should have untagged packets mapped to the VLAN. Untagged packets are packets that do not contain IEEE 802.1Q VLAN tags.
         */
        pn_untagged_ports?: string;
        /**
         * Target switch(es) to run the cli on.
         */
        pn_cliswitch?: string;
        /**
         * Specify if you want to collect statistics for a VLAN. Statistic collection is enabled by default.
         */
        pn_stats?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify a description for the VLAN.
         */
        pn_description?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or delete a subnet within a given virtual network. Allows setting and updating the address prefix CIDR, which must be valid within the context of the virtual network. Use the azure_rm_networkinterface module to associate interfaces with the subnet and assign specific IP addresses.
       */
      azure_rm_subnet?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Execute vlag-create/vlag-delete/vlag-modify command.
       * A virtual link aggregation group (VLAG) allows links that are physically connected to two different Pluribus Networks devices to appear as a single trunk to a third device. The third device can be a switch, server, or any Ethernet device. A VLAG can provide Layer 2 multipathing, which allows you to create redundancy by increasing bandwidth, enabling multiple parallel paths between nodes and loadbalancing traffic where alternative paths exist.
       */
      pn_vlag?: {
        /**
         * The C(pn_name) takes a valid name for vlag configuration.
         */
        pn_name: string;
        /**
         * Specify the LACP fallback mode as bundles or individual.
         */
        pn_lacp_fallback?: "individual" | "bundled";
        /**
         * Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.
         */
        pn_lacp_fallback_timeout?: string;
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Specify the LACP timeout as slow(30 seconds) or fast(4 seconds).
         */
        pn_lacp_timeout?: "slow" | "fast";
        /**
         * State the action to perform. Use 'present' to create vlag, 'absent' to delete vlag and 'update' to modify vlag.
         */
        state: "present" | "absent" | "update";
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Specify the LACP mode.
         */
        pn_lacp_mode?: "off" | "passive" | "active";
        /**
         * Specify the failover action as move or ignore.
         */
        pn_failover_action?: "move" | "ignore";
        /**
         * Specify the peer VLAG port.
         * Required for vlag-create.
         */
        pn_peer_port?: string;
        /**
         * Specify the fabric-name of the peer switch.
         */
        pn_peer_switch?: string;
        /**
         * Specify the local VLAG port.
         * Required for vlag-create.
         */
        pn_port?: string;
        /**
         * Target switch(es) to run this command on.
         */
        pn_cliswitch?: string;
        /**
         * Specify the mode for the VLAG. Active-standby indicates one side is active and the other side is in standby mode. Active-active indicates that both sides of the vlag are up by default.
         */
        pn_mode?: "active-active" | "active-standby";
        [k: string]: unknown;
      };
      /**
       * The C(hall) module connects to the U(https://hall.com) messaging API and allows you to deliver notication messages to rooms.
       */
      hall?: {
        /**
         * The message you wish to deliver as a notification
         */
        msg: string;
        /**
         * The full URL to the image you wish to use for the Icon of the message. Defaults to U(http://cdn2.hubspot.net/hub/330046/file-769078210-png/Official_Logos/ansible_logo_black_square_small.png?t=1421076128627)
         *
         */
        picture?: string;
        /**
         * Room token provided to you by setting up the Ansible room integation on U(https://hall.com)
         */
        room_token: string;
        /**
         * The title of the message
         */
        title: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Interfaces on Arista EOS network devices.
       */
      eos_interface?: {
        /**
         * Check the operational state of given interface C(name) for LLDP neighbor.
         * The following suboptions are available.
         */
        neighbors?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Receiver rate in bits per second (bps) for the interface given in C(name) option.
         * This is state check parameter only.
         * Supports conditionals, see L(Conditionals in Networking Modules,../network/user_guide/network_working_with_command_output.html)
         */
        rx_rate?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * This option configures autoneg and speed/duplex/flowcontrol for the interface given in C(name) option.
         */
        speed?: string;
        port?: number | string;
        transport?: "cli" | "eapi";
        auth_pass?: string;
        /**
         * Default: 10
         *
         * Time in seconds to wait before checking for the operational state on remote device. This wait is applicable for operational state argument which are I(state) with values C(up)/C(down), I(tx_rate) and I(rx_rate).
         */
        delay?: number | string;
        /**
         * Default: present
         *
         * State of the Interface configuration, C(up) means present and operationally up and C(down) means present and operationally C(down)
         */
        state?: "present" | "absent" | "up" | "down";
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * Description of Interface upto 240 characters.
         */
        description?: string;
        host?: string;
        /**
         * List of Interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and other options as required.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        /**
         * Transmit rate in bits per second (bps) for the interface given in C(name) option.
         * This is state check parameter only.
         * Supports conditionals, see L(Conditionals in Networking Modules,../network/user_guide/network_working_with_command_output.html)
         */
        tx_rate?: string;
        ssh_keyfile?: string;
        /**
         * Name of the Interface to be configured on remote device. The name of interface should be in expanded format and not abbreviated.
         */
        name?: string;
        /**
         * Default: True
         *
         * Interface link status. If the value is I(True) the interface state will be enabled, else if value is I(False) interface will be in disable (shutdown) state.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set maximum transmission unit size in bytes of transmit packet for the interface given in C(name) option.
         */
        mtu?: string;
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      name: string;
      /**
       * An Ansible module to Create, Delete, Start and Stop servers in CenturyLink Cloud.
       */
      clc_server?: {
        /**
         * The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_id'.
         */
        anti_affinity_policy_name?: string;
        /**
         * Default: standard
         *
         * The type of storage to attach to the server.
         */
        storage_type?: "standard" | "hyperscale";
        /**
         * The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_name'.
         */
        anti_affinity_policy_id?: string;
        /**
         * The time to live for the server in seconds.  The server will be deleted when this time expires.
         */
        ttl?: string;
        /**
         * Required when exact_count is specified.  The Server Group use to determine how many severs to deploy.
         */
        count_group?: string;
        /**
         * Secondary DNS used by the server.
         */
        secondary_dns?: string;
        /**
         * The list of custom fields to set on the server.
         */
        custom_fields?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Password for the administrator / root user
         */
        password?: string;
        /**
         * The list of blue print packages to run on the server after its created.
         */
        packages?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: Default Group
         *
         * The Server Group to create servers under.
         */
        group?: string;
        /**
         * Run in idempotent mode.  Will insure that this exact number of servers are running in the provided group, creating and deleting them to reach that count.  Requires count_group to be set.
         */
        exact_count?: number | string;
        /**
         * Default: present
         *
         * The state to insure that the provided resources are in.
         */
        state?: "present" | "absent" | "started" | "stopped";
        /**
         * The autoscale policy to assign to the server.
         */
        cpu_autoscale_policy_id?: string;
        /**
         * The template to use for server creation.  Will search for a template if a partial string is provided. This is required when state is 'present'
         */
        template?: string;
        /**
         * Default: 1
         *
         * Memory in GB.
         */
        memory?: string;
        /**
         * Required for started, stopped, and absent states. A list of server Ids to insure are started, stopped, or absent.
         */
        server_ids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: standard
         *
         * The type of server to create.
         */
        type?: "standard" | "hyperscale" | "bareMetal";
        /**
         * Default: no
         *
         * Whether to create the server as 'Managed' or not.
         */
        managed_os?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The Datacenter to create servers in.
         */
        location?: string;
        /**
         * The list of additional disks for the server
         */
        additional_disks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The description to set for the server.
         */
        description?: string;
        /**
         * Default: no
         *
         * Whether to add a public ip to the server
         */
        add_public_ip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Only required for bare metal servers. Specifies the identifier for the specific configuration type of bare metal server to deploy.
         */
        configuration_id?: string;
        /**
         * The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_id'.
         */
        alert_policy_name?: string;
        /**
         * The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_name'.
         */
        alert_policy_id?: string;
        /**
         * A list of ports to allow on the firewall to the servers public ip, if add_public_ip is set to True.
         */
        public_ip_ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The IP Address for the server. One is assigned if not provided.
         */
        ip_address?: string;
        /**
         * Default: TCP
         *
         * The protocol to use for the public ip if add_public_ip is set to True.
         */
        public_ip_protocol?: "TCP" | "UDP" | "ICMP";
        /**
         * Default: yes
         *
         * Whether to wait for the provisioning tasks to finish before returning.
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * The number of servers to build (mutually exclusive with exact_count)
         */
        count?: number | string;
        /**
         * A 1 to 6 character identifier to use for the server. This is required when state is 'present'
         */
        name?: string;
        /**
         * The network UUID on which to create servers.
         */
        network_id?: string;
        /**
         * Primary DNS used by the server.
         */
        primary_dns?: string;
        /**
         * The account alias to provision the servers under.
         */
        alias?: string;
        /**
         * The password for the source server if a clone is specified.
         */
        source_server_password?: string;
        /**
         * Only required for bare metal servers. Specifies the OS to provision with the bare metal server.
         */
        os_type?: "redHat6_64Bit" | "centOS6_64Bit" | "windows2012R2Standard_64Bit" | "ubuntu14_64Bit";
        /**
         * Default: 1
         *
         * How many CPUs to provision on the server
         */
        cpu?: string;
        [k: string]: unknown;
      };
      /**
       * Connect to external virtual and physical domains by using attachable Access Entity Profiles (AEP) on Cisco ACI fabrics.
       */
      aci_aep?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Manage route tables for AWS virtual private clouds
       */
      ec2_vpc_route_table?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of L3 interfaces on Mellanox ONYX network devices.
       */
      onyx_l3_interface?: {
        /**
         * Name of the L3 interface.
         */
        name?: string;
        /**
         * Purge L3 interfaces not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * State of the L3 interface configuration.
         */
        state?: "present" | "absent" | "enabled" | "disabled";
        /**
         * IPv4 of the L3 interface.
         */
        ipv4?: string;
        /**
         * IPv6 of the L3 interface (not supported for now).
         */
        ipv6?: string;
        /**
         * List of L3 interfaces definitions
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * This module is used to configure Tenant object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_tenant?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Name of the object.
         */
        name: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * Creator of this tenant.
         */
        created_by?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Tenantconfiguration settings for tenant.
         */
        config_settings?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Boolean flag to set local.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        local?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tenant_uuid?: string;
        api_version?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Adds and/or removes instances of DNS view objects from Infoblox NIOS servers.  This module manages NIOS C(view) objects using the Infoblox WAPI interface over REST.
       * Updates instances of DNS view object from Infoblox NIOS servers.
       */
      nios_dns_view?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Create or delete volumes and filesystem snapshots on Pure Storage FlashBlades.
       */
      purefb_snap?: {
        /**
         * Default: present
         *
         * Define whether the filesystem snapshot should exist or not.
         */
        state?: string;
        /**
         * Default: no
         *
         * Define whether to eradicate the snapshot on delete or leave in trash.
         */
        eradicate?: string;
        /**
         * Suffix of snapshot name.
         */
        suffix?: string;
        /**
         * The name of the source filesystem.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Runs the I(facter) discovery program (U(https://github.com/puppetlabs/facter)) on the remote system, returning JSON data that can be useful for inventory purposes.
       */
      facter?: {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of link aggregation groups on Cisco NXOS devices.
       */
      nxos_linkagg?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * When true it forces link aggregation group members to match what is declared in the members param. This can be used to remove members.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Channel-group number for the port-channel Link aggregation group.
         */
        group?: string;
        /**
         * List of interfaces that will be managed in the link aggregation group.
         */
        members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        provider?: {
          [k: string]: unknown;
        };
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of the link aggregation group.
         */
        state?: "present" | "absent";
        /**
         * Default: no
         *
         * Purge links not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        /**
         * Default: on
         *
         * Mode for the link aggregation group.
         */
        mode?: "active" | "on" | "passive";
        timeout?: number | string;
        /**
         * Minimum number of ports required up before bringing up the link aggregation group.
         */
        min_links?: number | string;
        /**
         * List of link aggregation definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Adds, removes or changes procedural languages with a PostgreSQL database.
       * This module allows you to add a language, remote a language or change the trust relationship with a PostgreSQL database. The module can be used on the machine where executed or on a remote host.
       * When removing a language from a database, it is possible that dependencies prevent the database from being removed. In that case, you can specify casade to automatically drop objects that depend on the language (such as functions in the language). In case the language can't be deleted because it is required by the database system, you can specify fail_on_drop=no to ignore the error.
       * Be carefull when marking a language as trusted since this could be a potential security breach. Untrusted languages allow only users with the PostgreSQL superuser privilege to use this language to create new functions.
       */
      postgresql_lang?: {
        /**
         * name of the procedural language to add, remove or change
         */
        lang: string;
        /**
         * Default: no
         *
         * marks the language as trusted, even if it's marked as untrusted in pg_pltemplate.
         * use with care!
         */
        force_trust?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: postgres
         *
         * User used to authenticate with PostgreSQL
         */
        login_user?: string;
        /**
         * Default: localhost
         *
         * Host running PostgreSQL where you want to execute the actions.
         */
        login_host?: string;
        /**
         * name of database where the language will be added, removed or changed
         */
        db: string;
        /**
         * Default: no
         *
         * when dropping a language, also delete object that depend on this language.
         * only used when C(state=absent).
         */
        cascade?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * The state of the language for the selected database
         */
        state?: "present" | "absent";
        /**
         * Password used to authenticate with PostgreSQL (must match C(login_user))
         */
        login_password?: string;
        /**
         * Default: no
         *
         * make this language trusted for the selected db
         */
        trust?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * if C(yes), fail when removing a language. Otherwise just log and continue
         * in some cases, it is not possible to remove a language (used by the db-system). When         dependencies block the removal, consider using C(cascade).
         */
        fail_on_drop?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 5432
         *
         * Database port to connect to.
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * Add and remove load balancer rule members.
       */
      cs_loadbalancer_rule_member?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Create, Update or Destroy a Forwarding_Rule. See U(https://cloud.google.com/compute/docs/load-balancing/http/target-proxies) for an overview. More details on the Global Forwarding_Rule API can be found at U(https://cloud.google.com/compute/docs/reference/latest/globalForwardingRules) More details on the Forwarding Rules API can be found at U(https://cloud.google.com/compute/docs/reference/latest/forwardingRules)
       */
      gcp_forwarding_rule?: {
        load_balancing_scheme?: "EXTERNAL";
        /**
         * For global forwarding rules, TCP, UDP, ESP, AH, SCTP or ICMP. Default is TCP.
         */
        protocol?: "TCP";
        /**
         * Target resource for forwarding rule. For global proxy, this is a Global TargetProxy resource. Required for external load balancing (including Global load balancing)
         */
        target?: string;
        service_account_email?: string;
        /**
         * The region for this forwarding rule. Currently, only 'global' is supported.
         */
        region: string;
        service_account_permissions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        pem_file?: string;
        /**
         * Name of the Forwarding_Rule.
         */
        forwarding_rule_name: string;
        /**
         * For global forwarding rules, must be set to 80 or 8080 for TargetHttpProxy, and 443 for TargetHttpsProxy or TargetSslProxy.
         */
        port_range?: string;
        /**
         * The state of the Forwarding Rule. 'present' or 'absent'
         */
        state: "present" | "absent";
        credentials_file?: string;
        project_id?: string;
        /**
         * IPv4 or named IP address. Must be of the same scope (regional, global). Reserved addresses can (and probably should) be used for global forwarding rules. You may reserve IPs from the console or via the gce_eip module.
         */
        address?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of node system attributes on Arista EOS devices.  It provides an option to configure host system parameters or remove those parameters from the device active configuration.
       */
      eos_system?: {
        [k: string]: unknown;
      };
      /**
       * Manage SLB (Server Load Balancing) virtual server objects on A10 Networks devices via aXAPIv2.
       */
      a10_virtual_server?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages F5 BIG-IP GTM tcp monitors.
       */
      bigip_gtm_monitor_tcp?: {
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Monitor name.
         */
        name?: string;
        /**
         * Default: /Common/tcp
         *
         * The parent template of this monitor template. Once this value has been set, it cannot be changed. By default, this value is the C(tcp) parent on the C(Common) partition.
         */
        parent?: string;
        /**
         * The receive string for the monitor call.
         */
        receive?: string;
        /**
         * IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
         * If this value is an IP address, then a C(port) number must be specified.
         */
        ip?: string;
        /**
         * The interval specifying how frequently the monitor instance of this template will run.
         * If this parameter is not provided when creating a new monitor, then the default value will be 30.
         * This value B(must) be less than the C(timeout) value.
         */
        interval?: string;
        /**
         * The send string for the monitor call.
         */
        send?: string;
        /**
         * Specifies whether the monitor operates in transparent mode.
         * A monitor in transparent mode directs traffic through the associated pool members or nodes (usually a router or firewall) to the aliased destination (that is, it probes the C(ip)-C(port) combination specified in the monitor).
         * If the monitor cannot successfully reach the aliased destination, the pool member or node through which the monitor traffic was sent is marked down.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(no).
         */
        transparent?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the monitor exists.
         * When C(absent), ensures the monitor is removed.
         */
        state?: string;
        /**
         * Specifies that the monitor allows more than one probe attempt per interval.
         * When C(yes), specifies that the monitor ignores down responses for the duration of the monitor timeout. Once the monitor timeout is reached without the system receiving an up response, the system marks the object down.
         * When C(no), specifies that the monitor immediately marks an object down when it receives a down response.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(no).
         */
        ignore_down_response?: string;
        /**
         * The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second.
         * If this parameter is not provided when creating a new monitor, then the default value will be 120.
         */
        timeout?: string;
        /**
         * Specifies the number of seconds after which the system times out the probe request to the system.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(5).
         */
        probe_timeout?: string;
        /**
         * Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
         */
        port?: string;
        /**
         * Instructs the system to mark the target resource down when the test is successful. This setting is useful, for example, if the content on your web site home page is dynamic and changes frequently, you may want to set up a reverse ECV service check that looks for the string Error.
         * A match for this string means that the web server was down.
         * To use this option, you must specify values for C(send) and C(receive).
         */
        reverse?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure Role object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_role?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * List of permission.
         */
        privileges?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Name of the object.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Configure the VMkernel IP Address
       */
      vmware_vmkernel_ip_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage OVH (French European hosting provider) LoadBalancing IP backends
       */
      ovh_ip_loadbalancing_backend?: {
        /**
         * The endpoint to use ( for instance ovh-eu)
         */
        endpoint: string;
        /**
         * Name of the LoadBalancing internal name (ip-X.X.X.X)
         */
        name: string;
        /**
         * Default: 8
         *
         * Determines the weight for this backend
         */
        weight?: number | string;
        /**
         * Default: none
         *
         * Determines the type of probe to use for this backend
         */
        probe?: "none" | "http" | "icmp" | "oco";
        /**
         * The applicationKey to use
         */
        application_key: string;
        /**
         * Default: present
         *
         * Determines whether the backend is to be created/modified or deleted
         */
        state?: "present" | "absent";
        /**
         * The application secret to use
         */
        application_secret: string;
        /**
         * Default: 120
         *
         * The timeout in seconds used to wait for a task to be completed.
         */
        timeout?: number | string;
        /**
         * The consumer key to use
         */
        consumer_key: string;
        /**
         * The IP address of the backend to update / modify / delete
         */
        backend: string;
        [k: string]: unknown;
      };
      /**
       * Allows element-based ordering, addition, and removal of Windows path environment variables.
       */
      win_path?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of static IP routes on Cisco IOS network devices.
       */
      ios_static_route?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Default: present
         *
         * State of the static route configuration.
         */
        state?: "present" | "absent";
        auth_pass?: string;
        /**
         * Network prefix mask of the static route.
         */
        mask?: string;
        host?: string;
        /**
         * Admin distance of the static route.
         */
        admin_distance?: number | string;
        /**
         * Network prefix of the static route.
         */
        prefix?: string;
        /**
         * Next hop IP of the static route.
         */
        next_hop?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of static route definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running OS9.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      dellos9_facts?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        host?: string;
        /**
         * Default: ['!config']
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages SNMP user configurations on CloudEngine switches.
       */
      ce_snmp_user?: {
        username?: string;
        /**
         * The encryption password. Password length 8-255 characters.
         */
        priv_key?: string;
        /**
         * Unique name to identify the local user.
         */
        aaa_local_user?: string;
        /**
         * The authentication password. Password length, 8-255 characters.
         */
        auth_key?: string;
        /**
         * Name of the group where user belongs to.
         */
        user_group?: string;
        /**
         * Unique name to identify the USM user.
         */
        usm_user_name?: string;
        state?: "present" | "absent";
        /**
         * Access control list number.
         */
        acl_number?: string;
        /**
         * Authentication protocol.
         */
        auth_protocol?: "noAuth" | "md5" | "sha";
        /**
         * Remote engine id of the USM user.
         */
        remote_engine_id?: string;
        host?: string;
        ssh_keyfile?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Encryption protocol.
         */
        priv_protocol?: "noPriv" | "des56" | "3des168" | "aes128" | "aes192" | "aes256";
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Create/delete static/dynamic IP addresses on network interfaces on Solaris/illumos systems.
       * Up/down static/dynamic IP addresses on network interfaces on Solaris/illumos systems.
       * Manage IPv6 link-local addresses on network interfaces on Solaris/illumos systems.
       */
      ipadm_addr?: {
        [k: string]: unknown;
      };
      /**
       * Manages VTP domain configuration.
       */
      nxos_vtp_domain?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * VTP domain name.
         */
        domain: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Create, delete, modify DNS servers.
       */
      na_ontap_dns?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage CORS for S3 buckets in AWS
       */
      aws_s3_cors?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * OS10 configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with OS10 configuration sections in a deterministic way.
       */
      dellos10_config?: {
        [k: string]: unknown;
      };
      /**
       * The Deploy Helper manages some of the steps common in deploying software. It creates a folder structure, manages a symlink for the current release and cleans up old releases.
       * Running it with the C(state=query) or C(state=present) will return the C(deploy_helper) fact. C(project_path), whatever you set in the path parameter, C(current_path), the path to the symlink that points to the active release, C(releases_path), the path to the folder to keep releases in, C(shared_path), the path to the folder to keep shared resources in, C(unfinished_filename), the file to check for to recognize unfinished builds, C(previous_release), the release the 'current' symlink is pointing to, C(previous_release_path), the full path to the 'current' symlink target, C(new_release), either the 'release' parameter or a generated timestamp, C(new_release_path), the path to the new release folder (not created by the module).
       */
      deploy_helper?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manipulate Rackspace Cloud Autoscale Scaling Policy
       */
      rax_scaling_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP SslPolicy
       */
      gcp_compute_ssl_policy_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Gathering facts from the API of an instance.
       */
      cs_instance_facts?: {
        /**
         * Account the instance is related to.
         */
        account?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Domain the instance is related to.
         */
        domain?: string;
        api_region?: string;
        /**
         * Project the instance is related to.
         */
        project?: string;
        api_key?: string;
        /**
         * Name or display name of the instance.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create and remove a bigmon inline service chain.
       */
      bigmon_chain?: {
        /**
         * Bigmon access token. If this isn't set, the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.
         */
        access_token?: string;
        /**
         * Default: present
         *
         * Whether the service chain should be present or absent.
         */
        state?: "present" | "absent";
        /**
         * Default: True
         *
         * If C(false), SSL certificates will not be validated. This should only be used on personally controlled devices using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The controller IP address.
         */
        controller: string;
        /**
         * The name of the chain.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Tap external Homebrew repositories.
       */
      homebrew_tap?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Add or remove licenses on NetApp ONTAP.
       */
      na_cdot_license?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Installs Python libraries, optionally in a I(virtualenv)
       */
      easy_install?: {
        /**
         * an optional I(virtualenv) directory path to install into. If the I(virtualenv) does not exist, it is created automatically
         */
        virtualenv?: string;
        /**
         * The explicit executable or a pathname to the executable to be used to run easy_install for a specific version of Python installed in the system. For example C(easy_install-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run easy_install for the Python 3.3 installation.
         */
        executable?: string;
        /**
         * A Python library name
         */
        name: string;
        /**
         * Default: virtualenv
         *
         * The command to create the virtual environment with. For example C(pyvenv), C(virtualenv), C(virtualenv2).
         */
        virtualenv_command?: string;
        /**
         * Default: no
         *
         * Whether the virtual environment will inherit packages from the global site-packages directory.  Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created.
         */
        virtualenv_site_packages?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * The desired state of the library. C(latest) ensures that the latest version is installed.
         */
        state?: "present" | "latest";
        [k: string]: unknown;
      };
      /**
       * Installs, upgrade, downgrades, removes, and lists packages and groups with the I(yum) package manager.
       * This module only works on Python 2. If you require Python 3 support see the M(dnf) module.
       */
      yum?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage docker services. Allows live altering of already defined services
       *
       */
      docker_swarm_service?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Set owner of files or directories
       */
      win_owner?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Allows for the management of Lambda functions.
       */
      lambda?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates and deletes DNS Health checks in Amazons Route53 service
       * Only the port, resource_path, string_match and request_interval are considered when updating existing health-checks.
       */
      route53_health_check?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Interfaces on Cisco IOS network devices.
       */
      ios_interface?: {
        /**
         * Check the operational state of given interface C(name) for CDP/LLDP neighbor.
         * The following suboptions are available.
         */
        neighbors?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        username?: string;
        ssh_keyfile?: string;
        /**
         * Description of Interface.
         */
        description?: string;
        /**
         * Default: auto
         *
         * Interface link status
         */
        duplex?: "full" | "half" | "auto";
        auth_pass?: string;
        /**
         * Interface link status.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * State of the Interface configuration, C(up) means present and operationally up and C(down) means present and operationally C(down)
         */
        state?: "present" | "absent" | "up" | "down";
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Maximum size of transmit packet.
         */
        mtu?: string;
        /**
         * Receiver rate in bits per second (bps).
         * This is state check parameter only.
         * Supports conditionals, see L(Conditionals in Networking Modules,../network/user_guide/network_working_with_command_output.html)
         */
        rx_rate?: string;
        host?: string;
        /**
         * Default: 10
         *
         * Time in seconds to wait before checking for the operational state on remote device. This wait is applicable for operational state argument which are I(state) with values C(up)/C(down), I(tx_rate) and I(rx_rate).
         */
        delay?: number | string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of Interfaces definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        /**
         * Interface link speed.
         */
        speed?: string;
        port?: number | string;
        /**
         * Transmit rate in bits per second (bps).
         * This is state check parameter only.
         * Supports conditionals, see L(Conditionals in Networking Modules,../network/user_guide/network_working_with_command_output.html)
         */
        tx_rate?: string;
        /**
         * Name of the Interface.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manage route tag policies on Cisco ACI fabrics.
       */
      aci_l3out_route_tag_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Collects a base set of device facts from a remote device that is running VyOS.  This module prepends all of the base network fact keys with U(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      vyos_facts?: {
        username?: string;
        ssh_keyfile?: string;
        host?: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, default, config, and neighbors.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Retrieve the facts about one or more of the FCoE Networks from OneView.
       */
      oneview_fcoe_network_facts?: {
        username?: string;
        image_streamer_hostname?: string;
        /**
         * FCoE Network name.
         */
        name?: string;
        hostname?: string;
        params?: {
          [k: string]: unknown;
        };
        password?: string;
        config?: string;
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create host groups if they do not exist.
       * Delete existing host groups if they exist.
       */
      zabbix_group?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Allows for the management of IAM users, user API keys, groups, roles.
       */
      iam?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Get I(openstack) client config data from clouds.yaml or environment
       */
      os_client_config?: {
        /**
         * List of clouds to limit the return list to. No value means return information on all configured clouds
         */
        clouds?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * This will configure both login and motd banners on remote devices running Cisco IOS.  It allows playbooks to add or remote banner text from the active running configuration.
       */
      ios_banner?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).
         */
        text?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Specifies whether or not the configuration is present in the current devices active running configuration.
         */
        state?: "present" | "absent";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Specifies which banner should be configured on the remote device. In Ansible 2.4 and earlier only I(login) and I(motd) were supported.
         */
        banner: "login" | "motd" | "exec" | "incoming" | "slip-ppp";
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create or delete or modify export rules in ONTAP
       */
      na_ontap_export_policy_rule?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create, update and delete Azure availability set. An availability set cannot be updated, you will have to recreate one instead. The only update operation will be for the tags.
       */
      azure_rm_availabilityset?: {
        profile?: string;
        /**
         * Default: Classic
         *
         * Define if the availability set supports managed disks.
         */
        sku?: "Classic" | "Aligned";
        /**
         * Name of the availability set.
         */
        name: string;
        /**
         * Name of a resource group where the availability set exists or will be created.
         */
        resource_group: string;
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        /**
         * Default: 5
         *
         * Update domains indicate groups of virtual machines and underlying physical hardware that can be rebooted at the same time. Default is 5.
         */
        platform_update_domain_count?: number | string;
        /**
         * Default: 3
         *
         * Fault domains define the group of virtual machines that share a common power source and network switch. Should be between 1 and 3. Default is 3
         */
        platform_fault_domain_count?: number | string;
        secret?: string;
        /**
         * Default: present
         *
         * Assert the state of the availability set. Use 'present' to create or update a availability set and 'absent' to delete a availability set.
         */
        state?: "absent" | "present";
        /**
         * Valid azure location. Defaults to location of the resource group.
         */
        location?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * OS9 configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with OS9 configuration sections in a deterministic way.
       */
      dellos9_config?: {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about the Network Sets from OneView.
       */
      oneview_network_set_facts?: {
        username?: string;
        image_streamer_hostname?: string;
        /**
         * Network Set name.
         */
        name?: string;
        hostname?: string;
        params?: {
          [k: string]: unknown;
        };
        password?: string;
        config?: string;
        /**
         * List with options to gather facts about Network Set. Option allowed: C(withoutEthernet). The option C(withoutEthernet) retrieves the list of network_sets excluding Ethernet networks.
         */
        options?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 AMIs
       */
      ec2_ami_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages MLAG configuration on HUAWEI CloudEngine switches.
       */
      ce_mlag_config?: {
        username?: string;
        /**
         * Name of the peer-link interface. The value is in the range from 0 to 511.
         */
        eth_trunk_id?: string;
        ssh_keyfile?: string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * The priority of a pseudo nickname. The value is an integer that ranges from 128 to 255. The default value is 192. A larger value indicates a higher priority.
         */
        pseudo_priority?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Priority of a DFS group. The value is an integer that ranges from 1 to 254. The default value is 100.
         */
        priority_id?: string;
        /**
         * Number of the peer-link interface. The value is 1.
         */
        peer_link_id?: string;
        /**
         * Name of the VPN instance bound to the DFS group. The value is a string of 1 to 31 case-sensitive characters without spaces. If the character string is quoted by double quotation marks, the character string can contain spaces. The value _public_ is reserved and cannot be used as the VPN instance name.
         */
        vpn_instance_name?: string;
        /**
         * The nickname bound to a DFS group. The value is an integer that ranges from 1 to 65471.
         */
        nickname?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * A pseudo nickname of a DFS group. The value is an integer that ranges from 1 to 65471.
         */
        pseudo_nickname?: string;
        timeout?: number | string;
        /**
         * Default: present
         *
         * ID of a DFS group. The value is 1.
         */
        dfs_group_id?: string;
        host?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        /**
         * IP address bound to the DFS group. The value is in dotted decimal notation.
         */
        ip_address?: string;
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * CyberArk User Management using PAS Web Services SDK. It currently supports the following actions Get User Details, Add User, Update User, Delete User.
       */
      cyberark_user?: {
        /**
         * The name of the user who will be queried (for details), added, updated or deleted.
         */
        username: string;
        /**
         * The user first name.
         */
        first_name?: string;
        /**
         * The user last name.
         */
        last_name?: string;
        /**
         * The password that the new user will use to log on the first time. This password must meet the password policy requirements. this parameter is required when state is present -- Add User.
         */
        initial_password?: string;
        /**
         * Default: EPVUser
         *
         * The type of user.
         */
        user_type_name?: string;
        /**
         * The user updated password. Make sure that this password meets the password policy requirements.
         */
        new_password?: string;
        /**
         * Dictionary set by a CyberArk authentication containing the different values to perform actions on a logged-on CyberArk session, please see M(cyberark_authentication) module for an example of cyberark_session.
         */
        cyberark_session: {
          [k: string]: unknown;
        };
        /**
         * The name of the group the user will be added to.
         */
        group_name?: string;
        /**
         * Default: no
         *
         * Whether or not the user will be disabled. Valid values = true/false.
         */
        disabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Whether or not the user must change their password in their next logon. Valid values = true/false.
         */
        change_password_on_the_next_logon?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Specifies the state needed for the user present for create user, absent for delete user.
         */
        state?: "present" | "absent";
        /**
         * The date and time when the user account will expire and become disabled.
         */
        expiry_date?: string;
        /**
         * The Vault Location for the user.
         */
        location?: string;
        /**
         * The user email address.
         */
        email?: string;
        [k: string]: unknown;
      };
      /**
       * Manages NTP options, e.g. authoritative server and logging.
       */
      nxos_ntp_options?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Sets whether NTP logging is enabled on the device.
         */
        logging?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * If C(master=true), an optional stratum can be supplied (1-15). The device default is 8.
         */
        stratum?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * Sets whether the device is an authoritative NTP server.
         */
        master?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Manage port security on Cisco ACI fabrics.
       */
      aci_interface_policy_port_security?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Netconf is a network management protocol developed and standardized by the IETF. It is documented in RFC 6241.
       * This module allows the user to send a configuration XML file to a netconf device, and detects if there was a configuration change.
       */
      netconf_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * The C(copy) module copies a file from the local or remote machine to a location on the remote machine. Use the M(fetch) module to copy files from remote locations to the local box. If you need variable interpolation in copied files, use the M(template) module.
       * For Windows targets, use the M(win_copy) module instead.
       */
      copy?: {
        [k: string]: unknown;
      };
      /**
       * The C(pam_limits) module modifies PAM limits. The default file is C(/etc/security/limits.conf). For the full documentation, see C(man 5 limits.conf).
       */
      pam_limits?: {
        /**
         * Comment associated with the limit.
         */
        comment?: string;
        /**
         * Default: no
         *
         * If set to C(yes), the maximal value will be used or conserved. If the specified value is superior to the value in the file, file content is replaced with the new value, else content is not modified.
         */
        use_max?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A username, @groupname, wildcard, uid/gid range.
         */
        domain: string;
        /**
         * Default: /etc/security/limits.conf
         *
         * Modify the limits.conf path.
         */
        dest?: string;
        /**
         * The value of the limit.
         */
        value: string;
        /**
         * Default: no
         *
         * If set to C(yes), the minimal value will be used or conserved. If the specified value is inferior to the value in the file, file content is replaced with the new value, else content is not modified.
         */
        use_min?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The limit to be set
         */
        limit_item:
          | "core"
          | "data"
          | "fsize"
          | "memlock"
          | "nofile"
          | "rss"
          | "stack"
          | "cpu"
          | "nproc"
          | "as"
          | "maxlogins"
          | "maxsyslogins"
          | "priority"
          | "locks"
          | "sigpending"
          | "msgqueue"
          | "nice"
          | "rtprio"
          | "chroot";
        /**
         * Limit type, see C(man 5 limits.conf) for an explanation
         */
        limit_type: "hard" | "soft" | "-";
        /**
         * Default: no
         *
         * Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Adds and/or removes instances of NAPTR record objects from Infoblox NIOS servers.  This module manages NIOS C(record:naptr) objects using the Infoblox WAPI interface over REST.
       */
      nios_naptr_record?: {
        [k: string]: unknown;
      };
      /**
       * An Ansible module to Create, Delete shared loadbalancers in CenturyLink Cloud.
       */
      clc_loadbalancer?: {
        /**
         * Default: enabled
         *
         * The status of the loadbalancer
         */
        status?: "enabled" | "disabled";
        /**
         * A description for the loadbalancer
         */
        description?: string;
        /**
         * -The balancing method for the load balancer pool
         */
        method?: "leastConnection" | "roundRobin";
        /**
         * The alias of your CLC Account
         */
        alias: string;
        /**
         * Default: present
         *
         * Whether to create or delete the load balancer pool
         */
        state?: "present" | "absent" | "port_absent" | "nodes_present" | "nodes_absent";
        /**
         * The location of the datacenter where the load balancer resides in
         */
        location: string;
        /**
         * A list of nodes that needs to be added to the load balancer pool
         */
        nodes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Port to configure on the public-facing side of the load balancer pool
         */
        port?: 80 | 443;
        /**
         * The persistence method for the load balancer
         */
        persistence?: "standard" | "sticky";
        /**
         * The name of the loadbalancer
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, destroy, or update admin users on SolidFire
       */
      na_elementsw_admin_users?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Can create or delete scaling policies for autoscaling groups
       * Referenced autoscaling groups must already exist
       */
      ec2_scaling_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Apstra AOS Logical Device Map module let you manage your Logical Device Map easily. You can create create and delete Logical Device Map by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.
       */
      aos_logical_device_map?: {
        /**
         * Datastructure of the Logical Device Map to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value). Only one of I(name), I(id) or I(content) can be set.
         */
        content?: string;
        /**
         * Default: present
         *
         * Indicate what is the expected state of the Logical Device Map (present or not).
         */
        state?: "present" | "absent";
        /**
         * An existing AOS session as obtained by M(aos_login) module.
         */
        session: {
          [k: string]: unknown;
        };
        /**
         * AOS Id of the Logical Device Map to manage (can't be used to create a new Logical Device Map), Only one of I(name), I(id) or I(content) can be set.
         */
        id?: string;
        /**
         * Name of the Logical Device Map to manage. Only one of I(name), I(id) or I(content) can be set.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * creates / deletes a Rackspace Public Cloud load balancer.
       */
      rax_clb?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage InfluxDB databases.
       */
      influxdb_database?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM tcp monitors via iControl SOAP API.
       */
      bigip_monitor_tcp?: {
        [k: string]: unknown;
      };
      /**
       * Create, update and remove static NATs.
       */
      cs_staticnat?: {
        /**
         * Default: no
         *
         * VM guest NIC secondary IP address for the static NAT.
         */
        vm_guest_ip?: string;
        /**
         * Domain the static NAT is related to.
         */
        domain?: string;
        api_key?: string;
        /**
         * Default: yes
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Network the IP address is related to.
         */
        network?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Name of virtual machine which we make the static NAT for.
         * Required if C(state=present).
         */
        vm?: string;
        api_region?: string;
        /**
         * Name of the project the static NAT is related to.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the static NAT.
         */
        state?: "present" | "absent";
        /**
         * VPC the network related to.
         */
        vpc?: string;
        /**
         * Account the static NAT is related to.
         */
        account?: string;
        /**
         * Name of the zone in which the virtual machine is in.
         * If not set, default zone is used.
         */
        zone?: string;
        /**
         * Public IP address the static NAT is assigned to.
         */
        ip_address: string;
        api_url?: string;
        [k: string]: unknown;
      };
      /**
       * Allows for querying, deleting, binding, and unbinding of configuration templates.
       */
      meraki_config_template?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Configure settings of an E-Series iSCSI interface
       */
      netapp_e_iscsi_interface?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, remove, update load balancers. This module has a dependency on 1and1 >= 1.0
       */
      oneandone_load_balancer?: {
        /**
         * A list of rules that will be added to an existing load balancer. It is syntax is the same as the one used for rules parameter. Used in combination with update state.
         */
        add_rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Authenticating API token provided by 1&1.
         */
        auth_token?: string;
        /**
         * A list of server identifiers (id or name) to be assigned to a load balancer. Used in combination with update state.
         */
        add_server_ips?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Url to call for cheking. Required for HTTP health check. maxLength=1000
         */
        health_check_path?: string;
        /**
         * Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
         */
        api_url?: string;
        /**
         * Default: 5
         *
         * Defines the number of seconds to wait when using the _wait_for methods
         */
        wait_interval?: number | string;
        /**
         * Default: present
         *
         * Define a load balancer state to create, remove, or update.
         */
        state?: "present" | "absent" | "update";
        /**
         * Balancing procedure.
         */
        method?: "ROUND_ROBIN" | "LEAST_CONNECTIONS";
        /**
         * Persistence.
         */
        persistence?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The identifier (id or name) of the load balancer used with update state.
         */
        load_balancer?: string;
        /**
         * Regular expression to check. Required for HTTP health check. maxLength=64
         */
        health_check_parse?: string;
        /**
         * Description of the load balancer. maxLength=256
         */
        description?: string;
        /**
         * A list of rule objects that will be set for the load balancer. Each rule must contain protocol, port_balancer, and port_server parameters, in addition to source parameter, which is optional.
         */
        rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Type of the health check. At the moment, HTTP is not allowed.
         */
        health_check_test?: "NONE" | "TCP" | "HTTP" | "ICMP";
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * Default: yes
         *
         * wait for the instance to be in state 'running' before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: US
         *
         * ID or country code of the datacenter where the load balancer will be created.
         */
        datacenter?: "US" | "ES" | "DE" | "GB";
        /**
         * Persistence time in seconds. Required if persistence is enabled. minimum=30, maximum=1200, multipleOf=1
         */
        persistence_time?: string;
        /**
         * Health check period in seconds. minimum=5, maximum=300, multipleOf=1
         */
        health_check_interval?: string;
        /**
         * Load balancer name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128
         */
        name?: string;
        /**
         * A list of server IP ids to be unassigned from a load balancer. Used in combination with update state.
         */
        remove_server_ips?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A list of rule ids that will be removed from an existing load balancer. Used in combination with update state.
         */
        remove_rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about available packages and their status on an ESXi host.
       */
      vmware_host_package_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running OS6.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      dellos6_facts?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        host?: string;
        /**
         * Default: ['!config']
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces. Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about vultr_startup_scripts available.
       */
      vultr_startup_script_facts?: {
        api_retries?: number | string;
        api_timeout?: number | string;
        api_endpoint?: string;
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV storage domains.
       */
      ovirt_storage_domain_facts?: {
        /**
         * Search term which is accepted by oVirt/RHV search backend.
         * For example to search storage domain X from datacenter Y use following pattern: name=X and datacenter=Y
         */
        pattern?: string;
        [k: string]: unknown;
      };
      /**
       * makes a computer speak! Amuse your friends, annoy your coworkers!
       */
      say?: {
        /**
         * What to say
         */
        msg: string;
        /**
         * What voice to use
         */
        voice?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows modifications and reading of dconf database. The module is implemented as a wrapper around dconf tool. Please see the dconf(1) man page for more details.
       * Since C(dconf) requires a running D-Bus session to change values, the module will try to detect an existing session and reuse it, or run the tool via C(dbus-run-session).
       */
      dconf?: {
        /**
         * Default: present
         *
         * The action to take upon the key/value.
         */
        state?: "read" | "present" | "absent";
        /**
         * A dconf key to modify or read from the dconf database.
         */
        key: string;
        /**
         * Value to set for the specified dconf key. Value should be specified in GVariant format. Due to complexity of this format, it is best to have a look at existing values in the dconf database. Required for C(state=present).
         */
        value?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP InstanceGroup
       */
      gcp_compute_instance_group_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A reference to the zone where the instance group resides.
         */
        zone: string;
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Build, load or pull an image, making the image available for creating containers. Also supports tagging an image into a repository and archiving an image to a .tar file.
       */
      docker_image?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage End Point Groups (EPG) on Cisco ACI fabrics.
       */
      aci_epg?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manage SmartOS virtual machines through vmadm(1M).
       */
      vmadm?: {
        [k: string]: unknown;
      };
      /**
       * Create, modify, and terminate AWS virtual private clouds.
       */
      ec2_vpc_net?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create a keypair for use with Rackspace Cloud Servers
       */
      rax_keypair?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Bind EPGs to Physical and Virtual Domains on Cisco ACI fabrics.
       */
      aci_epg_to_domain?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manage role/user access to a KMS key. Not designed for encrypting/decrypting.
       */
      aws_kms?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific Traffic Manager endpoints or all endpoints  in a Traffic Manager profile
       */
      azure_rm_trafficmanagerendpoint_facts?: {
        profile?: string;
        /**
         * Limit results to a specific Traffic Manager endpoint.
         */
        name?: string;
        /**
         * The resource group to search for the desired Traffic Manager profile
         */
        resource_group: string;
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        /**
         * Name of Traffic Manager Profile
         */
        profile_name: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        /**
         * Type of endpoint.
         */
        type?: "azure_endpoints" | "external_endpoints" | "nested_endpoints";
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Manages SNMP traps configurations.
       */
      nxos_snmp_traps?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Case sensitive group.
         */
        group:
          | "aaa"
          | "bfd"
          | "bgp"
          | "bridge"
          | "callhome"
          | "cfs"
          | "config"
          | "eigrp"
          | "entity"
          | "feature-control"
          | "generic"
          | "hsrp"
          | "license"
          | "link"
          | "lldp"
          | "mmode"
          | "ospf"
          | "pim"
          | "rf"
          | "rmon"
          | "snmp"
          | "storm-control"
          | "stpx"
          | "switchfabric"
          | "syslog"
          | "sysmgr"
          | "system"
          | "upgrade"
          | "vtp"
          | "all";
        auth_pass?: string;
        /**
         * Default: enabled
         *
         * Manage the state of the resource.
         */
        state?: "enabled" | "disabled";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Sets machine time to the specified timezone.
       */
      win_timezone?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage NTP servers on a BIG-IP.
       */
      bigip_device_ntp?: {
        /**
         * A list of NTP servers to set on the device. At least one of C(ntp_servers) or C(timezone) is required.
         */
        ntp_servers?: string;
        /**
         * The timezone to set for NTP lookups. At least one of C(ntp_servers) or C(timezone) is required.
         */
        timezone?: string;
        /**
         * Default: present
         *
         * The state of the NTP servers on the system. When C(present), guarantees that the NTP servers are set on the system. When C(absent), removes the specified NTP servers from the device configuration.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * Create and optionally attach an Elastic Network Interface (ENI) to an instance. If an ENI ID or private_ip is provided, the existing ENI (if any) will be modified. The 'attached' parameter controls the attachment status of the network interface.
       */
      ec2_eni?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Send a message to a Cisco Spark Room or Individual with options to control the formatting.
       */
      cisco_spark?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Manages information center debug configurations on HUAWEI CloudEngine switches.
       */
      ce_info_center_debug?: {
        username?: string;
        /**
         * Default: no_use
         *
         * Whether a device is enabled to output debugging information.
         */
        debug_enable?: "no_use" | "true" | "false";
        ssh_keyfile?: string;
        /**
         * Number of a channel. The value is an integer ranging from 0 to 9. The default value is 0.
         */
        channel_id?: string;
        /**
         * Timestamp type of debugging information.
         */
        debug_time_stamp?:
          | "date_boot"
          | "date_second"
          | "date_tenthsecond"
          | "date_millisecond"
          | "shortdate_second"
          | "shortdate_tenthsecond"
          | "shortdate_millisecond"
          | "formatdate_second"
          | "formatdate_tenthsecond"
          | "formatdate_millisecond";
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Debug level permitted to output.
         */
        debug_level?:
          | "emergencies"
          | "alert"
          | "critical"
          | "error"
          | "warning"
          | "notification"
          | "informational"
          | "debugging";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Module name of the rule. The value is a string of 1 to 31 case-insensitive characters. The default value is default. Please use lower-case letter, such as [aaa, acl, arp, bfd].
         */
        module_name?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 volume snapshots in AWS
       */
      ec2_snapshot_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts for ACM certificates
       */
      aws_acm_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Use this module for power management
       */
      ipmi_power?: {
        /**
         * Hostname or ip address of the BMC.
         */
        name: string;
        /**
         * Whether to ensure that the machine in desired state.
         */
        state: "on" | "off" | "shutdown" | "reset" | "boot";
        /**
         * Username to use to connect to the BMC.
         */
        user: string;
        /**
         * Default: 300
         *
         * Maximum number of seconds before interrupt request.
         */
        timeout?: number | string;
        /**
         * Password to connect to the BMC.
         */
        password: string;
        /**
         * Default: 623
         *
         * Remote RMCP port.
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Add, update and remove load balancer rules.
       */
      cs_loadbalancer_rule?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Create or remove a distributed vSwitch
       */
      vmware_dvswitch?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module manage MAC pools in oVirt/RHV.
       */
      ovirt_mac_pool?: {
        /**
         * If I(true) allow a MAC address to be used multiple times in a pool.
         * Default value is set by oVirt/RHV engine to I(false).
         */
        allow_duplicates?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the MAC pool to manage.
         */
        name: string;
        poll_interval?: number | string;
        fetch_nested?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nested_attributes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List of MAC ranges. The from and to should be split by comma.
         * For example: 00:1a:4a:16:01:51,00:1a:4a:16:01:61
         */
        ranges?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Should the mac pool be present or absent.
         */
        state?: "present" | "absent";
        auth: {
          [k: string]: unknown;
        };
        timeout?: number | string;
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Description of the MAC pool.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to fetch DigitalOcean Floating IPs facts.
       */
      digital_ocean_floating_ip_facts?: {
        [k: string]: unknown;
      };
      /**
       * Manage subnets in AWS virtual private clouds
       */
      ec2_vpc_subnet?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create and remove a Big Cloud Fabric switch.
       */
      bcf_switch?: {
        /**
         * The name of the switch.
         */
        name: string;
        /**
         * Big Cloud Fabric access token. If this isn't set then the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.
         */
        access_token?: string;
        /**
         * The controller IP address.
         */
        controller: string;
        /**
         * The MAC address of the switch.
         */
        mac: string;
        /**
         * Default: present
         *
         * Whether the switch should be present or absent.
         */
        state?: "present" | "absent";
        /**
         * The leaf group of the switch if the switch is a leaf.
         */
        leaf_group?: string;
        /**
         * Default: True
         *
         * If C(false), SSL certificates will not be validated. This should only be used on personally controlled devices using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Fabric role of the switch.
         */
        fabric_role: "spine" | "leaf";
        [k: string]: unknown;
      };
      /**
       * This module is used to configure HTTPPolicySet object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_httppolicyset?: {
        /**
         * Http security policy for the virtual service.
         */
        http_security_policy?: {
          [k: string]: unknown;
        };
        /**
         * Uuid of the http policy set.
         */
        uuid?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Creator name.
         */
        created_by?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Http request policy for the virtual service.
         */
        http_request_policy?: {
          [k: string]: unknown;
        };
        api_version?: string;
        username?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * Name of the http policy set.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Checksum of cloud configuration for pool.
         * Internally set by cloud connector.
         */
        cloud_config_cksum?: string;
        /**
         * Http response policy for the virtual service.
         */
        http_response_policy?: {
          [k: string]: unknown;
        };
        tenant_uuid?: string;
        /**
         * Boolean flag to set is_internal_policy.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        is_internal_policy?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Use the OpenShift Python client to perform read operations on K8s objects.
       * Access to the full range of K8s APIs.
       * Authenticate using either a config file, certificates, password or token.
       * Supports check mode.
       */
      k8s_facts?: {
        [k: string]: unknown;
      };
      /**
       * Add or remove MySQL databases from a remote host.
       */
      mysql_db?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Represents a Network resource.
       * Your Cloud Platform Console project can contain multiple networks, and each network can have multiple instances attached to it. A network allows you to define a gateway IP and the network range for the instances attached to that network. Every project is provided with a default network with preset configurations and firewall rules. You can choose to customize the default network by adding or removing rules, or you can create new networks in that project. Generally, most users only need one network, although you can have up to five networks per project by default.
       * A network belongs to only one project, and each instance can only belong to one network. All Compute Engine networks use the IPv4 protocol. Compute Engine currently does not support IPv6. However, Google is a major advocate of IPv6 and it is an important future direction.
       */
      gcp_compute_network?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: string;
        service_account_email?: string;
        /**
         * When set to true, the network is created in "auto subnet mode". When set to false, the network is in "custom subnet mode".
         * In "auto subnet mode", a newly created network is assigned the default CIDR of 10.128.0.0/9 and it automatically creates one subnetwork per region.
         */
        auto_create_subnetworks?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * The range of internal addresses that are legal on this network. This range is a CIDR specification, for example: 192.168.0.0/16. Provided by the client when the network is created.
         */
        ipv4_range?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * A gateway address for default routing to other networks. This value is read only and is selected by the Google Compute Engine, typically as the first usable address in the IPv4Range.
         */
        gateway_ipv4?: string;
        service_account_file?: string;
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM http monitors.
       */
      bigip_monitor_http?: {
        [k: string]: unknown;
      };
      /**
       * Create, Update or Destroy a Managed Instance Group (MIG).  See U(https://cloud.google.com/compute/docs/instance-groups) for an overview. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.
       */
      gce_mig?: {
        service_account_permissions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the Managed Instance Group.
         */
        name: string;
        /**
         * The GCE zone to use for this Managed Instance Group.
         */
        zone: string;
        /**
         * service account email
         */
        service_account_email?: string;
        /**
         * A dictionary of configuration for the autoscaler. 'enabled (bool)', 'name (str)' and policy.max_instances (int) are required fields if autoscaling is used. See U(https://cloud.google.com/compute/docs/reference/beta/autoscalers) for more information on Autoscaling.
         */
        autoscaling?: {
          [k: string]: unknown;
        };
        recreate_instances?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        pem_file?: string;
        /**
         * Define named ports that backend services can forward data to.  Format is a a list of name:port dictionaries.
         */
        named_ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * desired state of the resource
         */
        state?: "absent" | "present";
        /**
         * Instance Template to be used in creating the VMs.  See U(https://cloud.google.com/compute/docs/instance-templates) to learn more about Instance Templates.  Required for creating MIGs.
         */
        template?: string;
        /**
         * Path to the JSON file associated with the service account email
         */
        credentials_file?: string;
        /**
         * GCE project ID
         */
        project_id?: string;
        /**
         * Size of Managed Instance Group.  If MIG already exists, it will be resized to the number provided here.  Required for creating MIGs.
         */
        size?: number | string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to a NOS device and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(nos_config) to configure NOS devices.
       */
      nos_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        /**
         * List of commands to send to the remote NOS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy. Valid values are C(all) or C(any). If the value is set to C(all) then all conditionals in the wait_for must be satisfied. If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: "any" | "all";
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Layer-2 interfaces on Cisco IOS devices.
       */
      ios_l2_interface?: {
        [k: string]: unknown;
      };
      /**
       * Configure the E-Series management interfaces
       */
      netapp_e_mgmt_interface?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure ServiceEngineGroup object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_serviceenginegroup?: {
        /**
         * Disable tcp segmentation offload (tso) in dpdk poll-mode driver packet transmit path.
         * Tso is on by default on nics that support it.
         * Field introduced in 17.2.5.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        disable_tso?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Value of a (key, value) pair identifying a label for a set of nodes usually in container clouds.
         * Needs to be specified together with host_attribute_key.
         */
        host_attribute_value?: string;
        /**
         * Ssl handshakes will be handled by dedicated ssl threads.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        async_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Instance/flavor type for se instance.
         */
        instance_flavor?: string;
        /**
         * Redistribution of virtual services from the takeover se to the replacement se can cause momentary traffic loss.
         * If the auto-redistribute load option is left in its default off state, any desired rebalancing requires calls to rest api.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        auto_redistribute_active_standby_load?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Time to wait for the scaled in se to drain existing flows before marking the scalein done.
         * Default value when not specified in API or module is interpreted by Avi Controller as 30.
         * Units(SEC).
         */
        vs_scalein_timeout?: number | string;
        /**
         * Determines if se-se ipc messages are encapsulated in an udp header  0  automatically determine based on hypervisor type.
         * 1  use udp encap unconditionally.
         * ~[0,1]  don't use udp encap.
         * Field introduced in 17.1.2.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         */
        se_udp_encap_ipc?: number | string;
        /**
         * When cpu usage on an se falls below the minimum threshold, virtual services hosted on the se may be consolidated onto other underutilized ses.
         * After consolidation, unused service engines may then be eligible for deletion.
         * Allowed values are 20-60.
         * Default value when not specified in API or module is interpreted by Avi Controller as 30.
         * Units(PERCENT).
         */
        min_cpu_usage?: number | string;
        /**
         * Custom security groups to be associated with data vnics for se instances in openstack and aws clouds.
         * Field introduced in 17.1.3.
         */
        custom_securitygroups_data?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Vcenterclusters settings for serviceenginegroup.
         */
        vcenter_clusters?: {
          [k: string]: unknown;
        };
        /**
         * Iptable rules.
         */
        iptables?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Percentage of memory for connection state.
         * This will come at the expense of memory used for http in-memory cache.
         * Allowed values are 10-90.
         * Default value when not specified in API or module is interpreted by Avi Controller as 50.
         * Units(PERCENT).
         */
        connection_memory_percentage?: number | string;
        /**
         * Subnets assigned to the se group.
         * Required for vs group placement.
         * Field introduced in 17.1.1.
         */
        service_ip_subnets?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * If placement mode is 'auto', virtual services are automatically placed on service engines.
         * Enum options - PLACEMENT_MODE_AUTO.
         * Default value when not specified in API or module is interpreted by Avi Controller as PLACEMENT_MODE_AUTO.
         */
        placement_mode?: string;
        /**
         * Maximum number of active service engines for the virtual service.
         * Allowed values are 1-64.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.
         */
        max_scaleout_per_vs?: number | string;
        /**
         * Enable routing for this serviceenginegroup .
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        enable_routing?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable memory pool for waf.
         * Field introduced in 17.2.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        waf_mempool?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Per-app se mode is designed for deploying dedicated load balancers per app (vs).
         * In this mode, each se is limited to a max of 2 vss.
         * Vcpus in per-app ses count towards licensing usage at 25% rate.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        per_app?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Boolean flag to set vcenter_datastores_include.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        vcenter_datastores_include?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        /**
         * Name of the object.
         */
        name: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Maximum number of services engines in this group.
         * Allowed values are 0-1000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 10.
         */
        max_se?: number | string;
        /**
         * Tcp port on se where echo service will be run.
         * Field introduced in 17.2.2.
         * Default value when not specified in API or module is interpreted by Avi Controller as 7.
         */
        se_probe_port?: number | string;
        /**
         * If no license type is specified then default license enforcement for the cloud type is chosen.
         * Enum options - LIC_BACKEND_SERVERS, LIC_SOCKETS, LIC_CORES, LIC_HOSTS, LIC_SE_BANDWIDTH.
         * Field introduced in 17.2.5.
         */
        license_type?: string;
        /**
         * Dosthresholdprofile settings for serviceenginegroup.
         */
        se_dos_profile?: {
          [k: string]: unknown;
        };
        tenant_uuid?: string;
        /**
         * This setting limits the number of udf logs generated per second per core on this se.
         * Udf logs are generated due to the configured client log filters or the rules with logging enabled.
         * Default is 100 logs per second.
         * Set it to zero (0) to disable throttling.
         * Field introduced in 17.1.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as 100.
         * Units(PER_SECOND).
         */
        udf_log_throttle?: number | string;
        /**
         * Vcenterhosts settings for serviceenginegroup.
         */
        vcenter_hosts?: {
          [k: string]: unknown;
        };
        /**
         * Udp port for se_dp ipc in docker bridge mode.
         * Field introduced in 17.1.2.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1500.
         */
        se_ipc_udp_port?: number | string;
        /**
         * Number of vcpus for each of the service engine virtual machines.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.
         */
        vcpus_per_se?: number | string;
        /**
         * Allocate all the cpu cores for the service engine virtual machines  on the same cpu socket.
         * Applicable only for vcenter cloud.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        cpu_socket_affinity?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable or disable real time se metrics.
         */
        realtime_se_metrics?: {
          [k: string]: unknown;
        };
        /**
         * Custom tag will be used to create the tags for se instance in aws.
         * Note this is not the same as the prefix for se name.
         */
        custom_tag?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * This setting limits the number of non-significant logs generated per second per core on this se.
         * Default is 100 logs per second.
         * Set it to zero (0) to disable throttling.
         * Field introduced in 17.1.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as 100.
         * Units(PER_SECOND).
         */
        non_significant_log_throttle?: number | string;
        /**
         * Extra config memory to support large geo db configuration.
         * Field introduced in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         * Units(MB).
         */
        extra_shared_config_memory?: number | string;
        /**
         * List of vcenterdatastore.
         */
        vcenter_datastores?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Number of sideband threads per se.
         * Allowed values are 1-128.
         * Field introduced in 16.5.2, 17.1.9, 17.2.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.
         */
        se_sb_threads?: number | string;
        /**
         * Service engines in active/standby mode for ha failover.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        active_standby?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Capacities of se for auto rebalance for each criteria.
         * Field introduced in 17.2.4.
         */
        auto_rebalance_capacity_per_se?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_version?: string;
        /**
         * Multiplier for extra config to support large vs/pool config.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.0.
         */
        extra_config_multiplier?: number;
        /**
         * Number of async ssl threads per se_dp.
         * Allowed values are 1-16.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.
         */
        async_ssl_threads?: number | string;
        /**
         * Folder to place all the service engine virtual machines in vcenter.
         * Default value when not specified in API or module is interpreted by Avi Controller as AviSeFolder.
         */
        vcenter_folder?: string;
        /**
         * If serviceenginegroup is configured for legacy 1+1 active standby ha mode, floating ip's will be advertised only by the active se in the pair.
         * Virtual services in this group must be disabled/enabled for any changes to the floating ip's to take effect.
         * Only active se hosting vs tagged with active standby se 1 tag will advertise this floating ip when manual load distribution is enabled.
         */
        floating_intf_ip?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Advertise reach-ability of backend server networks via adc through bgp for default gateway feature.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        advertise_backend_networks?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tenant?: string;
        /**
         * When cpu usage on an se exceeds this threshold, virtual services hosted on this se may be rebalanced to other ses to reduce load.
         * A new se may be created as part of this process.
         * Allowed values are 40-90.
         * Default value when not specified in API or module is interpreted by Avi Controller as 80.
         * Units(PERCENT).
         */
        max_cpu_usage?: number | string;
        /**
         * Minimum number of active service engines for the virtual service.
         * Allowed values are 1-64.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.
         */
        min_scaleout_per_vs?: number | string;
        /**
         * If set, virtual services will be placed on only a subset of the cores of an se.
         * Field introduced in 17.2.5.
         */
        vss_placement?: {
          [k: string]: unknown;
        };
        /**
         * Excess service engine capacity provisioned for ha failover.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.
         */
        buffer_se?: number | string;
        /**
         * Override default hypervisor.
         * Enum options - DEFAULT, VMWARE_ESX, KVM, VMWARE_VSAN, XEN.
         */
        hypervisor?: string;
        /**
         * Enum options - vcenter_datastore_any, vcenter_datastore_local, vcenter_datastore_shared.
         * Default value when not specified in API or module is interpreted by Avi Controller as VCENTER_DATASTORE_ANY.
         */
        vcenter_datastore_mode?: string;
        /**
         * (this is a beta feature).
         * Enable hsm key priming.
         * If enabled, key handles on the hsm will be synced to se before processing client connections.
         * Field introduced in 17.2.7.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        enable_hsm_priming?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set of criteria for se auto rebalance.
         * Enum options - SE_AUTO_REBALANCE_CPU, SE_AUTO_REBALANCE_PPS, SE_AUTO_REBALANCE_MBPS, SE_AUTO_REBALANCE_OPEN_CONNS, SE_AUTO_REBALANCE_CPS.
         * Field introduced in 17.2.3.
         */
        auto_rebalance_criteria?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Select core with least load for new flow.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        least_load_core_selection?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Allow ses to be created using burst license.
         * Field introduced in 17.2.5.
         */
        allow_burst?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * This setting limits the number of significant logs generated per second per core on this se.
         * Default is 100 logs per second.
         * Set it to zero (0) to disable throttling.
         * Field introduced in 17.1.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as 100.
         * Units(PER_SECOND).
         */
        significant_log_throttle?: number | string;
        /**
         * Select the se bandwidth for the bandwidth license.
         * Enum options - SE_BANDWIDTH_UNLIMITED, SE_BANDWIDTH_25M, SE_BANDWIDTH_200M, SE_BANDWIDTH_1000M, SE_BANDWIDTH_10000M.
         * Field introduced in 17.2.5.
         */
        se_bandwidth_type?: string;
        /**
         * Maximum number of virtualservices for which heartbeat messages are aggregated in one packet.
         * Allowed values are 1-1024.
         * Field introduced in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as 256.
         */
        se_vs_hb_max_vs_in_pkt?: number | string;
        /**
         * Enable vip on all interfaces of se.
         * Field introduced in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        enable_vip_on_all_interfaces?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * If set, virtual services will be automatically migrated when load on an se is less than minimum or more than maximum thresholds.
         * Only alerts are generated when the auto_rebalance is not set.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        auto_rebalance?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Determines if dsr from secondary se is active or not  0  automatically determine based on hypervisor type.
         * 1  disable dsr unconditionally.
         * ~[0,1]  enable dsr unconditionally.
         * Field introduced in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         */
        se_tunnel_mode?: number | string;
        /**
         * Amount of memory for each of the service engine virtual machines.
         * Default value when not specified in API or module is interpreted by Avi Controller as 2048.
         */
        memory_per_se?: number | string;
        /**
         * Udp port for tunneled packets from secondary to primary se in docker bridge mode.
         * Field introduced in 17.1.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1550.
         */
        se_tunnel_udp_port?: number | string;
        /**
         * Disable generic receive offload (gro) in dpdk poll-mode driver packet receive path.
         * Gro is on by default on nics that do not support lro (large receive offload) or do not gain performance boost from lro.
         * Field introduced in 17.2.5.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        disable_gro?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Time to wait for the scaled out se to become ready before marking the scaleout done.
         * Default value when not specified in API or module is interpreted by Avi Controller as 30.
         * Units(SEC).
         */
        vs_scaleout_timeout?: number | string;
        /**
         * Management subnet to use for avi service engines.
         */
        mgmt_subnet?: {
          [k: string]: unknown;
        };
        /**
         * Udp port for punted packets in docker bridge mode.
         * Field introduced in 17.1.2.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1501.
         */
        se_remote_punt_udp_port?: number | string;
        /**
         * Program se security group ingress rules to allow ssh/icmp management access from remote cidr type.
         * Enum options - SG_INGRESS_ACCESS_NONE, SG_INGRESS_ACCESS_ALL, SG_INGRESS_ACCESS_VPC.
         * Field introduced in 17.1.5.
         * Default value when not specified in API or module is interpreted by Avi Controller as SG_INGRESS_ACCESS_ALL.
         */
        ingress_access_mgmt?: string;
        username?: string;
        /**
         * Maximum number of virtual services that can be placed on a single service engine.
         * East west virtual services are excluded from this limit.
         * Allowed values are 1-1000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 10.
         */
        max_vs_per_se?: number | string;
        /**
         * Amount of extra memory to be reserved for use by the operating system on a service engine.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         */
        os_reserved_memory?: number | string;
        /**
         * Management network uuid.
         */
        openstack_mgmt_network_uuid?: string;
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Maximum number of aggregated vs heartbeat packets to send in a batch.
         * Allowed values are 1-256.
         * Field introduced in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as 8.
         */
        se_vs_hb_max_pkts_in_batch?: number | string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Sideband traffic will be handled by a dedicated core.
         * Field introduced in 16.5.2, 17.1.9, 17.2.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        se_sb_dedicated_core?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Key of a (key, value) pair identifying a label for a set of nodes usually in container clouds.
         * Needs to be specified together with host_attribute_value.
         * Ses can be configured differently including ha modes across different se groups.
         * May also be used for isolation between different classes of virtualservices.
         * Virtualservices' se group may be specified via annotations/labels.
         * A openshift/kubernetes namespace maybe annotated with a matching se group label as openshift.io/node-selector  apptype=prod.
         * When multiple se groups are used in a cloud with host attributes specified,just a single se group can exist as a match-all se group without a
         * host_attribute_key.
         */
        host_attribute_key?: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Boolean flag to set mem_reserve.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        mem_reserve?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Boolean flag to set cpu_reserve.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        cpu_reserve?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Use virtual mac address for interfaces on which floating interface ips are placed.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        enable_vmac?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Amount of se memory in gb until which shared memory is collected in core archive.
         * Field introduced in 17.1.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as 8.
         * Units(GB).
         */
        archive_shm_limit?: number | string;
        /**
         * Field deprecated in 17.1.1.
         */
        openstack_availability_zone?: string;
        /**
         * Enable active health monitoring from the standby se for all placed virtual services.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        hm_on_standby?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Amount of disk space for each of the service engine virtual machines.
         * Default value when not specified in API or module is interpreted by Avi Controller as 10.
         * Units(GB).
         */
        disk_per_se?: number | string;
        /**
         * It is a reference to an object of type hardwaresecuritymodulegroup.
         */
        hardwaresecuritymodulegroup_ref?: string;
        /**
         * Custom security groups to be associated with management vnic for se instances in openstack and aws clouds.
         * Field introduced in 17.1.3.
         */
        custom_securitygroups_mgmt?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * If serviceenginegroup is configured for legacy 1+1 active standby ha mode, floating ip's will be advertised only by the active se in the pair.
         * Virtual services in this group must be disabled/enabled for any changes to the floating ip's to take effect.
         * Only active se hosting vs tagged with active standby se 2 tag will advertise this floating ip when manual load distribution is enabled.
         */
        floating_intf_ip_se_2?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Maximum disk capacity (in mb) to be allocated to an se.
         * This is exclusively used for debug and log data.
         * Default value when not specified in API or module is interpreted by Avi Controller as 10000.
         * Units(MB).
         */
        log_disksz?: number | string;
        /**
         * It is a reference to an object of type cloud.
         */
        cloud_ref?: string;
        /**
         * Frequency of rebalance, if 'auto rebalance' is enabled.
         * Default value when not specified in API or module is interpreted by Avi Controller as 300.
         * Units(SEC).
         */
        auto_rebalance_interval?: number | string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Enable aggressive failover configuration for ha.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        aggressive_failure_detection?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Ignore rtt samples if it is above threshold.
         * Field introduced in 17.1.6,17.2.2.
         * Default value when not specified in API or module is interpreted by Avi Controller as 5000.
         * Units(MILLISECONDS).
         */
        ignore_rtt_threshold?: number | string;
        /**
         * Field introduced in 17.1.1.
         */
        openstack_availability_zones?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Stop using tcp/udp and ip checksum offload features of nics.
         * Field introduced in 17.1.14, 17.2.5.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        disable_csum_offloads?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Number of changes in num flow cores sum to ignore.
         * Default value when not specified in API or module is interpreted by Avi Controller as 8.
         */
        num_flow_cores_sum_changes_to_ignore?: number | string;
        /**
         * Multiplier for se threads based on vcpu.
         * Allowed values are 1-10.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.
         */
        se_thread_multiplier?: number | string;
        /**
         * Avi management network name.
         */
        openstack_mgmt_network_name?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * During se upgrade, time to wait for the scaled-in se to drain existing flows before marking the scalein done.
         * Default value when not specified in API or module is interpreted by Avi Controller as 30.
         * Units(SEC).
         */
        vs_scalein_timeout_for_upgrade?: number | string;
        /**
         * Duration to preserve unused service engine virtual machines before deleting them.
         * If traffic to a virtual service were to spike up abruptly, this se would still be available to be utilized again rather than creating a new se.
         * If this value is set to 0, controller will never delete any ses and administrator has to manually cleanup unused ses.
         * Allowed values are 0-525600.
         * Default value when not specified in API or module is interpreted by Avi Controller as 120.
         * Units(MIN).
         */
        se_deprovision_delay?: number | string;
        /**
         * Program se security group ingress rules to allow vip data access from remote cidr type.
         * Enum options - SG_INGRESS_ACCESS_NONE, SG_INGRESS_ACCESS_ALL, SG_INGRESS_ACCESS_VPC.
         * Field introduced in 17.1.5.
         * Default value when not specified in API or module is interpreted by Avi Controller as SG_INGRESS_ACCESS_ALL.
         */
        ingress_access_data?: string;
        /**
         * Management network to use for avi service engines.
         * It is a reference to an object of type network.
         */
        mgmt_network_ref?: string;
        /**
         * Specifies the license tier which would be used.
         * This field by default inherits the value from cloud.
         * Enum options - ENTERPRISE_16, ENTERPRISE_18.
         * Field introduced in 17.2.5.
         */
        license_tier?: string;
        /**
         * Maximum number of flow table entries that have not completed tcp three-way handshake yet.
         * Field introduced in 17.2.5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         */
        flow_table_new_syn_max_entries?: number | string;
        /**
         * Enable the host gateway monitor when service engine is deployed as docker container.
         * Disabled by default.
         * Field introduced in 17.2.4.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        host_gateway_monitor?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Prefix to use for virtual machine name of service engines.
         * Default value when not specified in API or module is interpreted by Avi Controller as Avi.
         */
        se_name_prefix?: string;
        /**
         * High availability mode for all the virtual services using this service engine group.
         * Enum options - HA_MODE_SHARED_PAIR, HA_MODE_SHARED, HA_MODE_LEGACY_ACTIVE_STANDBY.
         * Default value when not specified in API or module is interpreted by Avi Controller as HA_MODE_SHARED.
         */
        ha_mode?: string;
        /**
         * Use both the active and standby service engines for virtual service placement in the legacy active standby ha mode.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        distribute_load_active_standby?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * In compact placement, virtual services are placed on existing ses until max_vs_per_se limit is reached.
         * Enum options - PLACEMENT_ALGO_PACKED, PLACEMENT_ALGO_DISTRIBUTED.
         * Default value when not specified in API or module is interpreted by Avi Controller as PLACEMENT_ALGO_PACKED.
         */
        algo?: string;
        /**
         * Memory pool size used for waf.
         * Field introduced in 17.2.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as 64.
         * Units(KB).
         */
        waf_mempool_size?: number | string;
        /**
         * Dedicate the core that handles packet receive/transmit from the network to just the dispatching function.
         * Don't use it for tcp/ip and ssl functions.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        dedicated_dispatcher_core?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Ensure primary and secondary service engines are deployed on different physical hosts.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        vs_host_redundancy?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create or Delete cinder block storage volume snapshots
       */
      os_volume_snapshot?: {
        /**
         * Name of the snapshot
         */
        display_name?: string;
        /**
         * Availability zone in which to create the snapshot.
         */
        availability_zone?: string;
        /**
         * String describing the snapshot
         */
        display_description?: string;
        /**
         * The volume name or id to create/delete the snapshot
         */
        volume?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Allows or disallows snapshot of a volume to be created when the volume is attached to an instance.
         */
        force?: string;
        [k: string]: unknown;
      };
      /**
       * This will configure both pre-login and post-login banners on remote devices running VyOS. It allows playbooks to add or remote banner text from the active running configuration.
       */
      vyos_banner?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * The banner text that should be present in the remote device running configuration. This argument accepts a multiline string, with no empty lines. Requires I(state=present).
         */
        text?: string;
        /**
         * Default: present
         *
         * Specifies whether or not the configuration is present in the current devices active running configuration.
         */
        state?: "present" | "absent";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Specifies which banner that should be configured on the remote device.
         */
        banner: "pre-login" | "post-login";
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * A CRUD-like interface to managing bits of XML files.
       * You might also be interested in a brief tutorial from U(https://www.w3schools.com/xml/xpath_intro.asp) and U(https://developer.mozilla.org/en-US/docs/Web/XPath).
       */
      xml?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * List details of EC2 Elastic IP addresses.
       */
      ec2_eip_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or destroy user roles
       */
      na_ontap_user_role?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Creates, removes and configures an IIS Web Application Pool.
       */
      win_iis_webapppool?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Interacts with FTP, HTTP and HTTPS web services.
       * Supports Digest, Basic and WSSE HTTP authentication mechanisms.
       * For non-Windows targets, use the M(uri) module instead.
       */
      win_uri?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Creates a Virtual Network Identifier member (VNI) for an NVE overlay interface.
       */
      nxos_vxlan_vtep_vni?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * This attribute is used to identify and separate processing VNIs that are associated with a VRF and used for routing. The VRF and VNI specified with this command must match the configuration of the VNI under the VRF.
         */
        assoc_vrf?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set the ingress-replication static peer list. Valid values are an array, a space-separated string of ip addresses, or the keyword 'default'.
         */
        peer_list?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Suppress arp under layer 2 VNI.
         */
        suppress_arp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        auth_pass?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * ID of the Virtual Network Identifier.
         */
        vni: string;
        port?: number | string;
        /**
         * The multicast group (range) of the VNI. Valid values are string and keyword 'default'.
         */
        multicast_group?: string;
        host?: string;
        ssh_keyfile?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Interface name for the VXLAN Network Virtualization Endpoint.
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies mechanism for host reachability advertisement.
         */
        ingress_replication?: "bgp" | "static" | "default";
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Manages SNMP location configuration.
       */
      nxos_snmp_location?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * Location information.
         */
        location: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Manipulate Rackspace Cloud Autoscale Groups
       */
      rax_scaling_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and remove startup scripts.
       */
      vultr_startup_script?: {
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 ENI interfaces in AWS
       */
      ec2_eni_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of the local usernames configured on network devices. It allows playbooks to manage either individual usernames or the aggregate of usernames in the current running config. It also supports purging usernames from the configuration that are not explicitly defined.
       */
      net_user?: {
        /**
         * Instructs the module to consider the resource definition absolute. It will remove any previously configured usernames on the device with the exception of the `admin` user (the current defined set of users).
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The set of username objects to be configured on the remote network device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Configures the state of the username definition as it relates to the device operational configuration. When set to I(present), the username(s) should be configured in the device active configuration and when set to I(absent) the username(s) should not be in the device active configuration
         */
        state?: "present" | "absent";
        /**
         * The username to be configured on the remote network device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).
         */
        name?: string;
        vlan_id?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete Azure Virtual Machine Extension
       */
      azure_rm_virtualmachine_extension?: {
        /**
         * Name of a resource group where the vm extension exists or will be created.
         */
        resource_group: string;
        cloud_environment?: string;
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        /**
         * Valid azure location. Defaults to location of the resource group.
         */
        location?: string;
        /**
         * Json formatted protected settings for the extension.
         */
        protected_settings?: {
          [k: string]: unknown;
        };
        subscription_id?: string;
        /**
         * The type version of the extension handler.
         */
        type_handler_version?: string;
        profile?: string;
        /**
         * Whether the extension handler should be automatically upgraded across minor versions.
         */
        auto_upgrade_minor_version?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The type of the extension handler.
         */
        virtual_machine_extension_type?: string;
        /**
         * Default: present
         *
         * Assert the state of the vm extension. Use 'present' to create or update a vm extension and 'absent' to delete a vm extension.
         */
        state?: "absent" | "present";
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        tenant?: string;
        /**
         * The name of the virtual machine where the extension should be create or updated.
         */
        virtual_machine_name?: string;
        /**
         * The name of the extension handler publisher.
         */
        publisher?: string;
        /**
         * Name of the vm extension
         */
        name: string;
        /**
         * Json formatted public settings for the extension.
         */
        settings?: {
          [k: string]: unknown;
        };
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        [k: string]: unknown;
      };
      /**
       * Configures anycast gateway MAC of the switch.
       */
      nxos_overlay_global?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Anycast gateway mac of the switch.
         */
        anycast_gateway_mac: string;
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * This module is used to configure ServerAutoScalePolicy object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_serverautoscalepolicy?: {
        /**
         * Use avi intelligent autoscale algorithm where autoscale is performed by comparing load on the pool against estimated capacity of all the servers.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        intelligent_autoscale?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Minimum extra capacity as percentage of load used by the intelligent scheme.
         * Scaleout is triggered when available capacity is less than this margin.
         * Allowed values are 1-99.
         * Default value when not specified in API or module is interpreted by Avi Controller as 20.
         */
        intelligent_scaleout_margin?: number | string;
        /**
         * Cooldown period during which no new scalein is triggered to allow previous scalein to successfully complete.
         * Default value when not specified in API or module is interpreted by Avi Controller as 300.
         * Units(SEC).
         */
        scalein_cooldown?: number | string;
        /**
         * Cooldown period during which no new scaleout is triggered to allow previous scaleout to successfully complete.
         * Default value when not specified in API or module is interpreted by Avi Controller as 300.
         * Units(SEC).
         */
        scaleout_cooldown?: number | string;
        /**
         * Maximum extra capacity as percentage of load used by the intelligent scheme.
         * Scalein is triggered when available capacity is more than this margin.
         * Allowed values are 1-99.
         * Default value when not specified in API or module is interpreted by Avi Controller as 40.
         */
        intelligent_scalein_margin?: number | string;
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Maximum number of servers to scaleout simultaneously.
         * The actual number of servers to scaleout is chosen such that target number of servers is always less than or equal to the max_size.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.
         */
        max_scaleout_adjustment_step?: number | string;
        api_version?: string;
        username?: string;
        /**
         * Use predicted load rather than current load.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        use_predicted_load?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Trigger scaleout when alerts due to any of these alert configurations are raised.
         * It is a reference to an object of type alertconfig.
         */
        scaleout_alertconfig_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * No scale-in happens once number of operationally up servers reach min_servers.
         * Allowed values are 0-400.
         */
        min_size?: number | string;
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * Name of the object.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Maximum number of servers to scalein simultaneously.
         * The actual number of servers to scalein is chosen such that target number of servers is always more than or equal to the min_size.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.
         */
        max_scalein_adjustment_step?: number | string;
        /**
         * Trigger scalein when alerts due to any of these alert configurations are raised.
         * It is a reference to an object of type alertconfig.
         */
        scalein_alertconfig_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Maximum number of servers after scaleout.
         * Allowed values are 0-400.
         */
        max_size?: number | string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Create (reserve) or Destroy (release) Regional or Global IP Addresses. See U(https://cloud.google.com/compute/docs/configure-instance-ip-addresses#reserve_new_static) for more on reserving static addresses.
       */
      gce_eip?: {
        /**
         * Name of Address.
         */
        name: string;
        service_account_email?: string;
        /**
         * Region to create the address in. Set to 'global' to create a global address.
         */
        region: string;
        service_account_permissions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        pem_file?: string;
        /**
         * Default: present
         *
         * The state the address should be in. C(present) or C(absent) are the only valid options.
         */
        state?: "present" | "absent";
        credentials_file?: string;
        project_id?: string;
        [k: string]: unknown;
      };
      /**
       * This module creates or deletes volumes to be used on IBM Spectrum Accelerate storage systems.
       */
      ibm_sa_vol?: {
        /**
         * Volume name.
         */
        vol?: string;
        /**
         * Default: present
         *
         * Volume state.
         */
        state?: string;
        /**
         * Volume pool.
         */
        pool?: string;
        /**
         * Volume size.
         */
        size?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV quotas.
       */
      ovirt_quota_facts?: {
        /**
         * Name of the quota, can be used as glob expression.
         */
        name?: string;
        /**
         * Name of the datacenter where quota resides.
         */
        data_center?: string;
        [k: string]: unknown;
      };
      /**
       * A named resource to which messages are sent by publishers.
       */
      gcp_pubsub_topic?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the topic.
         */
        name?: string;
        service_account_email?: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Create and renew SSL/TLS certificates with a CA supporting the L(ACME protocol,https://tools.ietf.org/html/rfc8555), such as L(Let's Encrypt,https://letsencrypt.org/). The current implementation supports the C(http-01), C(dns-01) and C(tls-alpn-01) challenges.
       * To use this module, it has to be executed twice. Either as two different tasks in the same run or during two runs. Note that the output of the first run needs to be recorded and passed to the second run as the module argument C(data).
       * Between these two tasks you have to fulfill the required steps for the chosen challenge by whatever means necessary. For C(http-01) that means creating the necessary challenge file on the destination webserver. For C(dns-01) the necessary dns record has to be created. For C(tls-alpn-01) the necessary certificate has to be created and served. It is I(not) the responsibility of this module to perform these steps.
       * For details on how to fulfill these challenges, you might have to read through L(the main ACME specification,https://tools.ietf.org/html/rfc8555#section-8) and the L(TLS-ALPN-01 specification,https://tools.ietf.org/html/draft-ietf-acme-tls-alpn-05#section-3). Also, consider the examples provided for this module.
       */
      acme_certificate?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Creates AWS VPC endpoints.
       * Deletes AWS VPC endpoints.
       * This module support check mode.
       */
      ec2_vpc_endpoint?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * When no given Hook found, will create one.
       * In case Hook found, but provided parameters are differes, will update existing Hook.
       * In case state=absent and Hook exists, will delete it.
       */
      ec2_asg_lifecycle_hook?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage AWS IAM groups
       */
      iam_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allow the syslog settings to be configured for an individual E-Series storage-system
       */
      netapp_e_syslog?: {
        /**
         * Default: udp
         *
         * This is the transmission protocol the syslog server's using to receive syslog messages.
         */
        protocol?: "udp" | "tcp" | "tls";
        api_url: string;
        /**
         * This argument specifies a local path for logging purposes.
         */
        log_path?: string;
        api_username: string;
        api_password: string;
        /**
         * Default: present
         *
         * Add or remove the syslog server configuration for E-Series storage array.
         * Existing syslog server configuration will be removed or updated when its address matches I(address).
         * Fully qualified hostname that resolve to an IPv4 address that matches I(address) will not be treated as a match.
         */
        state?: "present" | "absent";
        /**
         * Default: ['auditLog']
         *
         * The e-series logging components define the specific logs to transfer to the syslog server.
         * At the time of writing, 'auditLog' is the only logging component but more may become available.
         */
        components?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The syslog server's IPv4 address or a fully qualified hostname.
         * All existing syslog configurations will be removed when I(state=absent) and I(address=None).
         */
        address?: string;
        /**
         * This forces a test syslog message to be sent to the stated syslog server.
         * Only attempts transmission when I(state=present).
         */
        test?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 514
         *
         * This is the port the syslog server is using.
         */
        port?: number | string;
        ssid: string;
        [k: string]: unknown;
      };
      /**
       * Manage top level Application Profile (AP) objects on Cisco ACI fabrics
       */
      aci_ap?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * This module can create and delete GCE private images from gzipped compressed tarball containing raw disk data or from existing detached disks in any zone. U(https://cloud.google.com/compute/docs/images)
       */
      gce_img?: {
        /**
         * an optional description
         */
        description?: string;
        /**
         * an optional family name
         */
        family?: string;
        /**
         * service account email
         */
        service_account_email?: string;
        /**
         * path to the pem file associated with the service account email
         */
        pem_file?: string;
        /**
         * the source disk or the Google Cloud Storage URI to create the image from
         */
        source?: string;
        /**
         * Default: present
         *
         * desired state of the image
         */
        state?: "present" | "absent";
        /**
         * Default: us-central1-a
         *
         * the zone of the disk specified by source
         */
        zone?: string;
        /**
         * Default: 180
         *
         * timeout for the operation
         */
        timeout?: number | string;
        /**
         * your GCE project ID
         */
        project_id?: string;
        /**
         * the name of the image to create or delete
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Set up, reconfigure, or remove SSL termination for an existing load balancer.
       */
      rax_clb_ssl?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * The manageiq_alert_profiles module supports adding, updating and deleting alert profiles in ManageIQ.
       */
      manageiq_alert_profiles?: {
        /**
         * The unique alert profile name in ManageIQ.
         * Required when state is "absent" or "present".
         */
        name?: string;
        /**
         * Optional notes for this profile
         */
        notes?: string;
        /**
         * List of alert descriptions to assign to this profile.
         * Required if state is "present"
         */
        alerts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * absent - alert profile should not exist,
         * present - alert profile should exist,
         */
        state?: "absent" | "present";
        manageiq_connection?: {
          [k: string]: unknown;
        };
        /**
         * The resource type for the alert profile in ManageIQ. Required when state is "present".
         */
        resource_type?:
          | "Vm"
          | "ContainerNode"
          | "MiqServer"
          | "Host"
          | "Storage"
          | "EmsCluster"
          | "ExtManagementSystem"
          | "MiddlewareServer";
        [k: string]: unknown;
      };
      /**
       * This module will let you pause/unpause Pingdom alerts
       */
      pingdom?: {
        /**
         * Pingdom user password.
         */
        passwd: string;
        /**
         * Pingdom ID of the check.
         */
        checkid: string;
        /**
         * Define whether or not the check should be running or paused.
         */
        state: "running" | "paused" | "started" | "stopped";
        /**
         * Pingdom user ID.
         */
        uid: string;
        /**
         * Pingdom API key.
         */
        key: string;
        [k: string]: unknown;
      };
      /**
       * Install, uninstall a Windows hotfix.
       */
      win_hotfix?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of L3 interfaces on VyOS network devices.
       */
      vyos_l3_interface?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Name of the L3 interface.
         */
        name?: string;
        /**
         * IPv6 of the L3 interface.
         */
        ipv6?: string;
        /**
         * Default: present
         *
         * State of the L3 interface configuration.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * IPv4 of the L3 interface.
         */
        ipv4?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of L3 interfaces definitions
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module allows to manage samba shares on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
       */
      udm_share?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages local Windows computer name.
       * A reboot is required for the computer name to take effect.
       */
      win_hostname?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages domains and records via the DNSimple API, see the docs: U(http://developer.dnsimple.com/).
       */
      dnsimple?: {
        /**
         * Whether the record should be the only one for that record type and record name.
         * Only use with C(state) is set to C(present) on a record.
         */
        solo?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNSimple.
         * If omitted, a list of domains will be returned.
         * If domain is present but the domain doesn't exist, it will be created.
         */
        domain?: string;
        /**
         * Account email. If omitted, the environment variables C(DNSIMPLE_EMAIL) and C(DNSIMPLE_API_TOKEN) will be looked for.
         * If those aren't found, a C(.dnsimple) file will be looked for, see: U(https://github.com/mikemaccana/dnsimple-python#getting-started).
         */
        account_email?: string;
        /**
         * List of records to ensure they either exist or do not exist.
         */
        record_ids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Record value.
         * Must be specified when trying to ensure a record exists.
         */
        value?: string;
        /**
         * Record priority.
         */
        priority?: number | string;
        /**
         * Record to add, if blank a record for the domain will be created, supports the wildcard (*).
         */
        record?: string;
        /**
         * whether the record should exist or not.
         */
        state?: "present" | "absent";
        /**
         * Default: 3600
         *
         * The TTL to give the new record in seconds.
         */
        ttl?: number | string;
        /**
         * The type of DNS record to create.
         */
        type?:
          | "A"
          | "ALIAS"
          | "CNAME"
          | "MX"
          | "SPF"
          | "URL"
          | "TXT"
          | "NS"
          | "SRV"
          | "NAPTR"
          | "PTR"
          | "AAAA"
          | "SSHFP"
          | "HINFO"
          | "POOL";
        /**
         * Account API token. See I(account_email) for more information.
         */
        account_api_token?: string;
        [k: string]: unknown;
      };
      /**
       * Used to managed Chocolatey sources configured on the client.
       * Requires Chocolatey to be already installed on the remote host.
       */
      win_chocolatey_source?: {
        /**
         * The priority order of this source compared to other sources, lower is better.
         * All priorities above C(0) will be evaluated first, then zero-based values will be evaluated in config file order.
         * Requires Chocolatey >= 0.9.9.9.
         * When creating a new source, this defaults to C(0).
         */
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Add, remove or set User Rights for a group or users or groups.
       * You can set user rights for both local and domain accounts.
       */
      win_user_right?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage Self-IPs on a BIG-IP system.
       */
      bigip_selfip?: {
        /**
         * Default: Common
         *
         * Device partition to manage resources on. You can set different partitions for Self IPs, but the address used may not match any other address used by a Self IP. In that sense, Self IPs are not isolated by partitions as other resources on a BIG-IP are.
         */
        partition?: string;
        /**
         * The self IP to create.
         * If this parameter is not specified, then it will default to the value supplied in the C(address) parameter.
         */
        name?: string;
        /**
         * The VLAN that the new self IPs will be on. When creating a new Self IP, this value is required.
         */
        vlan?: string;
        /**
         * The netmask for the self IP. When creating a new Self IP, this value is required.
         */
        netmask?: string;
        /**
         * Configure port lockdown for the Self IP. By default, the Self IP has a "default deny" policy. This can be changed to allow TCP and UDP ports as well as specific protocols. This list should contain C(protocol):C(port) values.
         */
        allow_service?: string;
        /**
         * Default: present
         *
         * When C(present), guarantees that the Self-IP exists with the provided attributes.
         * When C(absent), removes the Self-IP from the system.
         */
        state?: string;
        /**
         * The route domain id of the system. When creating a new Self IP, if this value is not specified, a default value of C(0) will be used.
         * This value cannot be changed after it is set.
         */
        route_domain?: string;
        /**
         * The IP addresses for the new self IP. This value is ignored upon update as addresses themselves cannot be changed after they are created.
         * This value is required when creating new self IPs.
         */
        address?: string;
        /**
         * The traffic group for the Self IP addresses in an active-active, redundant load balancer configuration. When creating a new Self IP, if this value is not specified, the default of C(/Common/traffic-group-local-only) will be used.
         */
        traffic_group?: string;
        [k: string]: unknown;
      };
      /**
       * Manages BGP neighbors configurations on NX-OS switches.
       */
      nxos_bgp_neighbor?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        /**
         * Configure whether or not to negotiate capability with this neighbor.
         */
        capability_negotiation?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the encryption type the password will use. Valid values are '3des' or 'cisco_type_7' encryption or keyword 'default'.
         */
        pwd_type?: "3des" | "cisco_type_7" | "default";
        /**
         * Configure whether or not to enable dynamic capability.
         */
        dynamic_capability?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Configure to administratively shutdown this neighbor.
         */
        shutdown?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify whether or not to shut down this neighbor under memory pressure.
         */
        low_memory_exempt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the config to remove private AS number from outbound updates. Valid values are 'enable' to enable this config, 'disable' to disable this config, 'all' to remove all private AS number, or 'replace-as', to replace the private AS number.
         */
        remove_private_as?: "enable" | "disable" | "all" | "replace-as";
        /**
         * Configure to suppress 4-byte AS Capability.
         */
        suppress_4_byte_as?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        transport?: "cli" | "nxapi";
        /**
         * Configure whether or not to check for directly connected peer.
         */
        connected_check?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify Autonomous System Number of the neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.
         */
        remote_as?: string;
        /**
         * Specify multihop TTL for a remote peer. Valid values are integers between 2 and 255, or keyword 'default' to disable this property.
         */
        ebgp_multihop?: string;
        auth_pass?: string;
        /**
         * BGP autonomous system number. Valid values are string, Integer in ASPLAIN or ASDOT notation.
         */
        asn: string;
        port?: number | string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * Specify holdtime timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 180.
         */
        timers_holdtime?: string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Specify source interface of BGP session and updates.
         */
        update_source?: string;
        /**
         * Description of the neighbor.
         */
        description?: string;
        /**
         * Specify the local-as number for the eBGP neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.
         */
        local_as?: string;
        /**
         * Specify keepalive timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 60.
         */
        timers_keepalive?: string;
        host?: string;
        /**
         * Default: default
         *
         * Name of the VRF. The name 'default' is a valid VRF representing the global bgp.
         */
        vrf?: string;
        /**
         * Specify whether or not to enable log messages for neighbor up/down event.
         */
        log_neighbor_changes?: "enable" | "disable" | "inherit";
        password?: string;
        /**
         * Specify Maximum number of peers for this neighbor prefix Valid values are between 1 and 1000, or 'default', which does not impose the limit. Note that this parameter is accepted only on neighbors with address/prefix.
         */
        maximum_peers?: string;
        ssh_keyfile?: string;
        /**
         * Specify the password for neighbor. Valid value is string.
         */
        pwd?: string;
        /**
         * Specify whether or not to only allow passive connection setup. Valid values are 'true', 'false', and 'default', which defaults to 'false'. This property can only be configured when the neighbor is in 'ip' address format without prefix length.
         */
        transport_passive_only?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        timeout?: number | string;
        /**
         * Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.
         */
        neighbor: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific load balancer or all load balancers.
       */
      azure_rm_loadbalancer_facts?: {
        profile?: string;
        /**
         * Limit results to a specific resource group.
         */
        name?: string;
        /**
         * The resource group to search for the desired load balancer
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Create, destroy, attach, detach volumes.
       */
      cs_volume?: {
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an SLX node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(slxos_config) to configure SLX-OS devices.
       */
      slxos_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        /**
         * List of commands to send to the remote SLX-OS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: "any" | "all";
        [k: string]: unknown;
      };
      /**
       * Create, remove, start, stop and tune GlusterFS volumes
       */
      gluster_volume?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * This module can be used to create, delete, move and rename folder on then given datacenter.
       */
      vcenter_folder?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of static IP routes on Arista EOS network devices.
       */
      eos_static_route?: {
        [k: string]: unknown;
      };
      /**
       * Create, destroy, update, start, stop, and reboot a ProfitBricks virtual machine. When the virtual machine is created it can optionally wait for it to be 'running' before returning. This module has a dependency on profitbricks >= 1.0.0
       */
      profitbricks?: {
        /**
         * The system image ID for creating the virtual machine, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8.
         */
        image?: string;
        /**
         * Default: 2048
         *
         * The amount of memory to allocate to the virtual machine.
         */
        ram?: number | string;
        /**
         * THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
         */
        subscription_password?: string;
        /**
         * Public SSH keys allowing access to the virtual machine.
         */
        ssh_keys?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
         */
        subscription_user?: string;
        /**
         * Default: 10
         *
         * The size in GB of the boot volume.
         */
        volume_size?: number | string;
        /**
         * Default: present
         *
         * create or terminate instances
         */
        state?: string;
        /**
         * Default: us/las
         *
         * The datacenter location. Use only if you want to create the Datacenter or else this value is ignored.
         */
        location?: "us/las" | "de/fra" | "de/fkb";
        /**
         * Default: no
         *
         * This will assign the machine to the public LAN. If no LAN exists with public Internet access it is created.
         */
        assign_public_ip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Whether or not to increment a single number in the name for created virtual machines.
         */
        auto_increment?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * The ID of the LAN you wish to add the servers to.
         */
        lan?: number | string;
        /**
         * Password set for the administrative user.
         */
        image_password?: string;
        /**
         * Default: VIRTIO
         *
         * The bus type for the volume.
         */
        bus?: "IDE" | "VIRTIO";
        /**
         * list of instance ids, currently only used when state='absent' to remove instances.
         */
        instance_ids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * Default: AMD_OPTERON
         *
         * The CPU family type to allocate to the virtual machine.
         */
        cpu_family?: "AMD_OPTERON" | "INTEL_XEON";
        disk_type?: "HDD" | "SSD";
        /**
         * Default: yes
         *
         * wait for the instance to be in state 'running' before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * The number of virtual machines to create.
         */
        count?: number | string;
        /**
         * The datacenter to provision this virtual machine.
         */
        datacenter?: string;
        /**
         * Default: yes
         *
         * remove the bootVolume of the virtual machine you're destroying.
         */
        remove_boot_volume?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the virtual machine.
         */
        name?: string;
        /**
         * Default: 2
         *
         * The number of CPU cores to allocate to the virtual machine.
         */
        cores?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, update, remove hosts on NetApp E-series storage arrays
       */
      netapp_e_host?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        };
      /**
       * Add or remove server groups from OpenStack.
       */
      os_server_group?: {
        /**
         * Default: present
         *
         * Indicate desired state of the resource. When I(state) is 'present', then I(policies) is required.
         */
        state?: string;
        /**
         * Server group name.
         */
        name?: string;
        /**
         * A list of one or more policy names to associate with the server group. The list must contain at least one policy name. The current valid policy names are anti-affinity, affinity, soft-anti-affinity and soft-affinity.
         */
        policies?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove PostgreSQL users (roles) from a remote host and, optionally, grant the users access to an existing database or tables.
       * The fundamental function of the module is to create, or delete, roles from a PostgreSQL cluster. Privilege assignment, or removal, is an optional step, which works on one database at a time. This allows for the module to be called several times in the same module to modify the permissions on different databases, or to grant permissions to already existing users.
       * A user cannot be removed until all the privileges have been stripped from the user. In such situation, if the module tries to remove the user it will fail. To avoid this from happening the fail_on_user option signals the module to try to remove the user, but if not possible keep going; the module will report if changes happened and separately if the user was removed or not.
       */
      postgresql_user?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Lists S3 buckets in AWS
       */
      aws_s3_bucket_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can install new and updated packages on remote devices running Junos.  The module will compare the specified package with the one running on the remote device and install the specified version if there is a mismatch
       */
      junos_package?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Apstra AOS External Router module let you manage your External Router easily. You can create create and delete External Router by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.
       */
      aos_external_router?: {
        /**
         * Name of the External Router to manage. Only one of I(name), I(id) or I(content) can be set.
         */
        name?: string;
        /**
         * IP address of the Loopback interface of the external_router.
         */
        loopback?: string;
        /**
         * AOS Id of the External Router to manage (can't be used to create a new External Router), Only one of I(name), I(id) or I(content) can be set.
         */
        id?: string;
        /**
         * Datastructure of the External Router to create. The format is defined by the I(content_format) parameter. It's the same datastructure that is returned on success in I(value).
         */
        content?: string;
        /**
         * Default: present
         *
         * Indicate what is the expected state of the External Router (present or not).
         */
        state?: "present" | "absent";
        /**
         * An existing AOS session as obtained by M(aos_login) module.
         */
        session: {
          [k: string]: unknown;
        };
        /**
         * ASN id of the external_router.
         */
        asn?: string;
        [k: string]: unknown;
      };
      /**
       * Ensure the state of AWS VPC NAT Gateways based on their id, allocation and subnet ids.
       */
      ec2_vpc_nat_gateway?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates or removes managed zones in Google Cloud DNS.
       */
      gcdns_zone?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage the state of a virtual host in RabbitMQ
       */
      rabbitmq_vhost?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Manage cache snapshots in Amazon Elasticache.
       * Returns information about the specified snapshot.
       */
      elasticache_snapshot?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create and remove VPN connections.
       */
      cs_vpn_connection?: {
        /**
         * Name of the VPN customer gateway.
         */
        vpn_customer_gateway: string;
        /**
         * State of the VPN connection.
         * Only considered when C(state=present).
         */
        passive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Domain the VPN connection is related to.
         */
        domain?: string;
        api_key?: string;
        /**
         * Activate the VPN gateway if not already activated on C(state=present).
         * Also see M(cs_vpn_gateway).
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Account the VPN connection is related to.
         */
        account?: string;
        api_region?: string;
        /**
         * Name of the project the VPN connection is related to.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the VPN connection.
         */
        state?: "present" | "absent";
        /**
         * Name of the VPC the VPN connection is related to.
         */
        vpc: string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        zone?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete instance of App Service Plan.
       */
      azure_rm_appserviceplan?: {
        profile?: string;
        /**
         * Describe number of workers to be allocated.
         */
        number_of_workers?: string;
        /**
         * Unique name of the app service plan to create or update.
         */
        name: string;
        /**
         * Name of the resource group to which the resource belongs.
         */
        resource_group: string;
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        secret?: string;
        /**
         * Default: present
         *
         * Assert the state of the app service plan.
         * Use 'present' to create or update an app service plan and 'absent' to delete it.
         */
        state?: "absent" | "present";
        /**
         * The pricing tiers, e.g., F1, D1, B1, B2, B3, S1, P1, P1V2 etc.
         * Please see U(https://azure.microsoft.com/en-us/pricing/details/app-service/plans/) for more detail.
         * For linux app service plan, please see U(https://azure.microsoft.com/en-us/pricing/details/app-service/linux/) for more detail.
         */
        sku?: string;
        /**
         * Resource location. If not set, location from the resource group will be used as default.
         */
        location?: string;
        client_id?: string;
        cert_validation_mode?: "validate" | "ignore";
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        /**
         * Describe whether to host webapp on Linux worker.
         */
        is_linux?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tenant?: string;
        api_profile?: string;
        [k: string]: unknown;
      };
      /**
       * This module will allow user to pass and execute any supported OP command on the PANW device.
       */
      panos_op?: {
        /**
         * Default: admin
         *
         * Username credentials to use for authentication.
         */
        username?: string;
        /**
         * API key that can be used instead of I(username)/I(password) credentials.
         */
        api_key?: string;
        /**
         * Password credentials to use for authentication.
         */
        password?: string;
        /**
         * The OP command to be performed.
         */
        cmd: string;
        /**
         * IP address (or hostname) of PAN-OS device or Panorama management console being configured.
         */
        ip_address: string;
        [k: string]: unknown;
      };
      /**
       * Manage I(libvirt) networks.
       */
      virt_net?: {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure CloudProperties object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_cloudproperties?: {
        /**
         * Properties specific to a cloud type.
         */
        info?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Hypervisor properties.
         */
        hyp_props?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Cloud types supported by cloudconnector.
         * Enum options - CLOUD_NONE, CLOUD_VCENTER, CLOUD_OPENSTACK, CLOUD_AWS, CLOUD_VCA, CLOUD_APIC, CLOUD_MESOS, CLOUD_LINUXSERVER, CLOUD_DOCKER_UCP,
         * CLOUD_RANCHER, CLOUD_OSHIFT_K8S, CLOUD_AZURE.
         */
        cc_vtypes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        controller?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        username?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Cloudconnector properties.
         */
        cc_props?: {
          [k: string]: unknown;
        };
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running NOS. This module prepends all of the base network fact keys with C(ansible_net_<fact>). The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      nos_facts?: {
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset. Possible values for this argument include all, hardware, config, and interfaces. Can specify a list of values to include a larger subset. Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Manages ARP attributes of VXLAN on HUAWEI CloudEngine devices.
       */
      ce_vxlan_arp?: {
        username?: string;
        /**
         * Configures the local device as the router reflector (RR) on the EVN network.
         */
        evn_server?: "enable" | "disable";
        ssh_keyfile?: string;
        /**
         * Enables EVN BGP.
         */
        evn_bgp?: "enable" | "disable";
        /**
         * Full name of VBDIF interface, i.e. Vbdif100.
         */
        vbdif_name?: string;
        /**
         * Enables ARP broadcast suppression in a BD.
         */
        arp_suppress?: "enable" | "disable";
        /**
         * Enables EVN BGP or BGP EVPN to collect host information.
         */
        arp_collect_host?: "enable" | "disable";
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * Specifies a BD(bridge domain) ID. The value is an integer ranging from 1 to 16777215.
         */
        bridge_domain_id?: string;
        /**
         * Configures the local device as the route reflector (RR) and its peer as the client.
         */
        evn_reflect_client?: "enable" | "disable";
        host?: string;
        /**
         * Specifies the IP address of an EVN BGP peer. The value is in dotted decimal notation.
         */
        evn_peer_ip?: string;
        /**
         * Enables EVN BGP or BGP EVPN to advertise host information.
         */
        host_collect_protocol?: "bgp" | "none";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Specifies the source address of an EVN BGP peer. The value is in dotted decimal notation.
         */
        evn_source_ip?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Manage MCP interface policies on Cisco ACI fabrics.
       */
      aci_interface_policy_mcp?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Adds and/or removes instances of AAAA record objects from Infoblox NIOS servers.  This module manages NIOS C(record:aaaa) objects using the Infoblox WAPI interface over REST.
       */
      nios_aaaa_record?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Runs a remote command from a Linux host to a Windows host without WinRM being set up.
       * Can be run on the Ansible controller to bootstrap Windows hosts to get them ready for WinRM.
       */
      psexec?: {
        /**
         * Default: normal
         *
         * Set the command's priority on the Windows host.
         * See U(https://msdn.microsoft.com/en-us/library/windows/desktop/ms683211.aspx) for more details.
         */
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        /**
         * The executable to run on the Windows host.
         */
        executable: string;
        /**
         * The password for I(connection_user).
         * Required if the Kerberos requirements are not installed or the username is a local account to the Windows host.
         * Can be omitted to use a Kerberos principal ticket for the principal set by I(connection_user) if the Kerberos library is installed and the ticket has already been retrieved with the C(kinit) command before.
         */
        connection_password?: string;
        /**
         * Shows the process UI on the Winlogon secure desktop when I(process_username) is C(System).
         */
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: True
         *
         * Runs the remote command with the user's profile loaded.
         */
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Will run the process as an interactive process that shows a process Window of the Windows session specified by I(interactive_session).
         * The I(stdout) and I(stderr) return values will be null when this is set to C(yes).
         * The I(stdin) option does not work with this type of process.
         */
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The Windows session ID to use when displaying the interactive process on the remote Windows host.
         * This is only valid when I(interactive) is C(yes).
         * The default is C(0) which is the console session of the Windows host.
         */
        interactive_session?: number | string;
        /**
         * The remote Windows host to connect to, can be either an IP address or a hostname.
         */
        hostname: string;
        /**
         * Default: default
         *
         * The integrity level of the process when I(process_username) is defined and is not equal to C(System).
         * When C(default), the default integrity level based on the system setup.
         * When C(elevated), the command will be run with Administrative rights.
         * When C(limited), the command will be forced to run with non-Administrative rights.
         */
        integrity_level?: "limited" | "default" | "elevated";
        /**
         * The username to use when connecting to the remote Windows host.
         * This user must be a member of the C(Administrators) group of the Windows host.
         * Required if the Kerberos requirements are not installed or the username is a local account to the Windows host.
         * Can be omitted to use the default Kerberos principal ticket in the local credential cache if the Kerberos library is installed.
         * If I(process_username) is not specified, then the remote process will run under a Network Logon under this account.
         */
        connection_username?: string;
        /**
         * Default: C:\Windows\System32
         *
         * Changes the working directory set when starting the process.
         */
        working_directory?: string;
        /**
         * Any arguments as a single string to use when running the executable.
         */
        arguments?: string;
        /**
         * The user to run the process as.
         * This can be set to run the process under an Interactive logon of the specified account which bypasses limitations of a Network logon used when this isn't specified.
         * If omitted then the process is run under the same account as I(connection_username) with a Network logon.
         * Set to C(System) to run as the builtin SYSTEM account, no password is required with this account.
         * If I(encrypt) is C(no), the username and password are sent as a simple XOR scrambled byte string that is not encrypted. No special tools are required to get the username and password just knowledge of the protocol.
         */
        process_username?: string;
        /**
         * Will run the command as a detached process and the module returns immediately after starting the processs while the process continues to run in the background.
         * The I(stdout) and I(stderr) return values will be null when this is set to C(yes).
         * The I(stdin) option does not work with this type of process.
         * The I(rc) return value is not set when this is C(yes)
         */
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The password for I(process_username).
         * Required if I(process_username) is defined and not C(System).
         */
        process_password?: string;
        /**
         * Default: 60
         *
         * The timeout in seconds to wait when receiving the initial SMB negotiate response from the server.
         */
        connection_timeout?: number | string;
        /**
         * Default: True
         *
         * Will use SMB encryption to encrypt the SMB messages sent to and from the host.
         * This requires the SMB 3 protocol which is only supported from Windows Server 2012 or Windows 8, older versions like Windows 7 or Windows Server 2008 (R2) must set this to C(no) and use no encryption.
         * When setting to C(no), the packets are in plaintext and can be seen by anyone sniffing the network, any process options are included in this.
         */
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 445
         *
         * The port that the remote SMB service is listening on.
         */
        port?: number | string;
        /**
         * Data to send on the stdin pipe once the process has started.
         * This option has no effect when I(interactive) or I(asynchronous) is C(yes).
         */
        stdin?: string;
        /**
         * The timeout in seconds that is placed upon the running process.
         * A value of C(0) means no timeout.
         */
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, Update or Destroy a Healthcheck. Currently only HTTP and HTTPS Healthchecks are supported. Healthchecks are used to monitor individual instances, managed instance groups and/or backend services. Healtchecks are reusable.
       * Visit U(https://cloud.google.com/compute/docs/load-balancing/health-checks) for an overview of Healthchecks on GCP.
       * See U(https://cloud.google.com/compute/docs/reference/latest/httpHealthChecks) for API details on HTTP Healthchecks.
       * See U(https://cloud.google.com/compute/docs/reference/latest/httpsHealthChecks) for more details on the HTTPS Healtcheck API.
       */
      gcp_healthcheck?: {
        /**
         * Name of the Healthcheck.
         */
        healthcheck_name: string;
        /**
         * Type of Healthcheck.
         */
        healthcheck_type: "HTTP" | "HTTPS";
        /**
         * Default: 5
         *
         * How often (in seconds) to send a health check.
         */
        check_interval?: number | string;
        /**
         * service account email
         */
        service_account_email?: string;
        /**
         * Default: 2
         *
         * A so-far unhealthy instance will be marked healthy after this many consecutive successes.
         */
        healthy_threshold?: number | string;
        /**
         * service account permissions (see U(https://cloud.google.com/sdk/gcloud/reference/compute/instances/create), --scopes section for detailed information)
         */
        service_account_permissions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 2
         *
         * A so-far healthy instance will be marked unhealthy after this many consecutive failures.
         */
        unhealthy_threshold?: number | string;
        /**
         * The value of the host header in the health check request. If left empty, the public IP on behalf of which this health check is performed will be used.
         */
        host_header?: string;
        /**
         * State of the Healthcheck.
         */
        state?: "present" | "absent";
        /**
         * Default: 5
         *
         * How long (in seconds) to wait for a response before claiming failure. It is invalid for timeout to have a greater value than check_interval.
         */
        timeout?: number | string;
        /**
         * Path to the JSON file associated with the service account email
         */
        credentials_file?: string;
        /**
         * Your GCP project ID
         */
        project_id?: string;
        /**
         * The TCP port number for the health check request. The default value is 443 for HTTPS and 80 for HTTP.
         */
        port?: number | string;
        /**
         * Default: /
         *
         * The request path of the HTTPS health check request.
         */
        request_path?: string;
        [k: string]: unknown;
      };
      /**
       * Manage (add, remove, change) individual interface options in an interfaces-style file without having to manage the file as a whole with, say, M(template) or M(assemble). Interface has to be presented in a file.
       * Read information about interfaces from interfaces-styled files
       */
      interfaces_file?: {
        /**
         * Name of the interface, required for value changes or option remove
         */
        iface?: string;
        /**
         * Name of the option, required for value changes or option remove
         */
        option?: string;
        /**
         * Default: /etc/network/interfaces
         *
         * Path to the interfaces file
         */
        dest?: string;
        /**
         * If I(option) is not presented for the I(interface) and I(state) is C(present) option will be added. If I(option) already exists and is not C(pre-up), C(up), C(post-up) or C(down), it's value will be updated. C(pre-up), C(up), C(post-up) and C(down) options can't be updated, only adding new options, removing existing ones or cleaning the whole option set are supported
         */
        value?: string;
        /**
         * Default: present
         *
         * If set to C(absent) the option or section will be removed if present instead of created.
         */
        state?: "present" | "absent";
        /**
         * Default: no
         *
         * Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage the life cycle of docker containers.
       * Supports check mode. Run with --check and --diff to view config difference and list of actions to be taken.
       */
      docker_container?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows the management of AWS Lambda policy statements. It is idempotent and supports "Check" mode.  Use module M(lambda) to manage the lambda function itself, M(lambda_alias) to manage function aliases, M(lambda_event) to manage event source mappings such as Kinesis streams, M(execute_lambda) to execute a lambda function and M(lambda_facts) to gather facts relating to one or more lambda functions.
       */
      lambda_policy?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This will configure both login and motd banners on network devices. It allows playbooks to add or remote banner text from the active running configuration.
       */
      junos_banner?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).
         */
        text?: string;
        /**
         * Default: present
         *
         * Specifies whether or not the configuration is present in the current devices active running configuration.
         */
        state?: "present" | "absent";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: yes
         *
         * Specifies whether or not the configuration is active or deactivated
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        /**
         * Specifies which banner that should be configured on the remote device. Value C(login) indicates system login message prior to authenticating, C(motd) is login announcement after successful authentication.
         */
        banner: "login" | "motd";
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about AWS Autoscaling Launch Configurations
       */
      ec2_lc_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific route table or all route table in a resource group or subscription.
       */
      azure_rm_routetable_facts?: {
        profile?: string;
        /**
         * Limit results to a specific route table.
         */
        name?: string;
        /**
         * Limit results in a specific resource group.
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or delete a storage account.
       */
      azure_rm_storageaccount?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * This module controls active and configured mount points in C(/etc/fstab).
       */
      mount?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Provides an interface to manage Fibre Channel Network resources. Can create, update, and delete.
       */
      oneview_fc_network?: {
        username?: string;
        image_streamer_hostname?: string;
        hostname?: string;
        config?: string;
        validate_etag?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Indicates the desired state for the Fibre Channel Network resource. C(present) will ensure data properties are compliant with OneView. C(absent) will remove the resource from OneView, if it exists.
         */
        state: "present" | "absent";
        password?: string;
        /**
         * List with the Fibre Channel Network properties.
         */
        data: {
          [k: string]: unknown;
        };
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage BIG-IP ASM policies.
       */
      bigip_asm_policy?: {
        /**
         * The ASM policy to manage or create.
         */
        name?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Default: present
         *
         * When C(state) is C(present), and C(file) or C(template) parameter is provided, new ASM policy is imported and created with the given C(name).
         * When C(state) is present and no C(file) or C(template) parameter is provided new blank ASM policy is created with the given C(name).
         * When C(state) is C(absent), ensures that the policy is removed, even if it is currently active.
         */
        state?: string;
        /**
         * Full path to a policy file to be imported into the BIG-IP ASM.
         * Policy files exported from newer versions of BIG-IP cannot be imported into older versions of BIG-IP. The opposite, however, is true; you can import older into newer.
         */
        file?: string;
        /**
         * If C(yes) will apply and activate existing inactive policy. If C(no), it will deactivate existing active policy. Generally should be C(yes) only in cases where you want to activate new or existing policy.
         */
        active?: string;
        /**
         * An ASM policy built-in template. If the template does not exist we will raise an error.
         * Once the policy has been created, this value cannot change.
         * The C(Comprehensive), C(Drupal), C(Fundamental), C(Joomla), C(Vulnerability Assessment Baseline), and C(Wordpress) templates are only available on BIG-IP versions >= 13.
         */
        template?: string;
        [k: string]: unknown;
      };
      /**
       * Manage a bare metal server in the Packet Host (a "device" in the API terms).
       * When the machine is created it can optionally wait for public IP address, or for active state.
       * This module has a dependency on packet >= 1.0.
       * API is documented at U(https://www.packet.net/developers/api/devices).
       */
      packet_device?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Read the AWS documentation for WAF U(https://aws.amazon.com/documentation/waf/)
       */
      aws_waf_rule?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Use this module to manage crontab variables. This module allows you to create, update, or delete cron variable definitions.
       */
      cronvar?: {
        /**
         * Name of the crontab variable.
         */
        name: string;
        /**
         * Used with C(state=present). If specified, the variable will be inserted just before the variable specified.
         */
        insertbefore?: string;
        /**
         * If specified, uses this file instead of an individual user's crontab. Without a leading /, this is assumed to be in /etc/cron.d.  With a leading /, this is taken as absolute.
         */
        cron_file?: string;
        /**
         * The value to set this variable to.
         * Required if C(state=present).
         */
        value?: string;
        /**
         * Default: present
         *
         * Whether to ensure that the variable is present or absent.
         */
        state?: "absent" | "present";
        /**
         * Default: root
         *
         * The specific user whose crontab should be modified.
         */
        user?: string;
        /**
         * If specified, the variable will be inserted after the variable specified.
         * Used with C(state=present).
         */
        insertafter?: string;
        /**
         * Default: no
         *
         * If set, create a backup of the crontab before it is modified. The location of the backup is returned in the C(backup) variable by this module.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create, update, or destroy Ansible Tower roles. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_role?: {
        /**
         * Credential the role acts on.
         */
        credential?: string;
        /**
         * The job template the role acts on.
         */
        job_template?: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_password?: string;
        /**
         * Project the role acts on.
         */
        project?: string;
        tower_config_file?: string;
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * The role type to grant/revoke.
         */
        role?: "admin" | "read" | "member" | "execute" | "adhoc" | "update" | "use" | "auditor";
        /**
         * Inventory the role acts on.
         */
        inventory?: string;
        /**
         * Team that receives the permissions specified by the role.
         */
        team?: string;
        tower_username?: string;
        /**
         * Organization the role acts on.
         */
        organization?: string;
        /**
         * Team that the role acts on.
         */
        target_team?: string;
        tower_host?: string;
        /**
         * User that receives the permissions specified by the role.
         */
        user?: string;
        [k: string]: unknown;
      };
      /**
       * Represents a Router resource.
       */
      gcp_compute_router?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A reference to the network to which this router belongs.
         */
        network: {
          [k: string]: unknown;
        };
        service_account_email?: string;
        /**
         * Region where the router resides.
         */
        region: string;
        /**
         * An optional description of this resource.
         */
        description?: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        service_account_file?: string;
        /**
         * BGP information specific to this router.
         */
        bgp?: {
          [k: string]: unknown;
        };
        /**
         * Name of the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create and remove affinity groups.
       */
      cs_affinitygroup?: {
        /**
         * Account the affinity group is related to.
         */
        account?: string;
        /**
         * Default: yes
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        /**
         * Description of the affinity group.
         */
        description?: string;
        api_timeout?: number | string;
        affinty_type?: string;
        api_region?: string;
        /**
         * Type of the affinity group. If not specified, first found affinity type is used.
         */
        affinity_type?: string;
        /**
         * Name of the project the affinity group is related to.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the affinity group.
         */
        state?: "present" | "absent";
        /**
         * Domain the affinity group is related to.
         */
        domain?: string;
        api_key?: string;
        /**
         * Name of the affinity group.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP GTM tcp half-open monitors.
       */
      bigip_gtm_monitor_tcp_half_open?: {
        /**
         * Specifies the number of times the system attempts to probe the host server, after which the system considers the host server down or unavailable.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(3).
         */
        probe_attempts?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Monitor name.
         */
        name?: string;
        /**
         * Default: /Common/tcp_half_open
         *
         * The parent template of this monitor template. Once this value has been set, it cannot be changed. By default, this value is the C(tcp_half_open) parent on the C(Common) partition.
         */
        parent?: string;
        /**
         * IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
         */
        ip?: string;
        /**
         * Specifies, in seconds, the frequency at which the system issues the monitor check when either the resource is down or the status of the resource is unknown.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(30). This value B(must) be less than the C(timeout) value.
         */
        interval?: string;
        /**
         * Specifies whether the monitor operates in transparent mode.
         * A monitor in transparent mode directs traffic through the associated pool members or nodes (usually a router or firewall) to the aliased destination (that is, it probes the C(ip)-C(port) combination specified in the monitor).
         * If the monitor cannot successfully reach the aliased destination, the pool member or node through which the monitor traffic was sent is marked down.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(no).
         */
        transparent?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the monitor exists.
         * When C(absent), ensures the monitor is removed.
         */
        state?: string;
        /**
         * Specifies the number of seconds the big3d process waits before sending out a subsequent probe attempt when a probe fails and multiple probe attempts have been requested.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(1).
         */
        probe_interval?: string;
        /**
         * Specifies that the monitor allows more than one probe attempt per interval.
         * When C(yes), specifies that the monitor ignores down responses for the duration of the monitor timeout. Once the monitor timeout is reached without the system receiving an up response, the system marks the object down.
         * When C(no), specifies that the monitor immediately marks an object down when it receives a down response.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(no).
         */
        ignore_down_response?: string;
        /**
         * Specifies the number of seconds the target has in which to respond to the monitor request.
         * If the target responds within the set time period, it is considered up.
         * If the target does not respond within the set time period, it is considered down.
         * When this value is set to 0 (zero), the system uses the interval from the parent monitor.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(120).
         */
        timeout?: string;
        /**
         * Specifies the number of seconds after which the system times out the probe request to the system.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(5).
         */
        probe_timeout?: string;
        /**
         * Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * Creates, updates, or deletes Amazon Inspector Assessment Targets and manages the required Resource Groups.
       */
      aws_inspector_target?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages BFD global configuration on HUAWEI CloudEngine devices.
       */
      ce_bfd_global?: {
        username?: string;
        /**
         * Specifies a maximum flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 15000.
         */
        damp_max_wait_time?: number | string;
        /**
         * Indicates the priority of BFD control packets for static BFD sessions. The value is an integer ranging from 0 to 7. The default priority is 7, which is the highest priority of BFD control packets.
         */
        tos_exp_static?: number | string;
        /**
         * Specifies the default multicast IP address. The value ranges from 224.0.0.107 to 224.0.0.250.
         */
        default_ip?: string;
        /**
         * Specifies the delay before a BFD session becomes Up. The value is an integer ranging from 1 to 600, in seconds. The default value is 0, indicating that a BFD session immediately becomes Up.
         */
        delay_up_time?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enables the global Bidirectional Forwarding Detection (BFD) function.
         */
        bfd_enable?: "enable" | "disable";
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * Specifies an initial flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 2000.
         */
        damp_init_wait_time?: number | string;
        host?: string;
        /**
         * Indicates the priority of BFD control packets for dynamic BFD sessions. The value is an integer ranging from 0 to 7. The default priority is 7, which is the highest priority of BFD control packets.
         */
        tos_exp_dynamic?: number | string;
        /**
         * Specifies a secondary flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 5000.
         */
        damp_second_wait_time?: number | string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        ssh_keyfile?: string;
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Manages log publishers on a BIG-IP.
       */
      bigip_log_publisher?: {
        /**
         * Specifies log destinations for this log publisher to use.
         */
        destinations?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the resource exists.
         * When C(absent), ensures the resource is removed.
         */
        state?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies a description for the log publisher.
         */
        description?: string;
        /**
         * Specifies the name of the log publisher.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manage networks on Vultr. A network cannot be updated. It needs to be deleted and re-created.
       */
      vultr_network?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module uses rabbitMQ Rest API to create/delete exchanges
       */
      rabbitmq_exchange?: {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of LLDP service configuration on Mellanox ONYX network devices.
       */
      onyx_lldp?: {
        /**
         * Default: present
         *
         * State of the LLDP protocol configuration.
         */
        state?: "present" | "absent";
        [k: string]: unknown;
      };
      /**
       * Set system's hostname, supports most OSs/Distributions, including those using systemd.
       * Note, this module does *NOT* modify C(/etc/hosts). You need to modify it yourself using other modules like template or replace.
       * Windows, HP-UX and AIX are not currently supported.
       */
      hostname?: {
        /**
         * Name of the host
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * An HealthCheck resource. This resource defines a template for how individual virtual machines should be checked for health, via one of the supported protocols.
       */
      gcp_compute_health_check?: {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure DnsPolicy object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_dnspolicy?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Uuid of the dns policy.
         * Field introduced in 17.1.1.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.1.1.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Dns rules.
         * Field introduced in 17.1.1.
         */
        rule?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the dns policy.
         * Field introduced in 17.1.1.
         */
        name: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Creator name.
         * Field introduced in 17.1.1.
         */
        created_by?: string;
        api_context?: {
          [k: string]: unknown;
        };
        tenant?: string;
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Field introduced in 17.1.1.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * NETCONF is a network management protocol developed and standardized by the IETF. It is documented in RFC 6241.
       * This module allows the user to execute NETCONF RPC requests as defined by IETF RFC standards as well as proprietary requests.
       */
      netconf_rpc?: {
        /**
         * This argument specifies the optional request content (all RPC attributes). The I(content) value can either be provided as XML formatted string or as dictionary.
         */
        content?: string;
        /**
         * This argument specifies the request (name of the operation) to be executed on the remote NETCONF enabled device.
         */
        rpc: string;
        /**
         * NETCONF operations not defined in rfc6241 typically require the appropriate XML namespace to be set. In the case the I(request) option is not already provided in XML format, the namespace can be defined by the I(xmlns) option.
         */
        xmlns?: string;
        /**
         * Encoding scheme to use when serializing output from the device. The option I(json) will serialize the output as JSON data. If the option value is I(json) it requires jxmlease to be installed on control node. The option I(pretty) is similar to received XML response but is using human readable format (spaces, new lines). The option value I(xml) is similar to received XML response but removes all XML namespaces.
         */
        display?: "json" | "pretty" | "xml";
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific network interface or all network interfaces within a resource group.
       */
      azure_rm_networkinterface_facts?: {
        profile?: string;
        /**
         * Only show results for a specific network interface.
         */
        name?: string;
        /**
         * Name of the resource group containing the network interface(s). Required when searching by name.
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Aruba configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with Aruba configuration sections in a deterministic way.
       */
      aruba_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Enable/Disable Autosupport
       */
      na_ontap_autosupport?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create, destroy, update, start, stop, and reboot a 1&1 Host server. When the server is created it can optionally wait for it to be 'running' before returning.
       */
      oneandone_server?: {
        /**
         * The total number of processors. It must be provided with cores_per_processor, ram, and hdds parameters.
         */
        vcore?: number | string;
        /**
         * Authenticating API token provided by 1&1. Overrides the ONEANDONE_AUTH_TOKEN environement variable.
         */
        auth_token?: string;
        /**
         * The amount of RAM memory. It must be provided with with vcore, cores_per_processor, and hdds parameters.
         */
        ram?: number;
        /**
         * The private network name or ID.
         */
        private_network?: string;
        /**
         * Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
         */
        api_url?: string;
        /**
         * A list of hard disks with nested "size" and "is_main" properties. It must be provided with vcore, cores_per_processor, and ram parameters.
         */
        hdds?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 5
         *
         * Defines the number of seconds to wait when using the wait_for methods
         */
        wait_interval?: number | string;
        /**
         * The hostname or ID of the server. Only used when state is 'present'.
         */
        hostname?: string;
        /**
         * Default: present
         *
         * Define a server's state to create, remove, start or stop it.
         */
        state?: "present" | "absent" | "running" | "stopped";
        /**
         * The instance size name or ID of the server. It is required only for 'present' state, and it is mutually exclusive with vcore, cores_per_processor, ram, and hdds parameters.
         */
        fixed_instance_size?: string;
        /**
         * The load balancer name or ID.
         */
        load_balancer?: string;
        /**
         * The description of the server.
         */
        description?: string;
        /**
         * Default: cloud
         *
         * The type of server to be built.
         */
        server_type?: "cloud" | "baremetal" | "k8s_node";
        /**
         * Default: yes
         *
         * When creating multiple servers at once, whether to differentiate hostnames by appending a count after them or substituting the count where there is a %02d or %03d in the hostname string.
         */
        auto_increment?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * User's public SSH key (contents, not path).
         */
        ssh_key?: string;
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * The monitoring policy name or ID.
         */
        monitoring_policy?: string;
        /**
         * Default: yes
         *
         * Wait for the server to be in state 'running' before returning. Also used for delete operation (set to 'false' if you don't want to wait for each individual server to be deleted before moving on with other tasks.)
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * The number of servers to create.
         */
        count?: number | string;
        /**
         * Default: US
         *
         * The datacenter location.
         */
        datacenter?: "US" | "ES" | "DE" | "GB";
        /**
         * The firewall policy name or ID.
         */
        firewall_policy?: string;
        /**
         * The number of cores per processor. It must be provided with vcore, ram, and hdds parameters.
         */
        cores_per_processor?: number | string;
        /**
         * The operating system name or ID for the server. It is required only for 'present' state.
         */
        appliance?: string;
        /**
         * Server identifier (ID or hostname). It is required for all states except 'running' and 'present'.
         */
        server?: string;
        [k: string]: unknown;
      };
      /**
       * Manages timeout mode of NetStream on HUAWEI CloudEngine switches.
       */
      ce_netstream_aging?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Netstream timeout type.
         */
        timeout_type?: "active" | "inactive" | "tcp-session" | "manual";
        /**
         * Specifies the packet type of netstream timeout active interval.
         */
        type?: "ip" | "vxlan";
        /**
         * Default: 30
         *
         * Netstream timeout interval. If is active type the interval is 1-60. If is inactive ,the interval is 5-600.
         */
        timeout_interval?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Specifies the slot number of netstream manual timeout.
         */
        manual_slot?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * creates, updates, deletes beanstalk applications if app_name is provided
       */
      aws_elasticbeanstalk_app?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates a managed instance group using the information that you specify in the request. After the group is created, it schedules an action to create instances in the group using the specified instance template. This operation is marked as DONE when the group is created even if the instances in the group have not yet been created. You must separately verify the status of the individual instances.
       * A managed instance group can have up to 1000 VM instances per group.
       */
      gcp_compute_instance_group_manager?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The instance template that is specified for this managed instance group. The group uses this template to create all new instances in the managed instance group.
         */
        instance_template: {
          [k: string]: unknown;
        };
        /**
         * The name of the managed instance group. The name must be 1-63 characters long, and comply with RFC1035.
         */
        name: string;
        /**
         * The zone the managed instance group resides.
         */
        zone: string;
        /**
         * Named ports configured for the Instance Groups complementary to this Instance Group Manager.
         */
        named_ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * The target number of running instances for this managed instance group. Deleting or abandoning instances reduces this number. Resizing the group changes this number.
         */
        target_size?: number | string;
        project?: string;
        /**
         * The base instance name to use for instances in this group. The value must be 1-58 characters long. Instances are named by appending a hyphen and a random four-character string to the base instance name.
         * The base instance name must comply with RFC1035.
         */
        base_instance_name: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        /**
         * TargetPool resources to which instances in the instanceGroup field are added. The target pools automatically apply to all of the instances in the managed instance group.
         */
        target_pools?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM nodes.
       */
      bigip_node?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create/edit/delete scripts and execute the scripts on the FortiManager using jsonrpc API
       */
      fmgr_script?: {
        /**
         * The username to log into the FortiManager
         */
        username?: string;
        /**
         * The script content that will be executed.
         */
        script_content?: string;
        /**
         * The administrative domain (admon) the configuration belongs to
         */
        adom?: string;
        /**
         * (datasource) The devices that the script will run on, can have both device member and device group member.
         */
        script_scope?: string;
        /**
         * Default: present
         *
         * The desired state of the specified object.
         * present - will create a script.
         * execute - execute the scipt.
         * delete - delete the script.
         */
        state?: string;
        /**
         * The name of the script.
         */
        script_name?: string;
        /**
         * The FortiManager's Address.
         */
        host?: string;
        /**
         * The target of the script to be run.
         */
        script_target?: string;
        /**
         * The description of the script.
         */
        script_description?: string;
        /**
         * (datasource) Policy package object to run the script against
         */
        script_package?: string;
        /**
         * The password associated with the username account.
         */
        password?: string;
        /**
         * The virtual domain (vdom) the configuration belongs to
         */
        vdom?: string;
        /**
         * The type of script (CLI or TCL).
         */
        script_type?: string;
        [k: string]: unknown;
      };
      /**
       * Module manages AWS Config rules
       */
      aws_config_rule?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * The manageiq_provider module supports adding, updating, and deleting provider in ManageIQ.
       */
      manageiq_provider?: {
        [k: string]: unknown;
      };
      /**
       * This module manages volumes on Scaleway account U(https://developer.scaleway.com)
       */
      scaleway_volume?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Gather facts about AWS regions.
       */
      aws_region_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Can create or delete AWS Autoscaling Groups
       * Works with the ec2_lc module to manage Launch Configurations
       */
      ec2_asg?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Change the admin password of PAN-OS via SSH using a SSH key for authentication.
       * Useful for AWS instances where the first login should be done via SSH.
       */
      panos_admpwd?: {
        /**
         * Default: admin
         *
         * username for initial authentication
         */
        username?: string;
        /**
         * password to configure for admin on the PAN-OS device
         */
        newpassword: string;
        /**
         * filename of the SSH Key to use for authentication
         */
        key_filename: string;
        /**
         * IP address (or hostname) of PAN-OS device
         */
        ip_address: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure PoolGroup object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_poolgroup?: {
        /**
         * Whether an implicit set of priority labels is generated.
         * Field introduced in 17.1.9,17.2.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        implicit_priority_labels?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable an action - close connection, http redirect, or local http response - when a pool group failure happens.
         * By default, a connection will be closed, in case the pool group experiences a failure.
         */
        fail_action?: {
          [k: string]: unknown;
        };
        /**
         * Uuid of the pool group.
         */
        uuid?: string;
        /**
         * It is a reference to an object of type cloud.
         */
        cloud_ref?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Name of the user who created the object.
         */
        created_by?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * The minimum number of servers to distribute traffic to.
         * Allowed values are 1-65535.
         * Special values are 0 - 'disable'.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         */
        min_servers?: number | string;
        api_version?: string;
        username?: string;
        /**
         * Description of pool group.
         */
        description?: string;
        controller?: string;
        /**
         * List of pool group members object of type poolgroupmember.
         */
        members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * Uuid of the priority labels.
         * If not provided, pool group member priority label will be interpreted as a number with a larger number considered higher priority.
         * It is a reference to an object of type prioritylabels.
         */
        priority_labels_ref?: string;
        /**
         * The name of the pool group.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * When setup autoscale manager will automatically promote new pools into production when deployment goals are met.
         * It is a reference to an object of type poolgroupdeploymentpolicy.
         */
        deployment_policy_ref?: string;
        /**
         * Checksum of cloud configuration for poolgroup.
         * Internally set by cloud connector.
         */
        cloud_config_cksum?: string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Creates, deletes, and updates DNS records sets and records within an existing Azure DNS Zone.
       */
      azure_rm_dnsrecordset?: {
        /**
         * name of resource group
         */
        resource_group: string;
        cloud_environment?: string;
        secret?: string;
        /**
         * the type of record set to create or delete
         */
        record_type: "A" | "AAAA" | "CNAME" | "MX" | "NS" | "SRV" | "TXT" | "PTR";
        /**
         * Default: 3600
         *
         * time to live of the record set in seconds
         */
        time_to_live?: number | string;
        /**
         * name of the existing DNS zone in which to manage the record set
         */
        zone_name: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        /**
         * Default: present
         *
         * Assert the state of the record set. Use C(present) to create or update and C(absent) to delete.
         */
        state?: "absent" | "present";
        cert_validation_mode?: "validate" | "ignore";
        subscription_id?: string;
        /**
         * Default: purge
         *
         * whether existing record values not sent to the module should be purged
         */
        record_mode?: "append" | "purge";
        profile?: string;
        tags?: {
          [k: string]: unknown;
        };
        /**
         * relative name of the record set
         */
        relative_name: string;
        /**
         * list of records to be created depending on the type of record (set)
         */
        records?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        tenant?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP UrlMap
       */
      gcp_compute_url_map_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Deploy given repository URL / revision to dest. If dest exists, update to the specified revision, otherwise perform a checkout.
       */
      subversion?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * - Create a policy nat rule. Keep in mind that we can either end up configuring source NAT, destination NAT, or both. Instead of splitting it into two we will make a fair attempt to determine which one the user wants.
       *
       */
      panos_nat_rule?: {
        /**
         * Default: no
         *
         * bidirectional flag
         */
        snat_bidirectional?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * snat interface address
         */
        snat_interface_address?: string;
        /**
         * The action to be taken.  Supported values are I(add)/I(update)/I(find)/I(delete).
         */
        operation: "add" | "update" | "delete" | "find";
        to_interface?: string;
        /**
         * dnat translated address
         */
        dnat_address?: string;
        /**
         * Default: any
         *
         * service
         */
        service?: string;
        /**
         * Source NAT translated address. Used with Static-IP translation.
         */
        snat_static_address?: string;
        /**
         * destination zone
         */
        destination_zone?: string;
        /**
         * API key that can be used instead of I(username)/I(password) credentials.
         */
        api_key?: string;
        /**
         * snat interface
         */
        snat_interface?: string;
        /**
         * Default: admin
         *
         * Username credentials to use for auth unless I(api_key) is set.
         */
        username?: string;
        /**
         * Default: ['any']
         *
         * list of destination addresses
         */
        destination_ip?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        devicegroup?: string;
        description?: string;
        /**
         * dnat translated port
         */
        dnat_port?: string;
        /**
         * name of the SNAT rule
         */
        rule_name: string;
        /**
         * Default: translated-address
         *
         * type of source translation. Supported values are I(translated-address)/I(translated-address).
         */
        snat_address_type?: "interface-address" | "translated-address";
        /**
         * Password credentials to use for auth unless I(api_key) is set.
         */
        password: string;
        /**
         * IP address (or hostname) of PAN-OS device being configured.
         */
        ip_address: string;
        /**
         * type of source translation
         */
        snat_type?: "static-ip" | "dynamic-ip-and-port" | "dynamic-ip";
        /**
         * list of source zones
         */
        source_zone?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: ['any']
         *
         * list of source addresses
         */
        source_ip?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Source NAT translated address. Used with Dynamic-IP and Dynamic-IP-and-Port.
         */
        snat_dynamic_address?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        tag_name?: string;
        /**
         * Default: yes
         *
         * Commit configuration if changed.
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module provides an implementation for working with the active configuration running on Juniper JUNOS devices.  It provides a set of arguments for loading configuration, performing rollback operations and zeroing the active configuration on the device.
       */
      junos_config?: {
        /**
         * Default: configured by junos_config
         *
         * The C(comment) argument specifies a text string to be used when committing the configuration.  If the C(confirm) argument is set to False, this argument is silently ignored.
         */
        comment?: string;
        /**
         * The I(src) argument provides a path to the configuration file to load into the remote system. The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) argument.
         */
        src?: string;
        ssh_keyfile?: string;
        /**
         * The C(rollback) argument instructs the module to rollback the current configuration to the identifier specified in the argument.  If the specified rollback identifier does not exist on the remote device, the module will fail.  To rollback to the most recent commit, set the C(rollback) argument to 0.
         */
        rollback?: number | string;
        /**
         * The I(src_format) argument specifies the format of the configuration found int I(src).  If the I(src_format) argument is not provided, the module will attempt to determine the format of the configuration file specified in I(src).
         */
        src_format?: "xml" | "set" | "text" | "json";
        /**
         * The C(confirm) argument will configure a time out value in minutes for the commit to be confirmed before it is automatically rolled back.  If the C(confirm) argument is set to False, this argument is silently ignored.  If the value for this argument is set to 0, the commit is confirmed immediately.
         */
        confirm?: number | string;
        /**
         * This argument takes a list of C(set) or C(delete) configuration lines to push into the remote device.  Each line must start with either C(set) or C(delete).  This argument is mutually exclusive with the I(src) argument.
         */
        lines?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: merge
         *
         * This argument will decide how to load the configuration data particulary when the candidate configuration and loaded configuration contain conflicting statements. Following are accepted values. C(merge) combines the data in the loaded configuration with the candidate configuration. If statements in the loaded configuration conflict with statements in the candidate configuration, the loaded statements replace the candidate ones. C(override) discards the entire candidate configuration and replaces it with the loaded configuration. C(replace) substitutes each hierarchy level in the loaded configuration for the corresponding level.
         */
        update?: "merge" | "override" | "replace" | "update";
        /**
         * Default: no
         *
         * The C(replace) argument will instruct the remote device to replace the current configuration hierarchy with the one specified in the corresponding hierarchy of the source configuration loaded from this module.
         * Note this argument should be considered deprecated.  To achieve the equivalent, set the I(update) argument to C(replace). This argument will be removed in a future release. The C(replace) and C(update) argument is mutually exclusive.
         */
        replace?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        /**
         * Default: no
         *
         * This argument will execute commit operation on remote device. It can be used to confirm a previous commit.
         */
        confirm_commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The C(zeroize) argument is used to completely sanitize the remote device configuration back to initial defaults.  This argument will effectively remove all current configuration statements on the remote device.
         */
        zeroize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        host?: string;
        password?: string;
        /**
         * Default: no
         *
         * This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory or role root directory, if playbook is part of an ansible role. If the directory does not exist, it is created.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Manage Fabric Node Members on Cisco ACI fabrics.
       */
      aci_fabric_node?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Sends notifications to U(http://your.mattermost.url) via the Incoming WebHook integration.
       */
      mattermost?: {
        /**
         * Default: Ansible
         *
         * This is the sender of the message (Username Override need to be enabled by mattermost admin, see mattermost doc.
         */
        username?: string;
        /**
         * Mattermost url (i.e. http://mattermost.yourcompany.com).
         */
        url: string;
        /**
         * Text to send. Note that the module does not handle escaping characters.
         */
        text: string;
        /**
         * Default: https://www.ansible.com/favicon.ico
         *
         * Url for the message sender's icon.
         */
        icon_url?: string;
        /**
         * Mattermost webhook api key. Log into your mattermost site, go to Menu -> Integration -> Incoming Webhook -> Add Incoming Webhook. This will give you full URL. api_key is the last part. http://mattermost.example.com/hooks/C(API_KEY)
         */
        api_key: string;
        /**
         * Default: True
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Channel to send the message to. If absent, the message goes to the channel selected for the I(api_key).
         */
        channel?: string;
        [k: string]: unknown;
      };
      /**
       * Manages AAA server host-specific configuration.
       */
      nxos_aaa_server_host?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        provider?: {
          [k: string]: unknown;
        };
        ssh_keyfile?: string;
        /**
         * Shared secret for the specified host or keyword 'default'.
         */
        key?: string;
        /**
         * The server type is either radius or tacacs.
         */
        server_type: "radius" | "tacacs";
        /**
         * The state of encryption applied to the entered key. O for clear text, 7 for encrypted. Type-6 encryption is not supported.
         */
        encrypt_type?: "0" | "7";
        auth_pass?: string;
        /**
         * Alternate UDP port for RADIUS authentication or keyword 'default'.
         */
        auth_port?: string;
        /**
         * Timeout period for specified host, in seconds or keyword 'default. Range is 1-60.
         */
        host_timeout?: string;
        /**
         * Alternate TCP port TACACS Server or keyword 'default'.
         */
        tacacs_port?: string;
        host?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        timeout?: number | string;
        /**
         * Address or name of the radius or tacacs host.
         */
        address: string;
        /**
         * Alternate UDP port for RADIUS accounting or keyword 'default'.
         */
        acct_port?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Manages top level filter objects on Cisco ACI fabrics.
       * This modules does not manage filter entries, see M(aci_filter_entry) for this functionality.
       */
      aci_filter?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * This module allows you to create and delete devices in CA Spectrum U(https://www.ca.com/us/products/ca-spectrum.html).
       * Tested on CA Spectrum 9.4.2, 10.1.1 and 10.2.1
       */
      spectrum_device?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Allows users to add or remove flatpak remotes.
       * The flatpak remotes concept is comparable to what is called repositories in other packaging formats.
       * Currently, remote addition is only supported via I(flatpakrepo) file URLs.
       * Existing remotes will not be updated.
       * See the M(flatpak) module for managing flatpaks.
       */
      flatpak_remote?: {
        /**
         * Default: flatpak
         *
         * The path to the C(flatpak) executable to use.
         * By default, this module looks for the C(flatpak) executable on the path.
         */
        executable?: string;
        /**
         * Default: present
         *
         * Indicates the desired package state.
         */
        state?: "absent" | "present";
        /**
         * Default: system
         *
         * The installation method to use.
         * Defines if the I(flatpak) is supposed to be installed globally for the whole C(system) or only for the current C(user).
         */
        method?: "system" | "user";
        /**
         * The URL to the I(flatpakrepo) file representing the repository remote to add.
         * When used with I(state=present), the flatpak remote specified under the I(flatpakrepo_url) is added using the specified installation C(method).
         * When used with I(state=absent), this is not required.
         * Required when I(state=present).
         */
        flatpakrepo_url?: string;
        /**
         * The desired name for the flatpak remote to be registered under on the managed host.
         * When used with I(state=present), the remote will be added to the managed host under the specified I(name).
         * When used with I(state=absent) the remote with that name will be removed.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manage the atomic host platform.
       * Rebooting of Atomic host platform should be done outside this module.
       */
      atomic_host?: {
        [k: string]: unknown;
      };
      /**
       * Similar to the M(facter) module, this runs the I(Ohai) discovery program (U(https://docs.chef.io/ohai.html)) on the remote host and returns JSON inventory data. I(Ohai) data is a bit more verbose and nested than I(facter).
       */
      ohai?: {
        [k: string]: unknown;
      };
      /**
       * Create, update, or destroy Ansible Tower hosts. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_host?: {
        tower_host?: string;
        /**
         * The description to use for the host.
         */
        description?: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * If the host should be enabled.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Inventory the host should be made a member of.
         */
        inventory: string;
        tower_password?: string;
        tower_username?: string;
        /**
         * Variables to use for the host. Use C(@) for a file.
         */
        variables?: string;
        /**
         * The name to use for the host.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Perform software maintenance upgrades (SMUs) on Cisco NX-OS devices.
       */
      nxos_smu?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.
         */
        file_system?: string;
        host?: string;
        /**
         * Name of the remote package.
         */
        pkg: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Requests Ironic to set a node into inspect state in order to collect metadata regarding the node. This command may be out of band or in-band depending on the ironic driver configuration. This is only possible on nodes in 'manageable' and 'available' state.
       */
      os_ironic_inspect?: {
        /**
         * unique name identifier to identify the host in Ironic.
         */
        name?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API. Use with "auth" and "auth_type" settings set to None.
         */
        ironic_url?: string;
        /**
         * unique mac address that is used to attempt to identify the host.
         */
        mac?: string;
        /**
         * Default: 1200
         *
         * A timeout in seconds to tell the role to wait for the node to complete introspection if wait is set to True.
         */
        timeout?: string;
        /**
         * globally unique identifier (UUID) to identify the host.
         */
        uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Module to manage data centers in oVirt/RHV
       */
      ovirt_datacenter?: {
        /**
         * Compatibility version of the data center.
         */
        compatibility_version?: string;
        /**
         * Comment of the data center.
         */
        comment?: string;
        /**
         * This parameter can be used only when removing a data center. If I(True) data center will be forcibly removed, even though it contains some clusters. Default value is I(False), which means that only empty data center can be removed.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the data center to manage.
         */
        name: string;
        /**
         * MAC pool to be used by this datacenter.
         * IMPORTANT: This option is deprecated in oVirt/RHV 4.1. You should use C(mac_pool) in C(ovirt_clusters) module, as MAC pools are set per cluster since 4.1.
         */
        mac_pool?: string;
        /**
         * I(True) if the data center should be local, I(False) if should be shared.
         * Default value is set by engine.
         */
        local?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        poll_interval?: number | string;
        fetch_nested?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nested_attributes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Should the data center be present or absent.
         */
        state?: "present" | "absent";
        auth: {
          [k: string]: unknown;
        };
        timeout?: number | string;
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Quota mode of the data center. One of I(disabled), I(audit) or I(enabled)
         */
        quota_mode?: "disabled" | "audit" | "enabled";
        /**
         * Description of the data center.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manage tenants on Cisco ACI fabrics.
       */
      aci_tenant?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * OS6 configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with OS6 configuration sections in a deterministic way.
       */
      dellos6_config?: {
        [k: string]: unknown;
      };
      /**
       * Manage an AWS Glue job. See U(https://aws.amazon.com/glue/) for details.
       */
      aws_glue_job?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or Remove security groups from an OpenStack cloud.
       */
      os_security_group?: {
        /**
         * Unique name or ID of the project.
         */
        project?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Long description of the purpose of the security group
         */
        description?: string;
        /**
         * Name that has to be given to the security group. This module requires that security group names be unique.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Cisco IOS XR configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with IOS XR configuration sections in a deterministic way.
       */
      iosxr_config?: {
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about virtual machine's snapshots.
       */
      vmware_guest_snapshot_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can be used to wait for VMware tools to become available on the given VM and return facts.
       */
      vmware_guest_tools_wait?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Send a message to logentries
       */
      logentries_msg?: {
        /**
         * The message body.
         */
        msg: string;
        /**
         * Log token.
         */
        token: string;
        /**
         * Default: data.logentries.com
         *
         * API endpoint
         */
        api?: string;
        /**
         * Default: 80
         *
         * API endpoint port
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Control running and enabled state for system-wide or user services.
       * BSD and Linux systems are supported.
       */
      nosh?: {
        /**
         * C(started)/C(stopped) are idempotent actions that will not run commands unless necessary. C(restarted) will always bounce the service. C(reloaded) will send a SIGHUP or start the service. C(reset) will start or stop the service according to whether it is enabled or not.
         */
        state?: "started" | "stopped" | "reset" | "restarted" | "reloaded";
        /**
         * Enable or disable the service according to local preferences in *.preset files. Mutually exclusive with I(enabled). Only has an effect if set to true. Will take effect prior to I(state=reset).
         */
        preset?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable or disable the service, independently of C(*.preset) file preference or running state. Mutually exclusive with I(preset). Will take effect prior to I(state=reset).
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Run system-control talking to the calling user's service manager, rather than the system-wide service manager.
         */
        user?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the service to manage.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Add, remove cluster node on Element Software Cluster.
       */
      na_elementsw_node?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * An HttpsHealthCheck resource. This resource defines a template for how individual VMs should be checked for health, via HTTPS.
       */
      gcp_compute_https_health_check?: {
        [k: string]: unknown;
      };
      /**
       * Apstra AOS Blueprint Virtual Network module let you manage your Virtual Network easily. You can create access, define and delete Virtual Network by name or by using a JSON / Yaml file. This module is idempotent and support the I(check) mode. It's using the AOS REST API.
       */
      aos_blueprint_virtnet?: {
        /**
         * Datastructure of the Virtual Network to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).
         */
        content?: string;
        /**
         * Blueprint Name or Id as defined in AOS.
         */
        blueprint: string;
        /**
         * Default: present
         *
         * Indicate what is the expected state of the Virtual Network (present or not).
         */
        state?: "present" | "absent";
        /**
         * An existing AOS session as obtained by M(aos_login) module.
         */
        session: {
          [k: string]: unknown;
        };
        /**
         * Name of Virtual Network as part of the Blueprint.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manages SNMP traps configurations on HUAWEI CloudEngine switches.
       */
      ce_snmp_traps?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Source port number.
         */
        port_number?: string;
        /**
         * Interface number.
         */
        interface_number?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Interface type.
         */
        interface_type?:
          | "Ethernet"
          | "Eth-Trunk"
          | "Tunnel"
          | "NULL"
          | "LoopBack"
          | "Vlanif"
          | "100GE"
          | "40GE"
          | "MTunnel"
          | "10GE"
          | "GE"
          | "MEth"
          | "Vbdif"
          | "Nve";
        state?: "present" | "absent";
        host?: string;
        /**
         * Alarm feature name.
         */
        feature_name?:
          | "aaa"
          | "arp"
          | "bfd"
          | "bgp"
          | "cfg"
          | "configuration"
          | "dad"
          | "devm"
          | "dhcpsnp"
          | "dldp"
          | "driver"
          | "efm"
          | "erps"
          | "error-down"
          | "fcoe"
          | "fei"
          | "fei_comm"
          | "fm"
          | "ifnet"
          | "info"
          | "ipsg"
          | "ipv6"
          | "isis"
          | "l3vpn"
          | "lacp"
          | "lcs"
          | "ldm"
          | "ldp"
          | "ldt"
          | "lldp"
          | "mpls_lspm"
          | "msdp"
          | "mstp"
          | "nd"
          | "netconf"
          | "nqa"
          | "nvo3"
          | "openflow"
          | "ospf"
          | "ospfv3"
          | "pim"
          | "pim-std"
          | "qos"
          | "radius"
          | "rm"
          | "rmon"
          | "securitytrap"
          | "smlktrap"
          | "snmp"
          | "ssh"
          | "stackmng"
          | "sysclock"
          | "sysom"
          | "system"
          | "tcp"
          | "telnet"
          | "trill"
          | "trunk"
          | "tty"
          | "vbst"
          | "vfs"
          | "virtual-perception"
          | "vrrp"
          | "vstm"
          | "all";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        /**
         * Alarm trap name.
         */
        trap_name?: string;
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Manage gslb service entities in Netscaler.
       */
      netscaler_gslb_service?: {
        /**
         * Any comments that you might want to associate with the GSLB service.
         */
        comment?: string;
        /**
         * Canonical name of the GSLB service. Used in CNAME-based GSLB.
         * Minimum length = 1
         */
        cnameentry?: string;
        /**
         * Name of the server hosting the GSLB service.
         * Minimum length = 1
         */
        servername?: string;
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_protocol?: "http" | "https";
        /**
         * Name for the GSLB service. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the GSLB service is created.
         *
         * Minimum length = 1
         */
        servicename?: string;
        /**
         * Use cookie-based site persistence. Applicable only to C(HTTP) and C(SSL) GSLB services.
         */
        sitepersistence?: "ConnectionProxy" | "HTTPRedirect" | "NONE";
        /**
         * Bind monitors to this gslb service
         */
        monitor_bindings?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Integer specifying the maximum bandwidth allowed for the service. A GSLB service whose bandwidth reaches the maximum is not considered when a GSLB decision is made, until its bandwidth consumption drops below the maximum.
         */
        maxbandwidth?: number;
        /**
         * The public port associated with the GSLB service's public IP address. The port is mapped to the service's private port number. Applicable to the local GSLB service. Optional.
         */
        publicport?: number | string;
        /**
         * Port on which the load balancing entity represented by this GSLB service listens.
         * Minimum value = 1
         * Range 1 - 65535
         * * in CLI is represented as 65535 in NITRO API
         */
        port?: number | string;
        /**
         * Idle time, in seconds, after which a client connection is terminated. Applicable if connection proxy based site persistence is used.
         * Minimum value = 0
         * Maximum value = 31536000
         */
        clttimeout?: number;
        /**
         * Type of service to create.
         */
        servicetype?:
          | "HTTP"
          | "FTP"
          | "TCP"
          | "UDP"
          | "SSL"
          | "SSL_BRIDGE"
          | "SSL_TCP"
          | "NNTP"
          | "ANY"
          | "SIP_UDP"
          | "SIP_TCP"
          | "SIP_SSL"
          | "RADIUS"
          | "RDP"
          | "RTSP"
          | "MYSQL"
          | "MSSQL"
          | "ORACLE";
        /**
         * Monitoring threshold value for the GSLB service. If the sum of the weights of the monitors that are bound to this GSLB service and are in the UP state is not equal to or greater than this threshold value, the service is marked as DOWN.
         * Minimum value = C(0)
         * Maximum value = C(65535)
         */
        monthreshold?: number;
        /**
         * Maximum number of SSL VPN users that can be logged on concurrently to the VPN virtual server that is represented by this GSLB service. A GSLB service whose user count reaches the maximum is not considered when a GSLB decision is made, until the count drops below the maximum.
         * Minimum value = C(0)
         * Maximum value = C(65535)
         */
        maxaaausers?: number;
        /**
         * The maximum number of open connections that the service can support at any given time. A GSLB service whose connection count reaches the maximum is not considered when a GSLB decision is made, until the connection count drops below the maximum.
         * Minimum value = C(0)
         * Maximum value = C(4294967294)
         */
        maxclient?: number;
        /**
         * Name of the GSLB site to which the service belongs.
         * Minimum length = 1
         */
        sitename?: string;
        /**
         * The public IP address that a NAT device translates to the GSLB service's private IP address. Optional.
         */
        publicip?: string;
        state?: "present" | "absent";
        nitro_user: string;
        nitro_timeout?: number;
        /**
         * Enable logging appflow flow information.
         */
        appflowlog?: "enabled" | "disabled";
        /**
         * Unique hash identifier for the GSLB service, used by hash based load balancing methods.
         * Minimum value = C(1)
         */
        hashid?: number;
        /**
         * IP address for the GSLB service. Should represent a load balancing, content switching, or VPN virtual server on the NetScaler appliance, or the IP address of another load balancing device.
         */
        ipaddress?: string;
        /**
         * Flush all active transactions associated with the GSLB service when its state transitions from UP to DOWN. Do not enable this option for services that must complete their transactions. Applicable if connection proxy based site persistence is used.
         */
        downstateflush?: "enabled" | "disabled";
        /**
         * Name for the HTTP header that stores the client's IP address. Used with the Client IP option. If client IP header insertion is enabled on the service and a name is not specified for the header, the NetScaler appliance uses the name specified by the cipHeader parameter in the set ns param command or, in the GUI, the Client IP Header parameter in the Configure HTTP Parameters dialog box.
         * Minimum length = 1
         */
        cipheader?: string;
        /**
         * The site's prefix string. When the service is bound to a GSLB virtual server, a GSLB site domain is generated internally for each bound service-domain pair by concatenating the site prefix of the service and the name of the domain. If the special string NONE is specified, the site-prefix string is unset. When implementing HTTP redirect site persistence, the NetScaler appliance redirects GSLB requests to GSLB services by using their site domains.
         */
        siteprefix?: string;
        nsip: string;
        /**
         * In the request that is forwarded to the GSLB service, insert a header that stores the client's IP address. Client IP header insertion is used in connection-proxy based site persistence.
         */
        cip?: "enabled" | "disabled";
        /**
         * Monitor the health of the GSLB service.
         */
        healthmonitor?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_pass: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage Perl library dependencies.
       */
      cpanm?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage VLAN encap blocks that are assigned to VLAN pools on Cisco ACI fabrics.
       */
      aci_vlan_pool_encap_block?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Allows for management of SNMP settings for Meraki.
       */
      meraki_snmp?: {
        [k: string]: unknown;
      };
      /**
       * Create or Delete routers from OpenStack. Although Neutron allows routers to share the same name, this module enforces name uniqueness to be more user friendly.
       */
      os_router?: {
        /**
         * Enable Source NAT (SNAT) attribute.
         */
        enable_snat?: string;
        /**
         * Unique name or ID of the external gateway network.
         * required I(interfaces) or I(enable_snat) are provided.
         */
        network?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * List of subnets to attach to the router internal interface. Default gateway associated with the subnet will be automatically attached with the router's internal interface. In order to provide an ip address different from the default gateway,parameters are passed as dictionary with keys as network name or ID(net), subnet name or ID (subnet) and the IP of port (portip) from the network. User defined portip is often required when a multiple router need to be connected to a single subnet for which the default gateway has been already used.
         */
        interfaces?: string;
        /**
         * Default: yes
         *
         * Desired admin state of the created or existing router.
         */
        admin_state_up?: string;
        /**
         * Unique name or ID of the project.
         */
        project?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: string;
        /**
         * The IP address parameters for the external gateway network. Each is a dictionary with the subnet name or ID (subnet) and the IP address to assign on the subnet (ip). If no IP is specified, one is automatically assigned from that subnet.
         */
        external_fixed_ips?: string;
        /**
         * Name to be give to the router
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * The M(bearychat) module sends notifications to U(https://bearychat.com) via the Incoming Robot integration.
       */
      bearychat?: {
        /**
         * BearyChat WebHook URL. This authenticates you to the bearychat service. It looks like C(https://hook.bearychat.com/=ae2CF/incoming/e61bd5c57b164e04b11ac02e66f47f60).
         */
        url: string;
        /**
         * Message to send.
         */
        text?: string;
        /**
         * Default: yes
         *
         * If C(yes), text will be parsed as markdown.
         */
        markdown?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Define a list of attachments. For more information, see https://github.com/bearyinnovative/bearychat-tutorial/blob/master/robots/incoming.md#attachments
         */
        attachments?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Channel to send the message to. If absent, the message goes to the default channel selected by the I(url).
         */
        channel?: string;
        [k: string]: unknown;
      };
      /**
       * This module de-registers or registers an AWS EC2 instance from the ELBs that it belongs to.
       * Returns fact "ec2_elbs" which is a list of elbs attached to the instance if state=absent is passed as an argument.
       * Will be marked changed when called only if there are ELBs found to operate on.
       */
      elb_instance?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Unified utility to interact with redis instances.
       */
      redis?: {
        /**
         * Default: 6379
         *
         * The port to connect to
         */
        login_port?: number | string;
        /**
         * The password used to authenticate with (usually not used)
         */
        login_password?: string;
        /**
         * A redis config key.
         */
        name?: string;
        /**
         * Default: all
         *
         * Type of flush (all the dbs in a redis instance or a specific one) [flush command]
         */
        flush_mode?: "all" | "db";
        /**
         * The host of the master instance [slave command]
         */
        master_host?: string;
        /**
         * Default: localhost
         *
         * The host running the database
         */
        login_host?: string;
        /**
         * The port of the master instance [slave command]
         */
        master_port?: number | string;
        /**
         * The database to flush (used in db mode) [flush command]
         */
        db?: number | string;
        /**
         * A redis config value.
         */
        value?: string;
        /**
         * The selected redis command
         * C(config) (new in 1.6), ensures a configuration setting on an instance.
         * C(flush) flushes all the instance or a specified db.
         * C(slave) sets a redis instance in slave or master mode.
         */
        command?: "config" | "flush" | "slave";
        /**
         * Default: slave
         *
         * the mode of the redis instance [slave command]
         */
        slave_mode?: "master" | "slave";
        [k: string]: unknown;
      };
      /**
       * This module allows you to modify the running configuration of a switch. It provides a way to execute a single CNOS command on a network device by evaluating the current running configuration and executing the command only if the specific settings have not been already configured. The CNOS command is passed as an argument of the method. This module functions the same as the cnos_command module. The only exception is that following inventory variable can be specified ["condition = <flag string>"] When this inventory variable is specified as the variable of a task, the command is executed for the network element that matches the flag string. Usually, commands are executed across a group of network devices. When there is a requirement to skip the execution of the command on one or more devices, it is recommended to use this module. This module uses SSH to manage network device configuration.
       */
      cnos_conditional_command?: {
        username?: string;
        outputfile: string;
        /**
         * This specifies the CLI command as an attribute to this method. The command is passed using double quotes. The variables can be placed directly on to the CLI commands or can be invoked from the vars directory.
         */
        clicommand: string;
        /**
         * If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device.
         */
        flag: string;
        host?: string;
        deviceType: string;
        password?: string;
        enablePassword?: string;
        /**
         * If you specify condition=false in the inventory file against any device, the command execution is skipped for that device.
         */
        condition: string;
        [k: string]: unknown;
      };
      /**
       * Manage AWS IAM users
       */
      iam_user?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP Route
       */
      gcp_compute_route_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Manages information center trap configurations on HUAWEI CloudEngine switches.
       */
      ce_info_center_trap?: {
        /**
         * Timestamp format of alarm information.
         */
        trap_time_stamp?:
          | "date_boot"
          | "date_second"
          | "date_tenthsecond"
          | "date_millisecond"
          | "shortdate_second"
          | "shortdate_tenthsecond"
          | "shortdate_millisecond"
          | "formatdate_second"
          | "formatdate_tenthsecond"
          | "formatdate_millisecond";
        username?: string;
        /**
         * Size of a trap buffer. The value is an integer ranging from 0 to 1024. The default value is 256.
         */
        trap_buff_size?: string;
        /**
         * Module name of the rule. The value is a string of 1 to 31 case-insensitive characters. The default value is default. Please use lower-case letter, such as [aaa, acl, arp, bfd].
         */
        module_name?: string;
        /**
         * Default: no_use
         *
         * Whether a trap buffer is enabled to output information.
         */
        trap_buff_enable?: "no_use" | "true" | "false";
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Number of a channel. The value is an integer ranging from 0 to 9. The default value is 0.
         */
        channel_id?: string;
        host?: string;
        ssh_keyfile?: string;
        /**
         * Trap level permitted to output.
         */
        trap_level?:
          | "emergencies"
          | "alert"
          | "critical"
          | "error"
          | "warning"
          | "notification"
          | "informational"
          | "debugging";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no_use
         *
         * Whether a device is enabled to output alarms.
         */
        trap_enable?: "no_use" | "true" | "false";
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV templates relate to a storage domain.
       */
      ovirt_storage_template_facts?: {
        /**
         * Flag which indicates whether to get unregistered templates which contain one or more disks which reside on a storage domain or diskless templates.
         */
        unregistered?: string;
        /**
         * The storage domain name where the templates should be listed.
         */
        storage_domain?: string;
        /**
         * Sets the maximum number of templates to return. If not specified all the templates are returned.
         */
        max?: string;
        [k: string]: unknown;
      };
      /**
       * Assists in managing SNMP communities on a BIG-IP. Different SNMP versions are supported by this module. Take note of the different parameters offered by this module, as different parameters work for different versions of SNMP. Typically this becomes an interest if you are mixing versions C(v2c) and C(3).
       */
      bigip_snmp_community?: {
        /**
         * Specifies the encryption protocol.
         * When C(aes), specifies that the system encrypts the user information using AES (Advanced Encryption Standard).
         * When C(des), specifies that the system encrypts the user information using DES (Data Encryption Standard).
         * When C(none), specifies that the system does not encrypt the user information.
         * When creating a new SNMP C(v3) community, if this parameter is not specified, the default of C(aes) will be used.
         */
        snmp_privacy_protocol?: string;
        /**
         * Default: always
         *
         * C(always) will allow to update passwords if the user chooses to do so. C(on_create) will only set the password for newly created resources.
         */
        update_password?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Name that identifies the SNMP community.
         * When C(version) is C(v1) or C(v2c), this parameter is required.
         * The name C(public) is a reserved name on the BIG-IP. This module handles that name differently than others. Functionally, you should not see a difference however.
         */
        name?: string;
        /**
         * Specifies the password for the user.
         * When creating a new SNMP C(v3) community, this parameter is required.
         * This value must be at least 8 characters long.
         */
        snmp_auth_password?: string;
        /**
         * Specifies the name of the user for whom you want to grant access to the SNMP v3 MIB.
         * This parameter is only relevant when C(version) is C(v3). If C(version) is something else, this parameter is ignored.
         * When creating a new SNMP C(v3) community, this parameter is required.
         * This parameter cannot be changed once it has been set.
         */
        snmp_username?: string;
        /**
         * Specifies the object identifier (OID) for the record.
         * When C(version) is C(v3), this parameter is required.
         * When C(version) is either C(v1) or C(v2c), if this value is specified, then C(source) must not be set to C(all).
         */
        oid?: string;
        /**
         * Specifies the authentication method for the user.
         * When C(md5), specifies that the system uses the MD5 algorithm to authenticate the user.
         * When C(sha), specifies that the secure hash algorithm (SHA) to authenticate the user.
         * When C(none), specifies that user does not require authentication.
         * When creating a new SNMP C(v3) community, if this parameter is not specified, the default of C(sha) will be used.
         */
        snmp_auth_protocol?: string;
        /**
         * Specifies the user's access level to the MIB.
         * When creating a new community, if this parameter is not specified, the default is C(ro).
         * When C(ro), specifies that the user can view the MIB, but cannot modify the MIB.
         * When C(rw), specifies that the user can view and modify the MIB.
         */
        access?: string;
        /**
         * Specifies the source address for access to the MIB.
         * This parameter can accept a value of C(all).
         * If this parameter is not specified, the value C(all) is used.
         * This parameter is only relevant when C(version) is C(v1), or C(v2c). If C(version) is something else, this parameter is ignored.
         * If C(source) is set to C(all), then it is not possible to specify an C(oid). This will raise an error.
         * This parameter should be provided when C(state) is C(absent), so that the correct community is removed. To remove the C(public) SNMP community that comes with a BIG-IP, this parameter should be set to C(default).
         */
        source?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the address list and entries exists.
         * When C(absent), ensures the address list is removed.
         */
        state?: string;
        /**
         * Default: v2c
         *
         * Specifies to which Simple Network Management Protocol (SNMP) version the trap destination applies.
         */
        version?: string;
        /**
         * Specifies the community string (password) for access to the MIB.
         * This parameter is only relevant when C(version) is C(v1), or C(v2c). If C(version) is something else, this parameter is ignored.
         */
        community?: string;
        /**
         * Specifies whether the record applies to IPv4 or IPv6 addresses.
         * When creating a new community, if this value is not specified, the default of C(4) will be used.
         * This parameter is only relevant when C(version) is C(v1), or C(v2c). If C(version) is something else, this parameter is ignored.
         */
        ip_version?: string;
        /**
         * Specifies the port for the trap destination.
         * This parameter is only relevant when C(version) is C(v1), or C(v2c). If C(version) is something else, this parameter is ignored.
         */
        port?: string;
        /**
         * Specifies the password for the user.
         * When creating a new SNMP C(v3) community, this parameter is required.
         * This value must be at least 8 characters long.
         */
        snmp_privacy_password?: string;
        [k: string]: unknown;
      };
      /**
       * This modules configures the HP iLO interface using hponcfg.
       */
      hponcfg?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module creates, removes or resizes logical volumes.
       */
      lvol?: {
        /**
         * Comma separated list of physical volumes (e.g. /dev/sda,/dev/sdb).
         */
        pvs?: string;
        /**
         * Default: no
         *
         * Shrink or remove operations of volumes requires this switch. Ensures that that filesystems get never corrupted/destroyed by mistake.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The volume group this logical volume is part of.
         */
        vg: string;
        /**
         * The name of the logical volume.
         */
        lv?: string;
        /**
         * Default: no
         *
         * Resize the underlying filesystem together with the logical volume.
         */
        resizefs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Control if the logical volume exists. If C(present) and the volume does not already exist then the C(size) option is required.
         */
        state?: "absent" | "present";
        /**
         * The thin pool volume name. When you want to create a thin provisioned volume, specify a thin pool volume name.
         */
        thinpool?: string;
        /**
         * The name of the snapshot volume
         */
        snapshot?: string;
        /**
         * Default: yes
         *
         * Whether the volume is activate and visible to the host.
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Shrink if current size is higher than size requested.
         */
        shrink?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Free-form options to be passed to the lvcreate command.
         */
        opts?: string;
        /**
         * The size of the logical volume, according to lvcreate(8) --size, by default in megabytes or optionally with one of [bBsSkKmMgGtTpPeE] units; or according to lvcreate(8) --extents as a percentage of [VG|PVS|FREE]; Float values must begin with a digit. Resizing using percentage values was not supported prior to 2.1.
         */
        size?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of LLDP service on Arista EOS network devices.
       */
      eos_lldp?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of the LLDP configuration. If value is I(present) lldp will be enabled else if it is I(absent) it will be disabled.
         */
        state?: "present" | "absent" | "enabled" | "disabled";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "eapi";
        [k: string]: unknown;
      };
      /**
       * Assembles a configuration file from fragments. Often a particular program will take a single configuration file and does not support a C(conf.d) style structure where it is easy to build up the configuration from multiple sources. C(assemble) will take a directory of files that can be local or have already been transferred to the system, and concatenate them together to produce a destination file. Files are assembled in string sorting order. Puppet calls this idea I(fragments).
       */
      assemble?: {
        /**
         * Default: no
         *
         * A boolean that controls if files that start with a '.' will be included or not.
         */
        ignore_hidden?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * An already existing directory full of source files.
         */
        src: string;
        /**
         * Default: yes
         *
         * If False, it will search for src at originating/master machine, if True it will go to the remote/target machine for the src. Default is True.
         */
        remote_src?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A file to create using the concatenation of all of the source files.
         */
        dest: string;
        /**
         * A delimiter to separate the file contents.
         */
        delimiter?: string;
        /**
         * Assemble files only if C(regex) matches the filename. If not set, all files are assembled. All "\" (backslash) must be escaped as "\\" to comply yaml syntax. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).
         */
        regexp?: string;
        /**
         * The validation command to run before copying into place.  The path to the file to validate is passed in via '%s' which must be present as in the sshd example below. The command is passed securely so shell features like expansion and pipes won't work.
         */
        validate?: string;
        /**
         * Default: no
         *
         * Create a backup file (if C(yes)), including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Visibility into devices associated to a Meraki environment.
       */
      meraki_device?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * The C(win_dns_client) module configures the DNS client on Windows network adapters.
       */
      win_dns_client?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of the local usernames configured on network devices. It allows playbooks to manage either individual usernames or the aggregate of usernames in the current running config. It also supports purging usernames from the configuration that are not explicitly defined.
       */
      iosxr_user?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Installs, upgrade and removes packages using the underlying OS package manager.
       * For Windows targets, use the M(win_package) module instead.
       */
      package?: {
        [k: string]: unknown;
      };
      /**
       * Downloads files from HTTP, HTTPS, or FTP to the remote server. The remote server I(must) have direct access to the remote resource.
       * By default, if an environment variable C(<protocol>_proxy) is set on the target host, requests will be sent through that proxy. This behaviour can be overridden by setting a variable for this task (see `setting the environment <https://docs.ansible.com/playbooks_environment.html>`_), or by using the use_proxy option.
       * HTTP redirects can redirect from HTTP to HTTPS so you should be sure that your proxy environment for both protocols is correct.
       * From Ansible 2.4 when run with C(--check), it will do a HEAD request to validate the URL but will not download the entire file or verify it against hashes.
       * For Windows targets, use the M(win_get_url) module instead.
       */
      get_url?: {
        [k: string]: unknown;
      };
      /**
       * This module allows management of resources in an OpenShift cluster. The inventory host can be any host with network connectivity to the OpenShift cluster; the default port being 8443/TCP.
       * This module relies on a token to authenticate to OpenShift. This can either be a user or a service account.
       */
      oc?: {
        [k: string]: unknown;
      };
      /**
       * Sets and retrieves file ACL information.
       */
      acl?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * When the project does not exist in Gitlab, it will be created.
       * When the project does exists and state=absent, the project will be deleted.
       * When changes are made to the project, the project will be updated.
       */
      gitlab_project?: {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more of the SAN Managers from OneView
       */
      oneview_san_manager_facts?: {
        username?: string;
        image_streamer_hostname?: string;
        /**
         * Provider Display Name.
         */
        provider_display_name?: string;
        hostname?: string;
        /**
         * List of params to delimit, filter and sort the list of resources.
         * params allowed: - C(start): The first item to return, using 0-based indexing. - C(count): The number of resources to return. - C(query): A general query string to narrow the list of resources returned. - C(sort): The sort order of the returned data set.
         */
        params?: {
          [k: string]: unknown;
        };
        password?: string;
        config?: string;
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Lenovo CNOS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with CNOS configuration sections in a deterministic way.
       */
      cnos_config?: {
        [k: string]: unknown;
      };
      /**
       * Prepares certificates for ACME challenges such as C(tls-alpn-01).
       * The raw data is provided by the M(acme_certificate) module, and needs to be converted to a certificate to be used for challenge validation. This module provides a simple way to generate the required certificates.
       * The C(tls-alpn-01) implementation is based on L(the draft-05 version of the specification,https://tools.ietf.org/html/draft-ietf-acme-tls-alpn-05).
       */
      acme_challenge_cert_helper?: {
        /**
         * Content of the private key to use for this challenge certificate.
         * Mutually exclusive with C(private_key_src).
         */
        private_key_content?: string;
        /**
         * Path to a file containing the private key file to use for this challenge certificate.
         * Mutually exclusive with C(private_key_content).
         */
        private_key_src?: string;
        /**
         * The challenge type.
         */
        challenge: "tls-alpn-01";
        /**
         * The C(challenge_data) entry provided by M(acme_certificate) for the challenge.
         */
        challenge_data: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Write data points into InfluxDB.
       */
      influxdb_write?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, delete an image from virtual machine, blob uri, managed disk or snapshot.
       */
      azure_rm_image?: {
        profile?: string;
        /**
         * Name of the image.
         */
        name: string;
        /**
         * Name of resource group.
         */
        resource_group: string;
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        /**
         * List of data disk sources, including unmanaged blob uri, managed disk id or name, or snapshot id or name.
         */
        data_disk_sources?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * OS disk source from the same region, including a virtual machine id or name, OS disk blob uri, managed OS disk id or name, or OS snapshot id or name.
         */
        source?: string;
        secret?: string;
        /**
         * Default: present
         *
         * Assert the state of the image. Use C(present) to create or update a image and C(absent) to delete an image.
         */
        state?: "absent" | "present";
        /**
         * Location of the image. Derived from I(resource_group) if not specified.
         */
        location?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        /**
         * The OS type of image.
         */
        os_type?: "Windows" | "Linux";
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Create, remove, reconfigure, update firewall policies. This module has a dependency on 1and1 >= 1.0
       */
      oneandone_firewall_policy?: {
        /**
         * A list of rules that will be added to an existing firewall policy. It is syntax is the same as the one used for rules parameter. Used in combination with update state.
         */
        add_rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The identifier (id or name) of the firewall policy used with update state.
         */
        firewall_policy?: string;
        /**
         * Firewall policy description. maxLength=256
         */
        description?: string;
        /**
         * Default: 5
         *
         * Defines the number of seconds to wait when using the _wait_for methods
         */
        wait_interval?: number | string;
        /**
         * Authenticating API token provided by 1&1.
         */
        auth_token?: string;
        /**
         * A list of server IP ids to be unassigned from a firewall policy. Used in combination with update state.
         */
        remove_server_ips?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Firewall policy name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128
         */
        name?: string;
        /**
         * A list of rules that will be set for the firewall policy. Each rule must contain protocol parameter, in addition to three optional parameters (port_from, port_to, and source)
         */
        rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Define a firewall policy state to create, remove, or update.
         */
        state?: "present" | "absent" | "update";
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * A list of server identifiers (id or name) to be assigned to a firewall policy. Used in combination with update state.
         */
        add_server_ips?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: yes
         *
         * wait for the instance to be in state 'running' before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A list of rule ids that will be removed from an existing firewall policy. Used in combination with update state.
         */
        remove_rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
         */
        api_url?: string;
        [k: string]: unknown;
      };
      /**
       * Adds service hooks and removes service hooks that have an error status.
       */
      github_hooks?: {
        /**
         * The oauth key provided by GitHub. It can be found/generated on GitHub under "Edit Your Profile" >> "Developer settings" >> "Personal Access Tokens"
         */
        oauthkey: string;
        /**
         * When creating a new hook, this is the url that you want GitHub to post to. It is only required when creating a new hook.
         */
        hookurl?: string;
        /**
         * This is the API url for the repository you want to manage hooks for. It should be in the form of: https://api.github.com/repos/user:/repo:. Note this is different than the normal repo url.
         *
         */
        repo: string;
        /**
         * Github username.
         */
        user: string;
        /**
         * Default: json
         *
         * Content type to use for requests made to the webhook
         */
        content_type?: "json" | "form";
        /**
         * This tells the githooks module what you want it to do.
         */
        action: "create" | "cleanall" | "list" | "clean504";
        /**
         * Default: yes
         *
         * If C(no), SSL certificates for the target repo will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Creates, deletes, or modifies amazon Redshift cluster instances.
       */
      redshift?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows you to work with switch firmware images. It provides a way to download a firmware image to a network device from a remote server using FTP, SFTP, TFTP, or SCP. The first step is to create a directory from where the remote server can be reached. The next step is to provide the full file path of the image's location. Authentication details required by the remote server must be provided as well. By default, this method makes the newly downloaded firmware image the active image, which will be used by the switch during the next restart. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run.
       */
      cnos_image?: {
        /**
         * Specify the password for the server relating to the protocol used
         */
        serverpassword?: string;
        username?: string;
        outputfile: string;
        /**
         * This refers to the protocol used by the network device to interact with the remote server from where to download the firmware image. The choices are FTP, SFTP, TFTP, or SCP. Any other protocols will result in error. If this parameter is not specified there is no default value to be used.
         */
        protocol: string;
        /**
         * This specifies the IP Address of the remote server from where the software image will be downloaded.
         */
        serverip: string;
        /**
         * This specifies the full file path of the image located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.
         */
        imgpath: string;
        host?: string;
        deviceType: string;
        /**
         * Specify the username for the server relating to the protocol used
         */
        serverusername?: string;
        /**
         * This specifies the firmware image type to be downloaded
         */
        imgtype: string;
        password?: string;
        enablePassword?: string;
        [k: string]: unknown;
      };
      /**
       * Bind Domain to VLAN Pools on Cisco ACI fabrics.
       */
      aci_domain_to_vlan_pool?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Using VMware vCenter, move a virtual machine using vMotion to a different host, and/or its vmdks to another datastore using storage vMotion.
       */
      vmware_vmotion?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts about servers available.
       */
      vultr_server_facts?: {
        api_retries?: number | string;
        api_timeout?: number | string;
        api_endpoint?: string;
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * manages Zabbix host macros, it can create, update or delete them.
       */
      zabbix_hostmacro?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Gather facts for GCP TargetHttpProxy
       */
      gcp_compute_target_http_proxy_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Module to manage VM pools in oVirt/RHV.
       */
      ovirt_vmpool?: {
        /**
         * Comment of the Virtual Machine pool.
         */
        comment?: string;
        timeout?: number | string;
        /**
         * Name of the VM pool to manage.
         */
        name: string;
        /**
         * Description of the VM pool.
         */
        description?: string;
        poll_interval?: number | string;
        /**
         * Default: present
         *
         * Should the VM pool be present/absent.
         * Note that when C(state) is I(absent) all VMs in VM pool are stopped and removed.
         */
        state?: "present" | "absent";
        nested_attributes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Maximum number of VMs a single user can attach to from this pool.
         * Default value is set by engine.
         */
        vm_per_user?: number | string;
        /**
         * Name of the cluster, where VM pool should be created.
         */
        cluster?: string;
        fetch_nested?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Number of pre-started VMs defines the number of VMs in run state, that are waiting to be attached to Users.
         * Default value is set by engine.
         */
        prestarted?: number | string;
        auth: {
          [k: string]: unknown;
        };
        /**
         * Name of the template, which will be used to create VM pool.
         */
        template?: string;
        /**
         * Number of VMs in the pool.
         * Default value is set by engine.
         */
        vm_count?: number | string;
        /**
         * Type of the VM pool. Either manual or automatic.
         * C(manual) - The administrator is responsible for explicitly returning the virtual machine to the pool. The virtual machine reverts to the original base image after the administrator returns it to the pool.
         * C(Automatic) - When the virtual machine is shut down, it automatically reverts to its base image and is returned to the virtual machine pool.
         * Default value is set by engine.
         */
        type?: "manual" | "automatic";
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages log destinations on a BIG-IP.
       */
      bigip_log_destination?: {
        /**
         * Specifies the name of the log destination.
         */
        name?: string;
        /**
         * This parameter is only available when C(type) is C(remote-syslog).
         */
        syslog_settings?: string;
        /**
         * This parameter is only available when C(type) is C(remote-high-speed-log).
         */
        pool_settings?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the resource exists.
         * When C(absent), ensures the resource is removed.
         */
        state?: string;
        /**
         * Specifies the type of log destination.
         * Once created, this parameter cannot be changed.
         */
        type?: string;
        /**
         * The description of the log destination.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Allows the addition, modification and deletion of ACL keys and associated rules in a consul cluster via the agent. For more details on using and configuring ACLs, see https://www.consul.io/docs/guides/acl.html.
       */
      consul_acl?: {
        /**
         * the name that should be associated with the acl key, this is opaque to Consul
         */
        name?: string;
        /**
         * a list of the rules that should be associated with a given token
         */
        rules?: string;
        /**
         * the token key indentifying an ACL rule set. If generated by consul this will be a UUID
         */
        token?: string;
        /**
         * Default: client
         *
         * the type of token that should be created, either management or client
         */
        token_type?: string;
        /**
         * Default: present
         *
         * whether the ACL pair should be present or absent
         */
        state?: string;
        /**
         * a management token is required to manipulate the acl lists
         */
        mgmt_token?: string;
        /**
         * Default: localhost
         *
         * host of the consul agent defaults to localhost
         */
        host?: string;
        /**
         * Default: http
         *
         * the protocol scheme on which the consul agent is running
         */
        scheme?: string;
        /**
         * Default: True
         *
         * whether to verify the tls certificate of the consul agent
         */
        validate_certs?: string;
        /**
         * Default: 8500
         *
         * the port on which the consul agent is running
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * Add, update and remove regions.
       */
      cs_region?: {
        /**
         * Endpoint URL of the region.
         * Required if C(state=present)
         */
        endpoint?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Default: present
         *
         * State of the region.
         */
        state?: "present" | "absent";
        api_key?: string;
        /**
         * ID of the region.
         * Must be an number (int).
         */
        id: number | string;
        /**
         * Name of the region.
         * Required if C(state=present)
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manages SNMP user configuration.
       */
      nxos_snmp_user?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Group to which the user will belong to. If state = present, and the user is existing, the group is added to the user. If the user is not existing, user entry is created with this group argument. If state = absent, only the group is removed from the user entry. However, to maintain backward compatibility, if the existing user belongs to only one group, and if group argument is same as the existing user's group, then the user entry also is deleted.
         */
        group?: string;
        /**
         * Privacy password for the user. This is not idempotent
         */
        privacy?: string;
        auth_pass?: string;
        host?: string;
        /**
         * Authentication parameters for the user.
         */
        authentication?: "md5" | "sha";
        /**
         * Enables AES-128 bit encryption when using privacy password.
         */
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Authentication password when using md5 or sha. This is not idempotent
         */
        pwd?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Name of the user.
         */
        user: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific virtual network or all virtual networks within a resource group.
       */
      azure_rm_virtualnetwork_facts?: {
        profile?: string;
        /**
         * Only show results for a specific security group.
         */
        name?: string;
        /**
         * Limit results by resource group. Required when filtering by name.
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an CNOS node and returns the results read from the device. The C(cnos_command) module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      cnos_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        /**
         * List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        /**
         * A dict object containing connection details.
         */
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: "any" | "all";
        [k: string]: unknown;
      };
      /**
       * This module can be used to mount/umount datastore on ESXi host.
       * This module only support NFS/VMFS type of datastores.
       * For VMFS datastore, available device must already be connected on ESXi host.
       * All parameters and VMware object names are case sensitive.
       */
      vmware_host_datastore?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of static IP routes on Vyatta VyOS network devices.
       */
      vyos_static_route?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Default: present
         *
         * State of the static route configuration.
         */
        state?: "present" | "absent";
        /**
         * Network prefix mask of the static route.
         */
        mask?: string;
        host?: string;
        /**
         * Admin distance of the static route.
         */
        admin_distance?: number | string;
        /**
         * Network prefix of the static route. C(mask) param should be ignored if C(prefix) is provided with C(mask) value C(prefix/mask).
         */
        prefix?: string;
        /**
         * Next hop IP of the static route.
         */
        next_hop?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of static route definitions
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create/Delete cluster peer relations on ONTAP
       */
      na_ontap_cluster_peer?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages Bridge Domains (BD) on Cisco ACI fabrics.
       */
      aci_bd?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manages BIG-IQ applications used for load balancing an HTTP-based application, speeding up connections and reducing the number of connections to the back-end server.
       */
      bigiq_application_fasthttp?: {
        [k: string]: unknown;
      };
      /**
       * Add and remove username/password entries in a password file using htpasswd.
       * This is used by web servers such as Apache and Nginx for basic authentication.
       */
      htpasswd?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Authenticates to CyberArk Vault using Privileged Account Security Web Services SDK and creates a session fact that can be used by other modules. It returns an Ansible fact called I(cyberark_session). Every module can use this fact as C(cyberark_session) parameter.
       */
      cyberark_authentication?: {
        /**
         * The name of the user who will logon to the Vault.
         */
        username?: string;
        /**
         * Default: no
         *
         * Whether or not users will be authenticated via a RADIUS server. Valid values are true/false.
         */
        use_radius_authentication?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The new password of the user. This parameter is optional, and enables you to change a password.
         */
        new_password?: string;
        /**
         * Dictionary set by a CyberArk authentication containing the different values to perform actions on a logged-on CyberArk session.
         */
        cyberark_session?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Specifies if an authentication logon/logoff and a cyberark_session should be added/removed.
         */
        state?: "present" | "absent";
        /**
         * The password of the user.
         */
        password?: string;
        /**
         * Default: yes
         *
         * If C(false), SSL certificates will not be validated.  This should only set to C(false) used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Whether or not Shared Logon Authentication will be used.
         */
        use_shared_logon_authentication?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A string containing the base URL of the server hosting CyberArk's Privileged Account Security Web Services SDK.
         */
        api_base_url?: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP GTM virtual servers. A GTM server can have many virtual servers associated with it. They are arranged in much the same way that pool members are to pools.
       */
      bigip_gtm_virtual_server?: {
        /**
         * Specifies the health monitors that the system currently uses to monitor this resource.
         * When C(availability_requirements.type) is C(require), you may only have a single monitor in the C(monitors) list.
         */
        monitors?: string;
        /**
         * Specifies resource thresholds or limit requirements at the server level.
         * When you enable one or more limit settings, the system then uses that data to take servers in and out of service.
         * You can define limits for any or all of the limit settings. However, when a server does not meet the resource threshold limit requirement, the system marks the entire server as unavailable and directs load-balancing traffic to another resource.
         * The limit settings available depend on the type of server.
         */
        limits?: string;
        /**
         * Specifies the virtual servers on which the current virtual server depends.
         * If any of the specified servers are unavailable, the current virtual server is also listed as unavailable.
         */
        virtual_server_dependencies?: string;
        /**
         * Specifies the translation port number or service name for the virtual server.
         * To specify all ports, use an C(*).
         * When creating a new GTM virtual server, if this parameter is not specified, a default of C(*) will be used.
         */
        translation_port?: string;
        /**
         * Specifies the name of the server that the virtual server is associated with.
         */
        server_name?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the translation IP address for the virtual server.
         * To unset this parameter, provide an empty string (C("")) as a value.
         * When creating a new GTM virtual server, if this parameter is not specified, a default of C(::) will be used.
         */
        translation_address?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the resource exists.
         * When C(absent), ensures the resource is removed.
         */
        state?: string;
        /**
         * Specifies a link to assign to the server or virtual server.
         */
        link?: string;
        /**
         * Specifies, if you activate more than one health monitor, the number of health monitors that must receive successful responses in order for the link to be considered available.
         */
        availability_requirements?: string;
        /**
         * Specifies the IP Address of the virtual server.
         * When creating a new GTM virtual server, this parameter is required.
         */
        address?: string;
        /**
         * Specifies the service port number for the virtual server or pool member. For example, the HTTP service is typically port 80.
         * To specify all ports, use an C(*).
         * When creating a new GTM virtual server, if this parameter is not specified, a default of C(*) will be used.
         */
        port?: string;
        /**
         * Specifies the name of the virtual server.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manages configuration of an OSPF interface instance.
       */
      nxos_interface_ospf?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the ospf instance.
         */
        ospf: string;
        /**
         * Specifies the scheme used for encrypting message_digest_password. Valid values are '3des' or 'cisco_type_7' encryption or 'default'.
         */
        message_digest_encryption_type?: "cisco_type_7" | "3des" | "default";
        /**
         * The cost associated with this cisco_interface_ospf instance.
         */
        cost?: string;
        /**
         * Time between sending successive hello packets. Valid values are an integer or the keyword 'default'.
         */
        hello_interval?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        /**
         * Ospf area associated with this cisco_interface_ospf instance. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer.
         */
        area: string;
        /**
         * Algorithm used for authentication among neighboring routers within an area. Valid values are 'md5' and 'default'.
         */
        message_digest_algorithm_type?: "md5" | "default";
        auth_pass?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * Enable or disable passive-interface state on this interface. true - (enable) Prevent OSPF from establishing an adjacency or sending routing updates on this interface. false - (disable) Override global 'passive-interface default' for this interface.
         */
        passive_interface?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Enables or disables the usage of message digest authentication.
         */
        message_digest?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        /**
         * Specifies the message_digest password. Valid value is a string.
         */
        message_digest_password?: string;
        host?: string;
        /**
         * Name of this cisco_interface resource. Valid value is a string.
         */
        interface: string;
        password?: string;
        ssh_keyfile?: string;
        /**
         * Md5 authentication key-id associated with the ospf instance. If this is present, message_digest_encryption_type, message_digest_algorithm_type and message_digest_password are mandatory. Valid value is an integer and 'default'.
         */
        message_digest_key_id?: string;
        /**
         * Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer or the keyword 'default'.
         */
        dead_interval?: string;
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage service group configuration in Netscaler.
       * This module is intended to run either on the ansible  control node or a bastion (jumpserver) with access to the actual netscaler instance.
       */
      netscaler_servicegroup?: {
        /**
         * Any information about the service group.
         */
        comment?: string;
        /**
         * Enable TCP buffering for the service group.
         */
        tcpb?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Cache type supported by the cache server.
         */
        cachetype?: "TRANSPARENT" | "REVERSE" | "FORWARD";
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * When set to C(yes) the service group state will be set to DISABLED.
         * When set to C(no) the service group state will be set to ENABLED.
         * Note that due to limitations of the underlying NITRO API a C(disabled) state change alone does not cause the module result to report a changed status.
         */
        disabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_protocol?: "http" | "https";
        /**
         * Maximum number of requests that can be sent on a persistent connection to the service group.
         * Note: Connection requests beyond this value are rejected.
         * Minimum value = C(0)
         * Maximum value = C(65535)
         */
        maxreq?: number;
        /**
         * Wait for all existing connections to the service to terminate before shutting down the service.
         */
        graceful?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Maximum bandwidth, in Kbps, allocated for all the services in the service group.
         * Minimum value = C(0)
         * Maximum value = C(4294967287)
         */
        maxbandwidth?: number;
        /**
         * Time, in seconds, after which to terminate an idle server connection.
         * Minimum value = C(0)
         * Maximum value = C(31536000)
         */
        svrtimeout?: number;
        /**
         * Time, in seconds, after which to terminate an idle client connection.
         * Minimum value = C(0)
         * Maximum value = C(31536000)
         */
        clttimeout?: number;
        /**
         * Protocol used to exchange data with the service.
         */
        servicetype?:
          | "HTTP"
          | "FTP"
          | "TCP"
          | "UDP"
          | "SSL"
          | "SSL_BRIDGE"
          | "SSL_TCP"
          | "DTLS"
          | "NNTP"
          | "RPCSVR"
          | "DNS"
          | "ADNS"
          | "SNMP"
          | "RTSP"
          | "DHCPRA"
          | "ANY"
          | "SIP_UDP"
          | "SIP_TCP"
          | "SIP_SSL"
          | "DNS_TCP"
          | "ADNS_TCP"
          | "MYSQL"
          | "MSSQL"
          | "ORACLE"
          | "RADIUS"
          | "RADIUSListener"
          | "RDP"
          | "DIAMETER"
          | "SSL_DIAMETER"
          | "TFTP"
          | "SMPP"
          | "PPTP"
          | "GRE"
          | "SYSLOGTCP"
          | "SYSLOGUDP"
          | "FIX"
          | "SSL_FIX";
        /**
         * Use the transparent cache redirection virtual server to forward the request to the cache server.
         * Note: Do not set this parameter if you set the Cache Type.
         */
        cacheable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Auto scale option for a servicegroup.
         */
        autoscale?: "DISABLED" | "DNS" | "POLICY";
        /**
         * Maximum number of simultaneous open connections for the service group.
         * Minimum value = C(0)
         * Maximum value = C(4294967294)
         */
        maxclient?: number;
        /**
         * A list of monitornames to bind to this service
         * Note that the monitors must have already been setup possibly using the M(netscaler_lb_monitor) module or some other method
         */
        monitorbindings?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the service group. Must begin with an ASCII alphabetic or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the name is created.
         * Minimum length = 1
         */
        servicegroupname?: string;
        state?: "present" | "absent";
        /**
         * Use client's IP address as the source IP address when initiating connection to the server. With the NO setting, which is the default, a mapped IP (MIP) address or subnet IP (SNIP) address is used as the source IP address to initiate server side connections.
         */
        usip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_user: string;
        /**
         * Network profile for the service group.
         * Minimum length = 1
         * Maximum length = 127
         */
        netprofile?: string;
        /**
         * Enable RTSP session ID mapping for the service group.
         */
        rtspsessionidremap?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_timeout?: number;
        /**
         * Individual Path monitoring decisions.
         */
        pathmonitorindv?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Path monitoring for clustering.
         */
        pathmonitor?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable logging of AppFlow information for the specified service group.
         */
        appflowlog?: "enabled" | "disabled";
        /**
         * A list of dictionaries describing each service member of the service group.
         */
        servicemembers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Minimum sum of weights of the monitors that are bound to this service. Used to determine whether to mark a service as UP or DOWN.
         * Minimum value = C(0)
         * Maximum value = C(65535)
         */
        monthreshold?: number;
        /**
         * member port.
         */
        memberport?: number | string;
        /**
         * Enable client keep-alive for the service group.
         */
        cka?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the TCP profile that contains TCP configuration settings for the service group.
         * Minimum length = 1
         * Maximum length = 127
         */
        tcpprofilename?: string;
        /**
         * Enable surge protection for the service group.
         */
        sp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Flush all active transactions associated with all the services in the service group whose state transitions from UP to DOWN. Do not enable this option for applications that must complete their transactions.
         */
        downstateflush?: "enabled" | "disabled";
        /**
         * Name of the HTTP header whose value must be set to the IP address of the client. Used with the Client IP parameter. If client IP insertion is enabled, and the client IP header is not specified, the value of Client IP Header parameter or the value set by the set ns config command is used as client's IP header name.
         * Minimum length = 1
         */
        cipheader?: string;
        /**
         * Name of the HTTP profile that contains HTTP configuration settings for the service group.
         * Minimum length = 1
         * Maximum length = 127
         */
        httpprofilename?: string;
        nsip: string;
        /**
         * Insert the Client IP header in requests forwarded to the service.
         */
        cip?: "enabled" | "disabled";
        /**
         * Monitor the health of this service. Available settings function as follows:
         * C(yes) - Send probes to check the health of the service.
         * C(no) - Do not send probes to check the health of the service. With the NO option, the appliance shows the service as UP at all times.
         */
        healthmonitor?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Use the proxy port as the source port when initiating connections with the server. With the NO setting, the client-side connection port is used as the source port for the server-side connection.
         * Note: This parameter is available only when the Use Source IP C(usip) parameter is set to C(yes).
         */
        useproxyport?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_pass: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable compression for the specified service.
         */
        cmp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages static route configuration
       */
      nxos_static_route?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows you to create, modify and delete Zabbix screens and associated graph data.
       */
      zabbix_screen?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manages interface DLDP configuration on HUAWEI CloudEngine switches.
       */
      ce_dldp_interface?: {
        username?: string;
        /**
         * Specify whether reseting interface DLDP state.
         */
        reset?: "enable" | "disable";
        /**
         * Set interface DLDP enable state.
         */
        enable?: "enable" | "disable";
        /**
         * Set the source MAC address for DLDP packets sent in the DLDP-compatible mode. The value of MAC address is in H-H-H format. H contains 1 to 4 hexadecimal digits.
         */
        local_mac?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        ssh_keyfile?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Must be fully qualified interface name, i.e. GE1/0/1, 10GE1/0/1, 40GE1/0/22, 100GE1/0/1.
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set DLDP compatible-mode enable state.
         */
        mode_enable?: "enable" | "disable";
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Manage packages with the I(pacman) package manager, which is used by Arch Linux and its variants.
       */
      pacman?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages SNMP host configuration parameters.
       */
      nxos_snmp_host?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Community string or v3 username.
         */
        community?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        auth_pass?: string;
        /**
         * IP address of hostname of target host.
         */
        snmp_host: string;
        /**
         * Default: present
         *
         * Manage the state of the resource. If state = present, the host is added to the configuration. If only vrf and/or vrf_filter and/or src_intf are given, they will be added to the existing host configuration. If state = absent, the host is removed if community parameter is given. It is possible to remove only vrf and/or src_int and/or vrf_filter by providing only those parameters and no community parameter.
         */
        state?: "present" | "absent";
        /**
         * SNMP version. If this is not specified, v1 is used.
         */
        version?: "v1" | "v2c" | "v3";
        /**
         * type of message to send to host. If this is not specified, trap type is used.
         */
        snmp_type?: "trap" | "inform";
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * Default: 162
         *
         * UDP port number (0-65535).
         */
        udp?: string;
        /**
         * Source interface. Must be fully qualified interface name. If state = absent, the interface is removed.
         */
        src_intf?: string;
        host?: string;
        /**
         * Use this when verion is v3. SNMPv3 Security level.
         */
        v3?: "noauth" | "auth" | "priv";
        /**
         * VRF to use to source traffic to source. If state = absent, the vrf is removed.
         */
        vrf?: string;
        password?: string;
        /**
         * Name of VRF to filter. If state = absent, the vrf is removed from the filter.
         */
        vrf_filter?: string;
        ssh_keyfile?: string;
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Module manages AWS Config resources
       */
      aws_config_aggregation_authorization?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or delete a Java keystore in JKS format for a given certificate.
       */
      java_keystore?: {
        /**
         * Private key that should be used to create the key store.
         */
        private_key: string;
        /**
         * Default: no
         *
         * Key store will be created even if it already exists.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the certificate.
         */
        name: string;
        /**
         * Certificate that should be used to create the key store.
         */
        certificate: string;
        /**
         * Absolute path where the jks should be generated.
         */
        dest: string;
        /**
         * Password that should be used to secure the key store.
         */
        password: string;
        [k: string]: unknown;
      };
      /**
       * The C(expect) module executes a command and responds to prompts.
       * The given command will be executed on all selected nodes. It will not be processed through the shell, so variables like C($HOME) and operations like C("<"), C(">"), C("|"), and C("&") will not work.
       */
      expect?: {
        /**
         * Change into this directory before running the command.
         */
        chdir?: string;
        /**
         * Mapping of expected string/regex and string to respond with. If the response is a list, successive matches return successive responses. List functionality is new in 2.1.
         */
        responses: {
          [k: string]: unknown;
        };
        /**
         * A filename, when it does not exist, this step will B(not) be run.
         */
        removes?: string;
        /**
         * Whether or not to echo out your response strings.
         */
        echo?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A filename, when it already exists, this step will B(not) be run.
         */
        creates?: string;
        /**
         * The command module takes command to run.
         */
        command: string;
        /**
         * Default: 30
         *
         * Amount of time in seconds to wait for the expected strings. Use C(null) to disable timeout.
         */
        timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Used to import/export and remove certificates and keys from the local certificate store.
       * This module is not used to create certificates and will only manage existing certs as a file or in the store.
       * It can be used to import PEM, DER, P7B, PKCS12 (PFX) certificates and export PEM, DER and PKCS12 certificates.
       */
      win_certificate_store?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Query / Set MySQL variables
       */
      mysql_variables?: {
        ssl_key?: string;
        ssl_cert?: string;
        config_file?: string;
        login_port?: number | string;
        login_user?: string;
        login_host?: string;
        /**
         * If set, then sets variable value to this
         */
        value?: string;
        ssl_ca?: string;
        login_unix_socket?: string;
        login_password?: string;
        /**
         * Variable name to operate
         */
        variable?: string;
        connect_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * The C(nagios) module has two basic functions: scheduling downtime and toggling alerts for services or hosts.
       * All actions require the I(host) parameter to be given explicitly. In playbooks you can use the C({{inventory_hostname}}) variable to refer to the host the playbook is currently running on.
       * You can specify multiple services at once by separating them with commas, .e.g., C(services=httpd,nfs,puppet).
       * When specifying what service to handle there is a special service value, I(host), which will handle alerts/downtime for the I(host itself), e.g., C(service=host). This keyword may not be given with other services at the same time. I(Setting alerts/downtime for a host does not affect alerts/downtime for any of the services running on it.) To schedule downtime for all services on particular host use keyword "all", e.g., C(service=all).
       * When using the C(nagios) module you will need to specify your Nagios server using the C(delegate_to) parameter.
       */
      nagios?: {
        [k: string]: unknown;
      };
      /**
       * Manage fabric interface policy leaf policy groups on Cisco ACI fabrics.
       */
      aci_interface_policy_leaf_policy_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manages AFM Denial of Service (DoS) profiles on a BIG-IP. To manage the vectors associated with a DoS profile, refer to the C(bigip_firewall_dos_vector) module.
       */
      bigip_firewall_dos_profile?: {
        [k: string]: unknown;
      };
      /**
       * Module to manage logical networks in oVirt/RHV
       */
      ovirt_network?: {
        /**
         * Comment of the network.
         */
        comment?: string;
        timeout?: number | string;
        /**
         * Description of the network.
         */
        description?: string;
        /**
         * Name of the network to manage.
         */
        name: string;
        poll_interval?: number | string;
        /**
         * Default: present
         *
         * Should the network be present or absent
         */
        state?: "present" | "absent";
        auth: {
          [k: string]: unknown;
        };
        /**
         * Name of the label to assign to the network.
         */
        label?: string;
        fetch_nested?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nested_attributes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * If I(True) network will be marked as network for VM.
         * VM network carries traffic relevant to the virtual machine.
         */
        vm_network?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Datacenter name where network reside.
         */
        data_center: string;
        /**
         * List of dictionaries describing how the network is managed in specific cluster.
         * C(name) - Cluster name.
         * C(assigned) - I(true) if the network should be assigned to cluster. Default is I(true).
         * C(required) - I(true) if the network must remain operational for all hosts associated with this network.
         * C(display) - I(true) if the network should marked as display network.
         * C(migration) - I(true) if the network should marked as migration network.
         * C(gluster) - I(true) if the network should marked as gluster network.
         */
        clusters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Specify VLAN tag.
         */
        vlan_tag?: number | string;
        /**
         * Maximum transmission unit (MTU) of the network.
         */
        mtu?: number | string;
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running VOSS. This module prepends all of the base network fact keys with C(ansible_net_<fact>). The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      voss_facts?: {
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?: string;
        [k: string]: unknown;
      };
      /**
       * Sets attributes of files, symlinks, and directories, or removes files/symlinks/directories. Many other modules support the same options as the C(file) module - including M(copy), M(template), and M(assemble).
       * For Windows targets, use the M(win_file) module instead.
       */
      file?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Returns information about a Windows file.
       * For non-Windows targets, use the M(stat) module instead.
       */
      win_stat?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages PIM interface configuration settings.
       */
      nxos_pim_interface?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Type of policy mapped to C(jp_policy_in).
         */
        jp_type_in?: "prefix" | "routemap";
        /**
         * Hello interval in milliseconds for this interface.
         */
        hello_interval?: number | string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Configures interface to be a boundary of a PIM domain.
         */
        border?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        /**
         * Authentication for hellos on this interface.
         */
        hello_auth_key?: string;
        /**
         * Configures priority for PIM DR election on interface.
         */
        dr_prio?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manages desired state of the resource.
         */
        state?: "present" | "absent" | "default";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Policy for join-prune messages (inbound).
         */
        jp_policy_in?: string;
        username?: string;
        /**
         * Default: no
         *
         * Enable/disable sparse-mode on the interface.
         */
        sparse?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        /**
         * Configures a neighbor policy for filtering adjacencies.
         */
        neighbor_policy?: string;
        /**
         * Full name of the interface such as Ethernet1/33.
         */
        interface: string;
        password?: string;
        ssh_keyfile?: string;
        /**
         * Policy for join-prune messages (outbound).
         */
        jp_policy_out?: string;
        /**
         * Type of policy mapped to neighbor_policy.
         */
        neighbor_type?: "prefix" | "routemap";
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Type of policy mapped to C(jp_policy_out).
         */
        jp_type_out?: "prefix" | "routemap";
        [k: string]: unknown;
      };
      /**
       * Add and remove secondary IPs to and from a NIC.
       */
      cs_nic?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * This module allows the management of AWS Lambda functions aliases via the Ansible framework.  It is idempotent and supports "Check" mode.    Use module M(lambda) to manage the lambda function itself and M(lambda_event) to manage event source mappings.
       */
      lambda_alias?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create or destroy or modify cifs-share-access-controls on ONTAP
       */
      na_ontap_cifs_acl?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages applying ACLs to interfaces.
       */
      nxos_acl_interface?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Direction ACL to be applied in on the interface.
         */
        direction: "ingress" | "egress";
        ssh_keyfile?: string;
        /**
         * Case sensitive name of the access list (ACL).
         */
        name?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Full name of interface, e.g. I(Ethernet1/1).
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Creates, Removes and configures a virtual directory in IIS.
       */
      win_iis_virtualdirectory?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Configure data-port (DP) network interface for DHCP. By default DP interfaces are static.
       */
      panos_interface?: {
        username?: string;
        /**
         * Name of the interface to configure.
         */
        if_name: string;
        /**
         * Default: false
         *
         * Whether or not to add default route with router learned via DHCP.
         */
        create_default_route?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: True
         *
         * Commit if changed
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the zone for the interface. If the zone does not exist it is created but if the zone exists and it is not of the layer3 type the operation will fail.
         *
         */
        zone_name: string;
        password: string;
        ip_address: string;
        [k: string]: unknown;
      };
      /**
       * Create or destroy Azure Resource Manager template deployments via the Azure SDK for Python. You can find some quick start templates in GitHub here https://github.com/azure/azure-quickstart-templates. For more information on Azue resource manager templates see https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-deploy/.
       */
      azure_rm_deployment?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage PHP packages with the pear package manager.
       */
      pear?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage the hostname of a BIG-IP.
       */
      bigip_hostname?: {
        /**
         * Hostname of the BIG-IP host.
         */
        hostname?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides support for displaying data from Cisco NSO.
       */
      nso_show?: {
        username: string;
        url: string;
        /**
         * Controls whether or not operational data is included in the result.
         *
         */
        operational?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        timeout?: string;
        /**
         * Path to NSO data.
         */
        path: string;
        password: string;
        [k: string]: unknown;
      };
      /**
       * This module creates, deletes or modifies NFS exports on Infinibox.
       */
      infini_export?: {
        /**
         * Default: /
         *
         * Internal path of the export.
         */
        inner_path?: string;
        /**
         * Default: present
         *
         * Creates/Modifies export when present and removes when absent.
         */
        state?: string;
        /**
         * Default: All Hosts(*), RW, no_root_squash: True
         *
         * List of dictionaries with client entries. See examples. Check infini_export_client module to modify individual NFS client entries for export.
         */
        client_list?: string;
        /**
         * Export name. Should always start with C(/). (ex. name=/data)
         */
        name?: string;
        /**
         * Name of exported file system.
         */
        filesystem?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more of the Logical Interconnect Groups from OneView
       */
      oneview_logical_interconnect_group_facts?: {
        username?: string;
        image_streamer_hostname?: string;
        /**
         * Logical Interconnect Group name.
         */
        name?: string;
        hostname?: string;
        params?: {
          [k: string]: unknown;
        };
        password?: string;
        config?: string;
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Allows for the management of API Gateway APIs
       * Normally you should give the api_id since there is no other stable guaranteed unique identifier for the API.  If you do not give api_id then a new API will be create each time this is run.
       * Beware that there are very hard limits on the rate that you can call API Gateway's REST API.  You may need to patch your boto.  See https://github.com/boto/boto3/issues/876 and discuss with your AWS rep.
       * swagger_file and swagger_text are passed directly on to AWS transparently whilst swagger_dict is an ansible dict which is converted to JSON before the API definitions are uploaded.
       */
      aws_api_gateway?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages AAA server global configuration
       */
      nxos_aaa_server?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Enables direct authentication requests to AAA server or keyword 'default' Device default is disabled.
         */
        directed_request?: "enabled" | "disabled" | "default";
        /**
         * The server type is either radius or tacacs.
         */
        server_type: "radius" | "tacacs";
        /**
         * The state of encryption applied to the entered global key. O clear text, 7 encrypted. Type-6 encryption is not supported.
         */
        encrypt_type?: "0" | "7";
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "default";
        /**
         * Global AAA shared secret or keyword 'default'.
         */
        global_key?: string;
        host?: string;
        /**
         * Global AAA server timeout period, in seconds or keyword 'default. Range is 1-60. Device default is 5.
         */
        server_timeout?: string;
        /**
         * Duration for which a non-reachable AAA server is skipped, in minutes or keyword 'default. Range is 1-1440. Device default is 0.
         */
        deadtime?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Read the AWS documentation for WAF U(https://aws.amazon.com/documentation/waf/)
       */
      aws_waf_web_acl?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and delete an Azure Container Instance.
       */
      azure_rm_containerinstance?: {
        /**
         * Name of resource group.
         */
        resource_group: string;
        cloud_environment?: string;
        /**
         * The password to log in container image registry server.
         */
        registry_password?: string;
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        /**
         * Valid azure location. Defaults to location of the resource group.
         */
        location?: string;
        subscription_id?: string;
        /**
         * List of containers.
         */
        containers:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        profile?: string;
        /**
         * The container image registry login server.
         */
        registry_login_server?: string;
        /**
         * Default: present
         *
         * Assert the state of the container instance. Use 'present' to create or update an container instance and 'absent' to delete it.
         */
        state?: "absent" | "present";
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        /**
         * Default: none
         *
         * The IP address type of the container group (default is 'none')
         */
        ip_address?: "public" | "none";
        tenant?: string;
        /**
         * The username to log in container image registry server.
         */
        registry_username?: string;
        /**
         * The name of the container group.
         */
        name: string;
        /**
         * Default: no
         *
         * Force update of existing container instance. Any update will result in deletion and recreation of existing containers.
         */
        force_update?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        /**
         * Default: linux
         *
         * The OS type of containers.
         */
        os_type?: "linux" | "windows";
        /**
         * List of ports exposed within the container group.
         */
        ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Create, update or delete a virtual networks. Allows setting and updating the available IPv4 address ranges and setting custom DNS servers. Use the azure_rm_subnet module to associate subnets with a virtual network.
       */
      azure_rm_virtualnetwork?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages IGMP global configuration configuration settings.
       */
      nxos_igmp?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Enables or disables the enforce router alert option check for IGMPv2 and IGMPv3 packets.
         */
        enforce_rtr_alert?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Removes routes when the IGMP process is restarted. By default, routes are not flushed.
         */
        flush_routes?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manages desired state of the resource.
         */
        state?: "present" | "default";
        host?: string;
        transport?: "cli" | "nxapi";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        /**
         * Restarts the igmp process (using an exec config command).
         */
        restart?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage vlan, vxlan, and vsan ranges that are assigned to pools on Cisco ACI fabrics.
       */
      aci_encap_pool_range?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Lenovo ENOS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with ENOS configuration sections in a deterministic way.
       */
      enos_config?: {
        [k: string]: unknown;
      };
      /**
       * Configures the SELinux mode and policy. A reboot may be required after usage. Ansible will not issue this reboot but will let you know when it is required.
       */
      selinux?: {
        [k: string]: unknown;
      };
      /**
       * Create and remove firewall groups.
       */
      vultr_firewall_group?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module can create and destroy Google Compute Engine C(loadbalancer) and C(httphealthcheck) resources.  The primary LB resource is the C(load_balancer) resource and the health check parameters are all prefixed with I(httphealthcheck). The full documentation for Google Compute Engine load balancing is at U(https://developers.google.com/compute/docs/load-balancing/).  However, the ansible module simplifies the configuration by following the libcloud model. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.
       */
      gce_lb?: {
        /**
         * host header to pass through on HTTP check requests
         */
        httphealthcheck_host?: string;
        /**
         * the name identifier for the HTTP health check
         */
        httphealthcheck_name?: string;
        /**
         * name of the load-balancer resource
         */
        name?: string;
        /**
         * the external static IPv4 (or auto-assigned) address for the LB
         */
        external_ip?: string;
        /**
         * service account email
         */
        service_account_email?: string;
        /**
         * the GCE region where the load-balancer is defined
         */
        region?: string;
        /**
         * Default: 2
         *
         * number of consecutive failed checks before marking a node unhealthy
         */
        httphealthcheck_unhealthy_count?: string;
        /**
         * Default: 2
         *
         * number of consecutive successful checks before marking a node healthy
         */
        httphealthcheck_healthy_count?: string;
        /**
         * path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
         */
        pem_file?: string;
        /**
         * Default: /
         *
         * the url path to use for HTTP health checking
         */
        httphealthcheck_path?: string;
        /**
         * the port (range) to forward, e.g. 80 or 8000-8888 defaults to all ports
         */
        port_range?: string;
        /**
         * Default: present
         *
         * desired state of the LB
         */
        state?: string;
        /**
         * Default: 5
         *
         * the timeout in seconds before a request is considered a failed check
         */
        httphealthcheck_timeout?: string;
        /**
         * a list of zone/nodename pairs, e.g ['us-central1-a/www-a', ...]
         */
        members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * path to the JSON file associated with the service account email
         */
        credentials_file?: string;
        /**
         * Default: 80
         *
         * the TCP port to use for HTTP health checking
         */
        httphealthcheck_port?: string;
        /**
         * Default: tcp
         *
         * the protocol used for the load-balancer packet forwarding, tcp or udp
         */
        protocol?: string;
        /**
         * your GCE project ID
         */
        project_id?: string;
        /**
         * Default: 5
         *
         * the duration in seconds between each health check request
         */
        httphealthcheck_interval?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about a one or more OpenStack domains
       */
      os_keystone_domain_facts?: {
        /**
         * Name or ID of the domain
         */
        name?: string;
        /**
         * A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
         */
        filters?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * Manage OpenStack DNS recordsets. Recordsets can be created, deleted or updated. Only the I(records), I(description), and I(ttl) values can be updated.
       */
      os_recordset?: {
        /**
         * Name of the recordset
         */
        name?: string;
        /**
         * Zone managing the recordset
         */
        zone?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * List of recordset definitions
         */
        records?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * TTL (Time To Live) value in seconds
         */
        ttl?: string;
        /**
         * Recordset type
         */
        recordset_type?: string;
        /**
         * Description of the recordset
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * This module will let you create Zabbix maintenance windows.
       */
      zabbix_maintenance?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        };
      /**
       * Manage a maintenance-mode or normal-mode profile with configuration commands that can be applied during graceful removal or graceful insertion.
       */
      nxos_gir_profile_management?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of commands to be included into the profile.
         */
        commands?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * Configure the profile as Maintenance or Normal mode.
         */
        mode: "maintenance" | "normal";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Add or remove kernel modules from blacklist.
       */
      kernel_blacklist?: {
        /**
         * If specified, use this blacklist file instead of C(/etc/modprobe.d/blacklist-ansible.conf).
         */
        blacklist_file?: string;
        /**
         * Default: present
         *
         * Whether the module should be present in the blacklist or absent.
         */
        state?: "absent" | "present";
        /**
         * Name of kernel module to black- or whitelist.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Sends an arbitrary command to an NXOS node and returns the results read from the device.  This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      nxos_command?: {
        [k: string]: unknown;
      };
      /**
       * Manage upload, installation and removal of UCS files.
       */
      bigip_ucs?: {
        /**
         * If C(yes) will upload the file every time and replace the file on the device. If C(no), the file will only be uploaded if it does not already exist. Generally should be C(yes) only in cases where you have reason to believe that the image was corrupted during upload.
         */
        force?: string;
        /**
         * When specified, the device and trust domain certs and keys are not loaded from the UCS. Instead, a new set is regenerated.
         */
        reset_trust?: string;
        /**
         * Bypasses the platform check and allows a UCS that was created using a different platform to be installed. By default (without this option), a UCS created from a different platform is not allowed to be installed.
         */
        no_platform_check?: string;
        /**
         * Default: present
         *
         * When C(installed), ensures that the UCS is uploaded and installed, on the system. When C(present), ensures that the UCS is uploaded. When C(absent), the UCS will be removed from the system. When C(installed), the uploading of the UCS is idempotent, however the installation of that configuration is not idempotent.
         */
        state?: string;
        /**
         * During restore of the UCS file, include chassis level configuration that is shared among boot volume sets. For example, cluster default configuration.
         */
        include_chassis_level_config?: string;
        /**
         * Specifies the passphrase that is necessary to load the specified UCS file.
         */
        passphrase?: string;
        /**
         * The path to the UCS file to install. The parameter must be provided if the C(state) is either C(installed) or C(activated). When C(state) is C(absent), the full path for this parameter will be ignored and only the filename will be used to select a UCS for removal. Therefore you could specify C(/mickey/mouse/test.ucs) and this module would only look for C(test.ucs).
         */
        ucs?: string;
        /**
         * Performs a full restore of the UCS file and all the files it contains, with the exception of the license file. The option must be used to restore a UCS on RMA devices (Returned Materials Authorization).
         */
        no_license?: string;
        [k: string]: unknown;
      };
      /**
       * Modify a ONTAP service processor network
       */
      na_ontap_service_processor_network?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module provides declarative management of L3 interfaces on network devices.
       */
      net_l3_interface?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host: string;
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Sends logs to LogEntries in realtime
       */
      logentries?: {
        [k: string]: unknown;
      };
      /**
       * Manage timer policies on a BIG-IP.
       */
      bigip_timer_policy?: {
        /**
         * Rules that you want assigned to the timer policy
         */
        rules?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the resource exists.
         * When C(absent), ensures the resource is removed.
         */
        state?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the name of the timer policy.
         */
        name?: string;
        /**
         * Specifies descriptive text that identifies the timer policy.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM pool members via iControl SOAP API.
       */
      bigip_pool_member?: {
        /**
         * Pool member ratio weight. Valid values range from 1 through 100. New pool members -- unless overridden with this value -- default to 1.
         */
        ratio?: string;
        /**
         * Name of the node to create, or re-use, when creating a new pool member.
         * This parameter is optional and, if not specified, a node name will be created automatically from either the specified C(address) or C(fqdn).
         * The C(enabled) state is an alias of C(present).
         */
        name?: string;
        /**
         * Specifies whether the system automatically creates ephemeral nodes using the IP addresses returned by the resolution of a DNS query for a node defined by an FQDN.
         * When C(yes), the system generates an ephemeral node for each IP address returned in response to a DNS query for the FQDN of the node. Additionally, when a DNS response indicates the IP address of an ephemeral node no longer exists, the system deletes the ephemeral node.
         * When C(no), the system resolves a DNS query for the FQDN of the node with the single IP address associated with the FQDN.
         * When creating a new pool member, the default for this parameter is C(yes).
         * This parameter is ignored when C(reuse_nodes) is C(yes).
         */
        fqdn_auto_populate?: string;
        /**
         * Pool member rate limit (connections-per-second). Setting this to 0 disables the limit.
         */
        rate_limit?: string;
        /**
         * Default: Common
         *
         * Partition
         */
        partition?: string;
        /**
         * Pool member connection limit. Setting this to 0 disables the limit.
         */
        connection_limit?: string;
        /**
         * FQDN name of the pool member. This can be any name that is a valid RFC 1123 DNS name. Therefore, the only characters that can be used are "A" to "Z", "a" to "z", "0" to "9", the hyphen ("-") and the period (".").
         * FQDN names must include at lease one period; delineating the host from the domain. ex. C(host.domain).
         * FQDN names must end with a letter or a number.
         * When creating a new pool member, one of either C(address) or C(fqdn) must be provided. This parameter cannot be updated after it is set.
         */
        fqdn?: string;
        /**
         * Default: True
         *
         * Reuses node definitions if requested.
         */
        reuse_nodes?: string;
        /**
         * Default: present
         *
         * Pool member state.
         */
        state?: string;
        /**
         * When state is C(absent) attempts to remove the node that the pool member references.
         * The node will not be removed if it is still referenced by other pool members. If this happens, the module will not raise an error.
         * Setting this to C(yes) disables this behavior.
         */
        preserve_node?: string;
        /**
         * IP address of the pool member. This can be either IPv4 or IPv6. When creating a new pool member, one of either C(address) or C(fqdn) must be provided. This parameter cannot be updated after it is set.
         */
        address?: string;
        /**
         * Specifies a number representing the priority group for the pool member.
         * When adding a new member, the default is 0, meaning that the member has no priority.
         * To specify a priority, you must activate priority group usage when you create a new pool or when adding or removing pool members. When activated, the system load balances traffic according to the priority group number assigned to the pool member.
         * The higher the number, the higher the priority, so a member with a priority of 3 has higher priority than a member with a priority of 1.
         */
        priority_group?: string;
        /**
         * Pool member port.
         * This value cannot be changed after it has been set.
         */
        port?: string;
        /**
         * Pool name. This pool must exist.
         */
        pool?: string;
        /**
         * Pool member description.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Create or join or apply licenses to ONTAP clusters
       */
      na_ontap_cluster?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Adds and/or removes instances of CNAME record objects from Infoblox NIOS servers.  This module manages NIOS C(record:cname) objects using the Infoblox WAPI interface over REST.
       */
      nios_cname_record?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update, or destroy Ansible Tower inventories source. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_inventory_source?: {
        /**
         * List of regions for your cloud provider. You can include multiple all regions. Only Hosts associated with the selected regions will be updated. Refer to Ansible Tower documentation for more detail.
         */
        source_regions?: string;
        tower_username?: string;
        /**
         * If set, any hosts and groups that were previously present on the external source but are now removed will be removed from the Tower inventory. Hosts and groups that were not managed by the inventory source will be promoted to the next manually created group or if there is no manually created group to promote them into, they will be left in the "all" default group for the inventory. When not checked, local child hosts and groups not found on the external source will remain untouched by the inventory update process.
         */
        overwrite?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The source_vars allow to Override variables found in the source config file. For example with Openstack, specifying *private: false* would change the output of the openstack.py script. It has to be YAML or JSON.
         */
        source_vars?: string;
        /**
         * That parameter will sync the inventory when the project is synced. It can only be used with a SCM source.
         */
        update_on_project_update?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Provide a comma-separated list of filter expressions. Hosts are imported when all of the filters match. Refer to Ansible Tower documentation for more detail.
         */
        instance_filters?: string;
        /**
         * Types of inventory source.
         */
        source:
          | "file"
          | "scm"
          | "ec2"
          | "gce"
          | "azure"
          | "azure_rm"
          | "vmware"
          | "satellite6"
          | "cloudforms"
          | "openstack"
          | "rhv"
          | "tower"
          | "custom";
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Specify which groups to create automatically. Group names will be created similar to the options selected. If blank, all groups above are created. Refer to Ansible Tower documentation for more detail.
         */
        group_by?: string;
        /**
         * The inventory the source is linked to.
         */
        inventory: string;
        /**
         * Time in seconds to consider an inventory sync to be current. During job runs and callbacks the task system will evaluate the timestamp of the latest sync. If it is older than Cache Timeout, it is not considered current, and a new inventory sync will be performed.
         */
        update_cache_timeout?: number | string;
        /**
         * Credential to use to retrieve the inventory from.
         */
        credential?: string;
        /**
         * The description to use for the inventory source.
         */
        description?: string;
        /**
         * If set, all variables for child groups and hosts will be removed and replaced by those found on the external source. When not checked, a merge will be performed, combining local variables with those found on the external source.
         */
        overwrite_vars?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_host?: string;
        tower_password?: string;
        tower_config_file?: string;
        /**
         * Each time a job runs using this inventory, refresh the inventory from the selected source before executing job tasks.
         */
        update_on_launch?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The source custom script to use to build the inventory. It needs to exist.
         */
        source_script?: string;
        /**
         * The name to use for the inventory source.
         */
        name: string;
        /**
         * Tower option to avoid certificates check.
         */
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Use a *project* as a source for the *inventory*.
         */
        source_project?: string;
        /**
         * Path to the file to use as a source in the selected *project*.
         */
        source_path?: string;
        /**
         * Number in seconds after which the Tower API methods will time out.
         */
        timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Adds and/or removes instances of network objects from Infoblox NIOS servers.  This module manages NIOS C(network) objects using the Infoblox WAPI interface over REST.
       * Supports both IPV4 and IPV6 internet protocols
       */
      nios_network?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Add or Remove a floating IP to an instance
       */
      os_floating_ip?: {
        /**
         * To which fixed IP of server the floating IP address should be attached to.
         */
        fixed_address?: string;
        /**
         * The name or ID of a neutron external network or a nova pool name.
         */
        network?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Default: no
         *
         * When attaching a floating IP address, specify whether we should wait for it to appear as attached.
         */
        wait?: string;
        /**
         * The name or id of a neutron private network that the fixed IP to attach floating IP is on
         */
        nat_destination?: string;
        /**
         * Default: no
         *
         * When I(state) is absent, indicates whether or not to delete the floating IP completely, or only detach it from the server. Default is to detach only.
         */
        purge?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * A floating IP address to attach or to detach. Required only if I(state) is absent. When I(state) is present can be used to specify a IP address to attach.
         */
        floating_ip_address?: string;
        /**
         * Default: 60
         *
         * Time to wait for an IP address to appear as attached. See wait.
         */
        timeout?: string;
        /**
         * The name or ID of the instance to which the IP address should be assigned.
         */
        server?: string;
        /**
         * Default: no
         *
         * When I(state) is present, and I(floating_ip_address) is not present, this parameter can be used to specify whether we should try to reuse a floating IP address already allocated to the project.
         */
        reuse?: string;
        [k: string]: unknown;
      };
      /**
       * Installs or uninstalls Windows Roles or Features on Windows Server. This module uses the Add/Remove-WindowsFeature Cmdlets on Windows 2008 R2 and Install/Uninstall-WindowsFeature Cmdlets on Windows 2012, which are not available on client os machines.
       */
      win_feature?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * The M(proxysql_query_rules) module modifies query rules using the proxysql admin interface.
       */
      proxysql_query_rules?: {
        /**
         * Free form text field, usable for a descriptive comment of the query rule.
         */
        comment?: string;
        /**
         * Used in combination with I(flagIN) and apply to create chains of rules. When set, I(flagOUT) signifies the I(flagIN) to be used in the next chain of rules.
         */
        flagOUT?: number | string;
        login_user?: string;
        login_password?: string;
        /**
         * Regular expression that matches the query text. The dialect of regular expressions used is that of re2 - https://github.com/google/re2
         */
        match_pattern?: string;
        /**
         * Enables query mirroring. If set I(mirror_flagOUT) can be used to evaluates the mirrored query against the specified chain of rules.
         */
        mirror_flagOUT?: number | string;
        /**
         * Used in combination with I(flagIN) and I(flagOUT) to create chains of rules. Setting apply to True signifies the last rule to be applied.
         */
        apply?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Filtering criteria matching schemaname. If I(schemaname) is non-NULL, a query will match only if the connection uses schemaname as its default schema.
         */
        schemaname?: string;
        /**
         * This is the pattern with which to replace the matched pattern. Note that this is optional, and when omitted, the query processor will only cache, route, or set other parameters without rewriting.
         */
        replace_pattern?: string;
        /**
         * Match queries with a specific digest, as returned by stats_mysql_query_digest.digest.
         */
        digest?: string;
        /**
         * Regular expression that matches the query digest. The dialect of regular expressions used is that of re2 - https://github.com/google/re2
         */
        match_digest?: string;
        /**
         * Enables query mirroring. If set I(mirror_hostgroup) can be used to mirror queries to the same or different hostgroup.
         */
        mirror_hostgroup?: number | string;
        /**
         * Query will be logged.
         */
        log?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Number of milliseconds to delay the execution of the query. This is essentially a throttling mechanism and QoS, and allows a way to give priority to queries over others. This value is added to the mysql-default_query_delay global variable that applies to all queries.
         */
        delay?: number | string;
        /**
         * Default: present
         *
         * When C(present) - adds the rule, when C(absent) - removes the rule.
         */
        state?: "present" | "absent";
        /**
         * Match incoming traffic on a specific local IP.
         */
        proxy_addr?: string;
        /**
         * Filtering criteria matching username.  If I(username) is non-NULL, a query will match only if the connection is made with the correct username.
         */
        username?: string;
        config_file?: string;
        login_port?: number | string;
        login_host?: string;
        /**
         * Route matched queries to this hostgroup. This happens unless there is a started transaction and the logged in user has I(transaction_persistent) set to C(True) (see M(proxysql_mysql_users)).
         */
        destination_hostgroup?: number | string;
        /**
         * Match incoming traffic on a specific local port.
         */
        proxy_port?: number | string;
        login_unix_socket?: string;
        load_to_runtime?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        save_to_disk?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A rule with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures.
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The number of milliseconds for which to cache the result of the query. Note in ProxySQL 1.1 I(cache_ttl) was in seconds.
         */
        cache_ttl?: number | string;
        /**
         * Query will be blocked, and the specified error_msg will be returned to the client.
         */
        error_msg?: string;
        /**
         * The maximum number of times a query needs to be re-executed in case of detected failure during the execution of the query. If retries is not specified, the global variable mysql-query_retries_on_failure applies.
         */
        retries?: number | string;
        /**
         * If I(negate_match_pattern) is set to C(True), only queries not matching the query text will be considered as a match. This acts as a NOT operator in front of the regular expression matching against match_pattern.
         */
        negate_match_pattern?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * By default we avoid deleting more than one schedule in a single batch, however if you need this behaviour and you're not concerned about the schedules deleted, you can set I(force_delete) to C(True).
         */
        force_delete?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Match traffic from a specific source.
         */
        client_addr?: string;
        /**
         * The maximum timeout in milliseconds with which the matched or rewritten query should be executed. If a query run for longer than the specific threshold, the query is automatically killed. If timeout is not specified, the global variable mysql-default_query_timeout applies.
         */
        timeout?: number | string;
        /**
         * Used in combination with I(flagOUT) and I(apply) to create chains of rules.
         */
        flagIN?: number | string;
        /**
         * The unique id of the rule. Rules are processed in rule_id order.
         */
        rule_id?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module de-registers or registers an AWS EC2 instance from the ELBs that it belongs to.
       * Returns fact "ec2_elbs" which is a list of elbs attached to the instance if state=absent is passed as an argument.
       * Will be marked changed when called only if there are ELBs found to operate on.
       */
      ec2_elb?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about the oVirt/RHV API.
       */
      ovirt_api_facts?: {
        [k: string]: unknown;
      };
      /**
       * Creates temporary files and directories.
       * For non-Windows targets, please use the M(tempfile) module instead.
       */
      win_tempfile?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages the AFM address lists on a BIG-IP. This module can be used to add and remove address list entries.
       */
      bigip_firewall_address_list?: {
        /**
         * List of geolocations specified by their C(country) and C(region).
         */
        geo_locations?: string;
        /**
         * Individual addresses that you want to add to the list. These addresses differ from ranges, and lists of lists such as what can be used in C(address_ranges) and C(address_lists) respectively.
         * This list can also include networks that have CIDR notation.
         */
        addresses?: string;
        /**
         * Simple list of existing address lists to add to this list. Address lists can be specified in either their fully qualified name (/Common/foo) or their short name (foo). If a short name is used, the C(partition) argument will automatically be prepended to the short name.
         */
        address_lists?: string;
        /**
         * Description of the address list
         */
        description?: string;
        /**
         * A list of address ranges where the range starts with a port number, is followed by a dash (-) and then a second number.
         * If the first address is greater than the second number, the numbers will be reversed so-as to be properly formatted. ie, C(2.2.2.2-1.1.1). would become C(1.1.1.1-2.2.2.2).
         */
        address_ranges?: string;
        /**
         * A list of fully qualified domain names (FQDNs).
         * An FQDN has at least one decimal point in it, separating the host from the domain.
         * To add FQDNs to a list requires that a global FQDN resolver be configured. At the moment, this must either be done via C(bigip_command), or, in the GUI of BIG-IP. If using C(bigip_command), this can be done with C(tmsh modify security firewall global-fqdn-policy FOO) where C(FOO) is a DNS resolver configured at C(tmsh create net dns-resolver FOO).
         */
        fqdns?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the address list and entries exists.
         * When C(absent), ensures the address list is removed.
         */
        state?: string;
        /**
         * Specifies the name of the address list.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Reboot a Windows machine, wait for it to go down, come back up, and respond to commands.
       */
      win_reboot?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * A single DNS record that exists on a domain name (i.e. in a managed zone).
       * This record defines the information about the domain and where the domain / subdomains direct to.
       * The record will include the domain/subdomain name, a type (i.e. A, AAA, CAA, MX, CNAME, NS, etc) .
       */
      gcp_dns_resource_record_set?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * As defined in RFC 1035 (section 5) and RFC 1034 (section 3.6.1) .
         */
        target?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * Number of seconds that this ResourceRecordSet can be cached by resolvers.
         */
        ttl?: number | string;
        /**
         * Identifies the managed zone addressed by this request.
         * Can be the managed zone name or id.
         */
        managed_zone: {
          [k: string]: unknown;
        };
        service_account_file?: string;
        /**
         * One of valid DNS resource types.
         */
        type: "A" | "AAAA" | "CAA" | "CNAME" | "MX" | "NAPTR" | "NS" | "PTR" | "SOA" | "SPF" | "SRV" | "TXT";
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * For example, U(www.example.com.)
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure AlertEmailConfig object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_alertemailconfig?: {
        username?: string;
        /**
         * Alerts are sent to the comma separated list of  email recipients.
         */
        to_emails: string;
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * A user-friendly name of the email notification service.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Alerts are copied to the comma separated list of  email recipients.
         */
        cc_emails?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        controller?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        tenant?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM udp monitors.
       */
      bigip_monitor_udp?: {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure UserAccountProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_useraccountprofile?: {
        username?: string;
        /**
         * Maximum number of concurrent sessions allowed.
         * There are unlimited sessions by default.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         */
        max_concurrent_sessions?: number | string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * The time period after which credentials expire.
         * Default is 180 days.
         * Default value when not specified in API or module is interpreted by Avi Controller as 180.
         * Units(DAYS).
         */
        credentials_timeout_threshold?: number | string;
        controller?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Lock timeout period (in minutes).
         * Default is 30 minutes.
         * Default value when not specified in API or module is interpreted by Avi Controller as 30.
         * Units(MIN).
         */
        account_lock_timeout?: number | string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Number of login attempts before lockout.
         * Default is 3 attempts.
         * Default value when not specified in API or module is interpreted by Avi Controller as 3.
         */
        max_login_failure_count?: number | string;
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Maximum number of passwords to be maintained in the password history.
         * Default is 4 passwords.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.
         */
        max_password_history_count?: number | string;
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Name of the object.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about the Scaleway images available.
       */
      scaleway_image_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Adds or removes a user from a MySQL database.
       */
      mysql_user?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Sends arbitrary commands to an RouterOS node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      routeros_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        /**
         * List of commands to send to the remote RouterOS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: "any" | "all";
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of L3 interfaces on Juniper JUNOS network devices.
       */
      junos_l3_interface?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Name of the L3 interface.
         */
        name?: string;
        /**
         * IPv6 of the L3 interface.
         */
        ipv6?: string;
        /**
         * Default: present
         *
         * State of the L3 interface configuration.
         */
        state?: "present" | "absent";
        /**
         * Logical interface number.
         */
        unit?: number | string;
        /**
         * Default: True
         *
         * Specifies whether or not the configuration is active or deactivated
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        /**
         * IPv4 of the L3 interface.
         */
        ipv4?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of L3 interfaces definitions
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, put into maintenance, disable, enable and remove storage pools.
       */
      cs_storage_pool?: {
        [k: string]: unknown;
      };
      /**
       * Allows the addition, modification and deletion of sessions in a consul cluster. These sessions can then be used in conjunction with key value pairs to implement distributed locks. In depth documentation for working with sessions can be found at http://www.consul.io/docs/internals/sessions.html
       */
      consul_session?: {
        /**
         * The name of the node that with which the session will be associated. by default this is the name of the agent.
         */
        node?: string;
        /**
         * The name of the datacenter in which the session exists or should be created.
         */
        datacenter?: string;
        /**
         * The name that should be associated with the session. This is opaque to Consul and not required.
         */
        name?: string;
        /**
         * Default: localhost
         *
         * The host of the consul agent defaults to localhost.
         */
        host?: string;
        /**
         * Default: 8500
         *
         * The port on which the consul agent is running.
         */
        port?: string;
        /**
         * Default: 15
         *
         * The optional lock delay that can be attached to the session when it is created. Locks for invalidated sessions ar blocked from being acquired until this delay has expired. Durations are in seconds.
         */
        delay?: string;
        /**
         * Default: present
         *
         * Whether the session should be present i.e. created if it doesn't exist, or absent, removed if present. If created, the ID for the session is returned in the output. If absent, the name or ID is required to remove the session. Info for a single session, all the sessions for a node or all available sessions can be retrieved by specifying info, node or list for the state; for node or info, the node name or session id is required as parameter.
         */
        state?: string;
        /**
         * Default: release
         *
         * The optional behavior that can be attached to the session when it is created. This controls the behavior when a session is invalidated.
         */
        behavior?: string;
        /**
         * Default: http
         *
         * The protocol scheme on which the consul agent is running.
         */
        scheme?: string;
        /**
         * Default: True
         *
         * Whether to verify the tls certificate of the consul agent.
         */
        validate_certs?: string;
        /**
         * A list of checks that will be used to verify the session health. If all the checks fail, the session will be invalidated and any locks associated with the session will be release and can be acquired once the associated lock delay has expired.
         */
        checks?: string;
        [k: string]: unknown;
      };
      /**
       * Gets the default administrator password from any EC2 Windows instance. The instance is referenced by its id (e.g. C(i-XXXXXXX)). This module has a dependency on python-boto.
       */
      ec2_win_password?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Nokia SR OS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with SR OS configuration sections in a deterministic way.
       */
      sros_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage Jenkins jobs by using Jenkins REST API.
       */
      jenkins_job?: {
        /**
         * Name of the Jenkins job.
         */
        name: string;
        /**
         * Default: http://localhost:8080
         *
         * URL where the Jenkins server is accessible.
         */
        url?: string;
        /**
         * Whether the job should be enabled or disabled.
         * Mutually exclusive with C(config).
         * Considered if C(state=present).
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Attribute that specifies if the job has to be created or deleted.
         */
        state?: "present" | "absent";
        /**
         * API token used to authenticate alternatively to password.
         */
        token?: string;
        /**
         * User to authenticate with the Jenkins server.
         */
        user?: string;
        /**
         * Password to authenticate with the Jenkins server.
         */
        password?: string;
        /**
         * config in XML format.
         * Required if job does not yet exist.
         * Mutually exclusive with C(enabled).
         * Considered if C(state=present).
         */
        config?: string;
        [k: string]: unknown;
      };
      /**
       * Extreme NOS configurations use a simple block indent file syntax for segmenting configuration into sections. This module provides an implementation for working with NOS configuration sections in a deterministic way.
       */
      nos_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages global parameters of NetStream on HUAWEI CloudEngine switches.
       */
      ce_netstream_global?: {
        username?: string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Specifies the netstream statistic direction.
         */
        statistics_direction?: "inbound" | "outbound";
        /**
         * Default: ip
         *
         * Specifies the type of netstream global.
         */
        type?: "ip" | "vxlan";
        /**
         * Default: 16
         *
         * Specifies the netstream index-switch.
         */
        index_switch?: "16" | "32";
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Specifies the netstream sampler interval, length is 1 - 65535.
         */
        sampler_interval?: string;
        /**
         * Specifies the flexible netstream statistic record, length is 1 - 32.
         */
        statistics_record?: string;
        host?: string;
        ssh_keyfile?: string;
        timeout?: number | string;
        /**
         * Specifies the netstream sampler direction.
         */
        sampler_direction?: "inbound" | "outbound";
        /**
         * Netstream global interface.
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Used to make changes to the system wide Audit Policy.
       * It is recommended to take a backup of the policies before adjusting them for the first time.
       * See this page for in depth information U(https://technet.microsoft.com/en-us/library/cc766468.aspx).
       */
      win_audit_policy_system?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Install software maintenance upgrade (smu) RPMS and 3rd party RPMS on Cisco NX-OS devices.
       */
      nxos_rpm?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * If the state is present, the rpm will be installed, If the state is absent, it will be removed.
         */
        state?: "present" | "absent";
        port?: number | string;
        host?: string;
        /**
         * Name of the RPM package.
         */
        pkg?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of RPM/patch definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: bootflash
         *
         * The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.
         */
        file_system?: string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Read the AWS documentation for VPC Peering Connections U(http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-peering.html)
       */
      ec2_vpc_peer?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 VPC subnets in AWS
       */
      ec2_vpc_subnet_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Starts gunicorn with the parameters specified. Common settings for gunicorn configuration are supported. For additional configuration use a config file See U(https://gunicorn-docs.readthedocs.io/en/latest/settings.html) for more options. It's recommended to always use the chdir option to avoid problems with the location of the app.
       */
      gunicorn?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        };
      /**
       * Notify airbrake about app deployments (see http://help.airbrake.io/kb/api-2/deploy-tracking)
       */
      airbrake_deployment?: {
        /**
         * URL of the project repository
         */
        repo?: string;
        /**
         * Default: https://airbrake.io/deploys.txt
         *
         * Optional URL to submit the notification to. Use to send notifications to Airbrake-compliant tools like Errbit.
         */
        url?: string;
        /**
         * The airbrake environment name, typically 'production', 'staging', etc.
         */
        environment: string;
        /**
         * API token.
         */
        token: string;
        /**
         * The username of the person doing the deployment
         */
        user?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A hash, number, tag, or other identifier showing what revision was deployed
         */
        revision?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove YUM repositories in RPM-based Linux distributions.
       * If you wish to update an existing repository definition use M(ini_file) instead.
       */
      yum_repository?: {
        /**
         * Default: whatever
         *
         * Determines how yum resolves host names.
         * C(4) or C(IPv4) - resolve to IPv4 addresses only.
         * C(6) or C(IPv6) - resolve to IPv6 addresses only.
         */
        ip_resolve?: "4" | "6" | "IPv4" | "IPv6" | "whatever";
        /**
         * Default: yes
         *
         * This tells yum whether or not use this repository.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Username to use for proxy.
         */
        proxy_password?: string;
        /**
         * Maximum available network bandwidth in bytes/second. Used with the I(throttle) option.
         * If I(throttle) is a percentage and bandwidth is C(0) then bandwidth throttling will be disabled. If I(throttle) is expressed as a data rate (bytes/sec) then this option is ignored. Default is C(0) (no bandwidth throttling).
         */
        bandwidth?: string;
        /**
         * Default: 1000
         *
         * Relative cost of accessing this repository. Useful for weighing one repo's packages as greater/less than any other.
         */
        cost?: string;
        /**
         * File name without the C(.repo) extension to save the repo in. Defaults to the value of I(name).
         */
        file?: string;
        /**
         * Default: 21600
         *
         * Time (in seconds) after which the mirrorlist locally cached will expire.
         * Default value is 6 hours.
         */
        mirrorlist_expire?: string;
        /**
         * List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed.
         * The list can also be a regular YAML array.
         */
        exclude?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: no
         *
         * This tells yum whether or not HTTP/1.1 keepalive should be used with this repository. This can improve transfer speeds by using one connection when downloading multiple files from a repository.
         */
        keepalive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * This tells yum whether or not it should perform a GPG signature check on the repodata from this repository.
         */
        repo_gpgcheck?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Defines whether yum should verify SSL certificates/hosts at all.
         */
        sslverify?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: roundrobin
         *
         * C(roundrobin) randomly selects a URL out of the list of URLs to start with and proceeds through each of them as it encounters a failure contacting the host.
         * C(priority) starts from the first I(baseurl) listed and reads through them sequentially.
         */
        failovermethod?: "roundrobin" | "priority";
        /**
         * Default: 100
         *
         * When the relative size of deltarpm metadata vs pkgs is larger than this, deltarpm metadata is not downloaded from the repo. Note that you can give values over C(100), so C(200) means that the metadata is required to be half the size of the packages. Use C(0) to turn off this check, and always download metadata.
         */
        deltarpm_metadata_percentage?: string;
        /**
         * A URL pointing to the ASCII-armored GPG key file for the repository.
         * It can also be a list of multiple URLs.
         */
        gpgkey?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: all
         *
         * Determines how upstream HTTP caches are instructed to handle any HTTP downloads that Yum does.
         * C(all) means that all HTTP downloads should be cached.
         * C(packages) means that only RPM package downloads should be cached (but not repository metadata downloads).
         * C(none) means that no HTTP downloads should be cached.
         */
        http_caching?: "all" | "packages" | "none";
        /**
         * Default: 99
         *
         * Enforce ordered protection of repositories. The value is an integer from 1 to 99.
         * This option only works if the YUM Priorities plugin is installed.
         */
        priority?: string;
        /**
         * Default: present
         *
         * State of the repo file.
         */
        state?: "absent" | "present";
        /**
         * Specifies a URL to a file containing a list of baseurls.
         * This, the I(baseurl) or I(metalink) parameters are required if I(state) is set to C(present).
         */
        mirrorlist?: string;
        params?: {
          [k: string]: unknown;
        };
        /**
         * Tells yum whether or not it should perform a GPG signature check on packages.
         * No default setting. If the value is not set, the system setting from C(/etc/yum.conf) or system default of C(no) will be used.
         */
        gpgcheck?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the I(include=) line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected.
         */
        include?: string;
        /**
         * Password for this proxy.
         */
        proxy_username?: string;
        /**
         * Username to use for basic authentication to a repo or really any url.
         */
        username?: string;
        /**
         * Default: 21600
         *
         * Time (in seconds) after which the metadata will expire.
         * Default value is 6 hours.
         */
        metadata_expire?: string;
        /**
         * A human readable string describing the repository. This option corresponds to the "name" property in the repo file.
         * This parameter is only required if I(state) is set to C(present).
         */
        description?: string;
        /**
         * Default: 10
         *
         * Set the number of times any attempt to retrieve a file should retry before returning an error. Setting this to C(0) makes yum try forever.
         */
        retries?: string;
        /**
         * Path to the SSL client certificate yum should use to connect to repos/remote sites.
         */
        sslclientcert?: string;
        /**
         * A URL pointing to the ASCII-armored CA key file for the repository.
         */
        gpgcakey?: string;
        /**
         * URL to the directory where the yum repository's 'repodata' directory lives.
         * It can also be a list of multiple URLs.
         * This, the I(metalink) or I(mirrorlist) parameters are required if I(state) is set to C(present).
         */
        baseurl?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: no
         *
         * Enables support for S3 repositories.
         * This option only works if the YUM S3 plugin is installed.
         */
        s3_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed. Substitution variables (e.g. C($releasever)) are honored here.
         * The list can also be a regular YAML array.
         */
        includepkgs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: yes
         *
         * Determines whether yum will allow the use of package groups for this repository.
         */
        enablegroups?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Password to use with the username for basic authentication.
         */
        password?: string;
        /**
         * Default: releasever basearch
         *
         * When a repository id is displayed, append these yum variables to the string if they are used in the I(baseurl)/etc. Variables are appended in the order listed (and found).
         */
        ui_repoid_vars?: string;
        /**
         * Default: no
         *
         * Protect packages from updates from other repositories.
         */
        protect?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Whether yum should check the permissions on the paths for the certificates on the repository (both remote and local).
         * If we can't read any of the files then yum will force I(skip_if_unavailable) to be C(yes). This is most useful for non-root processes which use yum on repos that have client cert files which are readable only by root.
         */
        ssl_check_cert_permissions?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable bandwidth throttling for downloads.
         * This option can be expressed as a absolute data rate in bytes/sec. An SI prefix (k, M or G) may be appended to the bandwidth value.
         */
        throttle?: string;
        /**
         * Unique repository ID. This option builds the section name of the repository in the repo file.
         * This parameter is only required if I(state) is set to C(present) or C(absent).
         */
        name: string;
        /**
         * Default: 75
         *
         * When the relative size of delta vs pkg is larger than this, delta is not used. Use C(0) to turn off delta rpm processing. Local repositories (with file:// I(baseurl)) have delta rpms turned off by default.
         */
        deltarpm_percentage?: string;
        /**
         * Path to the SSL client key yum should use to connect to repos/remote sites.
         */
        sslclientkey?: string;
        /**
         * Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a I(baseurl).
         * This, the I(baseurl) or I(mirrorlist) parameters are required if I(state) is set to C(present).
         */
        metalink?: string;
        /**
         * Default: /etc/yum.repos.d
         *
         * Directory where the C(.repo) files will be stored.
         */
        reposdir?: string;
        /**
         * Default: no
         *
         * If set to C(yes) yum will continue running if this repository cannot be contacted for any reason. This should be set carefully as all repos are consulted for any given command.
         */
        skip_if_unavailable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * Either C(1) or C(0). Determines whether or not yum keeps the cache of headers and packages after successful installation.
         */
        keepcache?: "0" | "1";
        /**
         * Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates.
         */
        sslcacert?: string;
        /**
         * Default: 30
         *
         * Number of seconds to wait for a connection before timing out.
         */
        timeout?: string;
        /**
         * Default: yes
         *
         * If set to C(yes) Yum will download packages and metadata from this repo in parallel, if possible.
         */
        async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: read-only:present
         *
         * Filter the I(metadata_expire) time, allowing a trade of speed for accuracy if a command doesn't require it. Each yum command can specify that it requires a certain level of timeliness quality from the remote repos. from "I'm about to install/upgrade, so this better be current" to "Anything that's available is good enough".
         * C(never) - Nothing is filtered, always obey I(metadata_expire).
         * C(read-only:past) - Commands that only care about past information are filtered from metadata expiring. Eg. I(yum history) info (if history needs to lookup anything about a previous transaction, then by definition the remote package was available in the past).
         * C(read-only:present) - Commands that are balanced between past and future. Eg. I(yum list yum).
         * C(read-only:future) - Commands that are likely to result in running other commands which will require the latest metadata. Eg. I(yum check-update).
         * Note that this option does not override "yum clean expire-cache".
         */
        metadata_expire_filter?: "never" | "read-only:past" | "read-only:present" | "read-only:future";
        /**
         * URL to the proxy server that yum should use. Set to C(_none_) to disable the global proxy setting.
         */
        proxy?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Interfaces on VyOS network devices.
       */
      vyos_interface?: {
        /**
         * Check the operational state of given interface C(name) for LLDP neighbor.
         * The following suboptions are available.
         */
        neighbors?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        username?: string;
        ssh_keyfile?: string;
        /**
         * Description of Interface.
         */
        description?: string;
        /**
         * Default: auto
         *
         * Interface link status.
         */
        duplex?: "full" | "half" | "auto";
        /**
         * Interface link status.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * State of the Interface configuration, C(up) means present and operationally up and C(down) means present and operationally C(down)
         */
        state?: "present" | "absent" | "up" | "down";
        /**
         * Maximum size of transmit packet.
         */
        mtu?: number | string;
        /**
         * Default: 10
         *
         * Time in seconds to wait before checking for the operational state on remote device. This wait is applicable for operational state argument which are I(state) with values C(up)/C(down) and I(neighbors).
         */
        delay?: number | string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of Interfaces definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        /**
         * Interface link speed.
         */
        speed?: string;
        port?: number | string;
        /**
         * Name of the Interface.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Apstra AOS Template module let you manage your Template easily. You can create create and delete Template by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.
       */
      aos_template?: {
        /**
         * Datastructure of the Template to create. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).
         */
        content?: string;
        /**
         * Default: present
         *
         * Indicate what is the expected state of the Template (present or not).
         */
        state?: "present" | "absent";
        /**
         * An existing AOS session as obtained by M(aos_login) module.
         */
        session: {
          [k: string]: unknown;
        };
        /**
         * AOS Id of the Template to manage (can't be used to create a new Template), Only one of I(name), I(id) or I(src) can be set.
         */
        id?: string;
        /**
         * Name of the Template to manage. Only one of I(name), I(id) or I(src) can be set.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Returns list of matching AMIs with AMI ID, along with other useful information
       * Can search AMIs with different owners
       * Can search by matching tag(s), by AMI name and/or other criteria
       * Results can be sorted and sliced
       */
      ec2_ami_find?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific web app or all web app in a resource group, or all web app in current subscription.
       */
      azure_rm_webapp_facts?: {
        profile?: string;
        /**
         * Only show results for a specific web app.
         */
        name?: string;
        /**
         * Limit results by resource group.
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Indicate wheather to return publishing profile of the web app.
         */
        return_publish_profile?: string;
        cloud_environment?: string;
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Loads and executes a role as a task dynamically. This frees roles from the `roles:` directive and allows them to be treated more as tasks.
       * Unlike M(import_role), most keywords, including loop, with_items, and conditionals, apply to this statement.
       * The do until loop is not supported on M(include_role).
       * This module is also supported for Windows targets.
       */
      include_role?: {
        /**
         * The name of the role to be executed.
         */
        name?: string;
        /**
         * This option is a no op, and the functionality described in previous versions was not implemented. This option will be removed in Ansible v2.8.
         */
        private?: string;
        /**
         * Default: yes
         *
         * Overrides the role's metadata setting to allow using a role more than once with the same parameters.
         */
        allow_duplicates?: string;
        /**
         * Default: main
         *
         * File to load from a role's C(tasks/) directory.
         */
        tasks_from?: string;
        /**
         * Default: main
         *
         * File to load from a role's C(vars/) directory.
         */
        vars_from?: string;
        /**
         * Accepts a hash of task keywords (e.g. C(tags), C(become)) that will be applied to the tasks within the include.
         */
        apply?: string;
        /**
         * Default: main
         *
         * File to load from a role's C(defaults/) directory.
         */
        defaults_from?: string;
        /**
         * Default: no
         *
         * This option dictates whether the role's C(vars) and C(defaults) are exposed to the playbook. If set to C(yes) the variables will be available to tasks following the C(include_role) task. This functionality differs from standard variable exposure for roles listed under the C(roles) header or C(import_role) as they are exposed at playbook parsing time, and available to earlier roles and tasks as well.
         */
        public?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows one to (re)generate OpenSSL public keys from their private keys. It uses the pyOpenSSL python library to interact with openssl. Keys are generated in PEM format. This module works only if the version of PyOpenSSL is recent enough (> 16.0.0).
       */
      openssl_publickey?: {
        /**
         * The passphrase for the private key.
         */
        privatekey_passphrase?: string;
        /**
         * Should the key be regenerated even it it already exists
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: PEM
         *
         * The format of the public key.
         */
        format?: "PEM" | "OpenSSH";
        /**
         * Path to the TLS/SSL private key from which to generate the public key.
         */
        privatekey_path?: string;
        /**
         * Default: present
         *
         * Whether the public key should exist or not, taking action if the state is different from what is stated.
         */
        state?: "present" | "absent";
        /**
         * Name of the file in which the generated TLS/SSL public key will be written.
         */
        path: string;
        [k: string]: unknown;
      };
      /**
       * Creating / deleting and modifying the LIF.
       */
      na_ontap_interface?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module can be used to manage power states of host systems in given vCenter infrastructure.
       * User can set power state to 'power-down-to-standby', 'power-up-from-standby', 'shutdown-host' and 'reboot-host'.
       * State 'reboot-host', 'shutdown-host' and 'power-down-to-standby' are not supported by all the host systems.
       */
      vmware_host_powerstate?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages Sensu client configuration.
       * For more information, refer to the Sensu documentation: U(https://sensuapp.org/docs/latest/reference/clients.html)
       */
      sensu_client?: {
        /**
         * Default: no
         *
         * If a deregistration event should be created upon Sensu client process stop.
         */
        deregister?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * If Sensu should monitor keepalives for this client.
         */
        keepalives?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The socket definition scope, used to configure the Sensu client socket.
         */
        socket?: {
          [k: string]: unknown;
        };
        /**
         * An array of client subscriptions, a list of roles and/or responsibilities assigned to the system (e.g. webserver).
         * These subscriptions determine which monitoring checks are executed by the client, as check requests are sent to subscriptions.
         * The subscriptions array items must be strings.
         */
        subscriptions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: Non-loopback IPv4 address as determined by Ruby Socket.ip_address_list (provided by Sensu)
         *
         * An address to help identify and reach the client. This is only informational, usually an IP address or hostname.
         */
        address?: string;
        /**
         * The chef definition scope, used to configure the Sensu Enterprise Chef integration (Sensu Enterprise users only).
         */
        chef?: {
          [k: string]: unknown;
        };
        /**
         * Client definition attributes to redact (values) when logging and sending client keepalives.
         */
        redact?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Whether the client should be present or not
         */
        state?: "present" | "absent";
        /**
         * The puppet definition scope, used to configure the Sensu Enterprise Puppet integration (Sensu Enterprise users only).
         */
        puppet?: {
          [k: string]: unknown;
        };
        /**
         * The ec2 definition scope, used to configure the Sensu Enterprise AWS EC2 integration (Sensu Enterprise users only).
         */
        ec2?: {
          [k: string]: unknown;
        };
        /**
         * Default: no
         *
         * If safe mode is enabled for the client. Safe mode requires local check definitions in order to accept a check request and execute the check.
         */
        safe_mode?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The registration definition scope, used to configure Sensu registration event handlers.
         */
        registration?: {
          [k: string]: unknown;
        };
        /**
         * The keepalive definition scope, used to configure Sensu client keepalives behavior (e.g. keepalive thresholds, etc).
         */
        keepalive?: {
          [k: string]: unknown;
        };
        /**
         * The deregistration definition scope, used to configure automated Sensu client de-registration.
         */
        deregistration?: {
          [k: string]: unknown;
        };
        /**
         * The servicenow definition scope, used to configure the Sensu Enterprise ServiceNow integration (Sensu Enterprise users only).
         */
        servicenow?: {
          [k: string]: unknown;
        };
        /**
         * Default: System hostname as determined by Ruby Socket.gethostname (provided by Sensu)
         *
         * A unique name for the client. The name cannot contain special characters or spaces.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Layer-2 interface on Mellanox ONYX network devices.
       */
      onyx_l2_interface?: {
        /**
         * Configure given VLAN in access port.
         */
        access_vlan?: number | string;
        /**
         * Name of the interface.
         */
        name?: string;
        /**
         * Default: present
         *
         * State of the Layer-2 Interface configuration.
         */
        state?: "present" | "absent";
        /**
         * List of allowed VLANs in a given trunk port.
         */
        trunk_allowed_vlans?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: access
         *
         * Mode in which interface needs to be configured.
         */
        mode?: "access" | "trunk" | "hybrid";
        /**
         * List of Layer-2 interface definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Lists or describes services in ecs.
       */
      ecs_service_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, destroy, or update accounts on SolidFire
       */
      sf_account_manager?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Retrieve facts about one or more oVirt/RHV vmpools.
       */
      ovirt_vmpool_facts?: {
        /**
         * Search term which is accepted by oVirt/RHV search backend.
         * For example to search vmpool X: name=X
         */
        pattern?: string;
        [k: string]: unknown;
      };
      /**
       * Launches or updates an AWS CloudFormation stack and waits for it complete.
       */
      cloudformation?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure MicroServiceGroup object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_microservicegroup?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Uuid of the microservice group.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Creator name.
         */
        created_by?: string;
        /**
         * Name of the microservice group.
         */
        name: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        /**
         * Configure microservice(es).
         * It is a reference to an object of type microservice.
         */
        service_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * This module generates a self-signed certificate that can be used by GlobalProtect client, SSL connector, or
       * otherwise. Root certificate must be preset on the system first. This module depends on paramiko for ssh.
       */
      panos_cert_gen_ssh?: {
        /**
         * Human friendly certificate name (not CN but just a friendly name).
         */
        cert_friendly_name: string;
        /**
         * Location of the filename that is used for the auth. Either I(key_filename) or I(password) is required.
         */
        key_filename?: string;
        /**
         * Default: 2048
         *
         * Number of bits used by the RSA algorithm for the certificate generation.
         */
        rsa_nbits?: string;
        /**
         * Undersigning authority (CA) that MUST already be presents on the device.
         */
        signed_by: string;
        /**
         * Password credentials to use for auth. Either I(key_filename) or I(password) is required.
         */
        password?: string;
        /**
         * IP address (or hostname) of PAN-OS device being configured.
         */
        ip_address: string;
        /**
         * Certificate CN (common name) embedded in the certificate signature.
         */
        cert_cn: string;
        [k: string]: unknown;
      };
      /**
       * This module manages compute instances on Scaleway.
       */
      scaleway_compute?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        };
      /**
       * Installs or uninstalls a Windows MSI file that is already located on the target server.
       */
      win_msi?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage dynamic, cluster-wide parameters for RabbitMQ
       */
      rabbitmq_parameter?: {
        /**
         * Default: rabbit
         *
         * erlang node name of the rabbit we wish to configure
         */
        node?: string;
        /**
         * Name of the parameter being set
         */
        name: string;
        /**
         * Name of the component of which the parameter is being set
         */
        component: string;
        /**
         * Value of the parameter, as a JSON term
         */
        value?: string;
        /**
         * Default: /
         *
         * vhost to apply access privileges.
         */
        vhost?: string;
        /**
         * Default: present
         *
         * Specify if user is to be added or removed
         */
        state?: "present" | "absent";
        [k: string]: unknown;
      };
      /**
       * Manage OSPF interface policies on Cisco ACI fabrics.
       */
      aci_interface_policy_ospf?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * This module can be used to gather facts about an ESXi host's DNS configuration information when ESXi hostname or Cluster name is given.
       * All parameters and VMware object names are case sensitive.
       */
      vmware_host_dns_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Security policies allow you to enforce rules and take action, and can be as general or specific as needed. The policy rules are compared against the incoming traffic in sequence, and because the first rule that matches the traffic is applied, the more specific rules must precede the more general ones.
       */
      panos_security_rule?: {
        /**
         * Name of the already defined wildfire_analysis profile.
         */
        wildfire_analysis?: string;
        /**
         * Name of the already defined vulnerability profile.
         */
        vulnerability?: string;
        /**
         * Name of the already defined spyware profile.
         */
        spyware?: string;
        /**
         * Default: any
         *
         * - If you are using GlobalProtect with host information profile (HIP) enabled, you can also base the policy on information collected by GlobalProtect. For example, the user access level can be determined HIP that notifies the firewall about the user's local configuration.
         *
         */
        hip_profiles?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the already defined file_blocking profile.
         */
        file_blocking?: string;
        /**
         * Whether to log at session start.
         */
        log_start?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: add
         *
         * The action to be taken.  Supported values are I(add)/I(update)/I(find)/I(delete).
         */
        operation?: "add" | "update" | "delete" | "find";
        /**
         * Name of the already defined data_filtering profile.
         */
        data_filtering?: string;
        category?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: application-default
         *
         * List of services.
         */
        service?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: any
         *
         * List of applications.
         */
        application?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: any
         *
         * Use users to enforce policy for individual users or a group of users.
         */
        source_user?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the already defined url_filtering profile.
         */
        url_filtering?: string;
        /**
         * Default: any
         *
         * List of destination zones.
         */
        destination_zone?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * - Security profile group that is already defined in the system. This property supersedes antivirus, vulnerability, spyware, url_filtering, file_blocking, data_filtering, and wildfire_analysis properties.
         *
         */
        group_profile?: string;
        /**
         * API key that can be used instead of I(username)/I(password) credentials.
         */
        api_key?: string;
        /**
         * Default: admin
         *
         * Username credentials to use for auth unless I(api_key) is set.
         */
        username?: string;
        /**
         * Default: any
         *
         * List of destination addresses.
         */
        destination_ip?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * - Device groups are used for the Panorama interaction with Firewall(s). The group must exists on Panorama. If device group is not define we assume that we are contacting Firewall.
         *
         */
        devicegroup?: string;
        /**
         * Description for the security rule.
         */
        description?: string;
        /**
         * Name of the already defined antivirus profile.
         */
        antivirus?: string;
        /**
         * Name of the security rule.
         */
        rule_name: string;
        /**
         * Password credentials to use for auth unless I(api_key) is set.
         */
        password?: string;
        /**
         * IP address (or hostname) of PAN-OS device being configured.
         */
        ip_address: string;
        /**
         * Default: universal
         *
         * Type of security rule (version 6.1 of PanOS and above).
         */
        rule_type?: string;
        /**
         * Default: any
         *
         * List of source zones.
         */
        source_zone?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: any
         *
         * List of source addresses.
         */
        source_ip?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Administrative tags that can be added to the rule. Note, tags must be already defined.
         */
        tag_name?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: allow
         *
         * Action to apply once rules maches.
         */
        action?: string;
        /**
         * Default: yes
         *
         * Commit configuration if changed.
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: True
         *
         * Whether to log at session end.
         */
        log_end?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages configuration of an OSPF VPN instance on HUAWEI CloudEngine switches.
       */
      ce_ospf_vrf?: {
        /**
         * Specifies the hold interval of originate LSA . Valid value is an integer, in millisecond, from 0 to 5000, the default value is 1000.
         */
        lsaoholdinterval?: string;
        /**
         * Specifies the reference bandwidth used to assign ospf cost. Valid values are an integer, in Mbps, 1 - 2147483648, the default value is 100.
         */
        bandwidth?: string;
        /**
         * Specifies the interval to calculate SPF when use millisecond level  timer. Valid value is an integer, in millisecond, from 1 to 10000.
         */
        spfintervalmi?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Specifies the max interval of originate LSA . Valid value is an integer, in millisecond, from 1 to 10000, the default value is 5000.
         */
        lsaomaxinterval?: string;
        /**
         * Specifies the max interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 1000.
         */
        lsaamaxinterval?: string;
        /**
         * Specifies the start interval of originate LSA . Valid value is an integer, in millisecond, from 0 to 1000, the default value is 500.
         */
        lsaostartinterval?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Specifies the hold interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 5000, the default value is 200.
         */
        spfholdinterval?: string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Specifies the hold interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 500.
         */
        lsaaholdinterval?: string;
        username?: string;
        /**
         * Specifies the interval of originate LSA . Valid value is an integer, in second, from 0 to 10, the default value is 5.
         */
        lsaointerval?: string;
        /**
         * Specifies the description information of ospf process.
         */
        description?: string;
        /**
         * Default: no
         *
         * Specifies the mode of timer to calculate interval of arrive LSA. If set the parameter but not specifies value, the default will be used. If true use general timer. If false use intelligent timer.
         */
        lsaalflag?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        /**
         * Default: _public_
         *
         * Specifies the vpn instance which use ospf,length is 1 - 31. Valid values are a string.
         */
        vrf?: string;
        /**
         * Default: no
         *
         * Specifies whether cancel the interval of LSA originate or not. If set the parameter but noe specifies value, the default will be used. true:cancel the interval of LSA originate, the interval is 0. false:do not cancel the interval of LSA originate.
         */
        lsaointervalflag?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        /**
         * Specifies the start interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 500.
         */
        lsaastartinterval?: string;
        ssh_keyfile?: string;
        /**
         * The ID of the ospf process. Valid values are an integer, 1 - 4294967295, the default value is 1.
         */
        ospf: string;
        /**
         * Default: intelligent-timer
         *
         * Specifies the mode of timer which used to calculate SPF. If set the parameter but noe specifies value, the default will be used. If is intelligent-timer, then use intelligent timer. If is timer, then use second level timer. If is millisecond, then use millisecond level timer.
         */
        spfintervaltype?: "intelligent-timer" | "timer" | "millisecond";
        /**
         * Specifies the interval of arrive LSA when use the general timer. Valid value is an integer, in millisecond, from 0 to 10000.
         */
        lsaainterval?: string;
        /**
         * Specifies the start interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 1000, the default value is 50.
         */
        spfstartinterval?: string;
        /**
         * Specifies the ospf private route id,. Valid values are a string, formatted as an IP address (i.e. "10.1.1.1") the length is 0 - 20.
         */
        route_id?: string;
        /**
         * Specifies the max interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 20000, the default value is 5000.
         */
        spfmaxinterval?: string;
        timeout?: number | string;
        /**
         * Specifies the interval to calculate SPF when use second level  timer. Valid value is an integer, in second, from 1 to 10.
         */
        spfinterval?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * LogicMonitor is a hosted, full-stack, infrastructure monitoring platform.
       * This module manages hosts, host groups, and collectors within your LogicMonitor account.
       */
      logicmonitor?: {
        /**
         * Default: hostname -f
         *
         * The display name of a host in your LogicMonitor account or the desired display name of a device to manage.
         * Optional for managing hosts (target=host).
         */
        displayname?: string;
        /**
         * The long text description of the object in your LogicMonitor account.
         * Optional for managing hosts and host groups (target=host or target=hostgroup; action=add or action=update).
         */
        description?: string;
        /**
         * The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes."
         */
        company: string;
        /**
         * Default: hostname -f
         *
         * The hostname of a host in your LogicMonitor account, or the desired hostname of a device to manage.
         * Optional for managing hosts (target=host).
         */
        hostname?: string;
        /**
         * The fullpath of the host group object you would like to manage.
         * Recommend running on a single Ansible host.
         * Required for management of LogicMonitor host groups (target=hostgroup).
         */
        fullpath?: string;
        /**
         * A dictionary of properties to set on the LogicMonitor host or host group.
         * Optional for managing hosts and host groups (target=host or target=hostgroup; action=add or action=update).
         * This parameter will add or update existing properties in your LogicMonitor account.
         */
        properties?: {
          [k: string]: unknown;
        };
        /**
         * The action you wish to perform on target.
         * Add: Add an object to your LogicMonitor account.
         * Remove: Remove an object from your LogicMonitor account.
         * Update: Update properties, description, or groups (target=host) for an object in your LogicMonitor account.
         * SDT: Schedule downtime for an object in your LogicMonitor account.
         */
        action: "add" | "remove" | "update" | "sdt";
        /**
         * A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.
         */
        user: string;
        /**
         * A list of groups that the host should be a member of.
         * Optional for managing hosts (target=host; action=add or action=update).
         */
        groups?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 30
         *
         * The duration (minutes) of the Scheduled Down Time (SDT).
         * Optional for putting an object into SDT (action=sdt).
         */
        duration?: string;
        /**
         * Default: yes
         *
         * A boolean flag to turn alerting on or off for an object.
         * Optional for managing all hosts (action=add or action=update).
         */
        alertenable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: Now
         *
         * The time that the Scheduled Down Time (SDT) should begin.
         * Optional for managing SDT (action=sdt).
         * Y-m-d H:M
         */
        starttime?: string;
        /**
         * The password of the specified LogicMonitor user
         */
        password: string;
        /**
         * The fully qualified domain name of a collector in your LogicMonitor account.
         * This is required for the creation of a LogicMonitor host (target=host action=add).
         * This is required for updating, removing or scheduling downtime for hosts if 'displayname' isn't specified (target=host action=update action=remove action=sdt).
         */
        collector?: string;
        /**
         * ID of the datasource to target.
         * Required for management of LogicMonitor datasources (target=datasource).
         */
        id?: string;
        /**
         * The type of LogicMonitor object you wish to manage.
         * Collector: Perform actions on a LogicMonitor collector.
         * NOTE You should use Ansible service modules such as M(service) or M(supervisorctl) for managing the Collector 'logicmonitor-agent' and 'logicmonitor-watchdog' services. Specifically, you'll probably want to start these services after a Collector add and stop these services before a Collector remove.
         * Host: Perform actions on a host device.
         * Hostgroup: Perform actions on a LogicMonitor host group.
         * NOTE Host and Hostgroup tasks should always be performed via delegate_to: localhost. There are no benefits to running these tasks on the remote host and doing so will typically cause problems.
         *
         */
        target: "collector" | "host" | "datasource" | "hostgroup";
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running EdgeOS. This module prepends all of the base network fact keys with U(ansible_net_<fact>). The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      edgeos_facts?: {
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset. Possible values for this argument include all, default, config, and neighbors. Can specify a list of values to include a larger subset. Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about local role facts on an ESXi host
       */
      vmware_local_role_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows you to search for Zabbix host entries.
       */
      zabbix_host_facts?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Create snapshots of the running states of selected features, add new show commands for snapshot creation, delete and compare existing snapshots.
       */
      nxos_snapshot?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Snapshot name, to be used when C(action=create) or C(action=delete).
         */
        snapshot_name?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        /**
         * Used to name the show command output, to be used when C(action=add).
         */
        section?: string;
        auth_pass?: string;
        /**
         * Specify a new show command, to be used when C(action=add).
         */
        show_command?: string;
        /**
         * Specify the tags used to distinguish among row entries, to be used when C(action=add).
         */
        element_key1?: string;
        /**
         * Specify the tags used to distinguish among row entries, to be used when C(action=add).
         */
        element_key2?: string;
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * Snapshot description to be used when C(action=create).
         */
        description?: string;
        /**
         * First snapshot to be used when C(action=compare).
         */
        snapshot1?: string;
        /**
         * Second snapshot to be used when C(action=compare).
         */
        snapshot2?: string;
        host?: string;
        /**
         * Default: ./
         *
         * Specify the path of the file where new created snapshot or snapshots comparison will be stored, to be used when C(action=create) and C(save_snapshot_locally=true) or C(action=compare).
         */
        path?: string;
        password?: string;
        /**
         * Snapshot options to be used when C(action=compare).
         */
        compare_option?: "summary" | "ipv4routes" | "ipv6routes";
        ssh_keyfile?: string;
        /**
         * Default: no
         *
         * Specify to locally store a new created snapshot, to be used when C(action=create).
         */
        save_snapshot_locally?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the file where snapshots comparison will be stored when C(action=compare).
         */
        comparison_results_file?: string;
        timeout?: number | string;
        /**
         * Define what snapshot action the module would perform.
         */
        action: "add" | "compare" | "create" | "delete" | "delete_all";
        /**
         * Specifies the tag of each row entry of the show command's XML output, to be used when C(action=add).
         */
        row_id?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Copy a file to a remote cloudengine device over SCP on HUAWEI CloudEngine switches.
       */
      ce_file_copy?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Path to local file. Local directory must exist. The maximum length of I(local_file) is C(4096).
         */
        local_file: string;
        /**
         * Remote file path of the copy. Remote directories must exist. If omitted, the name of the local file will be used. The maximum length of I(remote_file) is C(4096).
         */
        remote_file?: string;
        /**
         * Default: flash:
         *
         * The remote file system of the device. If omitted, devices that support a I(file_system) parameter will use their default values. File system indicates the storage medium and can be set to as follows, 1) C(flash) is root directory of the flash memory on the master MPU. 2) C(slave#flash) is root directory of the flash memory on the slave MPU. If no slave MPU exists, this drive is unavailable. 3) C(chassis ID/slot number#flash) is root directory of the flash memory on a device in a stack. For example, C(1/5#flash) indicates the flash memory whose chassis ID is 1 and slot number is 5.
         */
        file_system?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Manages "spells" on Source Mage GNU/Linux using I(sorcery) toolchain
       */
      sorcery?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about all installed images on SmartOS. Facts will be inserted to the ansible_facts key.
       */
      smartos_image_facts?: {
        /**
         * Criteria for selecting image. Can be any value from image manifest and 'published_date', 'published', 'source', 'clones', and 'size'. More informaton can be found at U(https://smartos.org/man/1m/imgadm) under 'imgadm list'.
         */
        filters?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP TargetPool
       */
      gcp_compute_target_pool_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * The region where the target pool resides.
         */
        region: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        service_account_file?: string;
        [k: string]: unknown;
      };
      /**
       * Manage I(git) checkouts of repositories to deploy files or software.
       */
      git?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Modify a ONTAP broadcast domain.
       */
      na_ontap_broadcast_domain?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create, update or delete an Azure Function App
       */
      azure_rm_functionapp?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Gather facts about the Scaleway ips available.
       */
      scaleway_ip_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * The C(known_hosts) module lets you add or remove a host keys from the C(known_hosts) file.
       * Starting at Ansible 2.2, multiple entries per host are allowed, but only one for each key type supported by ssh. This is useful if you're going to want to use the M(git) module over ssh, for example.
       * If you have a very large number of host keys to manage, you will find the M(template) module more useful.
       */
      known_hosts?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module provides declarative management of VLANs on network devices.
       */
      net_vlan?: {
        [k: string]: unknown;
      };
      /**
       * Create, update and delete instance of SQL Database.
       */
      azure_rm_sqldatabase?: {
        /**
         * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
         */
        resource_group: string;
        adfs_authority_url?: string;
        cloud_environment?: string;
        secret?: string;
        /**
         * Required if I(create_mode) is C(restore_long_term_retention_backup), then this value is required. Specifies the resource ID of the recovery point to restore from.
         */
        recovery_services_recovery_point_resource_id?: string;
        /**
         * The edition of the database. The DatabaseEditions enumeration contains all the valid editions. If I(create_mode) is C(non_readable_secondary) or C(online_secondary), this value is ignored. To see possible values, query the capabilities API (/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationID}/capabilities) referred to by operationId: 'Capabilities_ListByLocation.'.
         */
        edition?:
          | "web"
          | "business"
          | "basic"
          | "standard"
          | "premium"
          | "free"
          | "stretch"
          | "data_warehouse"
          | "system"
          | "system2";
        /**
         * Is this database is zone redundant? It means the replicas of this database will be spread across multiple availability zones.
         */
        zone_redundant?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the server.
         */
        server_name: string;
        /**
         * Specifies the mode of database creation.
         * C(default): regular database creation.
         * C(copy): creates a database as a copy of an existing database.
         * C(online_secondary)/C(non_readable_secondary): creates a database as a (readable or nonreadable) secondary replica of an existing database.
         * C(point_in_time_restore): Creates a database by restoring a point in time backup of an existing database.
         * C(recovery): Creates a database by restoring a geo-replicated backup.
         * C(restore): Creates a database by restoring a backup of a deleted database.
         * C(restore_long_term_retention_backup): Creates a database by restoring from a long term retention vault.
         * C(copy), C(non_readable_secondary), C(online_secondary) and C(restore_long_term_retention_backup) are not supported for C(data_warehouse) edition.
         */
        create_mode?:
          | "copy"
          | "default"
          | "non_readable_secondary"
          | "online_secondary"
          | "point_in_time_restore"
          | "recovery"
          | "restore"
          | "restore_long_term_retention_backup";
        /**
         * Required if I(create_mode) is C(restore) and I(source_database_id) is the deleted database's original resource id when it existed (as opposed to its current restorable dropped database id), then this value is required. Specifies the time that the database was deleted.
         */
        source_database_deletion_date?: string;
        ad_user?: string;
        /**
         * Default: present
         *
         * Assert the state of the SQL Database. Use 'present' to create or update an SQL Database and 'absent' to delete it.
         */
        state?: "absent" | "present";
        /**
         * Required unless I(create_mode) is C(default) or C(restore_long_term_retention_backup).
         * Specifies the resource ID of the source database
         */
        source_database_id?: string;
        cert_validation_mode?: "validate" | "ignore";
        /**
         * Resource location. If not set, location from the resource group will be used as C(default).
         */
        location?: string;
        /**
         * Indicates the name of the sample schema to apply when creating this database. If I(create_mode) is not C(default), this value is ignored. Not supported for C(data_warehouse) edition.
         */
        sample_name?: "adventure_works_lt";
        subscription_id?: string;
        /**
         * If the database is a geo-secondary, indicates whether read-only connections are allowed to this database or not. Not supported for C(data_warehouse) edition.
         */
        read_scale?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        profile?: string;
        /**
         * Required if I(create_mode) is C(point_in_time_restore), this value is required. If I(create_mode) is C(restore), this value is optional. Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database. Must be greater than or equal to the source database's earliestRestoreDate value.
         */
        restore_point_in_time?: string;
        /**
         * The name of the elastic pool the database is in. Not supported for C(data_warehouse) edition.
         */
        elastic_pool_name?: string;
        client_id?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        /**
         * The collation of the database. If I(create_mode) is not C(default), this value is ignored.
         */
        collation?: string;
        password?: string;
        tenant?: string;
        /**
         * The name of the database to be operated on (updated or created).
         */
        name: string;
        /**
         * SQL Database will be updated if given parameters differ from existing resource state.
         * To force SQL Database update in any circumstances set this parameter to True.
         */
        force_update?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_profile?: string;
        /**
         * The max size of the database expressed in bytes. If I(create_mode) is not C(default), this value is ignored. To see possible values, query the capabilities API (/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationID}/capabilities) referred to by operationId: 'Capabilities_ListByLocation.'
         */
        max_size_bytes?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts for a device using SNMP, the facts will be inserted to the ansible_facts key.
       */
      snmp_facts?: {
        /**
         * Username for SNMPv3, required if version is v3
         */
        username?: string;
        /**
         * Encryption algorithm, required if level is authPriv
         */
        privacy?: "des" | "aes";
        /**
         * Authentication level, required if version is v3
         */
        level?: "authPriv" | "authNoPriv";
        /**
         * The SNMP community string, required if version is v2/v2c
         */
        community?: string;
        /**
         * Authentication key, required if version is v3
         */
        authkey?: string;
        /**
         * Set to target snmp server (normally {{inventory_hostname}})
         */
        host: string;
        /**
         * SNMP Version to use, v2/v2c or v3
         */
        version: "v2" | "v2c" | "v3";
        /**
         * Hashing algorithm, required if version is v3
         */
        integrity?: "md5" | "sha";
        removeplaceholder?: string;
        /**
         * Encryption key, required if version is authPriv
         */
        privkey?: string;
        [k: string]: unknown;
      };
      /**
       * Extreme EXOS configurations use a simple flat text file syntax. This module provides an implementation for working with EXOS configuration lines in a deterministic way.
       */
      exos_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This will configure both login and motd banners on remote devices running Arista EOS.  It allows playbooks to add or remote banner text from the active running configuration.
       */
      eos_banner?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string. Requires I(state=present).
         */
        text?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Specifies whether or not the configuration is present in the current devices active running configuration.
         */
        state?: "present" | "absent";
        /**
         * Specifies which banner that should be configured on the remote device.
         */
        banner: "login" | "motd";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "eapi";
        [k: string]: unknown;
      };
      /**
       * Create and remove network ACLs.
       */
      cs_network_acl?: {
        /**
         * Account the network ACL rule is related to.
         */
        account?: string;
        api_key?: string;
        /**
         * Default: yes
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        /**
         * Description of the network ACL.
         * If not set, identical to C(name).
         */
        description?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Name of the project the network ACL is related to.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the network ACL.
         */
        state?: "present" | "absent";
        /**
         * Domain the network ACL rule is related to.
         */
        domain?: string;
        /**
         * Name of the zone the VPC is related to.
         * If not set, default zone is used.
         */
        zone?: string;
        /**
         * VPC the network ACL is related to.
         */
        vpc: string;
        /**
         * Name of the network ACL.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Mellanox ONYX configurations uses a simple block indent file syntax for segmenting configuration into sections. This module provides an implementation for working with ONYX configuration sections in a deterministic way.
       */
      onyx_config?: {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV templates.
       */
      ovirt_template_facts?: {
        /**
         * Search term which is accepted by oVirt/RHV search backend.
         * For example to search template X from datacenter Y use following pattern: name=X and datacenter=Y
         */
        pattern?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts from ZFS pool properties.
       */
      zpool_facts?: {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of VRFs on network devices.
       */
      net_vrf?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host: string;
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * This module can create and destroy Google Compute Engine networks and firewall rules U(https://cloud.google.com/compute/docs/networking). The I(name) parameter is reserved for referencing a network while the I(fwname) parameter is used to reference firewall rules. IPv4 Address ranges must be specified using the CIDR U(http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) format. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.
       */
      gce_net?: {
        /**
         * the source instance tags for creating a firewall rule
         */
        src_tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * region of subnet to create
         */
        subnet_region?: string;
        /**
         * name of the network
         */
        name?: string;
        /**
         * Default: present
         *
         * desired state of the network or firewall
         */
        state?: string;
        /**
         * the source IPv4 address range in CIDR notation
         */
        src_range?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * path to the JSON file associated with the service account email
         */
        credentials_file?: string;
        /**
         * the IPv4 address range in CIDR notation for the network this parameter is not mandatory when you specified existing network in name parameter, but when you create new network, this parameter is mandatory
         */
        ipv4_range?: string;
        /**
         * name of the firewall rule
         */
        fwname?: string;
        /**
         * path to the pem file associated with the service account email This option is deprecated. Use C(credentials_file).
         */
        pem_file?: string;
        /**
         * the target instance tags for creating a firewall rule
         */
        target_tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * name of subnet to create
         */
        subnet_name?: string;
        /**
         * Default: legacy
         *
         * network mode for Google Cloud C(legacy) indicates a network with an IP address range; C(auto) automatically generates subnetworks in different regions; C(custom) uses networks to group subnets of user specified IP address ranges https://cloud.google.com/compute/docs/networking#network_types
         */
        mode?: "legacy" | "auto" | "custom";
        /**
         * the protocol:ports to allow (I(tcp:80) or I(tcp:80,443) or I(tcp:80-800;udp:1-25)) this parameter is mandatory when creating or updating a firewall rule
         */
        allowed?: string;
        /**
         * service account email
         */
        service_account_email?: string;
        /**
         * your GCE project ID
         */
        project_id?: string;
        /**
         * description of subnet to create
         */
        subnet_desc?: string;
        [k: string]: unknown;
      };
      /**
       * Configures route settings for the management interface of a BIG-IP.
       */
      bigip_management_route?: {
        /**
         * Description of the management route.
         */
        description?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the name of the management route.
         */
        name?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the resource exists.
         * When C(absent), ensures the resource is removed.
         */
        state?: string;
        /**
         * Specifies that the system forwards packets to the destination through the gateway with the specified IP address.
         */
        gateway?: string;
        /**
         * The subnet and netmask to be used for the route.
         * To specify that the route is the default route for the system, provide the value C(default).
         * Only one C(default) entry is allowed.
         * This parameter cannot be changed after it is set. Therefore, if you do need to change it, it is required that you delete and create a new route.
         */
        network?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to manage administrator permission for the local administrative account for the host when ESXi hostname is given.
       * All parameters and VMware objects values are case sensitive.
       * This module is destructive as administrator permission are managed using APIs used, please read options carefully and proceed.
       * Please specify C(hostname) as vCenter IP or hostname only, as lockdown operations are not possible from standalone ESXi server.
       */
      vmware_host_lockdown?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and delete Azure Traffic Manager endpoint.
       */
      azure_rm_trafficmanagerendpoint?: {
        /**
         * The weight of this endpoint when traffic manager profile has routing_method of C(weighted).
         * Possible values are from 1 to 1000.
         */
        weight?: number | string;
        cloud_environment?: string;
        /**
         * Name of Traffic Manager profile where this endpoints attaches to.
         */
        profile_name: string;
        /**
         * The Azure Resource URI of the of the endpoint.
         * Not applicable to endpoints of I(type) C(external_endpoints).
         */
        target_resource_id?: string;
        /**
         * Name of a resource group where the Traffic Manager endpoint exists or will be created.
         */
        resource_group: string;
        /**
         * The minimum number of endpoints that must be available in the child profile in order for the parent profile to be considered available.
         * Only applicable to endpoint of I(type) (nested_endpoints).
         */
        min_child_endpoints?: number | string;
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        /**
         * The priority of this endpoint when traffic manager profile has routing_method of C(priority).
         * Possible values are from 1 to 1000, lower values represent higher priority.
         * This is an optional parameter. If specified, it must be specified on all endpoints.
         * No two endpoints can share the same priority value.
         */
        priority?: number | string;
        secret?: string;
        /**
         * Specifies the location of the external or nested endpoints when using the 'Performance' traffic routing method.
         */
        location?: string;
        subscription_id?: string;
        /**
         * The type of the endpoint.
         */
        type: "azure_endpoints" | "external_endpoints" | "nested_endpoints";
        profile?: string;
        /**
         * Default: present
         *
         * Assert the state of the Traffic Manager endpoint. Use C(present) to create or update a Traffic Manager endpoint and C(absent) to delete it.
         */
        state?: "absent" | "present";
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        tenant?: string;
        /**
         * The name of the endpoint.
         */
        name: string;
        /**
         * The fully-qualified DNS name of the endpoint.
         */
        target?: string;
        /**
         * Default: True
         *
         * The status of the endpoint.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The list of countries/regions mapped to this endpoint when traffic manager profile has routing_method of C(geographic).
         */
        geo_mapping?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        [k: string]: unknown;
      };
      /**
       * Manage OpenStack Quotas. Quotas can be created, updated or deleted using this module. A quota will be updated if matches an existing project and is present.
       */
      os_quota?: {
        /**
         * Number of LVM snapshots to allow.
         */
        snapshots_lvm?: string;
        /**
         * Number of server groups to allow.
         */
        server_groups?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Maximum amount of ram in MB to allow.
         */
        ram?: string;
        /**
         * Number of snapshots to allow.
         */
        snapshots?: string;
        /**
         * Maximum number of instances allowed.
         */
        instances?: string;
        /**
         * Maximum number of backups allowed.
         */
        backups?: string;
        /**
         * Number of fixed IP's to allow.
         */
        fixed_ips?: string;
        /**
         * Number of Network ports to allow, this needs to be greater than the instances limit.
         */
        port?: string;
        /**
         * Number of subnets to allow.
         */
        subnet?: string;
        /**
         * Maximum size in GB's of individual volumes.
         */
        per_volume_gigabytes?: string;
        /**
         * Number of networks to allow.
         */
        network?: string;
        /**
         * Number of floating IP's to allow in Network.
         */
        floatingip?: string;
        /**
         * Number of LVM volumes to allow.
         */
        volumes_lvm?: string;
        /**
         * Number of floating IP's to allow in Compute.
         */
        floating_ips?: string;
        /**
         * Number of rules per security group to allow.
         */
        security_group_rule?: string;
        /**
         * Default: present
         *
         * A value of present sets the quota and a value of absent resets the quota to system defaults.
         */
        state?: string;
        /**
         * Number of injected files to allow.
         */
        injected_files?: string;
        /**
         * Maximum size in GB's of individual lvm volumes.
         */
        gigabytes_lvm?: string;
        /**
         * Maximum path size.
         */
        injected_path_size?: string;
        /**
         * Maximum volume storage allowed for project.
         */
        gigabytes?: string;
        /**
         * Maximum size of backups in GB's.
         */
        backup_gigabytes?: string;
        /**
         * Number of subnet pools to allow.
         */
        subnetpool?: string;
        /**
         * Number of key pairs to allow.
         */
        key_pairs?: string;
        /**
         * Number of policies to allow.
         */
        rbac_policy?: string;
        /**
         * Maximum file size in bytes.
         */
        injected_file_size?: string;
        /**
         * Number of routers to allow.
         */
        router?: string;
        /**
         * Number of properties to allow.
         */
        properties?: string;
        /**
         * Number of load balancer pools to allow.
         */
        pool?: string;
        /**
         * Number of server group members to allow.
         */
        server_group_members?: string;
        /**
         * Name of the OpenStack Project to manage.
         */
        name?: string;
        /**
         * Number of volumes to allow.
         */
        volumes?: string;
        /**
         * Number of security groups to allow.
         */
        security_group?: string;
        /**
         * Maximum number of CPU's per project.
         */
        cores?: string;
        /**
         * Number of load balancers to allow.
         */
        loadbalancer?: string;
        [k: string]: unknown;
      };
      /**
       * Manages VRRP interface attributes on HUAWEI CloudEngine devices.
       */
      ce_vrrp?: {
        /**
         * Type of a VRRP backup group.
         */
        vrrp_type?: "normal" | "member" | "admin";
        /**
         * Authentication type used for VRRP packet exchanges between virtual routers. The values are noAuthentication, simpleTextPassword, md5Authentication. The default value is noAuthentication.
         */
        auth_mode?: "simple" | "md5" | "none";
        /**
         * Default: no
         *
         * Select the display mode of an authentication key. By default, an authentication key is displayed in ciphertext.
         */
        is_plain?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Preemption delay. The value is an integer ranging from 0 to 3600. The default value is 0.
         */
        preempt_timer_delay?: string;
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Default: present
         *
         * VRRP backup group ID. The value is an integer ranging from 1 to 255.
         */
        vrid?: string;
        /**
         * Configured VRRP priority. The value ranges from 1 to 254. The default value is 100. A larger value indicates a higher priority.
         */
        priority?: string;
        /**
         * Delay in recovering after an interface goes Up. The delay is used for interface flapping suppression. The value is an integer ranging from 0 to 3600. The default value is 0 seconds.
         */
        recover_delay?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * VRRP version. The default version is v2.
         */
        version?: "v2" | "v3";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Configured interval between sending advertisements, in milliseconds. Only the master router sends VRRP advertisements. The default value is 1000 milliseconds.
         */
        advertise_interval?: string;
        username?: string;
        /**
         * Tracked mVRRP interface name. The value is a string of 1 to 63 characters.
         */
        admin_interface?: string;
        host?: string;
        /**
         * Name of an interface. The value is a string of 1 to 63 characters.
         */
        interface?: string;
        password?: string;
        /**
         * Interval at which gratuitous ARP packets are sent, in seconds. The value ranges from 30 to 1200.The default value is 300.
         */
        gratuitous_arp_interval?: string;
        ssh_keyfile?: string;
        /**
         * This object is set based on the authentication type. When noAuthentication is specified, the value is empty. When simpleTextPassword or md5Authentication is specified, the value is a string of 1 to 8 characters in plaintext and displayed as a blank text for security.
         */
        auth_key?: string;
        /**
         * Virtual IP address. The value is a string of 0 to 255 characters.
         */
        virtual_ip?: string;
        timeout?: number | string;
        /**
         * Default: no
         *
         * mVRRP ignores an interface Down event.
         */
        admin_ignore_if_down?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * mVRRP's fast resume mode.
         */
        fast_resume?: "enable" | "disable";
        /**
         * Default: no
         *
         * Disable the flowdown function for service VRRP.
         */
        admin_flowdown?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The configured holdMultiplier.The value is an integer ranging from 3 to 10. The default value is 3.
         */
        holding_multiplier?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Tracked mVRRP ID. The value is an integer ranging from 1 to 255.
         */
        admin_vrid?: string;
        [k: string]: unknown;
      };
      /**
       * Change an administrative parameter on a MongoDB server.
       */
      mongodb_parameter?: {
        /**
         * Default: 27017
         *
         * The port to connect to
         */
        login_port?: number | string;
        /**
         * The username used to authenticate with
         */
        login_user?: string;
        /**
         * Default: localhost
         *
         * The host running the database
         */
        login_host?: string;
        /**
         * The password used to authenticate with
         */
        login_password?: string;
        /**
         * MongoDB administrative parameter to modify
         */
        param: string;
        /**
         * Default: no
         *
         * Whether to use an SSL connection when connecting to the database
         */
        ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: str
         *
         * Define the parameter value (str, int)
         */
        param_type?: "str" | "int";
        /**
         * MongoDB administrative parameter value to set
         */
        value: string;
        /**
         * The database where login credentials are stored
         */
        login_database?: string;
        /**
         * Replica set to connect to (automatically connects to primary for writes)
         */
        replica_set?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of logging on network devices.
       */
      net_logging?: {
        /**
         * Purge logging not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of logging definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * State of the logging configuration.
         */
        state?: "present" | "absent";
        /**
         * If value of C(dest) is I(host) it indicates file-name the host name to be notified.
         */
        name?: string;
        vlan_id?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage Contract resources on Cisco ACI fabrics.
       */
      aci_contract?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Create, Update or Destory a Url_Map. See U(https://cloud.google.com/compute/docs/load-balancing/http/url-map) for an overview. More details on the Url_Map API can be found at U(https://cloud.google.com/compute/docs/reference/latest/urlMaps#resource).
       */
      gcp_url_map?: {
        /**
         * Default Backend Service if no host rules match.
         */
        default_service: string;
        service_account_email?: string;
        service_account_permissions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The list of named PathMatchers to use against the URL. Contains path_rules, which is a list of paths and an associated service. A default_service can also be specified for each path_matcher.
         * The 'name' parameter to which this path_matcher is referred by the host_rule.
         * The 'default_service' parameter is the name of the BackendService resource. This will be used if none of the path_rules defined by this path_matcher is matched by the URL's path portion.
         * The 'path_rules' parameter is a list of dictionaries containing a list of paths and a service to direct traffic to. Each path item must start with / and the only place a * is allowed is at the end following a /. The string fed to the path matcher does not include any text after the first ? or
         */
        path_matchers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the Url_Map.
         */
        url_map_name: string;
        pem_file?: string;
        /**
         * The list of HostRules to use against the URL. Contains a list of hosts and an associated path_matcher.
         * The 'hosts' parameter is a list of host patterns to match. They must be valid hostnames, except * will match any string of ([a-z0-9-.]*). In that case, * must be the first character and must be followed in the pattern by either - or ..
         * The 'path_matcher' parameter is name of the PathMatcher to use to match the path portion of the URL if the hostRule matches the URL's host portion.
         */
        host_rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        state?: "absent" | "present";
        credentials_file?: string;
        project_id?: string;
        [k: string]: unknown;
      };
      /**
       * UrlMaps are used to route requests to a backend service based on rules that you define for the host and path of an incoming URL.
       */
      gcp_compute_url_map?: {
        project?: string;
        /**
         * The list of expected URL mappings. Request to update this UrlMap will succeed only if all of the test cases pass.
         */
        tests?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name?: string;
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * The list of named PathMatchers to use against the URL.
         */
        path_matchers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A reference to BackendService resource if none of the hostRules match.
         */
        default_service: {
          [k: string]: unknown;
        };
        /**
         * The list of HostRules to use against the URL.
         */
        host_rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Execute cluster-create or cluster-delete command.
       * A cluster allows two switches to cooperate in high-availability (HA) deployments. The nodes that form the cluster must be members of the same fabric. Clusters are typically used in conjunction with a virtual link aggregation group (VLAG) that allows links physically connected to two separate switches appear as a single trunk to a third device. The third device can be a switch,server, or any Ethernet device.
       */
      pn_cluster?: {
        /**
         * Specify the name of the cluster.
         */
        pn_name: string;
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Validate the inter-switch links and state of switches in the cluster.
         */
        pn_validate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify action to perform. Use 'present' to create cluster and 'absent' to delete cluster.
         */
        state: "present" | "absent";
        /**
         * Target switch to run the cli on.
         */
        pn_cliswitch?: string;
        /**
         * Specify the name of the first switch in the cluster.
         * Required for 'cluster-create'.
         */
        pn_cluster_node1?: string;
        /**
         * Specify the name of the second switch in the cluster.
         * Required for 'cluster-create'.
         */
        pn_cluster_node2?: string;
        [k: string]: unknown;
      };
      /**
       * Creates and deletes Route53 private and public zones
       */
      route53_zone?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure AlertSyslogConfig object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_alertsyslogconfig?: {
        username?: string;
        /**
         * The list of syslog servers.
         */
        syslog_servers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * A user-friendly name of the syslog notification.
         */
        name: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * User defined description for alert syslog config.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Element OS Cluster restore snapshot to volume.
       */
      na_elementsw_snapshot_restore?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Collects a base set of device facts from a remote device that is running SLX-OS.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      slxos_facts?: {
        /**
         * Default: ['!config']
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Create, update and remove DNS records.
       */
      vultr_dns_record?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manipulate general SNMP settings on a BIG-IP.
       */
      bigip_snmp?: {
        /**
         * When C(enabled), ensures that the system sends a trap whenever the SNMP agent starts running or stops running. This is usually enabled by default on a BIG-IP.
         */
        agent_status_traps?: string;
        /**
         * Configures the IP addresses of the SNMP clients from which the snmpd daemon accepts requests.
         * This value can be hostnames, IP addresses, or IP networks.
         * You may specify a single list item of C(default) to set the value back to the system's default of C(127.0.0.0/8).
         * You can remove all allowed addresses by either providing the word C(none), or by providing the empty string C("").
         */
        allowed_addresses?: string;
        /**
         * When C(enabled), ensures that the system sends authentication warning traps to the trap destinations. This is usually disabled by default on a BIG-IP.
         */
        agent_authentication_traps?: string;
        /**
         * When C(enabled), ensures that the system sends device warning traps to the trap destinations. This is usually enabled by default on a BIG-IP.
         */
        device_warning_traps?: string;
        /**
         * Specifies the name of the person who administers the SNMP service for this system.
         */
        contact?: string;
        /**
         * Specifies the description of this system's physical location.
         */
        location?: string;
        [k: string]: unknown;
      };
      /**
       * Module to manage clusters in oVirt/RHV
       */
      ovirt_cluster?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage an AWS VPC Internet gateway
       */
      ec2_vpc_igw?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides an abstraction that enables and configures the netconf system service running on Junos devices.  This module can be used to easily enable the Netconf API. Netconf provides a programmatic interface for working with configuration and state resources as defined in RFC 6242. If the C(netconf_port) is not mentioned in the task by default netconf will be enabled on port 830 only.
       */
      junos_netconf?: {
        [k: string]: unknown;
      };
      /**
       * Manages IGMP snooping global configuration.
       */
      nxos_igmp_snooping?: {
        /**
         * Global link-local groups suppression.
         */
        link_local_grp_supp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        /**
         * Global IGMPv1/IGMPv2 Report Suppression.
         */
        report_supp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Enables/disables IGMP snooping on the switch.
         */
        snooping?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Global IGMPv3 Report Suppression and Proxy Reporting.
         */
        v3_report_supp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Group membership timeout value for all VLANs on the device. Accepted values are integer in range 1-10080, I(never) and I(default).
         */
        group_timeout?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "default";
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * This module allows to manage posix users on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
       */
      udm_user?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Module searches Amazon EFS file systems
       */
      efs_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows the administration of Keycloak client templates via the Keycloak REST API. It requires access to the REST API via OpenID Connect; the user connecting and the client being used must have the requisite access rights. In a default Keycloak installation, admin-cli and an admin user would work, as would a separate client definition with the scope tailored to your needs and a user having the expected roles.
       * The names of module options are snake_cased versions of the camelCase ones found in the Keycloak API and its documentation at U(http://www.keycloak.org/docs-api/3.3/rest-api/)
       * The Keycloak API does not always enforce for only sensible settings to be used -- you can set SAML-specific settings on an OpenID Connect client for instance and vice versa. Be careful. If you do not specify a setting, usually a sensible default is chosen.
       */
      keycloak_clienttemplate?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module can be used to gather facts about DigitalOcean provided Domains.
       */
      digital_ocean_domain_facts?: {
        [k: string]: unknown;
      };
      /**
       * Verifies Rackspace Cloud credentials and returns identity information
       */
      rax_identity?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP HealthCheck
       */
      gcp_compute_health_check_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Adds or removes deploy keys for GitHub repositories. Supports authentication using username and password, username and password and 2-factor authentication code (OTP), OAuth2 token, or personal access token.
       */
      github_deploy_key?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Creates or removes resource records in Google Cloud DNS.
       */
      gcdns_record?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * This module provides declarative management of LLDP service on VyOS network devices.
       */
      vyos_lldp?: {
        username?: string;
        ssh_keyfile?: string;
        interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * State of the LLDP configuration.
         */
        state?: "present" | "absent" | "enabled" | "disabled";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, update and remove port forwarding rules.
       */
      cs_portforward?: {
        [k: string]: unknown;
      };
      /**
       * This module can be used to collect facts about VMware tags.
       * Tag feature is introduced in vSphere 6 version, so this module is not supported in the earlier versions of vSphere.
       * All variables and VMware object names are case sensitive.
       */
      vmware_tag_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module manipulates sysctl entries and optionally performs a C(/sbin/sysctl -p) after changing them.
       */
      sysctl?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP GlobalForwardingRule
       */
      gcp_compute_global_forwarding_rule_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Get facts of PostgreSQL Database.
       */
      azure_rm_postgresqldatabase_facts?: {
        profile?: string;
        /**
         * The name of the database.
         */
        name?: string;
        /**
         * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
         */
        resource_group: string;
        ad_user?: string;
        /**
         * The name of the server.
         */
        server_name: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Create, manage and delete Windows shortcuts
       */
      win_shortcut?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module allows you to create, modify, get and delete Zabbix proxy entries.
       */
      zabbix_proxy?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manages members in a device group. Members in a device group can only be added or removed, never updated. This is because the members are identified by unique name values and changing that name would invalidate the uniqueness.
       */
      bigip_device_group_member?: {
        /**
         * Default: present
         *
         * When C(present), ensures that the device group member exists.
         * When C(absent), ensures the device group member is removed.
         */
        state?: string;
        /**
         * Specifies the name of the device that you want to add to the device group. Often this will be the hostname of the device. This member must be trusted by the device already. Trusting can be done with the C(bigip_device_trust) module and the C(peer_hostname) option to that module.
         */
        name?: string;
        /**
         * The device group that you want to add the member to.
         */
        device_group?: string;
        [k: string]: unknown;
      };
      /**
       * Import file on PAN-OS device
       */
      panos_import?: {
        /**
         * Default: software
         *
         * Category of file uploaded. The default is software.
         * See API > Import section of the API reference for category options.
         */
        category?: string;
        username?: string;
        /**
         * URL of the file that will be imported to device.
         */
        url?: string;
        ip_address: string;
        /**
         * Location of the file to import into device.
         */
        file?: string;
        password: string;
        /**
         * Default: True
         *
         * If C(no), SSL certificates will not be validated. Disabling certificate validation is not recommended.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Query current pagefile configuration.
       * Enable/Disable AutomaticManagedPagefile.
       * Create new or override pagefile configuration.
       */
      win_pagefile?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Install, upgrade, delete and list packages with the Helm package manager.
       */
      helm?: {
        /**
         * Default: no
         *
         * Whether to disable hooks during the uninstall process.
         */
        disable_hooks?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Release name to manage.
         */
        name?: string;
        /**
         * Default: default
         *
         * Kubernetes namespace where the chart should be installed.
         */
        namespace?: string;
        /**
         * A map describing the chart to install. See examples for available options.
         *
         */
        chart?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Whether to install C(present), remove C(absent), or purge C(purged) a package.
         */
        state?: "absent" | "purged" | "present";
        /**
         * A map of value options for the chart.
         */
        values?: {
          [k: string]: unknown;
        };
        /**
         * Default: localhost
         *
         * Tiller's server host.
         */
        host?: string;
        /**
         * Default: 44134
         *
         * Tiller's server port.
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage block storage volumes on Vultr.
       */
      vultr_block_storage?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Grant or revoke privileges on PostgreSQL database objects.
       * This module is basically a wrapper around most of the functionality of PostgreSQL's GRANT and REVOKE statements with detection of changes (GRANT/REVOKE I(privs) ON I(type) I(objs) TO/FROM I(roles))
       */
      postgresql_privs?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manages physical attributes of interfaces of NX-OS switches.
       */
      nxos_interface?: {
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote Lenovo device running on CNOS.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      cnos_facts?: {
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A dict object containing connection details.
         */
        provider?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Cancel Ansible Tower jobs. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_job_cancel?: {
        /**
         * ID of the job to cancel
         */
        job_id: number | string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Fail loudly if the I(job_id) does not reference a running job.
         */
        fail_if_not_running?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        tower_password?: string;
        tower_username?: string;
        tower_host?: string;
        [k: string]: unknown;
      };
      /**
       * Controls systemd services on remote hosts.
       */
      systemd?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, register and remove SSH keys.
       * If no key was found and no public key was provided and a new SSH private/public key pair will be created and the private key will be returned.
       */
      cs_sshkeypair?: {
        /**
         * String of the public key.
         */
        public_key?: string;
        /**
         * Account the public key is related to.
         */
        account?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Name of the project the public key to be registered in.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the public key.
         */
        state?: "present" | "absent";
        /**
         * Domain the public key is related to.
         */
        domain?: string;
        api_key?: string;
        /**
         * Name of public key.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create/delete/reconfigure a guest VM through VMware vSphere. This module has a dependency on pysphere >= 1.7
       */
      vsphere_guest?: {
        /**
         * The name of the resource_pool to create the VM in.
         */
        resource_pool?: string;
        /**
         * Desired hardware version identifier (for example, "vmx-08" for vms that needs to be managed with vSphere Client). Note that changing hardware version of existing vm is not supported.
         */
        vm_hw_version?: string;
        /**
         * The hostname of the vcenter server the module will connect to, to create the guest.
         */
        vcenter_hostname?: string;
        /**
         * Default: no
         *
         * Boolean. Allows you to run commands which may alter the running state of a guest. Also used to reconfigure and destroy.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The virtual server name you wish to manage.
         */
        guest: string;
        /**
         * A key, value list of disks and their sizes and which datastore to keep it in.
         */
        vm_disk?: {
          [k: string]: unknown;
        };
        /**
         * Dictionary which includes datacenter and hostname on which the VM should be created. For standalone ESXi hosts, ha-datacenter should be used as the datacenter name
         */
        esxi?: {
          [k: string]: unknown;
        };
        /**
         * A key, value list of nics, their types and what network to put them on.
         * Optionaly with their MAC address.
         */
        vm_nic?: {
          [k: string]: unknown;
        };
        /**
         * A key, value list of VM config settings. Must include ['memory_mb', 'num_cpus', 'osid', 'scsi'].
         */
        vm_hardware?: {
          [k: string]: unknown;
        };
        /**
         * Default: no
         *
         * Specifies if the VM should be deployed from a template (mutually exclusive with 'state' parameter). No guest customization changes to hardware such as CPU, RAM, NICs or Disks can be applied when launching from template.
         */
        from_template?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Username to connect to vcenter as.
         */
        username?: string;
        /**
         * The name of the cluster to create the VM in. By default this is derived from the host you tell the module to build the guest on.
         */
        cluster?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the vm. 'reconfigured' only applies changes to 'vm_cdrom', 'memory_mb', and 'num_cpus' in vm_hardware parameter. The 'memory_mb' and 'num_cpus' changes are applied to powered-on vms when hot-plugging is enabled for the guest.
         */
        state?:
          | "present"
          | "powered_off"
          | "absent"
          | "powered_on"
          | "restarted"
          | "reconfigured"
          | "reboot_guest"
          | "poweroff_guest";
        /**
         * Gather facts from vCenter on a particular VM
         */
        vmware_guest_facts?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A key, value pair of any extra values you want set or changed in the vmx file of the VM. Useful to set advanced options on the VM.
         */
        vm_extra_config?: {
          [k: string]: unknown;
        };
        /**
         * Default: yes
         *
         * Specifies if the VM should be powered on after the clone.
         */
        power_on_after_clone?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Password of the user to connect to vcenter as.
         */
        password?: string;
        /**
         * Default: yes
         *
         * Validate SSL certs.  Note, if running on python without SSLContext support (typically, python < 2.7.9) you will have to set this to C(no) as pysphere does not support validating certificates on older python. Prior to 2.1, this module would always validate on python >= 2.7.9 and never validate on python <= 2.7.8.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the source template to deploy from
         */
        template_src?: string;
        /**
         * A string that when specified, will create a linked clone copy of the VM. Snapshot must already be taken in vCenter.
         */
        snapshot_to_clone?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to enable or disable an Icinga2 feature.
       */
      icinga2_feature?: {
        /**
         * Default: present
         *
         * If set to C(present) and feature is disabled, then feature is enabled.
         * If set to C(present) and feature is already enabled, then nothing is changed.
         * If set to C(absent) and feature is enabled, then feature is disabled.
         * If set to C(absent) and feature is already disabled, then nothing is changed.
         */
        state?: "present" | "absent";
        /**
         * This is the feature name to enable or disable.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create and remove security groups.
       */
      cs_securitygroup?: {
        /**
         * Domain the security group is related to.
         */
        domain?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        /**
         * Description of the security group.
         */
        description?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Name of the project the security group to be created in.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the security group.
         */
        state?: "present" | "absent";
        /**
         * Account the security group is related to.
         */
        account?: string;
        api_key?: string;
        /**
         * Name of the security group.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Obtain a session token from the AWS Security Token Service
       */
      sts_session_token?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update or delete a route table.
       */
      azure_rm_routetable?: {
        profile?: string;
        /**
         * name of resource group.
         */
        resource_group: string;
        /**
         * Specified whether to disable the routes learned by BGP on that route table.
         */
        disable_bgp_route_propagation?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        /**
         * Default: present
         *
         * Assert the state of the route table. Use 'present' to create or update and 'absent' to delete.
         */
        state?: "absent" | "present";
        /**
         * Region of the resource.
         * Derived from C(resource_group) if not specified
         */
        location?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        /**
         * name of the route table.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, Modify or Delete Snapshot on Element OS Cluster.
       */
      na_elementsw_snapshot?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create and Delete Instances/Databases on Spanner. See U(https://cloud.google.com/spanner/docs) for an overview.
       */
      gcspanner?: {
        /**
         * Configuration the instance should use.
         * Examples are us-central1, asia-east1 and europe-west1.
         */
        configuration: string;
        service_account_email?: string;
        /**
         * Name of database contained on the instance.
         */
        database_name?: string;
        /**
         * Default: no
         *
         * To delete an instance, this argument must exist and be true (along with state being equal to absent).
         */
        force_instance_delete?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * GCP spanner instance name.
         */
        instance_id: string;
        /**
         * Default: present
         *
         * State of the instance or database. Applies to the most granular resource.
         * If a C(database_name) is specified we remove it.
         * If only C(instance_id) is specified, that is what is removed.
         */
        state?: "absent" | "present";
        credentials_file?: string;
        /**
         * Default: 1
         *
         * Number of nodes in the instance.
         */
        node_count?: number | string;
        project_id?: string;
        /**
         * Name of Instance to display.
         * If not specified, instance_id will be used instead.
         */
        instance_display_name?: string;
        [k: string]: unknown;
      };
      /**
       * Extreme Ironware configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with Ironware configuration sections in a deterministic way.
       */
      ironware_config?: {
        [k: string]: unknown;
      };
      /**
       * Create and remove Rundeck projects through HTTP API.
       */
      rundeck_project?: {
        /**
         * Sets the rundeck instance URL.
         */
        url: string;
        /**
         * Sets the token to authenticate against Rundeck API.
         */
        token: string;
        /**
         * Sets the project name.
         */
        name: string;
        /**
         * Default: 14
         *
         * Sets the API version used by module.
         * API version must be at least 14.
         */
        api_version?: number | string;
        /**
         * Default: present
         *
         * Create or remove Rundeck project.
         */
        state?: "present" | "absent";
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of LLDP service on Extreme SLX-OS network devices.
       */
      slxos_lldp?: {
        /**
         * Default: present
         *
         * State of the LLDP configuration. If value is I(present) lldp will be enabled else if it is I(absent) it will be disabled.
         */
        state?: "present" | "absent";
        [k: string]: unknown;
      };
      /**
       * Manages OpenNebula Hosts
       */
      one_host?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts about VPN Connections in AWS.
       */
      ec2_vpc_vpn_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creating / deleting and modifying the CIFS server.
       */
      na_ontap_cifs_server?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create or delete a Rackspace Cloud Monitoring alarm that associates an existing rax_mon_entity, rax_mon_check, and rax_mon_notification_plan with criteria that specify what conditions will trigger which levels of notifications. Rackspace monitoring module flow | rax_mon_entity -> rax_mon_check -> rax_mon_notification -> rax_mon_notification_plan -> *rax_mon_alarm*
       */
      rax_mon_alarm?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts of the SSL thumbprint information for a host.
       */
      vmware_host_ssl_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allows to create, modify or delete accounts with a CA supporting the L(ACME protocol,https://tools.ietf.org/html/rfc8555), such as L(Let's Encrypt,https://letsencrypt.org/).
       * This module only works with the ACME v2 protocol.
       */
      acme_account?: {
        [k: string]: unknown;
      };
      /**
       * The M(proxysql_backend_servers) module adds or removes mysql hosts using the proxysql admin interface.
       */
      proxysql_backend_servers?: {
        /**
         * Text field that can be used for any purposed defined by the user. Could be a description of what the host stores, a reminder of when the host was added or disabled, or a JSON processed by some checker script.
         */
        comment?: string;
        /**
         * ONLINE - Backend server is fully operational. OFFLINE_SOFT - When a server is put into C(OFFLINE_SOFT) mode, connections are kept in use until the current transaction is completed. This allows to gracefully detach a backend. OFFLINE_HARD - When a server is put into C(OFFLINE_HARD) mode, the existing connections are dropped, while new incoming connections aren't accepted either.
         * If omitted the proxysql database default for I(status) is C(ONLINE).
         */
        status?: "ONLINE" | "OFFLINE_SOFT" | "OFFLINE_HARD";
        /**
         * The ip address at which the mysqld instance can be contacted.
         */
        hostname: string;
        config_file?: string;
        /**
         * If the value of I(compression) is greater than 0, new connections to that server will use compression. If omitted the proxysql database default for I(compression) is 0.
         */
        compression?: number | string;
        /**
         * The bigger the weight of a server relative to other weights, the higher the probability of the server being chosen from the hostgroup. If omitted the proxysql database default for I(weight) is 1.
         */
        weight?: number | string;
        login_port?: number | string;
        login_user?: string;
        login_host?: string;
        login_password?: string;
        /**
         * The hostgroup in which this mysqld instance is included. An instance can be part of one or more hostgroups.
         */
        hostgroup_id?: number | string;
        login_unix_socket?: string;
        /**
         * Default: present
         *
         * When C(present) - adds the host, when C(absent) - removes the host.
         */
        state?: "present" | "absent";
        load_to_runtime?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        save_to_disk?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * If I(use_ssl) is set to C(True), connections to this server will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).
         */
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * If greater than 0, ProxySQL will reguarly monitor replication lag. If replication lag goes above I(max_replication_lag), proxysql will temporarily shun the server until replication catches up. If omitted the proxysql database default for I(max_replication_lag) is 0.
         */
        max_replication_lag?: number | string;
        /**
         * Default: 3306
         *
         * The port at which the mysqld instance can be contacted.
         */
        port?: number | string;
        /**
         * Ping time is monitored regularly. If a host has a ping time greater than I(max_latency_ms) it is excluded from the connection pool (although the server stays ONLINE). If omitted the proxysql database default for I(max_latency_ms) is 0.
         */
        max_latency_ms?: number | string;
        /**
         * The maximum number of connections ProxySQL will open to this backend server. If omitted the proxysql database default for I(max_connections) is 1000.
         */
        max_connections?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, delete cluster pair
       */
      na_elementsw_cluster_pair?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages Kibana plugins.
       */
      kibana_plugin?: {
        /**
         * Default: no
         *
         * Delete and re-install the plugin. Can be useful for plugins update
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: /opt/kibana/bin/kibana
         *
         * Location of the plugin binary
         */
        plugin_bin?: string;
        /**
         * Set exact URL to download the plugin from. For local file, prefix its absolute path with file://
         */
        url?: string;
        /**
         * Default: present
         *
         * Desired state of a plugin.
         */
        state?: "present" | "absent";
        /**
         * Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated if C(force) is not set to yes
         */
        version?: string;
        /**
         * Default: 1m
         *
         * Timeout setting: 30s, 1m, 1h...
         */
        timeout?: string;
        /**
         * Default: /opt/kibana/installedPlugins/
         *
         * Your configured plugin directory specified in Kibana
         */
        plugin_dir?: string;
        /**
         * Name of the plugin to install
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create and delete disk offerings for guest VMs.
       * Update display_text or display_offering of existing disk offering.
       */
      cs_disk_offering?: {
        [k: string]: unknown;
      };
      /**
       * The Buckets resource represents a bucket in Google Cloud Storage. There is a single global namespace shared by all buckets. For more information, see Bucket Name Requirements.
       * Buckets contain objects which can be accessed by their own methods. In addition to the acl property, buckets contain bucketAccessControls, for use in fine-grained manipulation of an existing bucket's access controls.
       * A bucket is always owned by the project team owners group.
       */
      gcp_storage_bucket?: {
        /**
         * The bucket's website configuration, controlling how the service behaves when accessing bucket contents as a web site. See the Static Website Examples for more information.
         */
        website?: {
          [k: string]: unknown;
        };
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The bucket's logging configuration, which defines the destination bucket and optional name prefix for the current bucket's logs.
         */
        logging?: {
          [k: string]: unknown;
        };
        /**
         * The name of the bucket.
         */
        name?: string;
        /**
         * The bucket's default storage class, used whenever no storageClass is specified for a newly-created object. This defines how objects in the bucket are stored and determines the SLA and the cost of storage.
         * Values include MULTI_REGIONAL, REGIONAL, STANDARD, NEARLINE, COLDLINE, and DURABLE_REDUCED_AVAILABILITY. If this value is not specified when the bucket is created, it will default to STANDARD. For more information, see storage classes.
         */
        storage_class?:
          | "MULTI_REGIONAL"
          | "REGIONAL"
          | "STANDARD"
          | "NEARLINE"
          | "COLDLINE"
          | "DURABLE_REDUCED_AVAILABILITY";
        /**
         * The bucket's lifecycle configuration.
         * See U(https://developers.google.com/storage/docs/lifecycle) for more information.
         */
        lifecycle?: {
          [k: string]: unknown;
        };
        service_account_email?: string;
        /**
         * Apply a predefined set of default object access controls to this bucket.
         * Acceptable values are:   - "authenticatedRead": Object owner gets OWNER access, and     allAuthenticatedUsers get READER access.
         * - "bucketOwnerFullControl": Object owner gets OWNER access, and     project team owners get OWNER access.
         * - "bucketOwnerRead": Object owner gets OWNER access, and project     team owners get READER access.
         * - "private": Object owner gets OWNER access.
         * - "projectPrivate": Object owner gets OWNER access, and project team     members get access according to their roles.
         * - "publicRead": Object owner gets OWNER access, and allUsers get     READER access.
         */
        predefined_default_object_acl?:
          | "authenticatedRead"
          | "bucketOwnerFullControl"
          | "bucketOwnerRead"
          | "private"
          | "projectPrivate"
          | "publicRead";
        /**
         * Access controls on the bucket.
         */
        acl?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A valid API project identifier.
         */
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * The metadata generation of this bucket.
         */
        metageneration?: number | string;
        /**
         * Default access controls to apply to new objects when no ACL is provided.
         */
        default_object_acl?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The location of the bucket. Object data for objects in the bucket resides in physical storage within this region. Defaults to US. See the developer's guide for the authoritative list.
         */
        location?: string;
        /**
         * The bucket's Cross-Origin Resource Sharing (CORS) configuration.
         */
        cors?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The owner of the bucket. This is always the project team's owner group.
         */
        owner?: {
          [k: string]: unknown;
        };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * The bucket's versioning configuration.
         */
        versioning?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Uploads files to Cisco FTD devices including disk files, backups, and upgrades.
       */
      ftd_file_upload?: {
        /**
         * Specifies Ansible fact name that is used to register received response from the FTD device.
         */
        register_as?: string;
        /**
         * The name of the operation to execute.
         * Only operations that upload file can be used in this module.
         */
        operation: string;
        /**
         * Absolute path to the file that should be uploaded.
         */
        file_to_upload: string;
        [k: string]: unknown;
      };
      /**
       * Module to manage Virtual Machine and floating disks in oVirt/RHV.
       */
      ovirt_disk?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allows you to modify mapped network drives for individual users.
       */
      win_mapped_drive?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages VTP version configuration.
       */
      nxos_vtp_version?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        host?: string;
        /**
         * VTP version number.
         */
        version: "1" | "2";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Create or delete Server Groups at Centurylink Centurylink Cloud
       */
      clc_group?: {
        /**
         * The name of the Server Group
         */
        name: string;
        /**
         * The parent group of the server group. If parent is not provided, it creates the group at top level.
         */
        parent?: string;
        /**
         * A description of the Server Group
         */
        description?: string;
        /**
         * Default: present
         *
         * Whether to create or delete the group
         */
        state?: "present" | "absent";
        /**
         * Datacenter to create the group in. If location is not provided, the group gets created in the default datacenter associated with the account
         */
        location?: string;
        /**
         * Default: True
         *
         * Whether to wait for the tasks to finish before returning.
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Adds or removes Vertica database role and, optionally, assign other roles.
       */
      vertica_role?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Create or delete a key within a given keyvault. By using Key Vault, you can encrypt keys and secrets (such as authentication keys, storage account keys, data encryption keys, .PFX files, and passwords).
       */
      azure_rm_keyvaultkey?: {
        profile?: string;
        /**
         * URI of the keyvault endpoint.
         */
        keyvault_uri: string;
        /**
         * PEM password.
         */
        pem_password?: string;
        tags?: {
          [k: string]: unknown;
        };
        /**
         * Name of the keyvault key.
         */
        key_name: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        secret?: string;
        /**
         * PEM file.
         */
        pem_file?: string;
        /**
         * Default: present
         *
         * Assert the state of the key. Use 'present' to create a key and 'absent' to delete a key.
         */
        state?: "absent" | "present";
        /**
         * BYOK file.
         */
        byok_file?: string;
        client_id?: string;
        cert_validation_mode?: "validate" | "ignore";
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        cloud_environment?: string;
        tenant?: string;
        api_profile?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows setting/accumulating stats on the current ansible run, either per host or for all hosts in the run.
       * This module is also supported for Windows targets.
       */
      set_stats?: {
        active_connection_states?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        connect_timeout?: number | string;
        delay?: number | string;
        search_regex?: string;
        state?: "absent" | "drained" | "present" | "started" | "stopped";
        sleep?: number | string;
        timeout?: number | string;
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        msg?: string;
        path?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * This modules allows for enable/disable/activate of I(awall) policies. Alpine Wall (I(awall)) generates a firewall configuration from the enabled policy files and activates the configuration on the system.
       */
      awall?: {
        /**
         * Default: enabled
         *
         * The policy(ies) will be C(enabled)
         * The policy(ies) will be C(disabled)
         */
        state?: "enabled" | "disabled";
        /**
         * Default: no
         *
         * Activate the new firewall rules. Can be run with other steps or on it's own.
         */
        activate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A policy name, like C(foo), or multiple policies, like C(foo, bar).
         */
        name?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * This module is used to configure VrfContext object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_vrfcontext?: {
        /**
         * Boolean flag to set system_default.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        system_default?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * It is a reference to an object of type cloud.
         */
        cloud_ref?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Configure ping based heartbeat check for gateway in service engines of vrf.
         */
        gateway_mon?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_version?: string;
        username?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * Configure ping based heartbeat check for all default gateways in service engines of vrf.
         * Field introduced in 17.1.1.
         */
        internal_gateway_monitor?: {
          [k: string]: unknown;
        };
        /**
         * Name of the object.
         */
        name: string;
        /**
         * List of staticroute.
         */
        static_routes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        tenant_uuid?: string;
        /**
         * Bgp local and peer info.
         */
        bgp_profile?: {
          [k: string]: unknown;
        };
        /**
         * Configure debug flags for vrf.
         * Field introduced in 17.1.1.
         */
        debugvrfcontext?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * This module will update settings for OpenDJ with the command set-backend-prop.
       * It will check first via de get-backend-prop if configuration needs to be applied.
       */
      opendj_backendprop?: {
        /**
         * Default: cn=Directory Manager
         *
         * The username to connect to.
         */
        username?: string;
        /**
         * The configuration setting to update.
         */
        name: string;
        /**
         * The hostname of the OpenDJ server.
         */
        hostname: string;
        /**
         * The value for the configuration item.
         */
        value: string;
        /**
         * Default: present
         *
         * If configuration needs to be added/updated
         */
        state?: string;
        /**
         * Location to the password file which holds the password for the cn=Directory Manager user.
         * Either password or passwordfile is needed.
         */
        passwordfile?: string;
        /**
         * The password for the cn=Directory Manager user.
         * Either password or passwordfile is needed.
         */
        password?: string;
        /**
         * Default: /opt/opendj/bin
         *
         * The path to the bin directory of OpenDJ.
         */
        opendj_bindir?: string;
        /**
         * The Admin port on which the OpenDJ instance is available.
         */
        port: string;
        /**
         * The name of the backend on which the property needs to be updated.
         */
        backend: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to query the facts about which Jenkins jobs which already exists.
       */
      jenkins_job_facts?: {
        /**
         * Exact name of the Jenkins job to fetch facts about.
         */
        name?: string;
        /**
         * Default: http://localhost:8080
         *
         * URL where the Jenkins server is accessible.
         */
        url?: string;
        /**
         * A shell glob of Jenkins job names to fetch facts about.
         */
        glob?: string;
        /**
         * Only fetch jobs with the given status color.
         */
        color?: string;
        /**
         * API token used to authenticate with the Jenkins server.
         * This is a required parameter, if C(password) is not provided.
         */
        token?: string;
        /**
         * User to authenticate with the Jenkins server.
         */
        user?: string;
        /**
         * Password to authenticate with the Jenkins server.
         * This is a required parameter, if C(token) is not provided.
         */
        password?: string;
        /**
         * Default: True
         *
         * If set to C(False), the SSL certificates will not be validated.
         * This should only set to C(False) used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Provides rollback and rollback preview functionality for Cisco ACI fabrics.
       * Config Rollbacks are done using snapshots C(aci_snapshot) with the configImportP class.
       */
      aci_config_rollback?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * The S3 module is great, but it is very slow for a large volume of files- even a dozen will be noticeable. In addition to speed, it handles globbing, inclusions/exclusions, mime types, expiration mapping, recursion, cache control and smart directory mapping.
       */
      s3_sync?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage InfluxDB users
       */
      influxdb_user?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allows for easy creation, updating and deletion of CloudFront distributions.
       */
      cloudfront_distribution?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Find the folder path(s) for a virtual machine by name or UUID
       */
      vmware_guest_find?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Can create or delete AWS metric alarms.
       * Metrics you wish to alarm on must already exist.
       */
      ec2_metric_alarm?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, destroy, or update accounts on Element SW
       */
      na_elementsw_account?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages Logstash plugins.
       */
      logstash_plugin?: {
        /**
         * Default: /usr/share/logstash/bin/logstash-plugin
         *
         * Specify logstash-plugin to use for plugin management.
         */
        plugin_bin?: string;
        /**
         * Proxy host to use during plugin installation.
         */
        proxy_host?: string;
        /**
         * Proxy port to use during plugin installation.
         */
        proxy_port?: string;
        /**
         * Default: present
         *
         * Apply plugin state.
         */
        state?: "present" | "absent";
        /**
         * Specify plugin Version of the plugin to install. If plugin exists with previous version, it will NOT be updated.
         */
        version?: string;
        /**
         * Install plugin with that name.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Configures VLANs on Cisco UCS Manager.
       * Examples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).
       */
      ucs_vlans?: {
        /**
         * Default: none
         *
         * The Sharing Type field.
         * Whether this VLAN is subdivided into private or secondary VLANs. This can be one of the following:
         * none - This VLAN does not have any secondary or private VLANs. This is a regular VLAN.
         * primary - This VLAN can have one or more secondary VLANs, as shown in the Secondary VLANs area. This VLAN is a primary VLAN in the private VLAN domain.
         * isolated - This is a private VLAN associated with a primary VLAN. This VLAN is an Isolated VLAN.
         * community - This VLAN can communicate with other ports on the same community VLAN as well as the promiscuous port. This VLAN is a Community VLAN.
         */
        sharing?: string;
        /**
         * Default: common
         *
         * The fabric configuration of the VLAN.  This can be one of the following:
         * common - The VLAN applies to both fabrics and uses the same configuration parameters in both cases.
         * A  The VLAN only applies to fabric A.
         * B  The VLAN only applies to fabric B.
         * For upstream disjoint L2 networks, Cisco recommends that you choose common to create VLANs that apply to both fabrics.
         */
        fabric?: string;
        /**
         * The multicast policy associated with this VLAN.
         * This option is only valid if the Sharing Type field is set to None or Primary.
         */
        multicast_policy?: string;
        /**
         * Default: present
         *
         * If C(present), will verify VLANs are present and will create if needed.
         * If C(absent), will verify VLANs are absent and will delete if needed.
         */
        state?: string;
        /**
         * Default: no
         *
         * Designates the VLAN as a native VLAN.
         */
        native?: string;
        /**
         * The unique string identifier assigned to the VLAN.
         * A VLAN ID can be between '1' and '3967', or between '4048' and '4093'.
         * You cannot create VLANs with IDs from 4030 to 4047. This range of VLAN IDs is reserved.
         * The VLAN IDs you specify must also be supported on the switch that you are using.
         * VLANs in the LAN cloud and FCoE VLANs in the SAN cloud must have different IDs.
         * Optional if state is absent.
         */
        id?: string;
        /**
         * The name assigned to the VLAN.
         * The VLAN name is case sensitive.
         * This name can be between 1 and 32 alphanumeric characters.
         * You cannot use spaces or any special characters other than - (hyphen), "_" (underscore), : (colon), and . (period).
         * You cannot change this name after the VLAN is created.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of LLDP interfaces configuration on network devices.
       */
      net_lldp_interface?: {
        username?: string;
        eth_trunk_id?: string;
        ssh_keyfile?: string;
        provider?: {
          [k: string]: unknown;
        };
        pseudo_priority?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        priority_id?: string;
        peer_link_id?: string;
        vpn_instance_name?: string;
        nickname?: string;
        /**
         * Default: present
         *
         * State of the LLDP configuration.
         */
        state?: "present" | "absent";
        pseudo_nickname?: string;
        timeout?: number | string;
        dfs_group_id?: string;
        host?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        ip_address?: string;
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP BackendService
       */
      gcp_compute_backend_service_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of the local usernames configured on Cisco Nexus devices.  It allows playbooks to manage either individual usernames or the collection of usernames in the current running config.  It also supports purging usernames from the configuration that are not explicitly defined.
       */
      nxos_user?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages SELinux file context mapping definitions.
       * Similar to the C(semanage fcontext) command.
       */
      sefcontext?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure PriorityLabels object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_prioritylabels?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Uuid of the priority labels.
         */
        uuid?: string;
        /**
         * The name of the priority labels.
         */
        name: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        controller?: string;
        /**
         * It is a reference to an object of type cloud.
         */
        cloud_ref?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        /**
         * Equivalent priority labels in descending order.
         */
        equivalent_labels?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * A description of the priority labels.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manage a host system from distributed virtual switch.
       */
      vmware_dvs_host?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific security group or all security groups within a resource group.
       */
      azure_rm_securitygroup_facts?: {
        profile?: string;
        /**
         * Only show results for a specific security group.
         */
        name?: string;
        /**
         * Name of the resource group to use.
         */
        resource_group: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Manage Elastic Kubernetes Service Clusters
       */
      aws_eks_cluster?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Will return whether the folder and task exists.
       * Returns the names of tasks in the folder specified.
       * If C(name) is set and exists, will return information on the task itself.
       * Use M(win_scheduled_task) to configure a scheduled task.
       */
      win_scheduled_task_stat?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage logging facility of an s3 bucket in AWS
       */
      s3_logging?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages creating and downloading qkviews from a BIG-IP. Various options can be provided when creating qkviews. The qkview is important when dealing with F5 support. It may be required that you upload this qkview to the supported channels during resolution of an SRs that you may have opened.
       */
      bigip_qkview?: {
        [k: string]: unknown;
      };
      /**
       * Sends alerts which appear in the Action Center area of the windows desktop.
       */
      win_toast?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages MLAG interface attributes on HUAWEI CloudEngine switches.
       */
      ce_mlag_interface?: {
        username?: string;
        /**
         * Name of the local M-LAG interface. The value is ranging from 0 to 511.
         */
        eth_trunk_id?: string;
        ssh_keyfile?: string;
        /**
         * ID of the M-LAG. The value is an integer that ranges from 1 to 2048.
         */
        mlag_id?: string;
        /**
         * Configure the interface on the slave device to enter the Error-Down state.
         */
        mlag_error_down?: "enable" | "disable";
        /**
         * Default: present
         *
         * ID of a DFS group.The value is 1.
         */
        dfs_group_id?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * M-LAG global LACP system MAC address. The value is a string of 0 to 255 characters. The default value is the MAC address of the Ethernet port of MPU.
         */
        mlag_system_id?: string;
        host?: string;
        /**
         * M-LAG global LACP system priority. The value is an integer ranging from 0 to 65535. The default value is 32768.
         */
        mlag_priority_id?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Name of the interface that enters the Error-Down state when the peer-link fails. The value is a string of 1 to 63 characters.
         */
        interface?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Create or destroy aggregates on NetApp cDOT.
       */
      na_cdot_aggregate?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Adds and/or removes instances of MX record objects from Infoblox NIOS servers.  This module manages NIOS C(record:mx) objects using the Infoblox WAPI interface over REST.
       */
      nios_mx_record?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Enable or Disable Windows Firewall profiles.
       */
      win_firewall?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an ASA node and returns the results read from the device. The C(asa_command) module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      asa_command?: {
        [k: string]: unknown;
      };
      /**
       * Represents a Global Address resource. Global addresses are used for HTTP(S) load balancing.
       */
      gcp_compute_global_address?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035.  Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        service_account_email?: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * The IP Version that will be used by this address. Valid options are IPV4 or IPV6. The default value is IPV4.
         */
        ip_version?: "IPV4" | "IPV6";
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * An optional description of this resource.
         * Provide this property when you create the resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Collects fact information from a remote device running the Junos operating system.  By default, the module will collect basic fact information from the device to be included with the hostvars. Additional fact information can be collected based on the configured set of arguments.
       */
      junos_facts?: {
        username?: string;
        ssh_keyfile?: string;
        host?: string;
        /**
         * Default: ['!config', '!ofacts']
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected. To maintain backward compatbility old style facts can be retrieved by explicilty adding C(ofacts)  to value, this reqires junos-eznc to be installed as a prerequisite. Valid value of gather_subset are default, hardware, config, interfaces, ofacts. If C(ofacts) is present in the list it fetches the old style facts (fact keys without 'ansible_' prefix) and it requires junos-eznc library to be installed on control node and the device login credentials must be given in C(provider) option.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: text
         *
         * The I(config_format) argument specifies the format of the configuration when serializing output from the device. This argument is applicable only when C(config) value is present in I(gather_subset). The I(config_format) should be supported by the junos version running on device. This value is not applicable while fetching old style facts that is when C(ofacts) value is present in value if I(gather_subset) value.
         */
        config_format?: "xml" | "text" | "set" | "json";
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an SR OS node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(sros_config) to configure SR OS devices.
       */
      sros_command?: {
        [k: string]: unknown;
      };
      /**
       * Send a message to jabber
       */
      jabber?: {
        /**
         * message encoding
         */
        encoding?: string;
        /**
         * user ID or name of the room, when using room use a slash to indicate your nick.
         */
        to: string;
        /**
         * host to connect, overrides user info
         */
        host?: string;
        /**
         * User as which to connect
         */
        user: string;
        /**
         * The message body.
         */
        msg: string;
        /**
         * password for user to connect
         */
        password: string;
        /**
         * Default: 5222
         *
         * port to connect to, overrides default
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * List the MFA (Multi-Factor Authentication) devices registered for a user
       */
      iam_mfa_device_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows you to work with the running configuration of a switch. It provides a way to execute a set of CNOS commands on a switch by evaluating the current running configuration and executing the commands only if the specific settings have not been already configured. The configuration source can be a set of commands or a template written in the Jinja2 templating language. This module functions the same as the cnos_template module. The only exception is that the following inventory variable can be specified. ["condition = <flag string>"] When this inventory variable is specified as the variable of a task, the template is executed for the network element that matches the flag string. Usually, templates are used when commands are the same across a group of network devices. When there is a requirement to skip the execution of the template on one or more devices, it is recommended to use this module. This module uses SSH to manage network device configuration.
       */
      cnos_conditional_template?: {
        username?: string;
        outputfile: string;
        /**
         * If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device.
         */
        flag: string;
        host?: string;
        deviceType: string;
        /**
         * This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. The command file must contain the Ansible keyword {{ inventory_hostname }} and the condition flag in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_ {{ inventory_hostname }}_LP21_commands.txt
         */
        commandfile: string;
        password?: string;
        enablePassword?: string;
        /**
         * If you specify condition=<flag string> in the inventory file against any device, the template execution is done for that device in case it matches the flag setting for that task.
         */
        condition: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of LLDP service on Juniper JUNOS network devices.
       */
      junos_lldp?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Frequency at which LLDP advertisements are sent (in seconds).
         */
        interval?: number | string;
        /**
         * Default: present
         *
         * Value of C(present) ensures given LLDP configuration is present on device and LLDP is enabled, for value of C(absent) LLDP configuration is deleted and LLDP is in disabled state. Value C(enabled) ensures LLDP protocol is enabled and LLDP configuration if any is configured on remote device, for value of C(disabled) it ensures LLDP protocol is disabled any LLDP configuration if any is still present.
         */
        state?: "present" | "absent" | "enabled" | "disabled";
        host?: string;
        /**
         * Specify the number of seconds the device waits before sending advertisements to neighbors after a change is made in local system.
         */
        transmit_delay?: number | string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: True
         *
         * Specifies whether or not the configuration is active or deactivated
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        /**
         * Specify the number of seconds that LLDP information is held before it is discarded. The multiplier value is used in combination with the C(interval) value.
         */
        hold_multiplier?: number | string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Manages HSRP configuration on NX-OS switches.
       */
      nxos_hsrp?: {
        /**
         * Authentication type.
         */
        auth_type?: "text" | "md5";
        username?: string;
        ssh_keyfile?: string;
        /**
         * HSRP group number.
         */
        group: string;
        /**
         * Enable/Disable preempt.
         */
        preempt?: "enabled" | "disabled";
        /**
         * Authentication string. If this needs to be hidden(for md5 type), the string should be 7 followed by the key string. Otherwise, it can be 0 followed by key string or just key string (for backward compatibility). For text type, this should be just be a key string. if this is 'default', authentication is removed.
         */
        auth_string?: string;
        /**
         * HSRP virtual IP address or keyword 'default'
         */
        vip?: string;
        auth_pass?: string;
        host?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * HSRP priority or keyword 'default'.
         */
        priority?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Default: 1
         *
         * HSRP version.
         */
        version?: "1" | "2";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Full name of interface that is being managed for HSRP.
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an IOS XR node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(iosxr_config) to configure iosxr devices.
       */
      iosxr_command?: {
        [k: string]: unknown;
      };
      /**
       * This module uncoditionally saves the configuration on the target netscaler node.
       * This module does not support check mode.
       * This module is intended to run either on the ansible  control node or a bastion (jumpserver) with access to the actual netscaler instance.
       */
      netscaler_save_config?: {
        /**
         * Default: http
         *
         * Which protocol to use when accessing the nitro API objects.
         */
        nitro_protocol?: "http" | "https";
        /**
         * The ip address of the netscaler appliance where the nitro API calls will be made.
         * The port can be specified with the colon (:). E.g. C(192.168.1.1:555).
         */
        nsip: string;
        /**
         * The username with which to authenticate to the netscaler node.
         */
        nitro_user: string;
        /**
         * The password with which to authenticate to the netscaler node.
         */
        nitro_pass: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 310
         *
         * Time in seconds until a timeout error is thrown when establishing a new session with Netscaler.
         */
        nitro_timeout?: number;
        [k: string]: unknown;
      };
      /**
       * Gets information about an AWS CloudFormation stack
       */
      cloudformation_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allows for creation, management, and visibility into networks within Meraki.
       */
      meraki_network?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages Windows Active Directory user accounts.
       */
      win_domain_user?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, destroy, or update volume access groups on SolidFire
       */
      sf_volume_access_group_manager?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Gather facts about virtual gateways in AWS.
       */
      ec2_vpc_vgw_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage an AWS Glue connection. See U(https://aws.amazon.com/glue/) for details.
       */
      aws_glue_connection?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage bower packages with bower
       */
      bower?: {
        /**
         * The name of a bower package to install
         */
        name?: string;
        /**
         * Default: present
         *
         * The state of the bower package
         */
        state?: "present" | "absent" | "latest";
        /**
         * Default: no
         *
         * Install with --production flag
         */
        production?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The version to be installed
         */
        version?: string;
        /**
         * Relative path to bower executable from install path
         */
        relative_execpath?: string;
        /**
         * The base path where to install the bower packages
         */
        path: string;
        /**
         * Default: no
         *
         * Install packages from local cache, if the packages were installed before
         */
        offline?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Execute vrouter-ospf-add, vrouter-ospf-remove command.
       * This command adds/removes Open Shortest Path First(OSPF) area to/from a virtual router(vRouter) service.
       */
      pn_ospfarea?: {
        /**
         * Specify the OSPF area number.
         */
        pn_ospf_area: string;
        /**
         * Login password.
         */
        pn_clipassword: string;
        /**
         * Specify the name of the vRouter.
         */
        pn_vrouter_name: string;
        /**
         * Login username.
         */
        pn_cliusername: string;
        /**
         * OSPF prefix list for filtering incoming packets.
         */
        pn_prefix_listin?: string;
        /**
         * State the action to perform. Use 'present' to add ospf-area, 'absent' to remove ospf-area and 'update' to modify ospf-area.
         */
        state: "present" | "absent" | "update";
        /**
         * OSPF prefix list for filtering outgoing packets.
         */
        pn_prefix_listout?: string;
        /**
         * Specify the OSPF stub type.
         */
        pn_stub_type?: "none" | "stub" | "stub-no-summary" | "nssa" | "nssa-no-summary";
        /**
         * Target switch(es) to run the CLI on.
         */
        pn_cliswitch?: string;
        /**
         * Default: True
         *
         * Enable/disable system information.
         */
        pn_quiet?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create, update, delete user roles.
       */
      cs_role?: {
        [k: string]: unknown;
      };
      /**
       * The C(unarchive) module unpacks an archive.
       * By default, it will copy the source file from the local system to the target before unpacking.
       * Set C(remote_src=yes) to unpack an archive which already exists on the target.
       * For Windows targets, use the M(win_unzip) module instead.
       * If checksum validation is desired, use M(get_url) or M(uri) instead to fetch the file and set C(remote_src=yes).
       */
      unarchive?: {
        /**
         * If C(remote_src=no) (default), local path to archive file to copy to the target server; can be absolute or relative. If C(remote_src=yes), path on the target server to existing archive file to unpack.
         * If C(remote_src=yes) and C(src) contains C(://), the remote machine will download the file from the URL first. (version_added 2.0). This is only for simple cases, for full download support use the M(get_url) module.
         */
        src: string;
        /**
         * Default: no
         *
         * Set to C(yes) to indicate the archived file is already on the remote system and not local to the Ansible controller.
         * This option is mutually exclusive with C(copy).
         */
        remote_src?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Remote absolute path where the archive should be unpacked.
         */
        dest: string;
        /**
         * Default: no
         *
         * If set to True, return the list of files that are contained in the tarball.
         */
        list_files?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Do not replace existing files that are newer than files from the archive.
         */
        keep_newer?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * If the specified absolute path (file or directory) already exists, this step will B(not) be run.
         */
        creates?: string;
        /**
         * List the directory and file entries that you would like to exclude from the unarchive action.
         */
        exclude?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Specify additional options by passing in an array.
         */
        extra_opts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: yes
         *
         * This only applies if using a https URL as the source of the file.
         * This should only set to C(no) used on personally controlled sites using self-signed certificate.
         * Prior to 2.2 the code worked as if this was set to C(yes).
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Module to manage network interfaces of Virtual Machines in oVirt/RHV.
       */
      ovirt_nic?: {
        /**
         * Virtual network interface profile to be attached to VM network interface.
         */
        profile?: string;
        fetch_nested?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the network interface to manage.
         */
        name: string;
        poll_interval?: number | string;
        /**
         * Name of the Virtual Machine to manage.
         * You must provide either C(vm) parameter or C(template) parameter.
         */
        vm?: string;
        nested_attributes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Should the Virtual Machine NIC be present/absent/plugged/unplugged.
         */
        state?: "absent" | "plugged" | "present" | "unplugged";
        auth: {
          [k: string]: unknown;
        };
        timeout?: number | string;
        /**
         * Custom MAC address of the network interface, by default it's obtained from MAC pool.
         */
        mac_address?: string;
        /**
         * Type of the network interface. For example e1000, pci_passthrough, rtl8139, rtl8139_virtio, spapr_vlan or virtio.
         * It's required parameter when creating the new NIC.
         */
        interface?: string;
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the template to manage.
         * You must provide either C(vm) parameter or C(template) parameter.
         */
        template?: string;
        /**
         * Logical network to which the VM network interface should use, by default Empty network is used if network is not specified.
         */
        network?: string;
        [k: string]: unknown;
      };
      /**
       * The C(jenkins_script) module takes a script plus a dict of values to use within the script and returns the result of the script being run.
       */
      jenkins_script?: {
        /**
         * The groovy script to be executed. This gets passed as a string Template if args is defined.
         */
        script: string;
        /**
         * Default: http://localhost:8080
         *
         * The jenkins server to execute the script against. The default is a local jenkins instance that is not being proxied through a webserver.
         */
        url?: string;
        /**
         * A dict of key-value pairs used in formatting the script using string.Template (see https://docs.python.org/2/library/string.html#template-strings).
         */
        args?: {
          [k: string]: unknown;
        };
        /**
         * The username to connect to the jenkins server with.
         */
        user?: string;
        /**
         * Default: 10
         *
         * The request timeout in seconds
         */
        timeout?: number | string;
        /**
         * The password to connect to the jenkins server with.
         */
        password?: string;
        /**
         * Default: yes
         *
         * If set to C(no), the SSL certificates will not be validated. This should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module is used to configure Scheduler object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_scheduler?: {
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Frequency at which custom scheduler will run.
         * Allowed values are 0-60.
         */
        frequency?: number | string;
        /**
         * Define scheduler action.
         * Enum options - SCHEDULER_ACTION_RUN_A_SCRIPT, SCHEDULER_ACTION_BACKUP.
         * Default value when not specified in API or module is interpreted by Avi Controller as SCHEDULER_ACTION_BACKUP.
         */
        scheduler_action?: string;
        /**
         * Scheduler end date and time.
         */
        end_date_time?: string;
        /**
         * Scheduler start date and time.
         */
        start_date_time?: string;
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Control script to be executed by this scheduler.
         * It is a reference to an object of type alertscriptconfig.
         */
        run_script_ref?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        api_version?: string;
        /**
         * Scheduler run mode.
         * Enum options - RUN_MODE_PERIODIC, RUN_MODE_AT, RUN_MODE_NOW.
         */
        run_mode?: string;
        username?: string;
        /**
         * Backup configuration to be executed by this scheduler.
         * It is a reference to an object of type backupconfiguration.
         */
        backup_config_ref?: string;
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * Name of scheduler.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Boolean flag to set enabled.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Unit at which custom scheduler will run.
         * Enum options - SCHEDULER_FREQUENCY_UNIT_MIN, SCHEDULER_FREQUENCY_UNIT_HOUR, SCHEDULER_FREQUENCY_UNIT_DAY, SCHEDULER_FREQUENCY_UNIT_WEEK,
         * SCHEDULER_FREQUENCY_UNIT_MONTH.
         */
        frequency_unit?: string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Manage (add, remove, change) individual settings in an INI-style file without having to manage the file as a whole with, say, M(template) or M(assemble). Adds missing sections if they don't exist.
       * Before version 2.0, comments are discarded when the source file is read, and therefore will not show up in the destination file.
       * Since version 2.3, this module adds missing ending newlines to files to keep in line with the POSIX standard, even when no other modifications need to be applied.
       */
      ini_file?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manages BGP configurations on HUAWEI CloudEngine switches.
       */
      ce_bgp?: {
        username?: string;
        /**
         * Default: no_use
         *
         * If the value is true, VPN BGP instances are enabled to automatically select router IDs. If the value is false, VPN BGP instances are disabled from automatically selecting router IDs.
         */
        vrf_rid_auto_sel?: "no_use" | "true" | "false";
        /**
         * Suppress interval.
         */
        suppress_interval?: string;
        /**
         * Default: no_use
         *
         * Support BGP RIB memory protection.
         */
        memory_limit?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * Interrupt BGP all neighbor.
         */
        is_shutdown?: "no_use" | "true" | "false";
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Hold time, in seconds. The value of the hold time can be 0 or range from 3 to 65535.
         */
        hold_time?: string;
        /**
         * Hold interval.
         */
        hold_interval?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Name of a BGP instance. The name is a case-sensitive string of characters.
         */
        vrf_name?: string;
        /**
         * Default: no_use
         *
         * Peer disconnection through GR.
         */
        gr_peer_reset?: "no_use" | "true" | "false";
        /**
         * ID of a router that is in IPv4 address format.
         */
        router_id?: string;
        /**
         * Local AS number. The value is a string of 1 to 11 characters.
         */
        as_number?: string;
        /**
         * Maximum number of AS numbers in the AS_Path attribute. The default value is 255.
         */
        as_path_limit?: string;
        /**
         * Confederation ID. The value is a string of 1 to 11 characters.
         */
        confed_id_number?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the system stores all route update messages received from all peers (groups) after BGP connection setup. If the value is false, the system stores only BGP update messages that are received from peers and pass the configured import policy.
         */
        keep_all_routes?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * The function to automatically select router IDs for all VPN BGP instances is enabled.
         */
        bgp_rid_auto_sel?: "no_use" | "true" | "false";
        /**
         * ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.
         */
        conn_retry_time?: string;
        host?: string;
        /**
         * Confederation AS number, in two-byte or four-byte format. The value is a string of 1 to 11 characters.
         */
        confed_peer_as_num?: string;
        /**
         * Min hold time, in seconds. The value of the hold time can be 0 or range from 20 to 65535.
         */
        min_hold_time?: string;
        /**
         * Default: no_use
         *
         * If the value is true, After the fast EBGP interface awareness function is enabled, EBGP sessions on an interface are deleted immediately when the interface goes Down. If the value is  false, After the fast EBGP interface awareness function is enabled, EBGP sessions on an interface are not deleted immediately when the interface goes Down.
         */
        ebgp_if_sensitive?: "no_use" | "true" | "false";
        password?: string;
        /**
         * Default: no_use
         *
         * Check the first AS in the AS_Path of the update messages from EBGP peers.
         */
        check_first_as?: "no_use" | "true" | "false";
        /**
         * Clear interval.
         */
        clear_interval?: string;
        ssh_keyfile?: string;
        /**
         * Default: no_use
         *
         * Enable GR of the BGP speaker in the specified address family, peer address, or peer group.
         */
        graceful_restart?: "no_use" | "true" | "false";
        /**
         * Period of waiting for the End-Of-RIB flag. The value is an integer ranging from 3 to 3000. The default value is 600.
         */
        time_wait_for_rib?: string;
        /**
         * Type of a created address family, which can be IPv4 unicast or IPv6 unicast. The default type is IPv4 unicast.
         */
        default_af_type?: "ipv4uni" | "ipv6uni";
        /**
         * If the value of a timer changes, the BGP peer relationship between the routers is disconnected. The value is an integer ranging from 0 to 21845. The default value is 60.
         */
        keepalive_time?: string;
        /**
         * Default: no_use
         *
         * Configure the device to be compatible with devices in a nonstandard confederation.
         */
        confed_nonstanded?: "no_use" | "true" | "false";
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module can be used to manage (create, delete) VMware vSphere Datacenters.
       */
      vmware_datacenter?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add, modify or delete sudo command within FreeIPA server using FreeIPA API.
       */
      ipa_sudocmd?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Create, update, or destroy Ansible Tower organizations. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_organization?: {
        /**
         * The description to use for the organization.
         */
        description?: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        tower_password?: string;
        tower_username?: string;
        tower_host?: string;
        /**
         * Name to use for the organization.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove network from OpenStack.
       */
      os_network?: {
        /**
         * Name to be assigned to the network.
         */
        name?: string;
        /**
         * The type of physical network that maps to this network resource.
         */
        provider_network_type?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Default: yes
         *
         * Whether the state should be marked as up or down.
         */
        admin_state_up?: string;
        /**
         * The physical network where this network object is implemented.
         */
        provider_physical_network?: string;
        /**
         * Project name or ID containing the network (name admin-only)
         */
        project?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource.
         */
        state?: string;
        /**
         * An isolated segment on the physical network. The I(network_type) attribute defines the segmentation model. For example, if the I(network_type) value is vlan, this ID is a vlan identifier. If the I(network_type) value is gre, this ID is a gre key.
         */
        provider_segmentation_id?: string;
        /**
         * Default: no
         *
         * Whether this network is externally accessible.
         */
        external?: string;
        /**
         * Default: no
         *
         * Whether this network is shared or not.
         */
        shared?: string;
        [k: string]: unknown;
      };
      /**
       * An Ansible module to modify servers in CenturyLink Cloud.
       */
      clc_modify_server?: {
        /**
         * The alert policy name to be associated to the server. This is mutually exclusive with 'alert_policy_id'
         */
        alert_policy_name?: string;
        /**
         * The anti affinity policy name to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_id'
         */
        anti_affinity_policy_name?: string;
        /**
         * Default: present
         *
         * The state to insure that the provided resources are in.
         */
        state?: "present" | "absent";
        /**
         * The anti affinity policy id to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_name'
         */
        anti_affinity_policy_id?: string;
        /**
         * The alert policy id to be associated to the server. This is mutually exclusive with 'alert_policy_name'
         */
        alert_policy_id?: string;
        /**
         * Memory (in GB) to set to the server.
         */
        memory?: string;
        /**
         * A list of server Ids to modify.
         */
        server_ids:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * How many CPUs to update on the server
         */
        cpu?: string;
        /**
         * Default: yes
         *
         * Whether to wait for the provisioning tasks to finish before returning.
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Allows notifications to be sent using sms / mms via the catapult bandwidth api.
       */
      catapult?: {
        /**
         * One of your catapult telephone numbers the message should come from (must be in E.164 format, like C(+19195551212)).
         */
        src: string;
        /**
         * User Id from Api account page.
         */
        user_id: string;
        /**
         * The phone number or numbers the message should be sent to (must be in E.164 format, like C(+19195551212)).
         */
        dest:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * For MMS messages, a media url to the location of the media to be sent with the message.
         */
        media?: string;
        /**
         * Api Secret from Api account page.
         */
        api_secret: string;
        /**
         * Api Token from Api account page.
         */
        api_token: string;
        /**
         * The contents of the text message (must be 2048 characters or less).
         */
        msg: string;
        [k: string]: unknown;
      };
      /**
       * osx_defaults allows users to read, write, and delete macOS user defaults from Ansible scripts. macOS applications and other programs use the defaults system to record user preferences and other information that must be maintained when the applications aren't running (such as default font for new documents, or the position of an Info panel).
       */
      osx_defaults?: {
        /**
         * Default: NSGlobalDomain
         *
         * The domain is a domain name of the form com.companyname.appname.
         */
        domain?: string;
        /**
         * Default: present
         *
         * The state of the user defaults
         */
        state?: "present" | "absent";
        /**
         * The value to write. Only required when state = present.
         */
        value?: string;
        /**
         * The host on which the preference should apply. The special value "currentHost" corresponds to the "-currentHost" switch of the defaults commandline tool.
         */
        host?: string;
        /**
         * The key of the user preference
         */
        key?: string;
        path?: string;
        /**
         * Default: string
         *
         * The type of value to write.
         */
        type?: "array" | "bool" | "boolean" | "date" | "float" | "int" | "integer" | "string";
        /**
         * Default: no
         *
         * Add new elements to the array for a key which has an array as its value.
         */
        array_add?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create, update and remove OMAPI hosts into compatible DHCPd servers.
       */
      omapi_host?: {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure VsVip object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_vsvip?: {
        /**
         * Force placement on all service engines in the service engine group (container clouds only).
         * Field introduced in 17.1.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        east_west_placement?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        /**
         * Virtual routing context that the virtual service is bound to.
         * This is used to provide the isolation of the set of networks the application is attached to.
         * It is a reference to an object of type vrfcontext.
         * Field introduced in 17.1.1.
         */
        vrf_context_ref?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Uuid of the vsvip object.
         * Field introduced in 17.1.1.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Service discovery specific data including fully qualified domain name, type and time-to-live of the dns record.
         * Field introduced in 17.1.1.
         */
        dns_info?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.1.1.
         */
        tenant_ref?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * It is a reference to an object of type cloud.
         * Field introduced in 17.1.1.
         */
        cloud_ref?: string;
        /**
         * List of virtual service ips and other shareable entities.
         * Field introduced in 17.1.1.
         */
        vip?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Name for the vsvip object.
         * Field introduced in 17.1.1.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, delete or modifiy hostgroups on Pure Storage FlashArrays.
       */
      purefa_hg?: {
        /**
         * List of existing volumes to add to hostgroup.
         */
        volume?: string;
        /**
         * Default: present
         *
         * Define whether the hostgroup should exist or not.
         */
        state?: string;
        /**
         * List of existing hosts to add to hostgroup.
         */
        host?: string;
        /**
         * The name of the hostgroup.
         */
        hostgroup?: string;
        [k: string]: unknown;
      };
      /**
       * Create or diminish a GlusterFS trusted storage pool. A set of nodes can be added into an existing trusted storage pool or a new storage pool can be formed. Or, nodes can be removed from an existing trusted storage pool.
       */
      gluster_peer?: {
        /**
         * Default: present
         *
         * Determines whether the nodes should be attached to the pool or removed from the pool. If the state is present, nodes will be attached to the pool. If state is absent, nodes will be detached from the pool.
         */
        state?: "present" | "absent";
        /**
         * Default: false
         *
         * Applicable only while removing the nodes from the pool. gluster will refuse to detach a node from the pool if any one of the node is down, in such cases force can be used.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of nodes that have to be probed into the pool.
         */
        nodes:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Create or delete a secret within a given keyvault. By using Key Vault, you can encrypt keys and secrets (such as authentication keys, storage account keys, data encryption keys, .PFX files, and passwords).
       */
      azure_rm_keyvaultsecret?: {
        profile?: string;
        /**
         * URI of the keyvault endpoint.
         */
        keyvault_uri: string;
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        /**
         * Default: present
         *
         * Assert the state of the subnet. Use 'present' to create or update a secret and 'absent' to delete a secret .
         */
        state?: "absent" | "present";
        tenant?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        /**
         * Name of the keyvault secret.
         */
        secret_name: string;
        /**
         * Secret to be secured by keyvault.
         */
        secret_value?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of VLANs on VyOS network devices.
       */
      vyos_vlan?: {
        username?: string;
        /**
         * Purge VLANs not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Name of the VLAN.
         */
        name?: string;
        /**
         * List of interfaces that should be associated to the VLAN.
         */
        interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Configure Virtual interface address.
         */
        address?: string;
        /**
         * Default: present
         *
         * State of the VLAN configuration.
         */
        state?: "present" | "absent";
        /**
         * Default: 10
         *
         * Delay the play should wait to check for declarative intent params values.
         */
        delay?: number | string;
        /**
         * List of VLANs definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vlan on device it will result in failure.
         */
        associated_interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        /**
         * ID of the VLAN. Range 0-4094.
         */
        vlan_id?: number | string;
        [k: string]: unknown;
      };
      /**
       * Offers ability to enable and disable features in NX-OS.
       */
      nxos_feature?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Name of feature.
         */
        feature: string;
        /**
         * Default: enabled
         *
         * Desired state of the feature.
         */
        state?: "enabled" | "disabled";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        host?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Assign all or part of disks to nodes.
       */
      na_ontap_disks?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Adds and/or removes instances of PTR record objects from Infoblox NIOS servers.  This module manages NIOS C(record:ptr) objects using the Infoblox WAPI interface over REST.
       */
      nios_ptr_record?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages firewall rules in an AFM firewall policy. New rules will always be added to the end of the policy. Rules can be re-ordered using the C(bigip_security_policy) module. Rules can also be pre-ordered using the C(bigip_security_policy) module and then later updated using the C(bigip_firewall_rule) module.
       */
      bigip_firewall_rule?: {
        [k: string]: unknown;
      };
      /**
       * You can wait for a set amount of time C(timeout), this is the default if nothing is specified or just C(timeout) is specified. This does not produce an error.
       * Waiting for a port to become available is useful for when services are not immediately available after their init scripts return which is true of certain Java application servers. It is also useful when starting guests with the M(virt) module and needing to pause until they are ready.
       * This module can also be used to wait for a regex match a string to be present in a file.
       * In 1.6 and later, this module can also be used to wait for a file to be available or absent on the filesystem.
       * In 1.8 and later, this module can also be used to wait for active connections to be closed before continuing, useful if a node is being rotated out of a load balancer pool.
       * For Windows targets, use the M(win_wait_for) module instead.
       */
      wait_for?: {
        /**
         * Default: ['ESTABLISHED', 'FIN_WAIT1', 'FIN_WAIT2', 'SYN_RECV', 'SYN_SENT', 'TIME_WAIT']
         *
         * The list of TCP connection states which are counted as active connections.
         */
        active_connection_states?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 127.0.0.1
         *
         * A resolvable hostname or IP address to wait for.
         */
        host?: string;
        /**
         * Default: 5
         *
         * Maximum number of seconds to wait for a connection to happen before closing and retrying.
         */
        connect_timeout?: number | string;
        /**
         * Number of seconds to wait before starting to poll.
         */
        delay?: number | string;
        /**
         * Can be used to match a string in either a file or a socket connection.
         * Defaults to a multiline regex.
         */
        search_regex?: string;
        /**
         * Default: started
         *
         * Either C(present), C(started), or C(stopped), C(absent), or C(drained).
         * When checking a port C(started) will ensure the port is open, C(stopped) will check that it is closed, C(drained) will check for active connections.
         * When checking for a file or a search string C(present) or C(started) will ensure that the file or string is present before continuing, C(absent) will check that file is absent or removed.
         */
        state?: "absent" | "drained" | "present" | "started" | "stopped";
        /**
         * Default: 1
         *
         * Number of seconds to sleep between checks, before 2.3 this was hardcoded to 1 second.
         */
        sleep?: number | string;
        /**
         * Default: 300
         *
         * Maximum number of seconds to wait for, when used with another condition it will force an error.
         * When used without other conditions it is equivalent of just sleeping.
         */
        timeout?: number | string;
        /**
         * List of hosts or IPs to ignore when looking for active TCP connections for C(drained) state.
         */
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * This overrides the normal error message from a failure to meet the required conditions.
         */
        msg?: string;
        /**
         * Path to a file on the filesystem that must exist before continuing.
         * C(path) and C(port) are mutually exclusive parameters.
         */
        path?: string;
        /**
         * Port number to poll.
         * C(path) and C(port) are mutually exclusive parameters.
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more subnets from OpenStack.
       */
      os_subnets_facts?: {
        /**
         * Name or ID of the subnet
         */
        subnet?: string;
        /**
         * A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
         */
        filters?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * Gathers Vertica database facts.
       */
      vertica_facts?: {
        /**
         * Default: dbadmin
         *
         * The username used to authenticate with.
         */
        login_user?: string;
        /**
         * Default: localhost
         *
         * Name of the cluster running the schema.
         */
        cluster?: string;
        /**
         * Name of the database running the schema.
         */
        db?: string;
        /**
         * Default: 5433
         *
         * Database port to connect to.
         */
        port?: string;
        /**
         * The password used to authenticate with.
         */
        login_password?: string;
        [k: string]: unknown;
      };
      /**
       * Get/Add/Edit Delete Users from WTI OOB and PDU devices
       */
      cpm_user?: {
        /**
         * If AccessLevel is lower than Administrator, which ports the user has access
         */
        user_portaccess?: string;
        /**
         * This is the Basic Authentication Username of the WTI device to send the module.
         */
        cpm_username: string;
        /**
         * If the user has ability to initiate Outbound connection
         * 0 No , 1 Yes
         */
        user_accessoutbound?: number | string;
        /**
         * If the user has access to the WTI device via Web
         * 0 No , 1 Yes
         */
        user_accessweb?: number | string;
        /**
         * This is the URL of the WTI device to send the module.
         */
        cpm_url: string;
        /**
         * This is the User Name that needs to be create/modified/deleted
         */
        user_name: string;
        /**
         * If the user has access to the WTI device via SSH
         * 0 No , 1 Yes
         */
        user_accessssh?: number | string;
        /**
         * If the user has access to the WTI device via Serial ports
         * 0 No , 1 Yes
         */
        user_accessserial?: number | string;
        /**
         * If the user has access to the WTI device via RESTful APIs
         * 0 No , 1 Yes
         */
        user_accessapi?: number | string;
        /**
         * If AccessLevel is lower than Administrator, which plugs the user has access
         */
        user_plugaccess?: string;
        /**
         * If the user has ability to monitor connection sessions
         * 0 No , 1 Yes
         */
        user_accessmonitor?: number | string;
        /**
         * This is the access level that needs to be create/modified/deleted
         * 0 View, 1 User, 2 SuperUser, 3 Adminstrator
         */
        user_accesslevel?: number | string;
        /**
         * This is the Action to send the module.
         */
        cpm_action: "getuser" | "adduser" | "edituser" | "deleteuser";
        /**
         * This is the User Password that needs to be create/modified/deleted
         * If the user is being Created this parameter is required
         */
        user_pass?: string;
        /**
         * If AccessLevel is lower than Administrator, which Groups the user has access
         */
        user_groupaccess?: string;
        /**
         * This is the Basic Authentication Password of the WTI device to send the module.
         */
        cpm_password: string;
        /**
         * Default: True
         *
         * If false, SSL certificates will not be validated. This should only be used
         * on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * This is the Call Back phone number used for POTS modem connections
         */
        user_callbackphone?: string;
        /**
         * Default: True
         *
         * Designates to use an https connection or http connection.
         */
        use_https?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Flag to control if the lookup will observe HTTP proxy environment variables when present.
         */
        use_proxy?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module is used to configure HealthMonitor object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_healthmonitor?: {
        /**
         * Healthmonitorhttp settings for healthmonitor.
         */
        https_monitor?: {
          [k: string]: unknown;
        };
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Number of continuous successful health checks before server is marked up.
         * Allowed values are 1-50.
         * Default value when not specified in API or module is interpreted by Avi Controller as 2.
         */
        successful_checks?: number | string;
        /**
         * Uuid of the health monitor.
         */
        uuid?: string;
        /**
         * Healthmonitordns settings for healthmonitor.
         */
        dns_monitor?: {
          [k: string]: unknown;
        };
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Number of continuous failed health checks before the server is marked down.
         * Allowed values are 1-50.
         * Default value when not specified in API or module is interpreted by Avi Controller as 2.
         */
        failed_checks?: number | string;
        /**
         * Healthmonitortcp settings for healthmonitor.
         */
        tcp_monitor?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        tenant?: string;
        /**
         * Healthmonitorexternal settings for healthmonitor.
         */
        external_monitor?: {
          [k: string]: unknown;
        };
        /**
         * Type of the health monitor.
         * Enum options - HEALTH_MONITOR_PING, HEALTH_MONITOR_TCP, HEALTH_MONITOR_HTTP, HEALTH_MONITOR_HTTPS, HEALTH_MONITOR_EXTERNAL, HEALTH_MONITOR_UDP,
         * HEALTH_MONITOR_DNS, HEALTH_MONITOR_GSLB.
         */
        type: string;
        api_version?: string;
        username?: string;
        /**
         * A valid response from the server is expected within the receive timeout window.
         * This timeout must be less than the send interval.
         * If server status is regularly flapping up and down, consider increasing this value.
         * Allowed values are 1-2400.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.
         * Units(SEC).
         */
        receive_timeout?: number | string;
        /**
         * User defined description for the object.
         */
        description?: string;
        controller?: string;
        /**
         * Healthmonitorudp settings for healthmonitor.
         */
        udp_monitor?: {
          [k: string]: unknown;
        };
        /**
         * Healthmonitorhttp settings for healthmonitor.
         */
        http_monitor?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Use this port instead of the port defined for the server in the pool.
         * If the monitor succeeds to this port, the load balanced traffic will still be sent to the port of the server defined within the pool.
         * Allowed values are 1-65535.
         * Special values are 0 - 'use server port'.
         */
        monitor_port?: number | string;
        /**
         * A user friendly name for this health monitor.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * This field describes the object's replication scope.
         * If the field is set to false, then the object is visible within the controller-cluster and its associated service-engines.
         * If the field is set to true, then the object is replicated across the federation.
         * Field introduced in 17.1.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        is_federated?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Frequency, in seconds, that monitors are sent to a server.
         * Allowed values are 1-3600.
         * Default value when not specified in API or module is interpreted by Avi Controller as 10.
         * Units(SEC).
         */
        send_interval?: number | string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Downloads an artifact from a maven repository given the maven coordinates provided to the module.
       * Can retrieve snapshots or release versions of the artifact and will resolve the latest available version if one is not available.
       */
      maven_artifact?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Module allows create, search and destroy Amazon EFS file systems
       */
      efs?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create/Delete/Modify_minute job-schedules on ONTAP
       */
      na_ontap_job_schedule?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create/remove Docker networks and connect containers to them.
       * Performs largely the same function as the "docker network" CLI subcommand.
       */
      docker_network?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * This module can be used to manage advance configuration information about an ESXi host when ESXi hostname or Cluster name is given.
       */
      vmware_host_config_manager?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create/update/delete Grafana datasources via API.
       */
      grafana_datasource?: {
        /**
         * Default: 1
         *
         * The opentsdb version.
         * Use C(1) for <=2.1, C(2) for ==2.2, C(3) for ==2.3.
         */
        tsdb_version?: number | string;
        /**
         * Use trends or not for zabbix datasource type
         */
        trends?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The type of the datasource.
         */
        ds_type?:
          | "graphite"
          | "prometheus"
          | "elasticsearch"
          | "influxdb"
          | "opentsdb"
          | "mysql"
          | "postgres"
          | "alexanderzobnin-zabbix-datasource";
        /**
         * Default: proxy
         *
         * The access mode for this datasource.
         */
        access?: "direct" | "proxy";
        /**
         * The datasource basic auth user.
         * Setting this option with basic_auth_password will enable basic auth.
         */
        basic_auth_user?: string;
        /**
         * Skip the TLS datasource certificate verification.
         */
        tls_skip_verify?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The Grafana URL.
         */
        grafana_url: string;
        /**
         * Default: no
         *
         * Whether credentials such as cookies or auth headers should be sent with cross-site requests.
         */
        with_credentials?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The TLS CA certificate for self signed certificates.
         * Only used when C(tls_client_cert) and C(tls_client_key) are set.
         */
        tls_ca_cert?: string;
        /**
         * Default: present
         *
         * Status of the datasource
         */
        state?: "absent" | "present";
        /**
         * The client TLS certificate.
         * If C(tls_client_cert) and C(tls_client_key) are set, this will enable TLS authentication.
         * Starts with ----- BEGIN CERTIFICATE -----
         */
        tls_client_cert?: string;
        /**
         * Default: admin
         *
         * The Grafana API password.
         */
        grafana_password?: string;
        /**
         * Minimum group by interval for C(influxdb) or C(elasticsearch) datasources.
         * for example C(>10s)
         */
        time_interval?: string;
        /**
         * Default: admin
         *
         * The Grafana API user.
         */
        grafana_user?: string;
        /**
         * Default: no
         *
         * Make this datasource the default one.
         */
        is_default?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * SSL mode for C(postgres) datasoure type.
         */
        sslmode?: "disable" | "require" | "verify-ca" | "verify-full";
        /**
         * The datasource login user for influxdb datasources.
         */
        user?: string;
        /**
         * The datasource password
         */
        password?: string;
        /**
         * Default: 256
         *
         * Starting with elasticsearch 5.6, you can specify the max concurrent shard per requests.
         */
        max_concurrent_shard_requests?: number | string;
        /**
         * The datasource basic auth password, when C(basic auth) is C(yes).
         */
        basic_auth_password?: string;
        /**
         * The name of the datasource.
         */
        name: string;
        /**
         * Name of the database for the datasource.
         * This options is required when the C(ds_type) is C(influxdb), C(elasticsearch) (index name), C(mysql) or C(postgres).
         */
        database?: string;
        /**
         * The URL of the datasource.
         */
        url: string;
        /**
         * For elasticsearch C(ds_type), this is the index pattern used.
         */
        interval?: "" | "Hourly" | "Daily" | "Weekly" | "Monthly" | "Yearly";
        /**
         * Default: 1
         *
         * Grafana Organisation ID in which the datasource should be created.
         * Not used when C(grafana_api_key) is set, because the C(grafana_api_key) only belong to one organisation.
         */
        org_id?: number | string;
        /**
         * Default: second
         *
         * The opentsdb time resolution.
         */
        tsdb_resolution?: "millisecond" | "second";
        /**
         * Default: timestamp
         *
         * Name of the time field in elasticsearch ds.
         * For example C(@timestamp)
         */
        time_field?: string;
        /**
         * The Grafana API key.
         * If set, C(grafana_user) and C(grafana_password) will be ignored.
         */
        grafana_api_key?: string;
        /**
         * Default: 5
         *
         * Elasticsearch version (for C(ds_type = elasticsearch) only)
         * Version 56 is for elasticsearch 5.6+ where tou can specify the C(max_concurrent_shard_requests) option.
         */
        es_version?: number | string;
        /**
         * Default: yes
         *
         * Whether to validate the Grafana certificate.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The client TLS private key
         * Starts with ----- BEGIN RSA PRIVATE KEY -----
         */
        tls_client_key?: string;
        [k: string]: unknown;
      };
      /**
       * Manage registration to the Red Hat Network.
       */
      rhn_register?: {
        /**
         * Red Hat Network username
         */
        username?: string;
        /**
         * supply an organizational id for use with registration
         */
        systemorgid?: string;
        /**
         * Default: no
         *
         * If C(no), extended update support will be requested.
         */
        enable_eus?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: Current value of I(serverURL) from C(/etc/sysconfig/rhn/up2date) is the default
         *
         * Specify an alternative Red Hat Network server URL
         */
        server_url?: string;
        /**
         * Optionally specify a list of comma-separated channels to subscribe to upon successful registration.
         */
        channels?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * whether to register (C(present)), or unregister (C(absent)) a system
         */
        state?: "present" | "absent";
        /**
         * supply a custom ssl CA certificate file for use with registration
         */
        sslcacert?: string;
        /**
         * supply an activation key for use with registration
         */
        activationkey?: string;
        /**
         * supply an profilename for use with registration
         */
        profilename?: string;
        /**
         * Red Hat Network password
         */
        password?: string;
        /**
         * Default: no
         *
         * If C(yes), the registered node will not upload its installed packages information to Satellite server
         */
        nopackages?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Allows the management of Foreman resources inside your Foreman server.
       */
      foreman?: {
        /**
         * Username on Foreman server.
         */
        username: string;
        /**
         * URL of Foreman server.
         */
        server_url: string;
        /**
         * The Foreman resource that the action will be performed on (e.g. organization, host).
         */
        entity: string;
        verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Parameters associated to the entity resource to set or edit in dictionary format (e.g. name, description).
         */
        params: {
          [k: string]: unknown;
        };
        /**
         * Password for user accessing Foreman server.
         */
        password: string;
        [k: string]: unknown;
      };
      /**
       * Create or delete or modify NTP server in ONTAP
       */
      na_ontap_ntp?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Add, modify or delete sudo rule within IPA server using IPA API.
       */
      ipa_sudorule?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Create the ip address to tag associations. Tags will in turn be used to create DAG's
       */
      panos_dag_tags?: {
        username?: string;
        password: string;
        /**
         * - Device groups are used for the Panorama interaction with Firewall(s). The group must exists on Panorama. If device group is not define we assume that we are contacting Firewall.
         *
         */
        devicegroup?: string;
        /**
         * The purpose / objective of the static Address Group
         */
        description?: string;
        /**
         * The list of the tags that will be added or removed from the IP address.
         */
        tag_names:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: True
         *
         * commit if changed
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The action to be taken. Supported values are I(add)/I(update)/I(find)/I(delete).
         */
        operation: string;
        /**
         * API key that can be used instead of I(username)/I(password) credentials.
         */
        api_key?: string;
        ip_address: string;
        /**
         * IP that will be registered with the given tag names.
         */
        ip_to_register?: string;
        [k: string]: unknown;
      };
      /**
       * LogicMonitor is a hosted, full-stack, infrastructure monitoring platform.
       * This module collects facts about hosts and host groups within your LogicMonitor account.
       */
      logicmonitor_facts?: {
        /**
         * Default: hostname -f
         *
         * The display name of a host in your LogicMonitor account or the desired display name of a device to add into monitoring.
         */
        displayname?: string;
        /**
         * The LogicMonitor object you wish to manage.
         */
        target: "host" | "hostgroup";
        /**
         * The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes".
         */
        company: string;
        /**
         * Default: hostname -f
         *
         * The hostname of a host in your LogicMonitor account, or the desired hostname of a device to add into monitoring.
         * Required for managing hosts (target=host).
         */
        hostname?: string;
        /**
         * A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.
         */
        user: string;
        /**
         * The fullpath of the hostgroup object you would like to manage.
         * Recommend running on a single ansible host.
         * Required for management of LogicMonitor host groups (target=hostgroup).
         */
        fullpath?: string;
        /**
         * The password for the chosen LogicMonitor User.
         * If an md5 hash is used, the digest flag must be set to true.
         */
        password: string;
        /**
         * The fully qualified domain name of a collector in your LogicMonitor account.
         * This is optional for querying a LogicMonitor host when a displayname is specified.
         * This is required for querying a LogicMonitor host when a displayname is not specified.
         */
        collector?: string;
        [k: string]: unknown;
      };
      /**
       * Adds, updates and removes project deploy keys
       */
      gitlab_deploy_key?: {
        /**
         * GitLab API url, e.g. https://gitlab.example.com/api
         */
        api_url: string;
        /**
         * Deploy key's title
         */
        title: string;
        /**
         * The oauth key provided by GitLab. One of access_token or private_token is required. See https://docs.gitlab.com/ee/api/oauth2.html
         */
        access_token?: string;
        /**
         * Numeric project id or name of project in the form of group/name
         */
        project: string;
        /**
         * Default: present
         *
         * When C(present) the deploy key added to the project if it doesn't exist.
         * When C(absent) it will be removed from the project if it exists
         */
        state?: "present" | "absent";
        /**
         * Deploy key
         */
        key: string;
        /**
         * Default: no
         *
         * Whether this key can push to the project
         */
        can_push?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Personal access token to use. One of private_token or access_token is required. See https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html
         */
        private_token?: string;
        [k: string]: unknown;
      };
      /**
       * Return various information about NetApp E-Series storage arrays (eg, configuration, disks)
       */
      netapp_e_facts?: {
        /**
         * The ID of the array to manage. This value must be unique for each array.
         */
        ssid: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP Firewall
       */
      gcp_compute_firewall_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Module to manage Virtual Machine Snapshots in oVirt/RHV
       */
      ovirt_snapshot?: {
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP HttpsHealthCheck
       */
      gcp_compute_https_health_check_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Create consistency group snapshot for ONTAP volumes.
       */
      na_ontap_cg_snapshot?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage VLANs on a BIG-IP system
       */
      bigip_vlan?: {
        /**
         * Specifies whether some of the stateless traffic on the VLAN should be disaggregated in a round-robin order instead of using a static hash. The stateless traffic includes non-IP L2 traffic, ICMP, some UDP protocols, and so on.
         * When creating a new VLAN, if this parameter is not specified, the default of (no) is used.
         */
        dag_round_robin?: string;
        /**
         * The VLAN to manage. If the special VLAN C(ALL) is specified with the C(state) value of C(absent) then all VLANs will be removed.
         */
        name?: string;
        /**
         * Specifies a list of untagged interfaces and trunks that you want to configure for the VLAN.
         */
        untagged_interfaces?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the maximum transmission unit (MTU) for traffic on this VLAN. When creating a new VLAN, if this parameter is not specified, the default value used will be C(1500).
         * This number must be between 576 to 9198.
         */
        mtu?: string;
        /**
         * Default: present
         *
         * The state of the VLAN on the system. When C(present), guarantees that the VLAN exists with the provided attributes. When C(absent), removes the VLAN from the system.
         */
        state?: string;
        /**
         * Tag number for the VLAN. The tag number can be any integer between 1 and 4094. The system automatically assigns a tag number if you do not specify a value.
         */
        tag?: string;
        /**
         * Specifies a list of tagged interfaces and trunks that you want to configure for the VLAN. Use tagged interfaces or trunks when you want to assign a single interface or trunk to multiple VLANs.
         */
        tagged_interfaces?: string;
        /**
         * Specifies how the traffic on the VLAN will be disaggregated. The value selected determines the traffic disaggregation method. You can choose to disaggregate traffic based on C(source-address) (the source IP address), C(destination-address) (destination IP address), or C(default), which specifies that the default CMP hash uses L4 ports.
         * When creating a new VLAN, if this parameter is not specified, the default of C(default) is used.
         */
        cmp_hash?: string;
        /**
         * Specifies how the disaggregator (DAG) distributes received tunnel-encapsulated packets to TMM instances. Select C(inner) to distribute packets based on information in inner headers. Select C(outer) to distribute packets based on information in outer headers without inspecting inner headers.
         * When creating a new VLAN, if this parameter is not specified, the default of C(outer) is used.
         * This parameter is not supported on Virtual Editions of BIG-IP.
         */
        dag_tunnel?: string;
        /**
         * The description to give to the VLAN.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Gets information about an AWS CloudFront distribution
       */
      cloudfront_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather IP geolocation facts of a host's IP address using ipinfo.io API
       */
      ipinfoio_facts?: {
        /**
         * Default: ansible-ipinfoio-module/0.0.1
         *
         * Set http user agent
         */
        http_agent?: string;
        /**
         * Default: 10
         *
         * HTTP connection timeout in seconds
         */
        timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Collect facts from F5 BIG-IP GTM devices.
       */
      bigip_gtm_facts?: {
        /**
         * Perform regex filter of response. Filtering is done on the name of the resource. Valid filters are anything that can be provided to Python's C(re) module.
         */
        filter?: string;
        /**
         * Fact category to collect.
         */
        include?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about an ESXi host's advance configuration information when ESXi hostname or Cluster name is given.
       */
      vmware_host_config_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure ErrorPageBody object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_errorpagebody?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Field introduced in 17.2.4.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.2.4.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Error page body sent to client when match.
         * Field introduced in 17.2.4.
         */
        error_page_body?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Field introduced in 17.2.4.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Huawei CloudEngine configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with CloudEngine configuration sections in a deterministic way.  This module works with CLI transports.
       */
      ce_config?: {
        [k: string]: unknown;
      };
      /**
       * This module allows you to view the switch running configuration. It executes the display running-config CLI command on a switch and returns a file containing the current running configuration of the target network device. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run.
       */
      cnos_showrun?: {
        username?: string;
        host?: string;
        password?: string;
        enablePassword?: string;
        outputfile: string;
        [k: string]: unknown;
      };
      /**
       * Bind Contract Subjects to Filters on Cisco ACI fabrics.
       */
      aci_contract_subject_to_filter?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Creates/deletes an issue in a Taiga Project Management Platform (U(https://taiga.io)).
       * An issue is identified by the combination of project, issue subject and issue type.
       * This module implements the creation or deletion of issues (not the update).
       */
      taiga_issue?: {
        /**
         * Default: New
         *
         * The issue status. Must exist previously.
         */
        status?: string;
        /**
         * Name of the project containing the issue. Must exist previously.
         */
        project: string;
        /**
         * The issue description.
         */
        description?: string;
        /**
         * A lists of tags to be assigned to the issue.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: Normal
         *
         * The issue priority. Must exist previously.
         */
        priority?: string;
        /**
         * Default: https://api.taiga.io
         *
         * The hostname of the Taiga instance.
         */
        taiga_host?: string;
        /**
         * Default: present
         *
         * Whether the issue should be present or not.
         */
        state?: "present" | "absent";
        /**
         * Path to a file to be attached to the issue.
         */
        attachment?: string;
        /**
         * The issue type. Must exist previously.
         */
        issue_type: string;
        /**
         * The issue subject.
         */
        subject: string;
        /**
         * A string describing the file to be attached to the issue.
         */
        attachment_description?: string;
        /**
         * Default: Normal
         *
         * The issue severity. Must exist previously.
         */
        severity?: string;
        [k: string]: unknown;
      };
      /**
       * Manipulate Rackspace Cloud Block Storage Volumes
       */
      rax_cbs?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages base ACL configurations on HUAWEI CloudEngine switches.
       */
      ce_acl?: {
        /**
         * ACL step. The value is an integer ranging from 1 to 20. The default value is 5.
         */
        acl_step?: string;
        /**
         * Default: no
         *
         * Flag of logging matched data packets.
         */
        log_flag?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of a time range in which an ACL rule takes effect. The value is a string of 1 to 32 characters. The value is case-insensitive, and cannot contain spaces. The name must start with an uppercase or lowercase letter. In addition, the word "all" cannot be specified as a time range name.
         */
        time_range?: string;
        /**
         * Type of packet fragmentation.
         */
        frag_type?: "fragment" | "clear_fragment";
        /**
         * ACL description. The value is a string of 1 to 127 characters.
         */
        acl_description?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Mask of a source IP address. The value is an integer ranging from 1 to 32.
         */
        src_mask?: string;
        transport?: "cli" | "netconf";
        /**
         * ACL number. The value is an integer ranging from 2000 to 2999.
         */
        acl_num?: string;
        port?: number | string;
        /**
         * Matching mode of basic ACL rules.
         */
        rule_action?: "permit" | "deny";
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent" | "delete_acl";
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * ACL number or name. For a numbered rule group, the value ranging from 2000 to 2999 indicates a basic ACL. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.
         */
        acl_name: string;
        /**
         * Name of a basic ACL rule. The value is a string of 1 to 32 characters. The value is case-insensitive, and cannot contain spaces or begin with an underscore (_).
         */
        rule_name?: string;
        host?: string;
        password?: string;
        /**
         * Description about an ACL rule. The value is a string of 1 to 127 characters.
         */
        rule_description?: string;
        ssh_keyfile?: string;
        /**
         * Source IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.
         */
        source_ip?: string;
        /**
         * VPN instance name. The value is a string of 1 to 31 characters.The default value is _public_.
         */
        vrf_name?: string;
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * ID of a basic ACL rule in configuration mode. The value is an integer ranging from 0 to 4294967294.
         */
        rule_id?: string;
        [k: string]: unknown;
      };
      /**
       * Manages AAA server global configuration on HUAWEI CloudEngine switches.
       */
      ce_aaa_server?: {
        username?: string;
        /**
         * Name of the user group where the user belongs. The user inherits all the rights of the user group. The value is a string of 1 to 32 characters.
         */
        local_user_group?: string;
        /**
         * Preferred authorization mode.
         */
        first_author_mode?: "invalid" | "local" | "hwtacacs" | "if-authenticated" | "none";
        /**
         * Name of an authentication scheme. The value is a string of 1 to 32 characters.
         */
        authen_scheme_name?: string;
        /**
         * Name of an authorization scheme. The value is a string of 1 to 32 characters.
         */
        author_scheme_name?: string;
        /**
         * Accounting Mode.
         */
        accounting_mode?: "invalid" | "hwtacacs" | "radius" | "none";
        /**
         * RADIUS server group's name. The value is a string of 1 to 32 case-insensitive characters.
         */
        radius_server_group?: string;
        /**
         * Name of a domain. The value is a string of 1 to 64 characters.
         */
        domain_name?: string;
        /**
         * Preferred authentication mode.
         */
        first_authen_mode?: "invalid" | "local" | "hwtacacs" | "radius" | "none";
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        ssh_keyfile?: string;
        /**
         * Name of a HWTACACS template. The value is a string of 1 to 32 case-insensitive characters.
         */
        hwtacas_template?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        host?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Accounting scheme name. The value is a string of 1 to 32 characters.
         */
        acct_scheme_name?: string;
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Return a list of files based on specific criteria. Multiple criteria are AND'd together.
       * For Windows targets, use the M(win_find) module instead.
       */
      find?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        };
      /**
       * Create, update, enable, disable and remove CloudStack VPC offerings.
       */
      cs_vpc_offering?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allows configuring of the BIG-IP to send mail via an SMTP server by configuring the parameters of an SMTP server.
       */
      bigip_smtp?: {
        /**
         * Specifies the SMTP port number.
         * When creating a new SMTP configuration, the default is C(25) when C(encryption) is C(none) or C(tls). The default is C(465) when C(ssl) is selected.
         */
        smtp_server_port?: string;
        /**
         * User name that the SMTP server requires when validating a user.
         */
        smtp_server_username?: string;
        /**
         * Default: always
         *
         * Passwords are stored encrypted, so the module cannot know if the supplied C(smtp_server_password) is the same or different than the existing password. This parameter controls the updating of the C(smtp_server_password) credential.
         * When C(always), will always update the password.
         * When C(on_create), will only set the password for newly created SMTP server configurations.
         */
        update_password?: string;
        /**
         * Email address that the email is being sent from. This is the "Reply-to" address that the recipient sees.
         */
        from_address?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the SMTP configuration exists.
         * When C(absent), ensures that the SMTP configuration does not exist.
         */
        state?: string;
        /**
         * Specifies whether the SMTP server requires an encrypted connection in order to send mail.
         */
        encryption?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * SMTP server host name in the format of a fully qualified domain name.
         * This value is required when create a new SMTP configuration.
         */
        smtp_server?: string;
        /**
         * Credentials can be set on an SMTP server's configuration even if that authentication is not used (think staging configs or emergency changes). This parameter acts as a switch to make the specified C(smtp_server_username) and C(smtp_server_password) parameters active or not.
         * When C(yes), the authentication parameters will be active.
         * When C(no), the authentication parameters will be inactive.
         */
        authentication?: string;
        /**
         * Host name used in SMTP headers in the format of a fully qualified domain name. This setting does not refer to the BIG-IP system's hostname.
         */
        local_host_name?: string;
        /**
         * Password that the SMTP server requires when validating a user.
         */
        smtp_server_password?: string;
        /**
         * Specifies the name of the SMTP server configuration.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Set column values in record in database table.
       */
      openvswitch_db?: {
        /**
         * Default: 5
         *
         * How long to wait for ovs-vswitchd to respond
         */
        timeout?: number | string;
        /**
         * Expected value for the table, record, column and key.
         */
        value: string;
        /**
         * Identifies the recoard in the table.
         */
        record: string;
        /**
         * Default: present
         *
         * Configures the state of the key. When set to I(present), the I(key) and I(value) pair will be set on the I(record) and when set to I(absent) the I(key) will not be set.
         */
        state?: "present" | "absent";
        /**
         * Identifies the key in the record column, when the column is a map type.
         */
        key?: string;
        /**
         * Identifies the table in the database.
         */
        table: string;
        /**
         * Identifies the column in the record.
         */
        col: string;
        [k: string]: unknown;
      };
      /**
       * Manage InfluxDB retention policies
       */
      influxdb_retention_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module only supports oVirt/RHEV version 3. A newer module M(ovirt_vm) supports oVirt/RHV version 4.
       * Allows you to create/remove/update or powermanage virtual machines on a RHEV/oVirt platform.
       */
      rhevm?: {
        [k: string]: unknown;
      };
      /**
       * obtain facts about one or more RDS instances
       */
      rds_instance_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add, Update or Remove metadata in compute instances from OpenStack.
       */
      os_server_metadata?: {
        /**
         * Availability zone in which to create the snapshot.
         */
        availability_zone?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * A list of key value pairs that should be provided as a metadata to the instance or a string containing a list of key-value pairs. Eg:  meta: "key1=value1,key2=value2"
         */
        meta?: string;
        /**
         * Name of the instance to update the metadata
         */
        server?: string;
        [k: string]: unknown;
      };
      /**
       * Set a password for an LDAP entry.  This module only asserts that a given password is valid for a given entry.  To assert the existence of an entry, see M(ldap_entry).
       */
      ldap_passwd?: {
        dn: string;
        server_uri?: string;
        start_tls?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        bind_dn?: string;
        /**
         * The (plaintext) password to be set for I(dn).
         */
        passwd?: string;
        bind_pw?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages vCMP guests on a BIG-IP. This functionality only exists on actual hardware and must be enabled by provisioning C(vcmp) with the C(bigip_provision) module.
       */
      bigip_vcmp_guest?: {
        /**
         * Specifies the IP address, and subnet or subnet mask that you use to access the guest when you want to manage a module running within the guest. This parameter is required if the C(mgmt_network) parameter is C(bridged).
         * When creating a new guest, if you do not specify a network or network mask, a default of C(/24) (C(255.255.255.0)) will be assumed.
         */
        mgmt_address?: string;
        /**
         * Specifies the gateway address for the C(mgmt_address).
         * If this value is not specified when creating a new guest, it is set to C(none).
         * The value C(none) can be used during an update to remove this value.
         */
        mgmt_route?: string;
        /**
         * The name of the vCMP guest to manage.
         */
        name?: string;
        /**
         * Contains those slots that the guest is allowed to be assigned to.
         * When the host determines which slots this guest should be assigned to, only slots in this list will be considered.
         * This is a good way to force guests to be assigned only to particular slots, or, by configuring disjoint C(allowed_slots) on two guests, that those guests are never assigned to the same slot.
         * By default this list includes every available slot in the cluster. This means, by default, the guest may be assigned to any slot.
         */
        allowed_slots?: string;
        /**
         * Specifies the number of slots for the system to use for creating the guest.
         * This value dictates how many cores a guest is allocated from each slot that it is assigned to.
         * Possible values are dependent on the type of blades being used in this cluster.
         * The default value depends on the type of blades being used in this cluster.
         */
        number_of_slots?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * When C(state) is C(absent), will additionally delete the virtual disk associated with the vCMP guest. By default, this value is C(no).
         */
        delete_virtual_disk?: string;
        /**
         * Specifies the base software release ISO image file for installing the TMOS hypervisor instance and any licensed BIG-IP modules onto the guest's virtual disk. When creating a new guest, this parameter is required.
         */
        initial_image?: string;
        /**
         * Default: present
         *
         * The state of the vCMP guest on the system. Each state implies the actions of all states before it.
         * When C(configured), guarantees that the vCMP guest exists with the provided attributes. Additionally, ensures that the vCMP guest is turned off.
         * When C(disabled), behaves the same as C(configured) the name of this state is just a convenience for the user that is more understandable.
         * When C(provisioned), will ensure that the guest is created and installed. This state will not start the guest; use C(deployed) for that. This state is one step beyond C(present) as C(present) will not install the guest; only setup the configuration for it to be installed.
         * When C(present), ensures the guest is properly provisioned and starts the guest so that it is in a running state.
         * When C(absent), removes the vCMP from the system.
         */
        state?: string;
        /**
         * Specifies the minimum number of slots that the guest must be assigned to in order to deploy.
         * This field dictates the number of slots that the guest must be assigned to.
         * If at the end of any allocation attempt the guest is not assigned to at least this many slots, the attempt fails and the change that initiated it is reverted.
         * A guest's C(min_number_of_slots) value cannot be greater than its C(number_of_slots).
         */
        min_number_of_slots?: string;
        /**
         * VLANs that the guest uses to communicate with other guests, the host, and with the external network. The available VLANs in the list are those that are currently configured on the vCMP host.
         * The order of these VLANs is not important; in fact, it's ignored. This module will order the VLANs for you automatically. Therefore, if you deliberately re-order them in subsequent tasks, you will find that this module will B(not) register a change.
         */
        vlans?: string;
        /**
         * Specifies the method by which the management address is used in the vCMP guest.
         * When C(bridged), specifies that the guest can communicate with the vCMP host's management network.
         * When C(isolated), specifies that the guest is isolated from the vCMP host's management network. In this case, the only way that a guest can communicate with the vCMP host is through the console port or through a self IP address on the guest that allows traffic through port 22.
         * When C(host only), prevents the guest from installing images and hotfixes other than those provided by the hypervisor.
         * If the guest setting is C(isolated) or C(host only), the C(mgmt_address) does not apply.
         * Concerning mode changing, changing C(bridged) to C(isolated) causes the vCMP host to remove all of the guest's management interfaces from its bridged management network. This immediately disconnects the guest's VMs from the physical management network. Changing C(isolated) to C(bridged) causes the vCMP host to dynamically add the guest's management interfaces to the bridged management network. This immediately connects all of the guest's VMs to the physical management network. Changing this property while the guest is in the C(configured) or C(provisioned) state has no immediate effect.
         */
        mgmt_network?: string;
        /**
         * Specifies the number of cores that the system allocates to the guest.
         * Each core represents a portion of CPU and memory. Therefore, the amount of memory allocated per core is directly tied to the amount of CPU. This amount of memory varies per hardware platform type.
         * The number you can specify depends on the type of hardware you have.
         * In the event of a reboot, the system persists the guest to the same slot on which it ran prior to the reboot.
         */
        cores_per_slot?: string;
        [k: string]: unknown;
      };
      /**
       * Create, modifies, and deletes Redshift cluster subnet groups.
       */
      redshift_subnet_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Collects a base set of device facts from a ONYX Mellanox network devices This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      onyx_facts?: {
        /**
         * Default: version
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, version, module, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * This module is used to configure AutoScaleLaunchConfig object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_autoscalelaunchconfig?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Autoscalemesossettings settings for autoscalelaunchconfig.
         */
        mesos?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Unique id of the amazon machine image (ami)  or openstack vm id.
         */
        image_id?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * If set to true, serverautoscalepolicy will use the autoscaling group (external_autoscaling_groups) from pool to perform scale up and scale down.
         * Pool should have single autoscaling group configured.
         * Field introduced in 17.2.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        use_external_asg?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Autoscaleopenstacksettings settings for autoscalelaunchconfig.
         */
        openstack?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Name of the object.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module authenticates to oVirt/RHV engine and creates SSO token, which should be later used in all other oVirt/RHV modules, so all modules don't need to perform login and logout. This module returns an Ansible fact called I(ovirt_auth). Every module can use this fact as C(auth) parameter, to perform authentication.
       */
      ovirt_auth?: {
        /**
         * The name of the user. For example: I(admin@internal) Default value is set by I(OVIRT_USERNAME) environment variable.
         */
        username?: string;
        /**
         * A string containing the hostname of the server. For example: I(server.example.com). Default value is set by I(OVIRT_HOSTNAME) environment variable.
         * Either C(url) or C(hostname) is required.
         */
        hostname?: string;
        /**
         * A PEM file containing the trusted CA certificates. The certificate presented by the server will be verified using these CA certificates. If C(ca_file) parameter is not set, system wide CA certificate store is used. Default value is set by I(OVIRT_CAFILE) environment variable.
         */
        ca_file?: string;
        /**
         * A string containing the API URL of the server. For example: I(https://server.example.com/ovirt-engine/api). Default value is set by I(OVIRT_URL) environment variable.
         * Either C(url) or C(hostname) is required.
         */
        url?: string;
        /**
         * A boolean flag that indicates if the server TLS certificate and host name should be checked.
         */
        insecure?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A boolean flag indicating if Kerberos authentication should be used instead of the default basic authentication.
         */
        kerberos?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A boolean flag indicating if the SDK should ask the server to send compressed responses. The default is I(True). Note that this is a hint for the server, and that it may return uncompressed data even when this parameter is set to I(True).
         */
        compress?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Specifies if a token should be created or revoked.
         */
        state?: "present" | "absent";
        /**
         * A dictionary of HTTP headers to be added to each API call.
         */
        headers?: {
          [k: string]: unknown;
        };
        /**
         * SSO token to be used instead of login with username/password. Default value is set by I(OVIRT_TOKEN) environment variable.
         */
        token?: string;
        ovirt_auth?: {
          [k: string]: unknown;
        };
        /**
         * The maximum total time to wait for the response, in seconds. A value of zero (the default) means wait forever. If the timeout expires before the response is received an exception will be raised.
         */
        timeout?: number | string;
        /**
         * The password of the user. Default value is set by I(OVIRT_PASSWORD) environment variable.
         */
        password?: string;
        [k: string]: unknown;
      };
      /**
       * Manage an AWS VPC Egress Only Internet gateway
       */
      ec2_vpc_egress_igw?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates Connector Card messages through
       * Office 365 Connectors U(https://dev.outlook.com/Connectors)
       */
      office_365_connector_card?: {
        /**
         * A title for the Connector message. Shown at the top of the message.
         */
        title?: string;
        /**
         * Accent color used for branding or indicating status in the card.
         */
        color?: string;
        /**
         * The main text of the card.
         * This will be rendered below the sender information and optional title,
         * and above any sections or actions present.
         */
        text?: string;
        /**
         * The webhook URL is given to you when you create a new Connector.
         */
        webhook: string;
        /**
         * This array of objects will power the action links
         * found at the bottom of the card.
         */
        actions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A string used for summarizing card content.
         * This will be shown as the message subject.
         * This is required if the text parameter isn't populated.
         */
        summary?: string;
        /**
         * Contains a list of sections to display in the card.
         * For more information see https://dev.outlook.com/Connectors/reference.
         */
        sections?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * This module allows the management of AWS Batch Job Queues. It is idempotent and supports "Check" mode.  Use module M(aws_batch_compute_environment) to manage the compute environment, M(aws_batch_job_queue) to manage job queues, M(aws_batch_job_definition) to manage job definitions.
       */
      aws_batch_job_queue?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Modify protocol properties on Solaris/illumos systems.
       */
      ipadm_prop?: {
        /**
         * Specifies the procotol for which we want to manage properties.
         */
        protocol: "ipv4" | "ipv6" | "icmp" | "tcp" | "udp" | "sctp";
        /**
         * Default: present
         *
         * Set or reset the property value.
         */
        state?: "present" | "absent" | "reset";
        /**
         * Specifies the name of property we want to manage.
         */
        property: string;
        /**
         * Specifies that the property value is temporary. Temporary property values do not persist across reboots.
         */
        temporary?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies the value we want to set for the property.
         */
        value?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete an Azure Managed Disk
       */
      azure_rm_managed_disk?: {
        /**
         * Name of a resource group where the managed disk exists or will be created.
         */
        resource_group: string;
        cloud_environment?: string;
        secret?: string;
        /**
         * Name of an existing virtual machine with which the disk is or will be associated, this VM should be in the same resource group.
         * To detach a disk from a vm, keep undefined.
         */
        managed_by?: string;
        /**
         * The resource ID of the managed disk to copy when I(create_option) is C(copy).
         */
        source_resource_uri?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        /**
         * Default: present
         *
         * Assert the state of the managed disk. Use C(present) to create or update a managed disk and 'absent' to delete a managed disk.
         */
        state?: "absent" | "present";
        /**
         * Type of storage for the managed disk: C(Standard_LRS)  or C(Premium_LRS). If not specified the disk is created C(Standard_LRS).
         */
        storage_account_type?: "Standard_LRS" | "Premium_LRS";
        cert_validation_mode?: "validate" | "ignore";
        /**
         * Valid Azure location. Defaults to location of the resource group.
         */
        location?: string;
        subscription_id?: string;
        profile?: string;
        /**
         * Tags to assign to the managed disk.
         */
        tags?: {
          [k: string]: unknown;
        };
        /**
         * URI to a valid VHD file to be used when I(create_option) is C(import).
         */
        source_uri?: string;
        client_id?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        adfs_authority_url?: string;
        password?: string;
        /**
         * Allowed values: empty, import, copy. C(import) from a VHD file in I(source_uri) and C(copy) from previous managed disk I(source_resource_uri).
         */
        create_option?: "empty" | "import" | "copy";
        tenant?: string;
        /**
         * Size in GB of the managed disk to be created. If I(create_option) is C(copy) then the value must be greater than or equal to the source's size.
         */
        disk_size_gb?: number | string;
        /**
         * Name of the managed disk.
         */
        name: string;
        api_profile?: string;
        /**
         * Type of Operating System: C(linux) or C(windows). Used when I(create_option) is either C(copy) or C(import) and the source is an OS disk.
         */
        os_type?: "linux" | "windows";
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about DRS VM-VM and VM-HOST rules from the given cluster.
       */
      vmware_drs_rule_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure PoolGroupDeploymentPolicy object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_poolgroupdeploymentpolicy?: {
        /**
         * Ratio of the traffic that is sent to the pool under test.
         * Test ratio of 100 means blue green.
         * Allowed values are 1-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 100.
         */
        test_traffic_ratio_rampup?: number | string;
        /**
         * It will automatically disable old production pools once there is a new production candidate.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        auto_disable_old_prod_pools?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Uuid of the pool group deployment policy.
         */
        uuid?: string;
        /**
         * It is a reference to an object of type cloud.
         */
        cloud_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Deployment scheme.
         * Enum options - BLUE_GREEN, CANARY.
         * Default value when not specified in API or module is interpreted by Avi Controller as BLUE_GREEN.
         */
        scheme?: string;
        api_version?: string;
        username?: string;
        /**
         * Target traffic ratio before pool is made production.
         * Allowed values are 1-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 100.
         * Units(RATIO).
         */
        target_test_traffic_ratio?: number | string;
        /**
         * Duration of evaluation period for automatic deployment.
         * Allowed values are 60-86400.
         * Default value when not specified in API or module is interpreted by Avi Controller as 300.
         * Units(SEC).
         */
        evaluation_duration?: number | string;
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * List of pgdeploymentrule.
         */
        rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Webhook configured with url that avi controller will pass back information about pool group, old and new pool information and current deployment
         * rule results.
         * It is a reference to an object of type webhook.
         * Field introduced in 17.1.1.
         */
        webhook_ref?: string;
        password?: string;
        tenant?: string;
        /**
         * The name of the pool group deployment policy.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * This module removes, or creates DHCP option sets, and can associate them to a VPC. Optionally, a new DHCP Options set can be created that converges a VPC's existing DHCP option set with values provided. When dhcp_options_id is provided, the module will 1. remove (with state='absent') 2. ensure tags are applied (if state='present' and tags are provided 3. attach it to a VPC (if state='present' and a vpc_id is provided. If any of the optional values are missing, they will either be treated as a no-op (i.e., inherit what already exists for the VPC) To remove existing options while inheriting, supply an empty value (e.g. set ntp_servers to [] if you want to remove them from the VPC's options) Most of the options should be self-explanatory.
       */
      ec2_vpc_dhcp_option?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allows users to add or remove flatpaks.
       * See the M(flatpak_remote) module for managing flatpak remotes.
       */
      flatpak?: {
        /**
         * Default: flatpak
         *
         * The path to the C(flatpak) executable to use.
         * By default, this module looks for the C(flatpak) executable on the path.
         */
        executable?: string;
        /**
         * Default: flathub
         *
         * The flatpak remote (repository) to install the flatpak from.
         * By default, C(flathub) is assumed, but you do need to add the flathub flatpak_remote before you can use this.
         * See the M(flatpak_remote) module for managing flatpak remotes.
         */
        remote?: string;
        /**
         * Default: system
         *
         * The installation method to use.
         * Defines if the I(flatpak) is supposed to be installed globally for the whole C(system) or only for the current C(user).
         */
        method?: "system" | "user";
        /**
         * The name of the flatpak to manage.
         * When used with I(state=present), I(name) can be specified as an C(http(s)) URL to a C(flatpakref) file or the unique reverse DNS name that identifies a flatpak.
         * When suppying a reverse DNS name, you can use the I(remote) option to specify on what remote to look for the flatpak. An example for a reverse DNS name is C(org.gnome.gedit).
         * When used with I(state=absent), it is recommended to specify the name in the reverse DNS format.
         * When supplying an C(http(s)) URL with I(state=absent), the module will try to match the installed flatpak based on the name of the flatpakref to remove it. However, there is no guarantee that the names of the flatpakref file and the reverse DNS name of the installed flatpak do match.
         */
        name: string;
        /**
         * Default: present
         *
         * Indicates the desired package state.
         */
        state?: "absent" | "present";
        [k: string]: unknown;
      };
      /**
       * Return information about installed packages as facts
       */
      package_facts?: {
        /**
         * Default: auto
         *
         * The package manager used by the system so we can query the package information
         */
        manager?: string;
        [k: string]: unknown;
      };
      /**
       * Manage DNS zones in a Memset account.
       */
      memset_zone?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Create/Delete SNMP community
       */
      na_ontap_snmp?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage SLB (Server Load Balancing) service-group objects on A10 Networks devices via aXAPIv2.
       */
      a10_service_group?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create, update and delete instance of MySQL Server.
       */
      azure_rm_mysqlserver?: {
        /**
         * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
         */
        resource_group: string;
        cloud_environment?: string;
        /**
         * The maximum storage allowed for a server.
         */
        storage_mb?: number | string;
        cert_validation_mode?: "validate" | "ignore";
        /**
         * Enable SSL enforcement.
         */
        enforce_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The SKU (pricing tier) of the server.
         */
        sku?: {
          [k: string]: unknown;
        };
        ad_user?: string;
        /**
         * Default: present
         *
         * Assert the state of the MySQL Server. Use 'present' to create or update a server and 'absent' to delete it.
         */
        state?: "absent" | "present";
        /**
         * Default: Default
         *
         * Create mode of SQL Server
         */
        create_mode?: string;
        secret?: string;
        /**
         * Server version.
         */
        version?: "5.6" | "5.7";
        /**
         * The password of the administrator login.
         */
        admin_password?: string;
        subscription_id?: string;
        /**
         * Resource location. If not set, location from the resource group will be used as default.
         */
        location?: string;
        profile?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        tenant?: string;
        /**
         * The name of the server.
         */
        name: string;
        /**
         * The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
         */
        admin_username?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        [k: string]: unknown;
      };
      /**
       * Get facts for all virtual machines of a resource group.
       */
      azure_rm_virtualmachine_facts?: {
        profile?: string;
        /**
         * Name of the virtual machine.
         */
        name?: string;
        /**
         * Name of the resource group containing the virtual machines (required when filtering by vm name).
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure L4PolicySet object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_l4policyset?: {
        /**
         * Policy to apply when a new transport connection is setup.
         * Field introduced in 17.2.7.
         */
        l4_connection_policy?: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * Field introduced in 17.2.7.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        is_internal_policy?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Id of the l4 policy set.
         * Field introduced in 17.2.7.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Field introduced in 17.2.7.
         */
        description?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.2.7.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Creator name.
         * Field introduced in 17.2.7.
         */
        created_by?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Name of the l4 policy set.
         * Field introduced in 17.2.7.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Trigger a graceful removal or insertion (GIR) of the switch.
       */
      nxos_gir?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * When C(system_mode_maintenance_dont_generate_profile=true) it prevents the dynamic searching of enabled protocols and executes commands configured in a maintenance-mode profile. Use this option if you want the system to use a maintenance-mode profile that you have created. When C(system_mode_maintenance_dont_generate_profile=false) it prevents the dynamic searching of enabled protocols and executes commands configured in a normal-mode profile. Use this option if you want the system to use a normal-mode profile that you have created.
         */
        system_mode_maintenance_dont_generate_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Shuts down all protocols, vPC domains, and interfaces except the management interface (using the shutdown command). This option is disruptive while C(system_mode_maintenance) (which uses the isolate command) is not.
         */
        system_mode_maintenance_shutdown?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        auth_pass?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "absent" | "present" | "default";
        host?: string;
        /**
         * Keeps the switch in maintenance mode for a specified number of minutes. Range is 5-65535.
         */
        system_mode_maintenance_timeout?: string;
        /**
         * Boots the switch into maintenance mode automatically in the event of a specified system crash. Note that not all reset reasons are applicable for all platforms. Also if reset reason is set to match_any, it is not idempotent as it turns on all reset reasons. If reset reason is match_any and state is absent, it turns off all the reset reasons.
         */
        system_mode_maintenance_on_reload_reset_reason?:
          | "hw_error"
          | "svc_failure"
          | "kern_failure"
          | "wdog_timeout"
          | "fatal_error"
          | "lc_failure"
          | "match_any"
          | "manual_reload"
          | "any_other"
          | "maintenance";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * When C(system_mode_maintenance=true) it puts all enabled protocols in maintenance mode (using the isolate command). When C(system_mode_maintenance=false) it puts all enabled protocols in normal mode (using the no isolate command).
         */
        system_mode_maintenance?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * This module creates, modifies, and deletes VPN connections. Idempotence is achieved by using the filters option or specifying the VPN connection identifier.
       */
      ec2_vpc_vpn?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV networks.
       */
      ovirt_network_facts?: {
        /**
         * Search term which is accepted by oVirt/RHV search backend.
         * For example to search network starting with string vlan1 use: name=vlan1*
         */
        pattern?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Layer-2 interface on Cisco NXOS devices.
       */
      nxos_l2_interface?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Lists the specified log groups. You can list all your log groups or filter the results by prefix.
       */
      cloudwatchlogs_log_group_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about DigitalOcean provided images.
       * These images can be either of type C(distribution), C(application) and C(private).
       */
      digital_ocean_image_facts?: {
        [k: string]: unknown;
      };
      /**
       * This module allows one to (re)generate OpenSSL private keys. It uses the pyOpenSSL python library to interact with openssl. One can generate either RSA or DSA private keys. Keys are generated in PEM format.
       */
      openssl_privatekey?: {
        /**
         * Should the key be regenerated even if it already exists
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Whether the private key should exist or not, taking action if the state is different from what is stated.
         */
        state?: "present" | "absent";
        /**
         * The cipher to encrypt the private key. (cipher can be found by running `openssl list-cipher-algorithms`)
         */
        cipher?: string;
        /**
         * The passphrase for the private key.
         */
        passphrase?: string;
        /**
         * Name of the file in which the generated TLS/SSL private key will be written. It will have 0600 mode.
         */
        path: string;
        /**
         * Default: RSA
         *
         * The algorithm used to generate the TLS/SSL private key
         */
        type?: "RSA" | "DSA";
        /**
         * Default: 4096
         *
         * Size (in bits) of the TLS/SSL key to generate
         */
        size?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of L3 interfaces on Cisco NXOS network devices.
       */
      nxos_l3_interface?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Name of the L3 interface.
         */
        name?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of the L3 interface configuration.
         */
        state?: "present" | "absent";
        /**
         * IPv6 of the L3 interface.
         */
        ipv6?: string;
        host?: string;
        /**
         * IPv4 of the L3 interface.
         */
        ipv4?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of L3 interfaces definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Create, delete, or modify a Direct Connect public or private virtual interface.
       */
      aws_direct_connect_virtual_interface?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module is used to configure ErrorPageProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_errorpageprofile?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Field introduced in 17.2.4.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.2.4.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Fully qualified domain name for which the error page is generated.
         * Field introduced in 17.2.4.
         * Default value when not specified in API or module is interpreted by Avi Controller as Host Header.
         */
        host_name?: string;
        /**
         * Defined error pages for http status codes.
         * Field introduced in 17.2.4.
         */
        error_pages?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Name of the company to show in error page.
         * Field introduced in 17.2.4.
         * Default value when not specified in API or module is interpreted by Avi Controller as Avi Networks.
         */
        company_name?: string;
        api_context?: {
          [k: string]: unknown;
        };
        tenant?: string;
        password?: string;
        /**
         * Name of the virtual service which generated the error page.
         * Field introduced in 17.2.4.
         * Default value when not specified in API or module is interpreted by Avi Controller as VS Name.
         */
        app_name?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Field introduced in 17.2.4.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific Azure Kubernetes Service or all Azure Kubernetes Services.
       */
      azure_rm_aks_facts?: {
        profile?: string;
        /**
         * Limit results to a specific resource group.
         */
        name?: string;
        /**
         * The resource group to search for the desired Azure Kubernetes Service
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Manage VLANs in Cloud Control network domains.
       */
      dimensiondata_vlan?: {
        wait_time?: number | string;
        mcp_user?: string;
        /**
         * A description of the VLAN.
         */
        description?: string;
        mcp_password?: string;
        region?: string;
        /**
         * The base address for the VLAN's IPv4 network (e.g. 192.168.1.0).
         */
        private_ipv4_base_address?: string;
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the target VLAN.
         * Required if C(state) is C(present).
         */
        name: string;
        /**
         * The size of the IPv4 address space, e.g 24.
         * Required, if C(private_ipv4_base_address) is specified.
         */
        private_ipv4_prefix_size?: number | string;
        /**
         * Default: present
         *
         * The desired state for the target VLAN.
         * C(readonly) ensures that the state is only ever read, not modified (the module will fail if the resource does not exist).
         */
        state?: "present" | "absent" | "readonly";
        location: string;
        /**
         * The Id or name of the target network domain.
         */
        network_domain: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Permit expansion of the target VLAN's network if the module parameters specify a larger network than the VLAN currently posesses?
         * If C(False), the module will fail under these conditions.
         * This is intended to prevent accidental expansion of a VLAN's network (since this operation is not reversible).
         */
        allow_expand?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        wait_poll_interval?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure ActionGroupConfig object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_actiongroupconfig?: {
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Trigger notification to autoscale manager.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        autoscale_trigger_notification?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        api_version?: string;
        username?: string;
        /**
         * Select the snmp trap notification to use when sending alerts via snmp trap.
         * It is a reference to an object of type snmptrapprofile.
         */
        snmp_trap_profile_ref?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        controller?: string;
        /**
         * Generate alert only to external destinations.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        external_only:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Select the email notification configuration to use when sending alerts via email.
         * It is a reference to an object of type alertemailconfig.
         */
        email_config_ref?: string;
        password?: string;
        tenant?: string;
        /**
         * Name of the object.
         */
        name: string;
        /**
         * Select the syslog notification configuration to use when sending alerts via syslog.
         * It is a reference to an object of type alertsyslogconfig.
         */
        syslog_config_ref?: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * When an alert is generated, mark its priority via the alert level.
         * Enum options - ALERT_LOW, ALERT_MEDIUM, ALERT_HIGH.
         * Default value when not specified in API or module is interpreted by Avi Controller as ALERT_LOW.
         */
        level: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Reference of the action script configuration to be used.
         * It is a reference to an object of type alertscriptconfig.
         */
        action_script_config_ref?: string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to manage the VMWare VMKernel interface (also known as Virtual NICs) of host system.
       * This module assumes that the host is already configured with Portgroup and vSwitch.
       */
      vmware_vmkernel?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage BIG-IP device DNS settings.
       */
      bigip_device_dns?: {
        /**
         * A list of name servers that the system uses to validate DNS lookups
         */
        name_servers?: string;
        /**
         * Specifies whether the DNS specifies IP addresses using IPv4 or IPv6.
         */
        ip_version?: string;
        /**
         * A list of domains that the system searches for local domain lookups, to resolve local host names.
         */
        search?: string;
        /**
         * Specifies whether the system caches DNS lookups or performs the operation each time a lookup is needed. Please note that this applies only to Access Policy Manager features, such as ACLs, web application rewrites, and authentication.
         */
        cache?: string;
        /**
         * Default: present
         *
         * The state of the variable on the system. When C(present), guarantees that an existing variable is set to C(value).
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * creates an EBS volume and optionally attaches it to an instance. If both an instance ID and a device name is given and the instance has a device at the device name, then no volume is created and no attachment is made. This module has a dependency on python-boto.
       */
      ec2_vol?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, delete, or modify a Direct Connect link aggregation group.
       */
      aws_direct_connect_link_aggregation_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Enables the management of the Cisco ACI fabric through direct access to the Cisco APIC REST API.
       * Thanks to the idempotent nature of the APIC, this module is idempotent and reports changes.
       */
      aci_rest?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Add or remove PostgreSQL extensions from a database.
       */
      postgresql_ext?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Edit PAM service's type, control, module path and module arguments. In order for a PAM rule to be modified, the type, control and module_path must match an existing rule.  See man(5) pam.d for details.
       */
      pamd?: {
        /**
         * The control of the PAM rule being modified.  This may be a complicated control with brackets.  If this is the case, be sure to put "[bracketed controls]" in quotes.  The type, control and module_path all must match a rule to be modified.
         */
        control: string;
        /**
         * The new module path to be assigned to the new rule.
         */
        new_module_path?: string;
        /**
         * When state is 'updated', the module_arguments will replace existing module_arguments.  When state is 'args_absent' args matching those listed in module_arguments will be removed.  When state is 'args_present' any args listed in module_arguments are added if missing from the existing rule.  Furthermore, if the module argument takes a value denoted by '=', the value will be changed to that specified in module_arguments.  Note that module_arguments is a list.  Please see the examples for usage.
         */
        module_arguments?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The type of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified.
         */
        type: "account" | "-account" | "auth" | "-auth" | "password" | "-password" | "session" | "-session";
        /**
         * The new type to assign to the new rule.
         */
        new_type?: "account" | "-account" | "auth" | "-auth" | "password" | "-password" | "session" | "-session";
        /**
         * Default: updated
         *
         * The default of 'updated' will modify an existing rule if type, control and module_path all match an existing rule.  With 'before', the new rule will be inserted before a rule matching type, control and module_path.  Similarly, with 'after', the new rule will be inserted after an existing rule matching type, control and module_path.  With either 'before' or 'after' new_type, new_control, and new_module_path must all be specified.  If state is 'args_absent' or 'args_present', new_type, new_control, and new_module_path will be ignored.  State 'absent' will remove the rule.  The 'absent' state was added in version 2.4 and is only available in Ansible versions >= 2.4.
         */
        state?: "updated" | "before" | "after" | "args_present" | "args_absent" | "absent";
        /**
         * The new control to assign to the new rule.
         */
        new_control?: string;
        /**
         * The module path of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified.
         */
        module_path: string;
        /**
         * Default: /etc/pam.d/
         *
         * This is the path to the PAM service files
         */
        path?: string;
        /**
         * Default: no
         *
         * Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name generally refers to the PAM service file to change, for example system-auth.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create and manage AWS EC2 instance
       */
      ec2_instance?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage IP tunnel interfaces on Solaris/illumos systems.
       */
      dladm_iptun?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Enable or disable HA on a cluster
       */
      na_ontap_cluster_ha?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Allows you to create or remove a volume from a ProfitBricks datacenter. This module has a dependency on profitbricks >= 1.0.0
       */
      profitbricks_volume?: {
        /**
         * Default: 1
         *
         * The number of volumes you wish to create.
         */
        count?: number | string;
        /**
         * The datacenter in which to create the volumes.
         */
        datacenter?: string;
        /**
         * Public SSH keys allowing access to the virtual machine.
         */
        ssh_keys?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
         */
        subscription_user?: string;
        /**
         * Password set for the administrative user.
         */
        image_password?: string;
        /**
         * Default: UNKNOWN
         *
         * The licence type for the volume. This is used when the image is non-standard.
         */
        licence_type?: string;
        /**
         * Default: True
         *
         * Whether or not to increment a single number in the name for created virtual machines.
         */
        auto_increment?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The system image ID for the volume, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8. This can also be a snapshot image ID.
         */
        image?: string;
        /**
         * list of instance ids, currently only used when state='absent' to remove instances.
         */
        instance_ids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The name of the volumes. You can enumerate the names using auto_increment.
         */
        name?: string;
        /**
         * THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
         */
        subscription_password?: string;
        /**
         * Default: present
         *
         * create or terminate datacenters
         */
        state?: string;
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * Default: VIRTIO
         *
         * The bus type.
         */
        bus?: "IDE" | "VIRTIO";
        /**
         * Default: yes
         *
         * wait for the datacenter to be created before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: HDD
         *
         * The disk type of the volume.
         */
        disk_type?: "HDD" | "SSD";
        server?: string;
        /**
         * Default: 10
         *
         * The size of the volume.
         */
        size?: number | string;
        [k: string]: unknown;
      };
      /**
       * Sends an arbitrary set of commands to an EOS node and returns the results read from the device.  This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      eos_command?: {
        [k: string]: unknown;
      };
      /**
       * Create, Update or Destroy GCE Labels on instances, disks, snapshots, etc. When specifying the GCE resource, users may specifiy the full URL for the resource (its 'self_link'), or the individual parameters of the resource (type, location, name). Examples for the two options can be seen in the documentaion. See U(https://cloud.google.com/compute/docs/label-or-tag-resources) for more information about GCE Labels. Labels are gradually being added to more GCE resources, so this module will need to be updated as new resources are added to the GCE (v1) API.
       */
      gce_labels?: {
        /**
         * The name of resource.
         */
        resource_name?: string;
        service_account_email?: string;
        /**
         * A list of labels (key/value pairs) to add or remove for the resource.
         */
        labels?: {
          [k: string]: unknown;
        };
        /**
         * The location of resource (global, us-central1-f, etc.)
         */
        resource_location?: string;
        state?: "absent" | "present";
        service_account_permissions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        credentials_file?: string;
        pem_file?: string;
        /**
         * The 'self_link' for the resource (instance, disk, snapshot, etc)
         */
        resource_url?: string;
        project_id?: string;
        /**
         * The type of resource (instances, disks, snapshots, images)
         */
        resource_type?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP VpnTunnel
       */
      gcp_compute_vpn_tunnel_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * The region where the tunnel is located.
         */
        region: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        service_account_file?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts from AWS Elasticache clusters
       */
      elasticache_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and delete a managed Azure Container Service (AKS) Instance.
       */
      azure_rm_aks?: {
        /**
         * Name of a resource group where the managed Azure Container Services (AKS) exists or will be created.
         */
        resource_group: string;
        cloud_environment?: string;
        secret?: string;
        /**
         * DNS prefix specified when creating the managed cluster.
         */
        dns_prefix?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        /**
         * Default: present
         *
         * Assert the state of the AKS. Use C(present) to create or update an AKS and C(absent) to delete it.
         */
        state?: "absent" | "present";
        cert_validation_mode?: "validate" | "ignore";
        /**
         * Valid azure location. Defaults to location of the resource group.
         */
        location?: string;
        subscription_id?: string;
        /**
         * The service principal suboptions.
         */
        service_principal?: {
          [k: string]: unknown;
        };
        profile?: string;
        /**
         * The linux profile suboptions.
         */
        linux_profile?: {
          [k: string]: unknown;
        };
        tags?: {
          [k: string]: unknown;
        };
        /**
         * The agent pool profile suboptions.
         */
        agent_pool_profiles?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        tenant?: string;
        /**
         * Name of the managed Azure Container Services (AKS) instance.
         */
        name: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        /**
         * Version of Kubernetes specified when creating the managed cluster.
         */
        kubernetes_version?: string;
        [k: string]: unknown;
      };
      /**
       * Sends an arbitrary netconf command on HUAWEI CloudEngine switches.
       */
      ce_netconf?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * The type of rpc.
         */
        rpc: "get" | "edit-config" | "execute-action" | "execute-cli";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * The config xml string.
         */
        cfg_xml: string;
        [k: string]: unknown;
      };
      /**
       * Manage binary packages for Slackware using 'slackpkg' which is available in versions after 12.2.
       */
      slackpkg?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Sends arbitrary commands to an Extreme VSP device running VOSS, and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode.
       */
      voss_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: string;
        /**
         * List of commands to send to the remote VOSS device. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired. If a command sent to the device requires answering a prompt, it is possible to pass a dict containing I(command), I(answer) and I(prompt). Common answers are 'y' or "\r" (carriage return, must be double quotes). See examples.
         */
        commands?: string;
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
         */
        wait_for?: string;
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: string;
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and remove DNS records using DDNS updates
       * DDNS works well with both bind and Microsoft DNS (see https://technet.microsoft.com/en-us/library/cc961412.aspx)
       */
      nsupdate?: {
        /**
         * Default: hmac-md5
         *
         * Specify key algorithm used by C(key_secret).
         */
        key_algorithm?:
          | "HMAC-MD5.SIG-ALG.REG.INT"
          | "hmac-md5"
          | "hmac-sha1"
          | "hmac-sha224"
          | "hmac-sha256"
          | "hmac-sha384"
          | "hmac-sha512";
        /**
         * DNS record will be modified on this C(zone).
         * When omitted DNS will be queried to attempt finding the correct zone.
         * Starting with Ansible 2.7 this parameter is optional.
         */
        zone?: string;
        /**
         * Use TSIG key name to authenticate against DNS C(server)
         */
        key_name?: string;
        /**
         * Sets the record value.
         */
        value?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Apply DNS modification on this server.
         */
        server: string;
        /**
         * Sets the DNS record to modify. When zone is omitted this has to be absolute (ending with a dot).
         */
        record: string;
        /**
         * Default: present
         *
         * Manage DNS record.
         */
        state?: "present" | "absent";
        /**
         * Default: 3600
         *
         * Sets the record TTL.
         */
        ttl?: number | string;
        /**
         * Default: A
         *
         * Sets the record type.
         */
        type?: string;
        /**
         * Default: 53
         *
         * Use this TCP port when connecting to C(server).
         */
        port?: number | string;
        /**
         * Use TSIG key secret, associated with C(key_name), to authenticate against C(server)
         */
        key_secret?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure ClusterCloudDetails object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_clusterclouddetails?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Field introduced in 17.2.5.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.2.5.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        /**
         * Azure info to configure cluster_vip on the controller.
         * Field introduced in 17.2.5.
         */
        azure_info?: {
          [k: string]: unknown;
        };
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Field introduced in 17.2.5.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 VPCs in AWS
       */
      ec2_vpc_net_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Cisco ASA configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with ASA configuration sections in a deterministic way.
       */
      asa_config?: {
        [k: string]: unknown;
      };
      /**
       * Extreme SLX-OS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with SLX-OS configuration sections in a deterministic way.
       */
      slxos_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add and remove security group rules.
       */
      cs_securitygroup_rule?: {
        [k: string]: unknown;
      };
      /**
       * Manage the container images on the atomic host platform.
       * Allows to execute the commands specified by the RUN label in the container image when present.
       */
      atomic_image?: {
        /**
         * Default: yes
         *
         * Start or Stop the container.
         */
        started?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: latest
         *
         * The state of the container image.
         * The state C(latest) will ensure container image is upgraded to the latest version and forcefully restart container, if running.
         */
        state?: "absent" | "latest" | "present";
        /**
         * Name of the container image.
         */
        name: string;
        /**
         * Define the backend where the image is pulled.
         */
        backend?: "docker" | "ostree";
        [k: string]: unknown;
      };
      /**
       * This module allows you to work with Border Gateway Protocol (BGP) related configurations. The operators used are overloaded to ensure control over switch BGP configurations. This module is invoked using method with asNumber as one of its arguments. The first level of the BGP configuration allows to set up an AS number, with the following attributes going into various configuration operations under the context of BGP. After passing this level, there are eight BGP arguments that will perform further configurations. They are bgpArg1, bgpArg2, bgpArg3, bgpArg4, bgpArg5, bgpArg6, bgpArg7, and bgpArg8. For more details on how to use these arguments, see [Overloaded Variables]. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run.
       */
      cnos_bgp?: {
        username?: string;
        outputfile: string;
        /**
         * This is an overloaded bgp eigth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        bgpArg8?: string;
        /**
         * AS number
         */
        asNum: string;
        /**
         * This is an overloaded bgp fourth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        bgpArg4?: string;
        /**
         * This is an overloaded bgp fifth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        bgpArg5?: string;
        /**
         * This is an overloaded bgp sixth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        bgpArg6?: string;
        /**
         * This is an overloaded bgp seventh argument. Use of this argument can be found is the User Guide referenced above.
         */
        bgpArg7?: string;
        /**
         * This is an overloaded bgp first argument. Usage of this argument can be found is the User Guide referenced above.
         */
        bgpArg1: string;
        /**
         * This is an overloaded bgp second argument. Usage of this argument can be found is the User Guide referenced above.
         */
        bgpArg2?: string;
        /**
         * This is an overloaded bgp third argument. Usage of this argument can be found is the User Guide referenced above.
         */
        bgpArg3?: string;
        host?: string;
        deviceType: string;
        password?: string;
        enablePassword?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of static IP routes on network appliances (routers, switches et. al.).
       */
      net_static_route?: {
        username: string;
        webfilter_content?: {
          [k: string]: unknown;
        };
        webfilter_url?: {
          [k: string]: unknown;
        };
        host: string;
        password?: string;
        vdom?: string;
        [k: string]: unknown;
      };
      /**
       * Module to manage hosts in oVirt/RHV
       */
      ovirt_host?: {
        [k: string]: unknown;
      };
      /**
       * Gathering facts from the API of a zone.
       * Sets Ansible facts accessable by the key C(cloudstack_zone) and since version 2.6 also returns results.
       */
      cs_zone_facts?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Configures the NXAPI feature on devices running Cisco NXOS.  The NXAPI feature is absent from the configuration by default.  Since this module manages the NXAPI feature it only supports the use of the C(Cli) transport.
       */
      nxos_nxapi?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides management of firewall IPv4 policies on FortiOS devices.
       */
      fortios_ipv4_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Wraps the reg.exe command to import the contents of a registry file.
       * Suitable for use with registry files created using M(win_template).
       * Windows registry files have a specific format and must be constructed correctly with carriage return and line feed line endings otherwise they will not be merged.
       * Exported registry files often start with a Byte Order Mark which must be removed if the file is to templated using M(win_template).
       * Registry file format is described at U(https://support.microsoft.com/en-us/kb/310516)
       * See also M(win_template), M(win_regedit)
       */
      win_regmerge?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Designed to return the same information as the C(whoami /all) command.
       * Also includes information missing from C(whoami) such as logon metadata like logon rights, id, type.
       */
      win_whoami?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage switch policy explicit vPC protection groups on Cisco ACI fabrics.
       */
      aci_switch_policy_vpc_protection_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Create, update and delete Azure load balancers
       */
      azure_rm_loadbalancer?: {
        [k: string]: unknown;
      };
      /**
       * Manage SmartOS virtual machine images through imgadm(1M)
       */
      imgadm?: {
        /**
         * Force a given operation (where supported by imgadm(1M)).
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Image UUID. Can either be a full UUID or C(*) for all images.
         */
        uuid?: string;
        /**
         * URI for the image source.
         */
        source?: string;
        /**
         * State the object operated on should be in. C(imported) is an alias for for C(present) and C(deleted) for C(absent). When set to C(vacuumed) and C(uuid) to C(*), it will remove all unused images.
         */
        state: "present" | "absent" | "deleted" | "imported" | "updated" | "vacuumed";
        /**
         * Default: imgapi
         *
         * Type for image sources.
         */
        type?: "imgapi" | "docker" | "dsapi";
        /**
         * Default: zones
         *
         * zpool to import to or delete images from.
         */
        pool?: string;
        [k: string]: unknown;
      };
      /**
       * Downloads files from Cisco FTD devices including pending changes, disk files, certificates, troubleshoot reports, and backups.
       */
      ftd_file_download?: {
        /**
         * Key-value pairs that should be sent as path parameters in a REST API call.
         */
        path_params?: {
          [k: string]: unknown;
        };
        /**
         * The name of the operation to execute.
         * Only operations that return a file can be used in this module.
         */
        operation: string;
        /**
         * Absolute path of where to download the file to.
         * If destination is a directory, the module uses a filename from 'Content-Disposition' header specified by the server.
         */
        destination: string;
        [k: string]: unknown;
      };
      /**
       * Manages MTU settings on HUAWEI CloudEngine switches.
       */
      ce_mtu?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Non-jumbo frame size threshod. The default value is 1518. The value is an integer that ranges from 1518 to jumbo_max, in bytes.
         */
        jumbo_min?: string;
        /**
         * Maximum frame size. The default value is 9216. The value is an integer and expressed in bytes. The value range is 1536 to 12224 for the CE12800 and 1536 to 12288 for ToR switches.
         */
        jumbo_max?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * MTU for a specific interface. The value is an integer ranging from 46 to 9600, in bytes.
         */
        mtu?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Full name of interface, i.e. 40GE1/0/22.
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Add or remove LDAP entries. This module only asserts the existence or non-existence of an LDAP entry, not its attributes. To assert the attribute values of an entry, see M(ldap_attr).
       */
      ldap_entry?: {
        dn: string;
        /**
         * If I(state=present), value or list of values to use when creating the entry. It can either be a string or an actual list of strings.
         */
        objectClass?: string;
        start_tls?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        bind_dn?: string;
        server_uri?: string;
        /**
         * Default: present
         *
         * The target state of the entry.
         */
        state?: "present" | "absent";
        /**
         * List of options which allows to overwrite any of the task or the I(attributes) options. To remove an option, set the value of the option to C(null).
         */
        params?: {
          [k: string]: unknown;
        };
        bind_pw?: string;
        /**
         * If I(state=present), attributes necessary to create an entry. Existing entries are never modified. To assert specific attribute values on an existing entry, use M(ldap_attr) module instead.
         */
        attributes?: {
          [k: string]: unknown;
        };
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages physical attributes of interfaces on HUAWEI CloudEngine switches.
       */
      ce_interface?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Specifies an interface description. The value is a string of 1 to 242 case-sensitive characters, spaces supported but question marks (?) not supported.
         */
        description?: string;
        /**
         * Interface type to be configured from the device.
         */
        interface_type?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent" | "default";
        host?: string;
        /**
         * Specifies the interface management status. The value is an enumerated type. up, An interface is in the administrative Up state. down, An interface is in the administrative Down state.
         */
        admin_state?: "up" | "down";
        /**
         * Manage Layer 2 or Layer 3 state of the interface.
         */
        mode?: "layer2" | "layer3";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Full name of interface, i.e. 40GE1/0/10, Tunnel1.
         */
        interface?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Default: no
         *
         * Specifies whether the interface is a Layer 2 sub-interface.
         */
        l2sub?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management and configuration of OSPF protocol on Mellanox ONYX network devices.
       */
      onyx_ospf?: {
        /**
         * OSPF router ID. Required if I(state=present).
         */
        router_id?: string;
        /**
         * Default: present
         *
         * OSPF state.
         */
        state?: "present" | "absent";
        /**
         * OSPF instance number 1-65535
         */
        ospf: number | string;
        /**
         * List of interfaces and areas. Required if I(state=present).
         */
        interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Backend buckets allow you to use Google Cloud Storage buckets with HTTP(S) load balancing.
       * An HTTP(S) load balancer can direct traffic to specified URLs to a backend bucket rather than a backend service. It can send requests for static content to a Cloud Storage bucket and requests for dynamic content a virtual machine instance.
       */
      gcp_compute_backend_bucket?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * An optional textual description of the resource; provided by the client when the resource is created.
         */
        description?: string;
        service_account_email?: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * Cloud Storage bucket name.
         */
        bucket_name: string;
        /**
         * If true, enable Cloud CDN for this BackendBucket.
         */
        enable_cdn?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035.  Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manage physical, virtual, bridged, routed or FC domain profiles on Cisco ACI fabrics.
       */
      aci_domain?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Fetch DigitalOcean SSH keys facts.
       */
      digital_ocean_sshkey_facts?: {
        [k: string]: unknown;
      };
      /**
       * Gather facts about a single VM on a VMware ESX cluster
       */
      vmware_guest_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Bind SPAN source groups to associated destinaton groups on Cisco ACI fabrics.
       */
      aci_tenant_span_src_group_to_dst_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * This module is used to configure ApplicationPersistenceProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_applicationpersistenceprofile?: {
        /**
         * Specifies behavior when a persistent server has been marked down by a health monitor.
         * Enum options - HM_DOWN_PICK_NEW_SERVER, HM_DOWN_ABORT_CONNECTION, HM_DOWN_CONTINUE_PERSISTENT_SERVER.
         * Default value when not specified in API or module is interpreted by Avi Controller as HM_DOWN_PICK_NEW_SERVER.
         */
        server_hm_down_recovery?: string;
        /**
         * Uuid of the persistence profile.
         */
        uuid?: string;
        /**
         * Method used to persist clients to the same server for a duration of time or a session.
         * Enum options - PERSISTENCE_TYPE_CLIENT_IP_ADDRESS, PERSISTENCE_TYPE_HTTP_COOKIE, PERSISTENCE_TYPE_TLS, PERSISTENCE_TYPE_CLIENT_IPV6_ADDRESS,
         * PERSISTENCE_TYPE_CUSTOM_HTTP_HEADER, PERSISTENCE_TYPE_APP_COOKIE, PERSISTENCE_TYPE_GSLB_SITE.
         * Default value when not specified in API or module is interpreted by Avi Controller as PERSISTENCE_TYPE_CLIENT_IP_ADDRESS.
         */
        persistence_type: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Specifies the http cookie persistence profile parameters.
         */
        http_cookie_persistence_profile?: {
          [k: string]: unknown;
        };
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Specifies the custom http header persistence profile parameters.
         */
        hdr_persistence_profile?: {
          [k: string]: unknown;
        };
        api_version?: string;
        username?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        controller?: string;
        /**
         * Specifies the client ip persistence profile parameters.
         */
        ip_persistence_profile?: {
          [k: string]: unknown;
        };
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * A user-friendly name for the persistence profile.
         */
        name: string;
        /**
         * Specifies the application cookie persistence profile parameters.
         */
        app_cookie_persistence_profile?: {
          [k: string]: unknown;
        };
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * This field describes the object's replication scope.
         * If the field is set to false, then the object is visible within the controller-cluster and its associated service-engines.
         * If the field is set to true, then the object is replicated across the federation.
         * Field introduced in 17.1.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        is_federated?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV virtual machine network interfaces.
       */
      ovirt_nic_facts?: {
        /**
         * Name of the VM where NIC is attached.
         */
        vm?: string;
        /**
         * Name of the NIC, can be used as glob expression.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * create / delete a database in the Cloud Databases.
       */
      rax_cdb_database?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Tests reachability using ping from switch to a remote destination.
       * For a general purpose network module, see the M(net_ping) module.
       * For Windows targets, use the M(win_ping) module instead.
       * For targets running Python, use the M(ping) module instead.
       */
      nxos_ping?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Default: present
         *
         * Determines if the expected result is success or fail.
         */
        state?: "absent" | "present";
        /**
         * IP address or hostname (resolvable by switch) of remote node.
         */
        dest: string;
        auth_pass?: string;
        /**
         * Default: 5
         *
         * Number of packets to send.
         */
        count?: string;
        /**
         * Source IP Address or hostname (resolvable by switch)
         */
        source?: string;
        host?: string;
        /**
         * Outgoing VRF.
         */
        vrf?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Manage Subnets on Cisco ACI fabrics.
       */
      aci_bd_subnet?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Allows you to attach or detach a volume from a ProfitBricks server. This module has a dependency on profitbricks >= 1.0.0
       */
      profitbricks_volume_attachments?: {
        /**
         * The datacenter in which to operate.
         */
        datacenter?: string;
        /**
         * The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
         */
        subscription_user?: string;
        /**
         * The name of the server you wish to detach or attach the volume.
         */
        server?: string;
        /**
         * The volume name or ID.
         */
        volume?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: string;
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
         */
        subscription_password?: string;
        /**
         * Default: yes
         *
         * wait for the operation to complete before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Searches, downloads, and installs Windows updates synchronously by automating the Windows Update client.
       */
      win_updates?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, delete, retrieve, and update znodes using ZooKeeper.
       */
      znode?: {
        /**
         * The path of the znode.
         */
        name: string;
        /**
         * The value assigned to the znode.
         */
        value?: string;
        /**
         * The state to enforce. Mutually exclusive with op.
         */
        state?: "present" | "absent";
        /**
         * A list of ZooKeeper servers (format '[server]:[port]').
         */
        hosts: string;
        /**
         * Default: 300
         *
         * The amount of time to wait for a node to appear.
         */
        timeout?: number | string;
        /**
         * An operation to perform. Mutually exclusive with state.
         */
        op?: "get" | "wait" | "list";
        /**
         * Default: no
         *
         * Recursively delete node and all its children.
         */
        recursive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages DNS records via the Netcup API, see the docs U(https://ccp.netcup.net/run/webservice/servers/endpoint.php)
       */
      netcup_dns?: {
        [k: string]: unknown;
      };
      /**
       * Sends an email with a SendGrid account through their API, not through the SMTP service.
       */
      sendgrid?: {
        body: string;
        /**
         * username for logging into the SendGrid account.
         * Since 2.2 it is only required if api_key is not supplied.
         */
        username?: string;
        /**
         * password that corresponds to the username
         * Since 2.2 it is only required if api_key is not supplied.
         */
        password?: string;
        /**
         * the name you want to appear in the from field, i.e 'John Doe'
         */
        from_name?: string;
        /**
         * a list of relative or explicit paths of files you want to attach (7MB limit as per SendGrid docs)
         */
        attachments?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * a list of email addresses to cc
         */
        cc?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * a list of email addresses to bcc
         */
        bcc?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * a dict to pass on as headers
         */
        headers?: {
          [k: string]: unknown;
        };
        /**
         * a list with one or more recipient email addresses
         */
        to_addresses:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: no
         *
         * whether the body is html content that should be rendered
         */
        html_body?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * sendgrid API key to use instead of username/password
         */
        api_key?: string;
        /**
         * the address in the "from" field for the email
         */
        from_address: string;
        /**
         * the desired subject for the email
         */
        subject: string;
        [k: string]: unknown;
      };
      /**
       * Manages configuration of a Protocol Independent Multicast (PIM) instance.
       */
      nxos_pim?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Configure group ranges for Source Specific Multicast (SSM). Valid values are multicast addresses or the keyword C(none) or keyword C(default). C(none) removes all SSM group ranges. C(default) will set ssm_range to the default multicast address. If you set multicast address, please ensure that it is not the same as the C(default), otherwise use the C(default) option.
         */
        ssm_range:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Manages IGMP interface configuration settings.
       */
      nxos_igmp_interface?: {
        /**
         * Query interval used when the IGMP process starts up. The range is from 1 to 18000 or keyword 'default'. The default is 31.
         */
        startup_query_interval?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Configure a routemap for static outgoing interface (OIF) or keyword 'default'.
         */
        oif_routemap?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Sets the number of times that the software sends an IGMP query in response to a host leave message. Values can range from 1 to 5 or keyword 'default'. The default is 2.
         */
        last_member_query_count?: string;
        port?: number | string;
        transport?: "cli" | "nxapi";
        /**
         * Configures report-link-local-groups. Enables sending reports for groups in 224.0.0.0/24. Reports are always sent for nonlink local groups. By default, reports are not sent for link local groups.
         */
        report_llg?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Sets the query interval waited after sending membership reports before the software deletes the group state. Values can range from 1 to 25 seconds or keyword 'default'. The default is 1 second.
         */
        last_member_qrt?: string;
        auth_pass?: string;
        /**
         * Configure prefixes and sources for static outgoing interface (OIF). This is a list of dict where each dict has source and prefix defined or just prefix if source is not needed. The specified values will be configured on the device and if any previous prefix/sources exist, they will be removed. Keyword 'default' is also accpted which removes all existing prefix/sources.
         */
        oif_ps?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Query count used when the IGMP process starts up. The range is from 1 to 10 or keyword 'default'. The default is 2.
         */
        startup_query_count?: string;
        /**
         * Enables the device to remove the group entry from the multicast routing table immediately upon receiving a leave message for the group. Use this command to minimize the leave latency of IGMPv2 group memberships on a given IGMP interface because the device does not send group-specific queries. The default is disabled.
         */
        immediate_leave?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Manages desired state of the resource.
         */
        state?: "present" | "absent" | "default";
        /**
         * IGMP version. It can be 2 or 3 or keyword 'default'.
         */
        version?: string;
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * Sets the group membership timeout for IGMPv2. Values can range from 3 to 65,535 seconds or keyword 'default'. The default is 260 seconds.
         */
        group_timeout?: string;
        host?: string;
        /**
         * This argument is deprecated, please use oif_ps instead. Configure a prefix for static outgoing interface (OIF).
         */
        oif_prefix?: string;
        /**
         * The full interface name for IGMP configuration. e.g. I(Ethernet1/2).
         */
        interface: string;
        /**
         * Sets the querier timeout that the software uses when deciding to take over as the querier. Values can range from 1 to 65535 seconds or keyword 'default'. The default is 255 seconds.
         */
        querier_timeout?: string;
        password?: string;
        /**
         * Restart IGMP. This is NOT idempotent as this is action only.
         */
        restart?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Sets the robustness variable. Values can range from 1 to 7 or keyword 'default'. The default is 2.
         */
        robustness?: string;
        timeout?: number | string;
        /**
         * This argument is deprecated, please use oif_ps instead. Configure a source for static outgoing interface (OIF).
         */
        oif_source?: string;
        /**
         * Sets the frequency at which the software sends IGMP host query messages. Values can range from 1 to 18000 seconds or keyword 'default'. The default is 125 seconds.
         */
        query_interval?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Sets the response time advertised in IGMP queries. Values can range from 1 to 25 seconds or keyword 'default'. The default is 10 seconds.
         */
        query_mrt?: string;
        [k: string]: unknown;
      };
      /**
       * Create, remove, reconfigure, update a private network. This module has a dependency on 1and1 >= 1.0
       */
      oneandone_private_network?: {
        /**
         * The identifier of the datacenter where the private network will be created
         */
        datacenter?: "US" | "ES" | "DE" | "GB";
        /**
         * Set a description for the network.
         */
        description?: string;
        /**
         * Default: 5
         *
         * Defines the number of seconds to wait when using the _wait_for methods
         */
        wait_interval?: number | string;
        /**
         * Authenticating API token provided by 1&1.
         */
        auth_token?: string;
        /**
         * Set a private network space, i.e. 192.168.1.0
         */
        network_address?: string;
        /**
         * Private network name used with present state. Used as identifier (id or name) when used with absent state.
         */
        name?: string;
        /**
         * Set the netmask for the private network, i.e. 255.255.255.0
         */
        subnet_mask?: string;
        /**
         * Default: present
         *
         * Define a network's state to create, remove, or update.
         */
        state?: "present" | "absent" | "update";
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * List of server identifiers (name or id) to be added to the private network.
         */
        add_members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The identifier (id or name) of the network used with update state.
         */
        private_network?: string;
        /**
         * Default: yes
         *
         * wait for the instance to be in state 'running' before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of server identifiers (name or id) to be removed from the private network.
         */
        remove_members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
         */
        api_url?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows to manage dns records on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
       */
      udm_dns_record?: {
        /**
         * Define the record type. C(host_record) is a A or AAAA record, C(alias) is a CNAME, C(ptr_record) is a PTR record, C(srv_record) is a SRV record and C(txt_record) is a TXT record.
         */
        type: string;
        /**
         * Default: present
         *
         * Whether the dns record is present or not.
         */
        state?: "present" | "absent";
        /**
         * Additional data for this record, e.g. ['a': '192.0.2.1']. Required if C(state=present).
         */
        data?: {
          [k: string]: unknown;
        };
        /**
         * Name of the record, this is also the DNS record. E.g. www for www.example.com.
         */
        name: string;
        /**
         * Corresponding DNS zone for this record, e.g. example.com.
         */
        zone: string;
        [k: string]: unknown;
      };
      /**
       * Deploy, start, stop, update, restart, reinstall servers.
       */
      vultr_server?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Manages domain membership or workgroup membership for a Windows host. Also supports hostname changes.
       * This module may require subsequent use of the M(win_reboot) action if changes are made.
       */
      win_domain_membership?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        /**
         * The desired hostname for the Windows host.
         */
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage user accounts and user attributes.
       * For Windows targets, use the M(win_user) module instead.
       */
      user?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Execute vrouter-interface-add, vrouter-interface-remove, vrouter-interface-modify command.
       * You configure interfaces to vRouter services on a fabric, cluster, standalone switch or virtual network(VNET).
       */
      pn_vrouterif?: {
        /**
         * Specify if the NIC is enabled or not
         */
        pn_nic_enable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Specify if the interface is exclusive to the configuration. Exclusive means that other configurations cannot use the interface. Exclusive is specified when you configure the interface as span interface and allows higher throughput through the interface.
         */
        pn_exclusive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the type of NIC. Used for vrouter-interface remove/modify.
         */
        pn_nic_str?: string;
        /**
         * Specify the ID for the VRRP interface. The IDs on both vRouters must be the same IS number.
         */
        pn_vrrp_id?: number | string;
        /**
         * Specify a VRRP advertisement interval in milliseconds. The range is from 30 to 40950 with a default value of 1000.
         */
        pn_vrrp_adv_int?: string;
        /**
         * Specify the priority for the VRRP interface. This is a value between 1 (lowest) and 255 (highest).
         */
        pn_vrrp_priority?: number | string;
        /**
         * Specify an alias for the interface.
         */
        pn_alias?: string;
        /**
         * Specify a secondary MAC address for the interface.
         */
        pn_secondary_macs?: string;
        /**
         * Specify the name of the vRouter interface.
         */
        pn_vrouter_name: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Specify the IP address of the interface in x.x.x.x/n format.
         */
        pn_interface_ip: string;
        /**
         * State the action to perform. Use 'present' to add vrouter interface, 'absent' to remove vrouter interface and 'update' to modify vrouter interface.
         */
        state: "present" | "absent";
        /**
         * Specify the VLAN identifier. This is a value between 1 and 4092.
         */
        pn_vlan?: number | string;
        /**
         * Specify if the interface is management, data or span interface.
         */
        pn_interface?: "mgmt" | "data" | "span";
        /**
         * Specify a Layer 3 port for the interface.
         */
        pn_l3port?: string;
        /**
         * Specify the VXLAN identifier. This is a value between 1 and 16777215.
         */
        pn_vxlan?: number | string;
        /**
         * Target switch to run the cli on.
         */
        pn_cliswitch?: string;
        /**
         * Specify the DHCP method for IP address assignment.
         */
        pn_assignment?: "none" | "dhcp" | "dhcpv6" | "autov6";
        [k: string]: unknown;
      };
      /**
       * Create and Delete Topics/Subscriptions, Publish and pull messages on PubSub. See U(https://cloud.google.com/pubsub/docs) for an overview.
       */
      gcpubsub?: {
        service_account_email?: string;
        /**
         * List of dictionaries describing messages and attributes to be published.  Dictionary is in message(str):attributes(dict) format. Only message is required.
         */
        publish?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * GCP pubsub topic name.
         * Only the name, not the full path, is required.
         */
        topic: string;
        /**
         * Default: present
         *
         * State of the topic or queue.
         * Applies to the most granular resource.
         * If subscription isspecified we remove it.
         * If only topic is specified, that is what is removed.
         * NOTE - A topic can be removed without first removing the subscription.
         */
        state?: "absent" | "present";
        credentials_file?: string;
        project_id?: string;
        /**
         * Dictionary containing a subscripton name associated with a topic (required), along with optional ack_deadline, push_endpoint and pull. For pulling from a subscription, message_ack (bool), max_messages (int) and return_immediate are available as subfields. See subfields name, push_endpoint and ack_deadline for more information.
         */
        subscription?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Allows for managing data groups on a BIG-IP. Data groups provide a way to store collections of values on a BIG-IP for later use in things such as LTM rules, iRules, and ASM policies.
       */
      bigip_data_group?: {
        /**
         * Specifies the name of the data group.
         */
        name?: string;
        /**
         * When C(yes), will ensure that the remote data group file is deleted.
         * This parameter is only relevant when C(state) is C(absent) and C(internal) is C(no).
         */
        delete_data_group_file?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Path to a file with records in it.
         * The file should be well-formed. This means that it includes records, one per line, that resemble the following format "key separator value". For example, C(foo := bar).
         * BIG-IP is strict about this format, but this module is a bit more lax. It will allow you to include arbitrary amounts (including none) of empty space on either side of the separator. For an illustration of this, see the Examples section.
         * Record keys are limited in length to no more than 65520 characters.
         * Values of record keys are limited in length to no more than 65520 characters.
         * The total number of records you can have in your BIG-IP is limited by the memory of the BIG-IP.
         * The format of this content is slightly different depending on whether you specify a C(type) of C(address), C(integer), or C(string). See the examples section for examples of the different types of payload formats that are expected in your data group file.
         * When C(internal) is C(no), at least one record must be specified in either C(records) or C(records_content).
         */
        records_src?: string;
        /**
         * Specifies the records that you want to add to a data group.
         * If you have a large number of records, it is recommended that you use C(records_content) instead of typing all those records here.
         * The technical limit of either 1. the number of records, or 2. the total size of all records, varies with the size of the total resources on your system; in particular, RAM.
         * When C(internal) is C(no), at least one record must be specified in either C(records) or C(records_content).
         */
        records?: string;
        /**
         * Default: present
         *
         * When C(state) is C(present), ensures the data group exists.
         * When C(state) is C(absent), ensures that the data group is removed.
         */
        state?: string;
        /**
         * The type of this data group.
         * You should only consider setting this value in cases where you know exactly what you're doing, B(or), you are working with a pre-existing internal data group.
         * Be aware that if you deliberately force this parameter to C(yes), and you have a either a large number of records or a large total records size, this large amount of data will be reflected in your BIG-IP configuration. This can lead to B(long) system configuration load times due to needing to parse and verify the large configuration.
         * There is a limit of either 4 megabytes or 65,000 records (whichever is more restrictive) for uploads when this parameter is C(yes).
         * This value cannot be changed once the data group is created.
         */
        internal?: string;
        /**
         * Default: :=
         *
         * When specifying C(records_content), this is the string of characters that will be used to break apart entries in the C(records_content) into key/value pairs.
         * By default, this parameter's value is C(:=).
         * This value cannot be changed once it is set.
         * This parameter is only relevant when C(internal) is C(no). It will be ignored otherwise.
         */
        separator?: string;
        /**
         * When creating a new data group, this specifies the file name that you want to give an external data group file on the BIG-IP.
         * This parameter is ignored when C(internal) is C(yes).
         * This parameter can be used to select an existing data group file to use with an existing external data group.
         * If this value is not provided, it will be given the value specified in C(name) and, therefore, match the name of the data group.
         * This value may only contain letters, numbers, underscores, dashes, or a period.
         */
        external_file_name?: string;
        /**
         * Default: string
         *
         * The type of records in this data group.
         * This parameter is especially important because it causes BIG-IP to store your data in different ways so-as to optimize access to it. For example, it would be wrong to specify a list of records containing IP addresses, but label them as a C(string) type.
         * This value cannot be changed once the data group is created.
         */
        type?: string;
        [k: string]: unknown;
      };
      /**
       * Modify IP interface properties on Solaris/illumos systems.
       */
      ipadm_ifprop?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manipulate Rackspace Cloud Files Containers
       */
      rax_files?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * NETCONF is a network management protocol developed and standardized by the IETF. It is documented in RFC 6241.
       * This module allows the user to fetch configuration and state data from NETCONF enabled network devices.
       */
      netconf_get?: {
        /**
         * This argument specifies the XML string which acts as a filter to restrict the portions of the data to be are retrieved from the remote device. If this option is not specified entire configuration or state data is returned in result depending on the value of C(source) option. The C(filter) value can be either XML string or XPath, if the filter is in XPath format the NETCONF server running on remote host should support xpath capability else it will result in an error.
         */
        filter?: string;
        /**
         * Default: never
         *
         * Instructs the module to explicitly lock the datastore specified as C(source). If no I(source) is defined, the I(running) datastore will be locked. By setting the option value I(always) is will explicitly lock the datastore mentioned in C(source) option. By setting the option value I(never) it will not lock the C(source) datastore. The value I(if-supported) allows better interworking with NETCONF servers, which do not support the (un)lock operation for all supported datastores.
         */
        lock?: "never" | "always" | "if-supported";
        /**
         * Encoding scheme to use when serializing output from the device. The option I(json) will serialize the output as JSON data. If the option value is I(json) it requires jxmlease to be installed on control node. The option I(pretty) is similar to received XML response but is using human readable format (spaces, new lines). The option value I(xml) is similar to received XML response but removes all XML namespaces.
         */
        display?: "json" | "pretty" | "xml";
        /**
         * This argument specifies the datastore from which configuration data should be fetched. Valid values are I(running), I(candidate) and I(startup). If the C(source) value is not set both configuration and state information are returned in response from running datastore.
         */
        source?: "running" | "candidate" | "startup";
        [k: string]: unknown;
      };
      /**
       * Create, update, enable, disable and remove network offerings.
       */
      cs_network_offering?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and remove VPN customer gateways.
       */
      cs_vpn_customer_gateway?: {
        [k: string]: unknown;
      };
      /**
       * Create, destroy, resize LUNs on NetApp ONTAP.
       */
      na_ontap_lun?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Send notifications via telegram bot, to a verified group or user
       */
      telegram?: {
        /**
         * What message you wish to send.
         */
        msg: string;
        /**
         * Default: plain
         *
         * Message format. Formatting options `markdown` and `html` described in Telegram API docs (https://core.telegram.org/bots/api#formatting-options). If option `plain` set, message will not be formatted.
         */
        msg_format?: "plain" | "markdown" | "html";
        /**
         * Token identifying your telegram bot.
         */
        token: string;
        /**
         * Telegram group or user chat_id
         */
        chat_id: string;
        [k: string]: unknown;
      };
      /**
       * Configuring Centralized All-Active Gateways or Distributed Gateway for the VXLAN Network on HUAWEI CloudEngine devices.
       */
      ce_vxlan_gateway?: {
        /**
         * Specifies a VNI ID. Binds a VXLAN network identifier (VNI) to a virtual private network (VPN) instance. The value is an integer ranging from 1 to 16000000.
         */
        vpn_vni?: string;
        /**
         * Specifies a MAC address for a VBDIF interface. The value is in the format of H-H-H. Each H is a 4-digit hexadecimal number, such as C(00e0) or C(fc01). If an H contains less than four digits, 0s are added ahead. For example,  C(e0) is equal to C(00e0). A MAC address cannot be all 0s or 1s or a multicast MAC address.
         */
        vbdif_mac?: string;
        /**
         * Specifies the IPv4 address bound to a DFS group. The value is in dotted decimal notation.
         */
        dfs_source_ip?: string;
        /**
         * Specifies the UDP port number of the DFS group. The value is an integer that ranges from 1025 to 65535.
         */
        dfs_udp_port?: string;
        /**
         * Specifies the name of the VPN instance that is associated with the interface. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.
         */
        vbdif_bind_vpn?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Specifies the name of a VPN instance bound to a DFS group. The value is a string of 1 to 31 case-sensitive characters without spaces. If the character string is quoted by double quotation marks, the character string can contain spaces. The value C(_public_) is reserved and cannot be used as the VPN instance name.
         */
        dfs_source_vpn?: string;
        /**
         * Enable VLINK direct route on VBDIF interface.
         */
        arp_direct_route?: "enable" | "disable";
        /**
         * Full name of VBDIF interface, i.e. Vbdif100.
         */
        vbdif_name?: string;
        /**
         * Configure the IP address of an all-active gateway peer. The value is in dotted decimal notation.
         */
        dfs_peer_ip?: string;
        /**
         * Enable the distributed gateway function on VBDIF interface.
         */
        arp_distribute_gateway?: "enable" | "disable";
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * Specifies the ID of a DFS group. The value must be 1.
         */
        dfs_id?: string;
        /**
         * Specifies the name of the VPN instance that is associated with all-active gateway peer. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.
         */
        dfs_peer_vpn?: string;
        host?: string;
        /**
         * Specifies the name of a VPN instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.
         */
        vpn_instance?: string;
        password?: string;
        ssh_keyfile?: string;
        /**
         * Creates all-active gateways.
         */
        dfs_all_active?: "enable" | "disable";
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create or delete etherstubs on Solaris/illumos systems.
       */
      dladm_etherstub?: {
        /**
         * Default: present
         *
         * Create or delete Solaris/illumos etherstub.
         */
        state?: "present" | "absent";
        /**
         * Specifies that the etherstub is temporary. Temporary etherstubs do not persist across reboots.
         */
        temporary?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Etherstub name.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages SNMP community configuration on HUAWEI CloudEngine switches.
       */
      ce_snmp_community?: {
        username?: string;
        /**
         * Mib view name for notification.
         */
        notify_view?: string;
        ssh_keyfile?: string;
        /**
         * Unique name to identify the community.
         */
        community_name?: string;
        /**
         * Mib view name.
         */
        community_mib_view?: string;
        /**
         * Security level indicating whether to use authentication and encryption.
         */
        security_level?: "noAuthNoPriv" | "authentication" | "privacy";
        /**
         * Mib view name for read.
         */
        read_view?: string;
        /**
         * Access control list number.
         */
        acl_number?: string;
        /**
         * Unique name to identify the SNMPv3 group.
         */
        group_name?: string;
        /**
         * Mib view name for write.
         */
        write_view?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Access right read or write.
         */
        access_right?: "read" | "write";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        host?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Create, update and delete blob containers and blob objects. Use to upload a file and store it as a blob object, or download a blob object to a file.
       */
      azure_rm_storageblob?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Manages device IP configuration settings for HA on a BIG-IP. Each BIG-IP device has synchronization and failover connectivity information (IP addresses) that you define as part of HA pairing or clustering. This module allows you to configure that information.
       */
      bigip_device_connectivity?: {
        /**
         * Interface over which the system sends multicast messages associated with failover. When C(failover_multicast) is C(yes) and this option is not provided, a default of C(eth0) will be used.
         */
        multicast_interface?: string;
        /**
         * Specifies the primary IP address for the system to use to mirror connections.
         */
        mirror_primary_address?: string;
        /**
         * Specifies the secondary IP address for the system to use to mirror connections.
         */
        mirror_secondary_address?: string;
        /**
         * Local IP address that the system uses for ConfigSync operations.
         */
        config_sync_ip?: string;
        /**
         * IP address for the system to send multicast messages associated with failover. When C(failover_multicast) is C(yes) and this option is not provided, a default of C(224.0.0.245) will be used.
         */
        multicast_address?: string;
        /**
         * When C(yes), ensures that the Failover Multicast configuration is enabled and if no further multicast configuration is provided, ensures that C(multicast_interface), C(multicast_address) and C(multicast_port) are the defaults specified in each option's description. When C(no), ensures that Failover Multicast configuration is disabled.
         */
        failover_multicast?: string;
        /**
         * Desired addresses to use for failover operations. Options C(address) and C(port) are supported with dictionary structure where C(address) is the local IP address that the system uses for failover operations. Port specifies the port that the system uses for failover operations. If C(port) is not specified, the default value C(1026) will be used.  If you are specifying the (recommended) management IP address, use 'management-ip' in the address field.
         */
        unicast_failover?: string;
        /**
         * Specifies whether mirroring occurs within the same cluster or between different clusters on a multi-bladed system.
         * This parameter is only supported on platforms that have multiple blades, such as Viprion hardware. It is not supported on VE.
         */
        cluster_mirroring?: string;
        /**
         * Port for the system to send multicast messages associated with failover. When C(failover_multicast) is C(yes) and this option is not provided, a default of C(62960) will be used. This value must be between 0 and 65535.
         */
        multicast_port?: string;
        [k: string]: unknown;
      };
      /**
       * Sets or updates the password for a storage array.  When the password is updated on the storage array, it must be updated on the SANtricity Web Services proxy. Note, all storage arrays do not have a Monitor or RO role.
       */
      netapp_e_auth?: {
        /**
         * the identifier of the storage array in the Web Services Proxy.
         */
        ssid?: string;
        /**
         * The full API url.
         * Example: http://ENDPOINT:8080/devmgr/v2
         * This can optionally be set via an environment variable, API_URL
         */
        api_url: string;
        /**
         * The password you would like to set. Cannot be more than 30 characters.
         */
        new_password: string;
        /**
         * The password used to authenticate against the API
         * This can optionally be set via an environment variable, API_PASSWORD
         */
        api_password?: string;
        /**
         * The current admin password. This is not required if the password hasn't been set before.
         */
        current_password?: string;
        /**
         * The username used to authenticate against the API
         * This can optionally be set via an environment variable, API_USERNAME
         */
        api_username?: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Boolean value on whether to update the admin password. If set to false then the RO account is updated.
         */
        set_admin:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the storage array. Note that if more than one storage array with this name is detected, the task will fail and you'll have to use the ID instead.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * - Security policies allow you to enforce rules and take action, and can be as general or specific as needed. The policy rules are compared against the incoming traffic in sequence, and because the first rule that matches the traffic is applied, the more specific rules must precede the more general ones.
       *
       */
      panos_query_rules?: {
        /**
         * Default: admin
         *
         * Username credentials to use for authentication.
         */
        username?: string;
        /**
         * The destination IP address to be queried.
         */
        destination_ip?: string;
        /**
         * Password credentials to use for authentication.
         */
        password?: string;
        /**
         * The protocol used to be queried.  Must be either I(tcp) or I(udp).
         */
        protocol?: "tcp" | "udp";
        /**
         * Name of the source security zone to be queried.
         */
        source_zone?: string;
        /**
         * The source IP address to be queried.
         */
        source_ip?: string;
        /**
         * Name of the application or application group to be queried.
         */
        application?: string;
        /**
         * Name of the rule tag to be queried.
         */
        tag_name?: string;
        /**
         * Name of the destination security zone to be queried.
         */
        destination_zone?: string;
        /**
         * The source port to be queried.
         */
        source_port?: string;
        /**
         * The Panorama device group in which to conduct the query.
         */
        devicegroup?: string;
        /**
         * The destination port to be queried.
         */
        destination_port?: string;
        /**
         * API key that can be used instead of I(username)/I(password) credentials.
         */
        api_key?: string;
        /**
         * IP address (or hostname) of PAN-OS firewall or Panorama management console being queried.
         */
        ip_address: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, or delete OpenStack Identity domains. If a domain with the supplied name already exists, it will be updated with the new description and enabled attributes.
       */
      os_keystone_domain?: {
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Default: yes
         *
         * Is the domain enabled
         */
        enabled?: string;
        /**
         * Description of the domain
         */
        description?: string;
        /**
         * Name that has to be given to the instance
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module only supports oVirt/RHEV version 3. A newer module M(ovirt_vm) supports oVirt/RHV version 4.
       * Allows you to create new instances, either from scratch or an image, in addition to deleting or stopping instances on the oVirt/RHEV platform.
       */
      ovirt?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Sets or deletes values in etcd3 cluster using its v3 api.
       * Needs python etcd3 lib to work
       */
      etcd3?: {
        /**
         * the key where the information is stored in the cluster
         */
        key: string;
        /**
         * Default: localhost
         *
         * the IP address of the cluster
         */
        host?: string;
        /**
         * the state of the value for the key.
         * can be present or absent
         */
        state: "present" | "absent";
        /**
         * the information stored
         */
        value: string;
        /**
         * Default: 2379
         *
         * the port number used to connect to the cluster
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage registration and subscription to the Red Hat Subscription Management entitlement platform using the C(subscription-manager) command
       */
      redhat_subscription?: {
        [k: string]: unknown;
      };
      /**
       * This module allows a server team to provision server network ports for new servers without having to access Arista CVP or asking the network team to do it for them. Provide the information for connecting to CVP, switch rack, port the new server is connected to, optional vlan, and an action and the module will apply the configuration to the switch port via CVP. Actions are add (applies template config to port), remove (defaults the interface config) and show (returns the current port config).
       */
      cv_server_provision?: {
        /**
         * The user that will be used to connect to CVP for making API calls.
         */
        username: string;
        /**
         * The vlan that should be applied to the port for this server. This parameter is dependent on a proper template that supports single vlan provisioning with it. If a port vlan is specified by the template specified does not support this the module will exit out with no changes. If a template is specified that requires a port vlan but no port vlan is specified the module will exit out with no changes.
         */
        port_vlan?: string;
        /**
         * Default: https
         *
         * The protocol to use when making API calls to CVP. CVP defaults to https and newer versions of CVP no longer support http.
         */
        protocol?: "https" | "http";
        /**
         * The physical port number on the switch that the new server is connected to.
         */
        switch_port: string;
        /**
         * The hostname or identifier for the server that is having it's switch port provisioned.
         */
        server_name: string;
        /**
         * The port number to use when making API calls to the CVP node. This will default to the default port for the specified protocol. Port 80 for http and port 443 for https.
         */
        port?: string;
        /**
         * The hostname or IP address of the CVP node being connected to.
         */
        host: string;
        /**
         * A path to a Jinja formatted template file that contains the configuration block that will be applied to the specified switch port. This template will have variable fields replaced by the module before being applied to the switch configuration.
         */
        template?: string;
        /**
         * Default: no
         *
         * Flag that determines whether or not the module will execute the CVP task spawned as a result of changes to a switch configlet. When an add or remove action is taken which results in a change to a switch configlet, CVP will spawn a task that needs to be executed for the configuration to be applied to the switch. If this option is True then the module will determined the task number created by the configuration change, execute it and wait for the task to complete. If the option is False then the task will remain in the Pending state in CVP for a network administrator to review and execute.
         */
        auto_run?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: show
         *
         * The action for the module to take. The actions are add, which applies the specified template config to port, remove, which defaults the specified interface configuration, and show, which will return the current port configuration with no changes.
         */
        action?: "show" | "add" | "remove";
        /**
         * The password of the user that will be used to connect to CVP for API calls.
         */
        password: string;
        /**
         * The hostname of the switch is being configured for the server being provisioned.
         */
        switch_name: string;
        [k: string]: unknown;
      };
      /**
       * Manage DNS zone domains in a Memset account.
       */
      memset_zone_domain?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Gather facts about the Scaleway servers available.
       */
      scaleway_server_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Request a reload of Memset's DNS infrastructure, and optionally poll until it finishes.
       */
      memset_dns_reload?: {
        /**
         * The API key obtained from the Memset control panel.
         */
        api_key: string;
        /**
         * Boolean value, if set will poll the reload job's status and return when the job has completed (unless the 30 second timeout is reached first). If the timeout is reached then the task will not be marked as failed, but stderr will indicate that the polling failed.
         */
        poll?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create, update and delete a Traffic Manager profile.
       */
      azure_rm_trafficmanagerprofile?: {
        /**
         * Default: performance
         *
         * The traffic routing method of the Traffic Manager profile.
         */
        routing_method?: "performance" | "priority" | "weighted" | "geographic";
        /**
         * Name of a resource group where the Traffic Manager profile exists or will be created.
         */
        resource_group: string;
        cloud_environment?: string;
        secret?: string;
        /**
         * Default: {'path': '/', 'protocol': 'HTTP', 'port': 80}
         *
         * The endpoint monitoring settings of the Traffic Manager profile.
         */
        monitor_config?: {
          [k: string]: unknown;
        };
        /**
         * Default: enabled
         *
         * The status of the Traffic Manager profile.
         */
        profile_status?: "enabled" | "disabled";
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        /**
         * Default: present
         *
         * Assert the state of the Traffic Manager profile. Use C(present) to create or update a Traffic Manager profile and C(absent) to delete it.
         */
        state?: "absent" | "present";
        /**
         * The DNS settings of the Traffic Manager profile.
         */
        dns_config?: {
          [k: string]: unknown;
        };
        cert_validation_mode?: "validate" | "ignore";
        /**
         * Default: global
         *
         * Valid azure location. Defaults to 'global' because in default public Azure cloud, Traffic Manager profile can only be deployed globally.
         * Reference https://docs.microsoft.com/en-us/azure/traffic-manager/quickstart-create-traffic-manager-profile#create-a-traffic-manager-profile
         */
        location?: string;
        subscription_id?: string;
        profile?: string;
        tags?: {
          [k: string]: unknown;
        };
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        tenant?: string;
        /**
         * Name of the Traffic Manager profile.
         */
        name: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        [k: string]: unknown;
      };
      /**
       * Create and clear (delete) a silence entries via the Sensu API for subscriptions and checks.
       */
      sensu_silence?: {
        /**
         * Specifies the entity responsible for this entry.
         */
        creator?: string;
        /**
         * Default: http://127.0.01:4567
         *
         * Specifies the URL of the Sensu monitoring host server.
         */
        url?: string;
        /**
         * If specified as true, the silence entry will be automatically cleared once the condition it is silencing is resolved.
         */
        expire_on_resolve?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * If specified, this free-form string is used to provide context or rationale for the reason this silence entry was created.
         */
        reason?: string;
        /**
         * Default: present
         *
         * Specifies to create or clear (delete) a silence entry via the Sensu API
         */
        state?: "present" | "absent";
        /**
         * If specified, the silence entry will be automatically cleared after this number of seconds.
         */
        expire?: number | string;
        /**
         * Specifies the check which the silence entry applies to.
         */
        check?: string;
        /**
         * Specifies the subscription which the silence entry applies to.
         * To create a silence entry for a client prepend C(client:) to client name. Example - C(client:server1.example.dev)
         */
        subscription: string;
        [k: string]: unknown;
      };
      /**
       * Add and delete an IPA DNS Zones using IPA API
       */
      ipa_dnszone?: {
        ipa_port?: number | string;
        ipa_prot?: "http" | "https";
        /**
         * Default: present
         *
         * State to ensure
         */
        state?: "present" | "absent";
        ipa_host?: string;
        ipa_user?: string;
        ipa_pass: string;
        /**
         * The DNS zone name to which needs to be managed.
         */
        zone_name: string;
        ipa_timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create or Delete a Kinesis Stream.
       * Update the retention period of a Kinesis Stream.
       * Update Tags on a Kinesis Stream.
       * Enable/disable server side encryption on a Kinesis Stream.
       */
      kinesis_stream?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages VTP password configuration.
       */
      nxos_vtp_password?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * VTP password
         */
        vtp_password?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource
         */
        state?: "present" | "absent";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Bind Domain to Encap Pools on Cisco ACI fabrics.
       */
      aci_domain_to_encap_pool?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Create or delete AWS SQS queues.
       * Update attributes on existing queues.
       */
      sqs_queue?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides management of FortiOS Devices configuration.
       */
      fortios_config?: {
        username?: string;
        /**
         * The I(src) argument provides a path to the configuration template to load into the remote device.
         */
        src?: string;
        config_file?: string;
        file_mode?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        backup_path?: string;
        /**
         * Only for partial backup, you can restrict by giving expected configuration path (ex. firewall address).
         */
        filter?: string;
        host?: string;
        backup_filename?: string;
        timeout?: number | string;
        password?: string;
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        vdom?: string;
        [k: string]: unknown;
      };
      /**
       * Manage s3 bucket lifecycle rules in AWS
       */
      s3_lifecycle?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add, Update or Remove ports from an OpenStack cloud. A I(state) of 'present' will ensure the port is created or updated if required.
       */
      os_port?: {
        /**
         * Network ID or name this port belongs to.
         */
        network?: string;
        /**
         * Allowed address pairs list.  Allowed address pairs are supported with dictionary structure. e.g.  allowed_address_pairs: - ip_address: 10.1.0.12 mac_address: ab:cd:ef:12:34:56 - ip_address: ...
         */
        allowed_address_pairs?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Extra dhcp options to be assigned to this port.  Extra options are supported with dictionary structure. e.g.  extra_dhcp_opts: - opt_name: opt name1 opt_value: value1 - opt_name: ...
         */
        extra_dhcp_opts?: string;
        /**
         * Sets admin state.
         */
        admin_state_up?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * The ID of the entity that uses this port.
         */
        device_owner?: string;
        /**
         * Default: no
         *
         * Do not associate a security group with this port.
         */
        no_security_groups?: string;
        /**
         * MAC address of this port.
         */
        mac_address?: string;
        /**
         * Device ID of device using this port.
         */
        device_id?: string;
        /**
         * Desired IP and/or subnet for this port.  Subnet is referenced by subnet_id and IP is referenced by ip_address.
         */
        fixed_ips?: string;
        /**
         * Security group(s) ID(s) or name(s) associated with the port (comma separated string or YAML list)
         */
        security_groups?: string;
        /**
         * Name that has to be given to the port.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manages SELinux network port type definitions.
       */
      seport?: {
        /**
         * Default: yes
         *
         * Reload SELinux policy after commit.
         */
        reload?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Desired boolean value.
         */
        state: "absent" | "present";
        /**
         * Ports or port ranges. Can be a list (since 2.6) or comma separated string.
         */
        ports:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * SELinux type for the specified port.
         */
        setype: string;
        /**
         * Protocol for the specified port.
         */
        proto: "tcp" | "udp";
        [k: string]: unknown;
      };
      /**
       * Manages BIG-IQ applications used for load balancing a TCP-based application with a FastL4 profile.
       */
      bigiq_application_fastl4_tcp?: {
        [k: string]: unknown;
      };
      /**
       * Manages application service deployments via the App Services Extension functionality in BIG-IP.
       */
      bigip_appsvcs_extension?: {
        [k: string]: unknown;
      };
      /**
       * Add, modify and delete an IPA host-group using IPA API
       */
      ipa_hostgroup?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Send a message to typetalk using typetalk API ( http://developers.typetalk.in/ )
       */
      typetalk?: {
        /**
         * message body
         */
        msg: string;
        /**
         * topic id to post message
         */
        topic: number | string;
        /**
         * OAuth2 client ID
         */
        client_id: string;
        /**
         * OAuth2 client secret
         */
        client_secret: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove PostgreSQL databases from a remote host.
       */
      postgresql_db?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manages Layer 3 attributes for IPv4 and IPv6 interfaces on HUAWEI CloudEngine switches.
       */
      ce_ip_interface?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * IPv4 or IPv6 Address.
         */
        addr?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Subnet mask for IPv4 or IPv6 Address in decimal format.
         */
        mask?: string;
        /**
         * Default: main
         *
         * Specifies an address type. The value is an enumerated type. main, primary IP address. sub, secondary IP address.
         */
        ipv4_type?: "main" | "sub";
        host?: string;
        /**
         * Default: v4
         *
         * IP address version.
         */
        version?: "v4" | "v6";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Full name of interface, i.e. 40GE1/0/22, vlanif10.
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Bind leaf selectors (with node block range and policy group) to switch policy leaf profiles on Cisco ACI fabrics.
       */
      aci_switch_leaf_selector?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Supports managing traffic groups and their attributes on a BIG-IP.
       */
      bigip_traffic_group?: {
        /**
         * Default: present
         *
         * When C(present), ensures that the traffic group exists.
         * When C(absent), ensures the traffic group is removed.
         */
        state?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * The name of the traffic group.
         */
        name?: string;
        /**
         * Specifies the floating Media Access Control (MAC) address associated with the floating IP addresses defined for a traffic group.
         * Primarily, a MAC masquerade address minimizes ARP communications or dropped packets as a result of failover.
         * A MAC masquerade address ensures that any traffic destined for a specific traffic group reaches an available device after failover, which happens because along with the traffic group, the MAC masquerade address floats to the available device.
         * Without a MAC masquerade address, the sending host must learn the MAC address for a newly-active device, either by sending an ARP request or by relying on the gratuitous ARP from the newly-active device.
         * To unset the MAC address, specify an empty value (C("")) to this parameter.
         */
        mac_address?: string;
        [k: string]: unknown;
      };
      /**
       * Downloads files from HTTP, HTTPS, or FTP to the remote server. The remote server I(must) have direct access to the remote resource.
       * For non-Windows targets, use the M(get_url) module instead.
       */
      win_get_url?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of LLDP service configuration on network devices.
       */
      net_lldp?: {
        username?: string;
        provider?: {
          [k: string]: unknown;
        };
        ssh_keyfile?: string;
        local_max_checkpoints?: number | string;
        /**
         * Default: present
         *
         * State of the LLDP service configuration.
         */
        state?: "present" | "absent";
        rollback_location?: string;
        host?: string;
        rescue_location?: string;
        timeout?: number | string;
        remote_max_checkpoints?: number | string;
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Bind static paths to EPGs on Cisco ACI fabrics.
       */
      aci_static_binding_to_epg?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * create or delete an ec2 key pair.
       */
      ec2_key?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Start, Stop and Enable FCP services.
       */
      na_ontap_fcp?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create, update, restart and delete networks.
       */
      cs_network?: {
        /**
         * Domain the network is related to.
         */
        domain?: string;
        /**
         * The ending IPv6 address of the network belongs to.
         * If not specified, value of C(start_ipv6) is used.
         * Only considered on create.
         */
        end_ipv6?: string;
        api_http_method?: "get" | "post";
        /**
         * The gateway of the network.
         * Required for shared networks and isolated networks when it belongs to a VPC.
         * Only considered on create.
         */
        gateway?: string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        /**
         * Name of the zone in which the network should be deployed.
         * If not set, default zone is used.
         */
        zone?: string;
        /**
         * The beginning IPv6 address of the network belongs to.
         * Only considered on create.
         */
        start_ipv6?: string;
        /**
         * CIDR of IPv6 network, must be at least /64.
         * Only considered on create.
         */
        cidr_ipv6?: string;
        /**
         * Default: present
         *
         * State of the network.
         */
        state?: "present" | "absent" | "restarted";
        /**
         * The ending IPv4 address of the network belongs to.
         * If not specified, value of C(start_ip) is used.
         * Only considered on create.
         */
        end_ip?: string;
        /**
         * Defines whether to allow subdomains to use networks dedicated to their parent domain(s).
         * Should be used with C(acl_type=domain).
         * Only considered on create.
         */
        subdomain_access?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_key?: string;
        /**
         * The ID or VID of the network.
         */
        vlan?: string;
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Cleanup old network elements.
         * Only considered on C(state=restarted).
         */
        clean_up?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The netmask of the network.
         * Required for shared networks and isolated networks when it belongs to a VPC.
         * Only considered on create.
         */
        netmask?: string;
        /**
         * Name of the offering for the network.
         * Required if C(state=present).
         */
        network_offering?: string;
        /**
         * Name of the VPC of the network.
         */
        vpc?: string;
        /**
         * The beginning IPv4 address of the network belongs to.
         * Only considered on create.
         */
        start_ip?: string;
        /**
         * The gateway of the IPv6 network.
         * Required for shared networks.
         * Only considered on create.
         */
        gateway_ipv6?: string;
        /**
         * Display text of the network.
         * If not specified, C(name) will be used as C(display_text).
         */
        display_text?: string;
        /**
         * The isolated private VLAN for this network.
         */
        isolated_pvlan?: string;
        /**
         * Account the network is related to.
         */
        account?: string;
        /**
         * The network domain.
         */
        network_domain?: string;
        /**
         * Name (case sensitive) of the network.
         */
        name: string;
        api_region?: string;
        /**
         * The name of the access control list for the VPC network tier.
         */
        acl?: string;
        /**
         * Name of the project the network to be deployed in.
         */
        project?: string;
        /**
         * Default: account
         *
         * Access control type for the VPC network tier.
         * Only considered on create.
         */
        acl_type?: "account" | "domain";
        [k: string]: unknown;
      };
      /**
       * Manages external GTM monitors on a BIG-IP.
       */
      bigip_gtm_monitor_external?: {
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the name of the monitor.
         */
        name?: string;
        /**
         * Default: /Common/external
         *
         * The parent template of this monitor template. Once this value has been set, it cannot be changed. By default, this value is the C(http) parent on the C(Common) partition.
         */
        parent?: string;
        /**
         * IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
         */
        ip?: string;
        /**
         * Specifies any variables that the script requires.
         * Note that double quotes in values will be suppressed.
         */
        variables?: string;
        /**
         * The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 30. This value B(must) be less than the C(timeout) value.
         */
        interval?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the monitor exists.
         * When C(absent), ensures the monitor is removed.
         */
        state?: string;
        /**
         * Specifies any command-line arguments that the script requires.
         */
        arguments?: string;
        /**
         * The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 120.
         */
        timeout?: string;
        /**
         * Specifies the name of the file for the monitor to use. In order to reference a file, you must first import it using options on the System > File Management > External Monitor Program File List > Import screen. The BIG-IP system automatically places the file in the proper location on the file system.
         */
        external_program?: string;
        /**
         * Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * This module will configure both exec and motd banners on remote device running Cisco IOS XR. It allows playbooks to add or remove banner text from the running configuration.
       */
      iosxr_banner?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Banner text to be configured. Accepts multiline string, without empty lines. Requires I(state=present).
         */
        text?: string;
        /**
         * Default: present
         *
         * Existential state of the configuration on the device.
         */
        state?: "present" | "absent";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Specifies the type of banner to configure on remote device.
         */
        banner: "login" | "motd";
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage Open vSwitch bridges
       */
      openvswitch_bridge?: {
        /**
         * Name of bridge or fake bridge to manage
         */
        bridge: string;
        /**
         * Set bridge fail-mode. The default value (None) is a No-op.
         */
        fail_mode?: string;
        /**
         * Bridge parent of the fake bridge to manage
         */
        parent?: string;
        /**
         * The VLAN id of the fake bridge to manage (must be between 0 and 4095). This parameter is required if I(parent) parameter is set.
         */
        vlan?: number | string;
        /**
         * Default: present
         *
         * Whether the bridge should exist
         */
        state?: "present" | "absent";
        /**
         * Run set command after bridge configuration. This parameter is non-idempotent, play will always return I(changed) state if present
         */
        set?: string;
        /**
         * Default: 5
         *
         * How long to wait for ovs-vswitchd to respond
         */
        timeout?: number | string;
        /**
         * A dictionary of external-ids. Omitting this parameter is a No-op. To  clear all external-ids pass an empty value.
         */
        external_ids?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Create/delete a DNS domain in DigitalOcean.
       */
      digital_ocean_domain?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Provides an interface to manage Network Set resources. Can create, update, or delete.
       */
      oneview_network_set?: {
        username?: string;
        image_streamer_hostname?: string;
        hostname?: string;
        config?: string;
        validate_etag?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Indicates the desired state for the Network Set resource. - C(present) will ensure data properties are compliant with OneView. - C(absent) will remove the resource from OneView, if it exists.
         */
        state?: "present" | "absent";
        password?: string;
        /**
         * List with the Network Set properties.
         */
        data: {
          [k: string]: unknown;
        };
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Configure management settings of device
       */
      panos_mgtconfig?: {
        username?: string;
        /**
         * address of secondary DNS server
         */
        dns_server_secondary?: string;
        /**
         * address of primary Panorama server
         */
        panorama_primary?: string;
        /**
         * address of primary DNS server
         */
        dns_server_primary?: string;
        /**
         * address of secondary Panorama server
         */
        panorama_secondary?: string;
        /**
         * Default: yes
         *
         * commit if changed
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password: string;
        ip_address: string;
        [k: string]: unknown;
      };
      /**
       * Create a static address group object in the firewall used for policy rules.
       */
      panos_sag?: {
        username?: string;
        password: string;
        /**
         * - The name of the Panorama device group. The group must exist on Panorama. If device group is not defined it is assumed that we are contacting a firewall.
         *
         */
        devicegroup?: string;
        /**
         * The purpose / objective of the static Address Group
         */
        description?: string;
        /**
         * Tags to be associated with the address group
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * name of the dynamic address group
         */
        sag_name: string;
        sag_match_filter?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: yes
         *
         * commit if changed
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The operation to perform Supported values are I(add)/I(list)/I(delete).
         */
        operation: "add" | "list" | "delete";
        /**
         * API key that can be used instead of I(username)/I(password) credentials.
         */
        api_key?: string;
        ip_address: string;
        [k: string]: unknown;
      };
      /**
       * List Ansible Tower jobs. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_job_list?: {
        /**
         * Only list jobs with this status.
         */
        status?: "pending" | "waiting" | "running" | "error" | "failed" | "canceled" | "successful";
        tower_host?: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        /**
         * Default: no
         *
         * Fetch all the pages and return a single result.
         */
        all_pages?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_password?: string;
        tower_username?: string;
        /**
         * Query used to further filter the list of jobs. C({"foo":"bar"}) will be passed at C(?foo=bar)
         */
        query?: {
          [k: string]: unknown;
        };
        /**
         * Page number of the results to fetch.
         */
        page?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure AuthProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_authprofile?: {
        username?: string;
        /**
         * Http user authentication params.
         */
        http?: {
          [k: string]: unknown;
        };
        /**
         * Uuid of the auth profile.
         */
        uuid?: string;
        /**
         * Saml settings.
         * Field introduced in 17.2.3.
         */
        saml?: {
          [k: string]: unknown;
        };
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * Ldap server and directory settings.
         */
        ldap?: {
          [k: string]: unknown;
        };
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        controller?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Tacacs+ settings.
         */
        tacacs_plus?: {
          [k: string]: unknown;
        };
        api_context?: {
          [k: string]: unknown;
        };
        tenant?: string;
        password?: string;
        /**
         * Type of the auth profile.
         * Enum options - AUTH_PROFILE_LDAP, AUTH_PROFILE_TACACS_PLUS, AUTH_PROFILE_SAML.
         */
        type: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Name of the auth profile.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module creates, deletes or modifies filesystems on Infinibox.
       */
      infini_fs?: {
        /**
         * Default: present
         *
         * Creates/Modifies file system when present or removes when absent.
         */
        state?: string;
        /**
         * File system name.
         */
        name?: string;
        /**
         * Pool that will host file system.
         */
        pool?: string;
        /**
         * File system size in MB, GB or TB units. See examples.
         */
        size?: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to a Extreme Ironware node and returns the results read from the device. This module includes a I(wait_for) argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      ironware_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        /**
         * List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy. If the value is set to C(all) then all conditionals in the I(wait_for) must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: "any" | "all";
        [k: string]: unknown;
      };
      /**
       * Add or remove MSSQL databases from a remote host.
       */
      mssql_db?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage BIG-IP system database variables
       */
      bigip_sys_db?: {
        /**
         * Default: present
         *
         * The state of the variable on the system. When C(present), guarantees that an existing variable is set to C(value). When C(reset) sets the variable back to the default value. At least one of value and state C(reset) are required.
         */
        state?: string;
        /**
         * The value to set the key to. At least one of value and state C(reset) are required.
         */
        value?: string;
        /**
         * The database variable to manipulate.
         */
        key?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV external providers.
       */
      ovirt_external_provider_facts?: {
        /**
         * Type of the external provider.
         */
        type?: string;
        /**
         * Name of the external provider, can be used as glob expression.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Create, delete, enable or disable IP interfaces on Solaris/illumos systems.
       */
      ipadm_if?: {
        /**
         * Default: present
         *
         * Create or delete Solaris/illumos IP interfaces.
         */
        state?: "present" | "absent" | "enabled" | "disabled";
        /**
         * Specifies that the IP interface is temporary. Temporary IP interfaces do not persist across reboots.
         */
        temporary?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * IP interface name.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or destroy host groups on a NetApp E-Series storage array.
       */
      netapp_e_hostgroup?: {
        /**
         * specify this when you need to update the name of a host group
         */
        new_name?: string;
        /**
         * The ID of the array to manage (as configured on the web services proxy).
         */
        ssid: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * The name of the host group to manage. Either this or C(id_num) must be supplied.
         */
        name?: string;
        /**
         * Whether the specified host group should exist or not.
         */
        state: "present" | "absent";
        /**
         * a list of host names/labels to add to the group
         */
        hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?: string;
        /**
         * The id number of the host group to manage. Either this or C(name) must be supplied.
         */
        id?: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        [k: string]: unknown;
      };
      /**
       * Create, edit, query, or delete VLANs in a Meraki environment.
       */
      meraki_vlan?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage firewall with UFW.
       */
      ufw?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages applying ACLs to interfaces on HUAWEI CloudEngine switches.
       */
      ce_acl_interface?: {
        username?: string;
        /**
         * Direction ACL to be applied in on the interface.
         */
        direction: "inbound" | "outbound";
        ssh_keyfile?: string;
        /**
         * ACL number or name. For a numbered rule group, the value ranging from 2000 to 4999. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.
         */
        acl_name: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Interface name. Only support interface full name, such as "40GE2/0/1".
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Allows the management of Katello resources inside your Foreman server.
       */
      katello?: {
        /**
         * Username on Foreman server.
         */
        username: string;
        /**
         * URL of Foreman server.
         */
        server_url: string;
        /**
         * The Foreman resource that the action will be performed on (e.g. organization, host).
         */
        entity:
          | "repository"
          | "manifest"
          | "repository_set"
          | "sync_plan"
          | "content_view"
          | "lifecycle_environment"
          | "activation_key"
          | "product";
        /**
         * verify the ssl/https connection (e.g for a valid certificate)
         */
        verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Parameters associated to the entity resource and action, to set or edit in dictionary format.
         * Each choice may be only available with specific entitys and actions.
         * Possible Choices are in the format of param_name ([entry,action,action,...],[entity,..],...).
         * The action "None" means no action specified.
         * Possible Params in relation to entity and action.
         * name ([product,sync,None], [repository,sync], [repository_set,None], [sync_plan,None],
         * [content_view,promote,publish,None], [lifecycle_environment,None], [activation_key,None])
         * organization ([product,sync,None] ,[repository,sync,None], [repository_set,None], [sync_plan,None],
         * [content_view,promote,publish,None], [lifecycle_environment,None], [activation_key,None])
         * content ([manifest,None])
         * product ([repository,sync,None], [repository_set,None], [sync_plan,None])
         * basearch ([repository_set,None])
         * releaserver ([repository_set,None])
         * sync_date ([sync_plan,None])
         * interval ([sync_plan,None])
         * repositories ([content_view,None])
         * from_environment ([content_view,promote])
         * to_environment([content_view,promote])
         * prior ([lifecycle_environment,None])
         * content_view ([activation_key,None])
         * lifecycle_environment ([activation_key,None])
         */
        params: {
          [k: string]: unknown;
        };
        /**
         * action associated to the entity resource to set or edit in dictionary format.
         * Possible Action in relation to Entitys.
         * sync (available when entity=product or entity=repository)
         * publish (available when entity=content_view)
         * promote (available when entity=content_view)
         */
        action?: "sync" | "publish" | "promote";
        /**
         * Password for user accessing Foreman server.
         */
        password: string;
        /**
         * Default: 1000
         *
         * The timeout in seconds to wait for the started Foreman action to finish.
         * If the timeout is reached and the Foreman action did not complete, the ansible task fails. However the foreman action does not get canceled.
         */
        task_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage gslb site entities in Netscaler.
       */
      netscaler_gslb_site?: {
        /**
         * The naptr replacement suffix configured here will be used to construct the naptr replacement field in NAPTR record.
         * Minimum length = 1
         */
        naptrreplacementsuffix?: string;
        /**
         * Parent site of the GSLB site, in a parent-child topology.
         */
        parentsite?: string;
        /**
         * Exchange, with other GSLB sites, network metrics such as round-trip time (RTT), learned from communications with various local DNS (LDNS) servers used by clients. RTT information is used in the dynamic RTT load balancing method, and is exchanged every 5 seconds.
         */
        nwmetricexchange?: "enabled" | "disabled";
        /**
         * Cluster IP address. Specify this parameter to connect to the remote cluster site for GSLB auto-sync. Note: The cluster IP address is defined when creating the cluster.
         */
        clip?: string;
        /**
         * Name for the GSLB site. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the virtual server is created.
         * Minimum length = 1
         */
        sitename?: string;
        /**
         * Type of site to create. If the type is not specified, the appliance automatically detects and sets the type on the basis of the IP address being assigned to the site. If the specified site IP address is owned by the appliance (for example, a MIP address or SNIP address), the site is a local site. Otherwise, it is a remote site.
         */
        sitetype?: "REMOTE" | "LOCAL";
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Exchange persistent session entries with other GSLB sites every five seconds.
         */
        sessionexchange?: "enabled" | "disabled";
        state?: "present" | "absent";
        /**
         * IP address to be used to globally access the remote cluster when it is deployed behind a NAT. It can be same as the normal cluster IP address.
         */
        publicclip?: string;
        /**
         * Public IP address for the local site. Required only if the appliance is deployed in a private address space and the site has a public IP address hosted on an external firewall or a NAT device.
         * Minimum length = 1
         */
        publicip?: string;
        nitro_protocol?: "http" | "https";
        nsip: string;
        /**
         * IP address for the GSLB site. The GSLB site uses this IP address to communicate with other GSLB sites. For a local site, use any IP address that is owned by the appliance (for example, a SNIP or MIP address, or the IP address of the ADNS service).
         * Minimum length = 1
         */
        siteipaddress?: string;
        nitro_user: string;
        /**
         * Specify the conditions under which the GSLB service must be monitored by a monitor, if one is bound. Available settings function as follows:
         * * C(ALWAYS) - Monitor the GSLB service at all times.
         * * C(MEPDOWN) - Monitor the GSLB service only when the exchange of metrics through the Metrics Exchange Protocol (MEP) is disabled.
         * C(MEPDOWN_SVCDOWN) - Monitor the service in either of the following situations:
         * * The exchange of metrics through MEP is disabled.
         * * The exchange of metrics through MEP is enabled but the status of the service, learned through metrics exchange, is DOWN.
         */
        triggermonitor?: "ALWAYS" | "MEPDOWN" | "MEPDOWN_SVCDOWN";
        nitro_pass: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_timeout?: number;
        /**
         * Exchange metrics with other sites. Metrics are exchanged by using Metric Exchange Protocol (MEP). The appliances in the GSLB setup exchange health information once every second.
         * If you disable metrics exchange, you can use only static load balancing methods (such as round robin, static proximity, or the hash-based methods), and if you disable metrics exchange when a dynamic load balancing method (such as least connection) is in operation, the appliance falls back to round robin. Also, if you disable metrics exchange, you must use a monitor to determine the state of GSLB services. Otherwise, the service is marked as DOWN.
         */
        metricexchange?: "enabled" | "disabled";
        [k: string]: unknown;
      };
      /**
       * Manages HTTPD related settings on the BIG-IP. These settings are interesting to change when you want to set GUI timeouts and other TMUI related settings.
       */
      bigip_device_httpd?: {
        [k: string]: unknown;
      };
      /**
       * Return service state information as fact data for various service management utilities
       */
      service_facts?: {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of logging on Juniper JUNOS devices.
       */
      junos_logging?: {
        /**
         * Number of files to be archived, this is applicable if value of I(dest) is C(file). The acceptable value is in range from 1 to 1000.
         */
        files?: number | string;
        username?: string;
        ssh_keyfile?: string;
        src_addr?: string;
        /**
         * If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.
         */
        name?: string;
        /**
         * Set logging severity levels.
         */
        level?: string;
        /**
         * Destination of the logs.
         */
        dest?: "console" | "host" | "file" | "user";
        /**
         * Set logging facility.
         */
        facility?: string;
        /**
         * Default: present
         *
         * State of the logging configuration.
         */
        state?: "present" | "absent";
        /**
         * List of logging definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: True
         *
         * Specifies whether or not the configuration is active or deactivated
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Rotate log frequency in minutes, this is applicable if value of I(dest) is C(file). The acceptable value is in range of 1 to 59. This controls the frequency after which log file is rotated.
         */
        rotate_frequency?: number | string;
        password?: string;
        port?: number | string;
        transport?: string;
        /**
         * Size of the file in archive, this is applicable if value of I(dest) is C(file). The acceptable value is in range from 65536 to 1073741824 bytes.
         */
        size?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create and remove tag(s) to DigitalOcean resource.
       */
      digital_ocean_tag?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Configures SAN Connectivity Policies on Cisco UCS Manager.
       * Examples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).
       */
      ucs_san_connectivity?: {
        /**
         * List of vHBAs used by the SAN Connectivity Policy.
         * vHBAs used by the SAN Connectivity Policy must be created from a vHBA template.
         * Each list element has the following suboptions:
         * = name
         *   The name of the virtual HBA (required).
         * = vhba_template
         *   The name of the virtual HBA template (required).
         * - adapter_policy
         *   The name of the Fibre Channel adapter policy.
         *   A user defined policy can be used, or one of the system defined policies (default, Linux, Solaris, VMware, Windows, WindowsBoot)
         *   [Default: default]
         * - order
         *   String specifying the vHBA assignment order (e.g., '1', '2').
         *   [Default: unspecified]
         */
        vhba_list?: string;
        /**
         * A description of the policy.
         * Cisco recommends including information about where and when to use the policy.
         * Enter up to 256 characters.
         * You can use any characters or spaces except the following:
         * ` (accent mark),  (backslash), ^ (carat), " (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).
         */
        description?: string;
        /**
         * Default: org-root
         *
         * Org dn (distinguished name)
         */
        org_dn?: string;
        /**
         * Default: present
         *
         * If C(present), will verify SAN Connectivity Policies are present and will create if needed.
         * If C(absent), will verify SAN Connectivity Policies are absent and will delete if needed.
         */
        state?: string;
        /**
         * Default: default
         *
         * Name of the WWNN pool to use for WWNN assignment.
         */
        wwnn_pool?: string;
        /**
         * The name of the SAN Connectivity Policy.
         * This name can be between 1 and 16 alphanumeric characters.
         * You cannot use spaces or any special characters other than - (hyphen), "_" (underscore), : (colon), and . (period).
         * You cannot change this name after the policy is created.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows you to create, modify and delete Zabbix host entries and associated group and template data.
       */
      zabbix_host?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Provide one or more image names, and the module will inspect each, returning an array of inspection results.
       */
      docker_image_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV virtual machines.
       */
      ovirt_vm_facts?: {
        /**
         * If I(true) all the attributes of the virtual machines should be included in the response.
         */
        all_content?: string;
        /**
         * Search term which is accepted by oVirt/RHV search backend.
         * For example to search VM X from cluster Y use following pattern: name=X and cluster=Y
         */
        pattern?: string;
        /**
         * The maximum number of results to return.
         */
        max?: string;
        /**
         * Default: True
         *
         * If I(true) performed search will take case into account.
         */
        case_sensitive?: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an ENOS node and returns the results read from the device. The C(enos_command) module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      enos_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        /**
         * List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: "any" | "all";
        [k: string]: unknown;
      };
      /**
       * This module allows you to create or restore a volume snapshot. This module has a dependency on profitbricks >= 1.0.0
       */
      profitbricks_nic?: {
        /**
         * The datacenter in which to operate.
         */
        datacenter?: string;
        /**
         * The LAN to place the NIC on. You can pass a LAN that doesn't exist and it will be created. Required on create.
         */
        lan?: string;
        /**
         * The name or ID of the NIC. This is only required on deletes, but not on create.
         */
        name?: string;
        /**
         * The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.
         */
        subscription_user?: string;
        /**
         * The server name or ID.
         */
        server?: string;
        /**
         * THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.
         */
        subscription_password?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: string;
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * Default: yes
         *
         * wait for the operation to complete before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module provides functionality to copy file from network device to ansible controller.
       */
      net_get?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host: string;
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Manage DNS records in a Memset account.
       */
      memset_zone_record?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Create, disable, lock, enable and remove accounts.
       */
      cs_account?: {
        /**
         * Username of the user to be created if account did not exist.
         * Required on C(state=present).
         */
        username?: string;
        /**
         * Default: ROOT
         *
         * Domain the account is related to.
         */
        domain?: string;
        /**
         * Last name of the user to be created if account did not exist.
         * Required on C(state=present).
         */
        last_name?: string;
        /**
         * Default: user
         *
         * Type of the account.
         */
        account_type?: "user" | "root_admin" | "domain_admin";
        /**
         * Name of account.
         */
        name: string;
        api_http_method?: "get" | "post";
        /**
         * Network domain of the account.
         */
        network_domain?: string;
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * First name of the user to be created if account did not exist.
         * Required on C(state=present).
         */
        first_name?: string;
        api_region?: string;
        api_key?: string;
        /**
         * Default: present
         *
         * State of the account.
         * C(unlocked) is an alias for C(enabled).
         */
        state?: "present" | "absent" | "enabled" | "disabled" | "locked" | "unlocked";
        /**
         * Default: yes
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Timezone of the user to be created if account did not exist.
         */
        timezone?: string;
        /**
         * Password of the user to be created if account did not exist.
         * Required on C(state=present).
         */
        password?: string;
        /**
         * Email of the user to be created if account did not exist.
         * Required on C(state=present).
         */
        email?: string;
        api_url?: string;
        [k: string]: unknown;
      };
      /**
       * Uploads a new or updates an existing configuration template or workflow template into the Radware vDirect server. All parameters may be set as environment variables.
       */
      vdirect_file?: {
        /**
         * Default: 2189
         *
         * vDirect server HTTPS port number, may be set as VDIRECT_HTTPS_PORT environment variable.
         */
        vdirect_https_port?: number | string;
        /**
         * Default: 2188
         *
         * vDirect server HTTP port number, may be set as VDIRECT_HTTP_PORT environment variable.
         */
        vdirect_http_port?: number | string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated,
         * may be set as VDIRECT_VALIDATE_CERTS or VDIRECT_VERIFY environment variable.
         * This should only set to C(no) used on personally controlled sites using self-signed certificates.
         */
        vdirect_validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * vDirect runnable file name to be uploaded.
         * May be velocity configuration template (.vm) or workflow template zip file (.zip).
         */
        file_name: string;
        /**
         * Default: 60
         *
         * Amount of time to wait for async operation completion [seconds],
         * may be set as VDIRECT_TIMEOUT environment variable.
         */
        vdirect_timeout?: number | string;
        /**
         * Default: yes
         *
         * Wait for async operation to complete, may be set as VDIRECT_WAIT environment variable.
         */
        vdirect_wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Primary vDirect server IP address, may be set as VDIRECT_IP environment variable.
         */
        vdirect_ip: string;
        /**
         * vDirect server username, may be set as VDIRECT_USER environment variable.
         */
        vdirect_user: string;
        /**
         * Secondary vDirect server IP address, may be set as VDIRECT_SECONDARY_IP environment variable.
         */
        vdirect_secondary_ip?: string;
        /**
         * Default: yes
         *
         * If C(no), an HTTP connection will be used instead of the default HTTPS connection,
         * may be set as VDIRECT_HTTPS or VDIRECT_USE_SSL environment variable.
         */
        vdirect_use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * vDirect server password, may be set as VDIRECT_PASSWORD environment variable.
         */
        vdirect_password: string;
        [k: string]: unknown;
      };
      /**
       * Reads data out of lldpctl
       */
      lldp?: {
        [k: string]: unknown;
      };
      /**
       * Manage load balancing monitors.
       * This module is intended to run either on the ansible  control node or a bastion (jumpserver) with access to the actual netscaler instance.
       */
      netscaler_lb_monitor?: {
        /**
         * Version number of the Citrix Advanced Access Control Logon Agent. Required by the C(CITRIX-AAC-LAS) monitor.
         */
        lasversion?: string;
        /**
         * SNMP OID for C(SNMP) monitors.
         * Minimum length = 1
         */
        Snmpoid?: string;
        /**
         * Enable/Disable probing for Account Service. Applicable only to Store Front monitors. For multi-tenancy configuration users my skip account service.
         */
        storefrontacctservice?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Firmware-Revision value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
         */
        firmwarerevision?: number;
        /**
         * Domain name to resolve as part of monitoring the DNS service (for example, C(example.com)).
         */
        query?: string;
        /**
         * List of Auth-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring CER message.
         * Minimum value = C(0)
         * Maximum value = C(4294967295)
         */
        authapplicationid?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Version of MSSQL server that is to be monitored.
         */
        mssqlprotocolversion?: "70" | "2000" | "2000SP1" | "2005" | "2008" | "2008R2" | "2012" | "2014";
        /**
         * Maximum number of hops that the SIP request used for monitoring can traverse to reach the server. Applicable only to monitors of type C(SIP-UDP).
         * Minimum value = C(0)
         * Maximum value = C(255)
         */
        maxforwards?: number;
        /**
         * String to send to the service. Applicable to C(TCP-ECV), C(HTTP-ECV), and C(UDP-ECV) monitors.
         */
        send?: string;
        /**
         * RTSP request to send to the server (for example, C("OPTIONS *")).
         */
        rtsprequest?: string;
        /**
         * Code expected when the server is under maintenance.
         */
        trofscode?: number;
        /**
         * Name for the monitor. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters.
         * Minimum length = 1
         */
        monitorname?: string;
        nitro_timeout?: number;
        /**
         * Unit of measurement for the Deviation parameter. Cannot be changed after the monitor is created.
         */
        units1?: "SEC" | "MSEC" | "MIN";
        /**
         * monitor interval units.
         */
        units3?: "SEC" | "MSEC" | "MIN";
        /**
         * Unit of measurement for the Down Time parameter. Cannot be changed after the monitor is created.
         */
        units2?: "SEC" | "MSEC" | "MIN";
        /**
         * Response codes for which to mark the service as UP. For any other response code, the action performed depends on the monitor type. C(HTTP) monitors and C(RADIUS) monitors mark the service as C(DOWN), while C(HTTP-INLINE) monitors perform the action indicated by the Action parameter.
         */
        respcode?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * String of arguments for the script. The string is copied verbatim into the request.
         */
        scriptargs?: string;
        /**
         * Amount of time for which the appliance must wait before it marks a probe as FAILED. Must be less than the value specified for the Interval parameter.
         * Note: For C(UDP-ECV) monitors for which a receive string is not configured, response timeout does not apply. For C(UDP-ECV) monitors with no receive string, probe failure is indicated by an ICMP port unreachable error received from the service.
         * Minimum value = C(1)
         * Maximum value = C(20939)
         */
        resptimeout?: number | string;
        /**
         * Time duration for which to wait before probing a service that has been marked as DOWN. Expressed in milliseconds, seconds, or minutes.
         * Minimum value = C(1)
         * Maximum value = C(20939)
         */
        downtime?: number | string;
        /**
         * Password that is required for logging on to the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3), C(CITRIX-AG), C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC-ECV) or C(CITRIX-XDM) server. Used in conjunction with the user name specified for the C(username) parameter.
         * Minimum length = 1
         */
        password?: string;
        /**
         * The monitor is bound to a transparent device such as a firewall or router. The state of a transparent device depends on the responsiveness of the services behind it. If a transparent device is being monitored, a destination IP address must be specified. The probe is sent to the specified IP address by using the MAC address of the transparent device.
         */
        transparent?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Number of retries that must fail, out of the number specified for the Retries parameter, for a service to be marked as DOWN. For example, if the Retries parameter is set to 10 and the Failure Retries parameter is set to 6, out of the ten probes sent, at least six probes must fail if the service is to be marked as DOWN. The default value of 0 means that all the retries must fail if the service is to be marked as DOWN.
         * Minimum value = C(0)
         * Maximum value = C(32)
         */
        failureretries?: number | string;
        /**
         * Authentication key (shared secret text string) for RADIUS clients and servers to exchange. Applicable to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).
         * Minimum length = 1
         */
        radkey?: string;
        /**
         * Product-Name value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
         * Minimum length = 1
         */
        productname?: string;
        /**
         * Name of the service identifier that is used to connect to the Oracle database during authentication.
         * Minimum length = 1
         */
        oraclesid?: string;
        /**
         * Account Type to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).
         * Minimum value = 0
         * Maximum value = 15
         */
        radaccounttype?: number;
        /**
         * The distinguished name with which an LDAP monitor can perform the Bind operation on the LDAP server. Optional. Applicable to C(LDAP) monitors.
         * Minimum length = 1
         */
        binddn?: string;
        /**
         * Domain in which the XenDesktop Desktop Delivery Controller (DDC) servers or Web Interface servers are present. Required by C(CITRIX-XD-DDC) and C(CITRIX-WI-EXTENDED) monitors for logging on to the DDC servers and Web Interface servers, respectively.
         */
        domain?: string;
        /**
         * Response time threshold, specified as a percentage of the Response Time-out parameter. If the response to a monitor probe has not arrived when the threshold is reached, the appliance generates an SNMP trap called monRespTimeoutAboveThresh. After the response time returns to a value below the threshold, the appliance generates a monRespTimeoutBelowThresh SNMP trap. For the traps to be generated, the "MONITOR-RTO-THRESHOLD" alarm must also be enabled.
         * Minimum value = C(0)
         * Maximum value = C(100)
         */
        resptimeoutthresh?: number;
        /**
         * Host-IP-Address value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. If Host-IP-Address is not specified, the appliance inserts the mapped IP (MIP) address or subnet IP (SNIP) address from which the CER request (the monitoring probe) is sent.
         * Minimum length = 1
         */
        hostipaddress?: string;
        /**
         * SIP URI string to send to the service (for example, C(sip:sip.test)). Applicable only to monitors of type C(SIP-UDP).
         * Minimum length = 1
         */
        sipuri?: string;
        /**
         * Vendor-Id to use in the Vendor-Specific-Application-Id grouped attribute-value pair (AVP) in the monitoring CER message. To specify Auth-Application-Id or Acct-Application-Id in Vendor-Specific-Application-Id, use vendorSpecificAuthApplicationIds or vendorSpecificAcctApplicationIds, respectively. Only one Vendor-Id is supported for all the Vendor-Specific-Application-Id AVPs in a CER monitoring message.
         * Minimum value = 1
         */
        vendorspecificvendorid?: number;
        /**
         * Path and name of the script to execute. The script must be available on the NetScaler appliance, in the /nsconfig/monitors/ directory.
         * Minimum length = 1
         */
        scriptname?: string;
        /**
         * Origin-Realm value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
         * Minimum length = 1
         */
        originrealm?: string;
        /**
         * Calling Stations Id to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).
         * Minimum length = 1
         */
        radmsisdn?: string;
        /**
         * String expected from the server for the service to be marked as trofs. Applicable to HTTP-ECV/TCP-ECV monitors.
         */
        trofsstring?: string;
        /**
         * Name of a file on the FTP server. The appliance monitors the FTP service by periodically checking the existence of the file on the server. Applicable to C(FTP-EXTENDED) monitors.
         * Minimum length = 1
         */
        filename?: string;
        /**
         * State of the monitor. The C(disabled) setting disables not only the monitor being configured, but all monitors of the same type, until the parameter is set to C(enabled). If the monitor is bound to a service, the state of the monitor is not taken into account when the state of the service is determined.
         */
        state?: "present" | "absent";
        nitro_user: string;
        /**
         * Name of the network profile.
         * Minimum length = 1
         * Maximum length = 127
         */
        netprofile?: string;
        /**
         * Number of consecutive probe failures after which the appliance generates an SNMP trap called monProbeFailed.
         * Minimum value = C(0)
         * Maximum value = C(32)
         */
        alertretries?: number | string;
        /**
         * Account Session ID to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).
         * Minimum length = 1
         */
        radaccountsession?: string;
        /**
         * The base distinguished name of the LDAP service, from where the LDAP server can begin the search for the attributes in the monitoring query. Required for C(LDAP) service monitoring.
         * Minimum length = 1
         */
        basedn?: string;
        /**
         * Name of a newsgroup available on the NNTP service that is to be monitored. The appliance periodically generates an NNTP query for the name of the newsgroup and evaluates the response. If the newsgroup is found on the server, the service is marked as UP. If the newsgroup does not exist or if the search fails, the service is marked as DOWN. Applicable to NNTP monitors.
         * Minimum length = 1
         */
        group?: string;
        /**
         * String expected from the server for the service to be marked as UP. Applicable to C(TCP-ECV), C(HTTP-ECV), and C(UDP-ECV) monitors.
         */
        recv?: string;
        /**
         * Type of DNS record for which to send monitoring queries. Set to C(Address) for querying A records, C(AAAA) for querying AAAA records, and C(Zone) for querying the SOA record.
         */
        querytype?: "Address" | "Zone" | "AAAA";
        /**
         * The TOS ID of the specified destination IP. Applicable only when the TOS parameter is set.
         * Minimum value = C(1)
         * Maximum value = C(63)
         */
        tosid?: number;
        /**
         * Mark a service as DOWN, instead of UP, when probe criteria are satisfied, and as UP instead of DOWN when probe criteria are not satisfied.
         */
        reverse?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Store Name. For monitors of type C(STOREFRONT), C(storename) is an optional argument defining storefront service store name. Applicable to C(STOREFRONT) monitors.
         * Minimum length = 1
         */
        storename?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Calculate the least response times for bound services. If this parameter is not enabled, the appliance does not learn the response times of the bound services. Also used for LRTM load balancing.
         */
        lrtm?: "enabled" | "disabled";
        /**
         * Filter criteria for the LDAP query. Optional.
         * Minimum length = 1
         */
        filter?: string;
        /**
         * Action to perform when the response to an inline monitor (a monitor of type C(HTTP-INLINE)) indicates that the service is down. A service monitored by an inline monitor is considered C(DOWN) if the response code is not one of the codes that have been specified for the Response Code parameter.
         * Available settings function as follows:
         * * C(NONE) - Do not take any action. However, the show service command and the show lb monitor command indicate the total number of responses that were checked and the number of consecutive error responses received after the last successful probe.
         * * C(LOG) - Log the event in NSLOG or SYSLOG.
         * * C(DOWN) - Mark the service as being down, and then do not direct any traffic to the service until the configured down time has expired. Persistent connections to the service are terminated as soon as the service is marked as C(DOWN). Also, log the event in NSLOG or SYSLOG.
         */
        action?: "NONE" | "LOG" | "DOWN";
        nitro_pass: string;
        /**
         * Use a secure SSL connection when monitoring a service. Applicable only to TCP based monitors. The secure option cannot be used with a C(CITRIX-AG) monitor, because a CITRIX-AG monitor uses a secure connection by default.
         */
        secure?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Network Access Server (NAS) IP address to use as the source IP address when monitoring a RADIUS server. Applicable to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).
         */
        radnasip?: string;
        /**
         * NAS-Identifier to send in the Access-Request packet. Applicable to monitors of type C(RADIUS).
         * Minimum length = 1
         */
        radnasid?: string;
        /**
         * Set of IP addresses expected in the monitoring response from the DNS server, if the record type is A or AAAA. Applicable to C(DNS) monitors.
         * Minimum length = 1
         */
        ipaddress?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Store the database list populated with the responses to monitor probes. Used in database specific load balancing if C(MSSQL-ECV)/C(MYSQL-ECV) monitor is configured.
         */
        storedb?: "enabled" | "disabled";
        /**
         * Vendor-Id value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
         */
        vendorid?: number;
        /**
         * This option will enable monitoring of services running on storefront server. Storefront services are monitored by probing to a Windows service that runs on the Storefront server and exposes details of which storefront services are running.
         */
        storefrontcheckbackendservices?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Probe the service by encoding the destination IP address in the IP TOS (6) bits.
         */
        tos?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Number of consecutive successful probes required to transition a service's state from DOWN to UP.
         * Minimum value = C(1)
         * Maximum value = C(32)
         */
        successretries?: number | string;
        /**
         * Send the monitoring probe to the service through an IP tunnel. A destination IP address must be specified.
         */
        iptunnel?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Type of monitor that you want to create.
         */
        type?:
          | "PING"
          | "TCP"
          | "HTTP"
          | "TCP-ECV"
          | "HTTP-ECV"
          | "UDP-ECV"
          | "DNS"
          | "FTP"
          | "LDNS-PING"
          | "LDNS-TCP"
          | "LDNS-DNS"
          | "RADIUS"
          | "USER"
          | "HTTP-INLINE"
          | "SIP-UDP"
          | "SIP-TCP"
          | "LOAD"
          | "FTP-EXTENDED"
          | "SMTP"
          | "SNMP"
          | "NNTP"
          | "MYSQL"
          | "MYSQL-ECV"
          | "MSSQL-ECV"
          | "ORACLE-ECV"
          | "LDAP"
          | "POP3"
          | "CITRIX-XML-SERVICE"
          | "CITRIX-WEB-INTERFACE"
          | "DNS-TCP"
          | "RTSP"
          | "ARP"
          | "CITRIX-AG"
          | "CITRIX-AAC-LOGINPAGE"
          | "CITRIX-AAC-LAS"
          | "CITRIX-XD-DDC"
          | "ND6"
          | "CITRIX-WI-EXTENDED"
          | "DIAMETER"
          | "RADIUS_ACCOUNTING"
          | "STOREFRONT"
          | "APPC"
          | "SMPP"
          | "CITRIX-XNC-ECV"
          | "CITRIX-XDM"
          | "CITRIX-STA-SERVICE"
          | "CITRIX-STA-SERVICE-NHOP";
        /**
         * User name with which to probe the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3), C(CITRIX-AG), C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC) or C(CITRIX-XDM) server.
         * Minimum length = 1
         */
        username?: string;
        /**
         * SIP user to be registered. Applicable only if the monitor is of type C(SIP-UDP) and the SIP Method parameter is set to C(REGISTER).
         * Minimum length = 1
         */
        sipreguri?: string;
        /**
         * Maximum number of probes to send to establish the state of a service for which a monitoring probe failed.
         * Minimum value = C(1)
         * Maximum value = C(127)
         */
        retries?: number | string;
        /**
         * Threshold for C(SNMP) monitors.
         * Minimum length = 1
         */
        snmpthreshold?: string;
        /**
         * IP address of the service to which to send probes. If the parameter is set to 0, the IP address of the server to which the monitor is bound is considered the destination IP address.
         */
        destip?: string;
        /**
         * Validate the credentials of the Xen Desktop DDC server user. Applicable to monitors of type C(CITRIX-XD-DDC).
         */
        validatecred?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of Acct-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message.
         * Minimum value = C(0)
         * Maximum value = C(4294967295)
         */
        acctapplicationid?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List of Vendor-Specific-Acct-Application-Id attribute value pairs (AVPs) to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message. The specified value is combined with the value of vendorSpecificVendorId to obtain the Vendor-Specific-Application-Id AVP in the CER monitoring message.
         * Minimum value = C(0)
         * Maximum value = C(4294967295)
         */
        vendorspecificacctapplicationids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Secondary password that users might have to provide to log on to the Access Gateway server. Applicable to C(CITRIX-AG) monitors.
         */
        secondarypassword?: string;
        /**
         * Attribute to evaluate when the LDAP server responds to the query. Success or failure of the monitoring probe depends on whether the attribute exists in the response. Optional.
         * Minimum length = 1
         */
        attribute?: string;
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_protocol?: "http" | "https";
        /**
         * Community name for C(SNMP) monitors.
         * Minimum length = 1
         */
        snmpcommunity?: string;
        /**
         * monitor response timeout units.
         */
        units4?: "SEC" | "MSEC" | "MIN";
        /**
         * HTTP request to send to the server (for example, C("HEAD /file.html")).
         */
        httprequest?: string;
        /**
         * Name of the logon point that is configured for the Citrix Access Gateway Advanced Access Control software. Required if you want to monitor the associated login page or Logon Agent. Applicable to C(CITRIX-AAC-LAS) and C(CITRIX-AAC-LOGINPAGE) monitors.
         */
        logonpointname?: string;
        /**
         * Called Station Id to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).
         * Minimum length = 1
         */
        radapn?: string;
        /**
         * Hostname in the FQDN format (Example: C(porche.cars.org)). Applicable to C(STOREFRONT) monitors.
         * Minimum length = 1
         */
        hostname?: string;
        /**
         * Source ip with which the packet will go out . Applicable to monitors of type C(RADIUS_ACCOUNTING).
         */
        radframedip?: string;
        /**
         * Name of the application used to determine the state of the service. Applicable to monitors of type C(CITRIX-XML-SERVICE).
         * Minimum length = 1
         */
        application?: string;
        /**
         * Time value added to the learned average response time in dynamic response time monitoring (DRTM). When a deviation is specified, the appliance learns the average response time of bound services and adds the deviation to the average. The final value is then continually adjusted to accommodate response time variations over time. Specified in milliseconds, seconds, or minutes.
         * Minimum value = C(0)
         * Maximum value = C(20939)
         */
        deviation?: number;
        /**
         * List of Supported-Vendor-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum eight of these AVPs are supported in a monitoring message.
         * Minimum value = C(1)
         * Maximum value = C(4294967295)
         */
        supportedvendorids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Inband-Security-Id for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
         */
        inbandsecurityid?: "NO_INBAND_SECURITY" | "TLS";
        /**
         * SQL query for a C(MYSQL-ECV) or C(MSSQL-ECV) monitor. Sent to the database server after the server authenticates the connection.
         * Minimum length = 1
         */
        sqlquery?: string;
        /**
         * Default syntax expression that evaluates the database server's response to a MYSQL-ECV or MSSQL-ECV monitoring query. Must produce a Boolean result. The result determines the state of the server. If the expression returns TRUE, the probe succeeds.
         * For example, if you want the appliance to evaluate the error message to determine the state of the server, use the rule C(MYSQL.RES.ROW(10) .TEXT_ELEM(2).EQ("MySQL")).
         */
        evalrule?: string;
        /**
         * SIP method to use for the query. Applicable only to monitors of type C(SIP-UDP).
         */
        sipmethod?: "OPTIONS" | "INVITE" | "REGISTER";
        /**
         * Custom header string to include in the monitoring probes.
         */
        customheaders?: string;
        /**
         * URL of the logon page. For monitors of type C(CITRIX-WEB-INTERFACE), to monitor a dynamic page under the site path, terminate the site path with a slash C(/). Applicable to C(CITRIX-WEB-INTERFACE), C(CITRIX-WI-EXTENDED) and C(CITRIX-XDM) monitors.
         * Minimum length = 1
         */
        sitepath?: string;
        /**
         * TCP or UDP port to which to send the probe. If the parameter is set to 0, the port number of the service to which the monitor is bound is considered the destination port. For a monitor of type C(USER), however, the destination port is the port number that is included in the HTTP request sent to the dispatcher. Does not apply to monitors of type C(PING).
         */
        destport?: number | string;
        /**
         * Port number on which the dispatcher listens for the monitoring probe.
         */
        dispatcherport?: number | string;
        /**
         * Name of the database to connect to during authentication.
         * Minimum length = 1
         */
        database?: string;
        /**
         * Time interval between two successive probes. Must be greater than the value of Response Time-out.
         * Minimum value = C(1)
         * Maximum value = C(20940)
         */
        interval?: number | string;
        /**
         * Origin-Host value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.
         * Minimum length = 1
         */
        originhost?: string;
        nsip: string;
        /**
         * List of Vendor-Specific-Auth-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message. The specified value is combined with the value of vendorSpecificVendorId to obtain the Vendor-Specific-Application-Id AVP in the CER monitoring message.
         * Minimum value = C(0)
         * Maximum value = C(4294967295)
         */
        vendorspecificauthapplicationids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * SNMP version to be used for C(SNMP) monitors.
         */
        snmpversion?: "V1" | "V2";
        /**
         * IP address of the dispatcher to which to send the probe.
         */
        dispatcherip?: string;
        [k: string]: unknown;
      };
      /**
       * Manage the software update settings of a BIG-IP.
       */
      bigip_software_update?: {
        /**
         * Specifies whether to automatically send phone home data to the F5 Networks PhoneHome server.
         */
        auto_phone_home?: string;
        /**
         * Specifies whether to automatically check for updates on the F5 Networks downloads server.
         */
        auto_check?: string;
        /**
         * Specifies the schedule for the automatic update check.
         */
        frequency?: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP GTM BIG-IP monitors. This monitor is used by GTM to monitor BIG-IPs themselves.
       */
      bigip_gtm_monitor_bigip?: {
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Monitor name.
         */
        name?: string;
        /**
         * Default: /Common/bigip
         *
         * The parent template of this monitor template. Once this value has been set, it cannot be changed. By default, this value is the C(bigip) parent on the C(Common) partition.
         */
        parent?: string;
        /**
         * IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
         */
        ip?: string;
        /**
         * Specifies, in seconds, the frequency at which the system issues the monitor check when either the resource is down or the status of the resource is unknown.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(30). This value B(must) be less than the C(timeout) value.
         */
        interval?: string;
        /**
         * Specifies how the system combines the module values to create the proportion (score) for the load balancing operation.
         * The score represents the module's estimated capacity for handing traffic.
         * Averaged values are appropriate for downstream Web Accelerator or Application Security Manager virtual servers.
         * When creating a new monitor, if this parameter is not specified, the default of C(none) is used, meaning that the system does not use the scores in the load balancing operation.
         * When C(none), specifies that the monitor ignores the nodes and pool member scores.
         * When C(average-nodes), specifies that the system averages the dynamic ratios on the nodes associated with the monitor's target virtual servers and returns that average as the virtual servers' score.
         * When C(sum-nodes), specifies that the system adds together the scores of the nodes associated with the monitor's target virtual servers and uses that value in the load balancing operation.
         * When C(average-members), specifies that the system averages the dynamic ratios on the pool members associated with the monitor's target virtual servers and returns that average as the virtual servers' score.
         * When C(sum-members), specifies that the system adds together the scores of the pool members associated with the monitor's target virtual servers and uses that value in the load balancing operation.
         */
        aggregate_dynamic_ratios?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the monitor exists.
         * When C(absent), ensures the monitor is removed.
         */
        state?: string;
        /**
         * Specifies that the monitor allows more than one probe attempt per interval.
         * When C(yes), specifies that the monitor ignores down responses for the duration of the monitor timeout. Once the monitor timeout is reached without the system receiving an up response, the system marks the object down.
         * When C(no), specifies that the monitor immediately marks an object down when it receives a down response.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(no).
         */
        ignore_down_response?: string;
        /**
         * Specifies the number of seconds the target has in which to respond to the monitor request.
         * If the target responds within the set time period, it is considered up.
         * If the target does not respond within the set time period, it is considered down.
         * When this value is set to 0 (zero), the system uses the interval from the parent monitor.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(90).
         */
        timeout?: string;
        /**
         * Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP GTM FirePass monitors.
       */
      bigip_gtm_monitor_firepass?: {
        /**
         * Specifies the number that the monitor uses to mark the Secure Access Manager system up or down.
         * The system compares the Max Load Average setting against a one-minute average of the Secure Access Manager system load.
         * When the Secure Access Manager system-load average falls within the specified Max Load Average, the monitor marks the Secure Access Manager system up.
         * When the average exceeds the setting, the monitor marks the system down.
         * When creating a new monitor, if this parameter is not specified, the default is C(12).
         */
        max_load_average?: string;
        /**
         * Default: always
         *
         * C(always) will update passwords if the C(target_password) is specified.
         * C(on_create) will only set the password for newly created monitors.
         */
        update_password?: string;
        /**
         * Specifies the list of ciphers for this monitor.
         * The items in the cipher list are separated with the colon C(:) symbol.
         * When creating a new monitor, if this parameter is not specified, the default list is C(HIGH:!ADH).
         */
        cipher_list?: string;
        /**
         * Monitor name.
         */
        name?: string;
        /**
         * Default: /Common/firepass_gtm
         *
         * The parent template of this monitor template. Once this value has been set, it cannot be changed. By default, this value is the C(tcp) parent on the C(Common) partition.
         */
        parent?: string;
        /**
         * IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.
         * If this value is an IP address, then a C(port) number must be specified.
         */
        ip?: string;
        /**
         * The interval specifying how frequently the monitor instance of this template will run.
         * If this parameter is not provided when creating a new monitor, then the default value will be 30.
         * This value B(must) be less than the C(timeout) value.
         */
        interval?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.
         */
        port?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the monitor exists.
         * When C(absent), ensures the monitor is removed.
         */
        state?: string;
        /**
         * Specifies that the monitor allows more than one probe attempt per interval.
         * When C(yes), specifies that the monitor ignores down responses for the duration of the monitor timeout. Once the monitor timeout is reached without the system receiving an up response, the system marks the object down.
         * When C(no), specifies that the monitor immediately marks an object down when it receives a down response.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(no).
         */
        ignore_down_response?: string;
        /**
         * The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second.
         * If this parameter is not provided when creating a new monitor, then the default value will be 90.
         */
        timeout?: string;
        /**
         * Specifies the maximum percentage of licensed connections currently in use under which the monitor marks the Secure Access Manager system up.
         * As an example, a setting of 95 percent means that the monitor marks the Secure Access Manager system up until 95 percent of licensed connections are in use.
         * When the number of in-use licensed connections exceeds 95 percent, the monitor marks the Secure Access Manager system down.
         * When creating a new monitor, if this parameter is not specified, the default is C(95).
         */
        concurrency_limit?: string;
        /**
         * Specifies the password, if the monitored target requires authentication.
         */
        target_password?: string;
        /**
         * Specifies the number of seconds after which the system times out the probe request to the system.
         * When creating a new monitor, if this parameter is not provided, then the default value will be C(5).
         */
        probe_timeout?: string;
        /**
         * Specifies the user name, if the monitored target requires authentication.
         */
        target_username?: string;
        [k: string]: unknown;
      };
      /**
       * Adds or removes Vertica database schema and, optionally, roles with schema access privileges.
       * A schema will not be removed until all the objects have been dropped.
       * In such a situation, if the module tries to remove the schema it will fail and only remove roles created for the schema if they have no dependencies.
       */
      vertica_schema?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Allows you to create/remove/update firewall rules.
       */
      win_firewall_rule?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Module allows user to run common system administration commands in the guest operating system.
       */
      vmware_vm_shell?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module manages filesystems on Pure Storage FlashBlade.
       */
      purefb_fs?: {
        /**
         * Define whether a snapshot directory is enabled for the filesystem.
         */
        snapshot?: string;
        /**
         * Default: *(rw,no_root_squash)
         *
         * Define the NFS rules in operation.
         */
        nfs_rules?: string;
        /**
         * Define whether to HTTP/HTTPS protocol is enabled for the filesystem.
         */
        http?: string;
        /**
         * Filesystem Name.
         */
        name?: string;
        /**
         * Default: present
         *
         * Create, delete or modifies a filesystem.
         */
        state?: string;
        /**
         * Default: True
         *
         * Define whether to NFS protocol is enabled for the filesystem.
         */
        nfs?: string;
        /**
         * Define whether the fast remove directory is enabled for the filesystem.
         */
        fastremove?: string;
        /**
         * Define whether to eradicate the filesystem on delete or leave in trash.
         */
        eradicate?: string;
        /**
         * Define whether to SMB protocol is enabled for the filesystem.
         */
        smb?: string;
        /**
         * Default: 32G
         *
         * Volume size in M, G, T or P units. See examples.
         */
        size?: string;
        [k: string]: unknown;
      };
      /**
       * Manages BGP configurations on NX-OS switches.
       */
      nxos_bgp?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable/Disable handle BGP neighbor down event, due to various reasons.
         */
        neighbor_down_fib_accelerate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * AS confederation parameters.
         */
        confederation_peers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Routing domain confederation AS.
         */
        confederation_id?: string;
        /**
         * Enable/Disable cli event history buffer.
         */
        event_history_cli?: "true" | "false" | "default" | "size_small" | "size_medium" | "size_large" | "size_disable";
        /**
         * Enable/Disable periodic event history buffer.
         */
        event_history_periodic?:
          | "true"
          | "false"
          | "default"
          | "size_small"
          | "size_medium"
          | "size_large"
          | "size_disable";
        /**
         * Route Reflector Cluster-ID.
         */
        cluster_id?: string;
        /**
         * Administratively shutdown the BGP protocol.
         */
        shutdown?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set BGP hold timer.
         */
        timer_bgp_hold?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable/Disable load sharing across the providers with different (but equal-length) AS paths.
         */
        bestpath_aspath_multipath_relax?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        /**
         * Set maximum time that BGP keeps the stale routes from the restarting BGP peer.
         */
        graceful_restart_timers_stalepath_time?: string;
        /**
         * Specify Maximum number of AS numbers allowed in the AS-path attribute. Valid values are between 1 and 512.
         */
        maxas_limit?: string;
        /**
         * Set maximum time for a restart sent to the BGP peer.
         */
        graceful_restart_timers_restart?: string;
        auth_pass?: string;
        /**
         * Enable/Disable isolate this router from BGP perspective.
         */
        isolate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set BGP keepalive timer.
         */
        timer_bgp_keepalive?: string;
        /**
         * Enable/Disable Ignores the cost community for BGP best-path calculations.
         */
        bestpath_cost_community_ignore?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable/Disable immediately reset the session if the link to a directly connected BGP peer goes down.  Only supported in the global BGP context.
         */
        fast_external_fallover?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * Enable/Disable the batching evaluation of prefix advertisement to all peers.
         */
        disable_policy_batching?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.
         */
        disable_policy_batching_ipv6_prefix_list?: string;
        /**
         * Enable/Disable advertise only routes programmed in hardware to peers.
         */
        suppress_fib_pending?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable/Disable assigns the value of infinity to received routes that do not carry the MED attribute, making these routes the least desirable.
         */
        bestpath_med_missing_as_worst?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Router Identifier (ID) of the BGP router VRF instance.
         */
        router_id?: string;
        /**
         * Specify timeout for the first best path after a restart, in seconds.
         */
        timer_bestpath_limit?: string;
        /**
         * Enable/Disable neighborid. Use this when more paths available than max path config.
         */
        bestpath_compare_neighborid?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Local AS number to be used within a VRF instance.
         */
        local_as?: string;
        /**
         * Enable/Disable MED comparison on paths from different autonomous systems.
         */
        bestpath_always_compare_med?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        /**
         * Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.
         */
        disable_policy_batching_ipv4_prefix_list?: string;
        /**
         * Name of the VRF. The name 'default' is a valid VRF representing the global BGP.
         */
        vrf?: string;
        /**
         * Enable/Disable graceful restart helper mode.
         */
        graceful_restart_helper?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable/Disable message logging for neighbor up/down event.
         */
        log_neighbor_changes?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        /**
         * BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.
         */
        asn: string;
        /**
         * Enable/Disable event history buffer.
         */
        event_history_events?:
          | "true"
          | "false"
          | "default"
          | "size_small"
          | "size_medium"
          | "size_large"
          | "size_disable";
        /**
         * Enable/Disable detail event history buffer.
         */
        event_history_detail?:
          | "true"
          | "false"
          | "default"
          | "size_small"
          | "size_medium"
          | "size_large"
          | "size_disable";
        ssh_keyfile?: string;
        /**
         * Enable/Disable graceful restart.
         */
        graceful_restart?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable/Disable flush routes in RIB upon controlled restart. On NX-OS, this property is only supported in the global BGP context.
         */
        flush_routes?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable/Disable enforces the neighbor autonomous system to be the first AS number listed in the AS path attribute for eBGP. On NX-OS, this property is only supported in the global BGP context.
         */
        enforce_first_as?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable/Disable deterministic selection of the best MED pat from among the paths from the same autonomous system.
         */
        bestpath_med_non_deterministic?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        /**
         * The BGP reconnection interval for dropped sessions. Valid values are between 1 and 60.
         */
        reconnect_interval?: string;
        timeout?: number | string;
        /**
         * Enable/Disable enforcement of bestpath to do a MED comparison only between paths originated within a confederation.
         */
        bestpath_med_confed?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable/Disable comparison of router IDs for identical eBGP paths.
         */
        bestpath_compare_routerid?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of VRF definitions on Cisco IOS devices.  It allows playbooks to manage individual or the entire VRF collection.  It also supports purging VRF definitions from the configuration that are not explicitly defined.
       */
      ios_vrf?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Adds an export list of extended route target communities to the VRF.
         */
        route_export?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * This is a intent option and checks the operational state of the for given vrf C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vrf interfaces on device it will result in failure.
         */
        associated_interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        port?: number | string;
        /**
         * Provides a short description of the VRF definition in the current active configuration.  The VRF definition value accepts alphanumeric characters used to provide additional information about the VRF.
         */
        description?: string;
        /**
         * The router-distinguisher value uniquely identifies the VRF to routing processes on the remote IOS system.  The RD value takes the form of C(A:B) where C(A) and C(B) are both numeric values.
         */
        rd?: string;
        auth_pass?: string;
        /**
         * Default: 10
         *
         * Time in seconds to wait before checking for the operational state on remote device.
         */
        delay?: number | string;
        /**
         * Default: present
         *
         * Configures the state of the VRF definition as it relates to the device operational configuration.  When set to I(present), the VRF should be configured in the device active configuration and when set to I(absent) the VRF should not be in the device active configuration
         */
        state?: "present" | "absent";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Identifies the set of interfaces that should be configured in the VRF.  Interfaces must be routed interfaces in order to be placed into a VRF.
         */
        interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        username?: string;
        /**
         * Adds an import list of extended route target communities in address-family configuration submode to the VRF.
         */
        route_import_ipv4?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Adds an export list of extended route target communities in address-family configuration submode to the VRF.
         */
        route_export_ipv6?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Adds an import list of extended route target communities in address-family configuration submode to the VRF.
         */
        route_import_ipv6?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Adds an export list of extended route target communities in address-family configuration submode to the VRF.
         */
        route_export_ipv4?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Adds an export and import list of extended route target communities in address-family configuration submode to the VRF.
         */
        route_both_ipv4?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Adds an export and import list of extended route target communities in address-family configuration submode to the VRF.
         */
        route_both_ipv6?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        password?: string;
        /**
         * Adds an import list of extended route target communities to the VRF.
         */
        route_import?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ssh_keyfile?: string;
        /**
         * The name of the VRF definition to be managed on the remote IOS device.  The VRF definition name is an ASCII string name used to uniquely identify the VRF.  This argument is mutually exclusive with the C(vrfs) argument
         */
        name?: string;
        /**
         * Adds an export and import list of extended route target communities to the VRF.
         */
        route_both?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Instructs the module to consider the VRF definition absolute.  It will remove any previously configured VRFs on the device.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The set of VRF definition objects to be configured on the remote IOS device.  Ths list entries can either be the VRF name or a hash of VRF definitions and attributes.  This argument is mutually exclusive with the C(name) argument.
         */
        vrfs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Add, Erase or Remove drive for nodes on Element Software Cluster.
       */
      na_elementsw_drive?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Gather facts for GCP SslCertificate
       */
      gcp_compute_ssl_certificate_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Commits pending configuration changes on one or more Radware devices via vDirect server.
       * For Alteon ADC device, apply, sync and save actions will be performed by default. Skipping of an action is possible by explicit parameter specifying.
       * For Alteon VX Container device, no sync operation will be performed since sync action is only relevant for Alteon ADC devices.
       * For DefensePro and AppWall devices, a bulk commit action will be performed. Explicit apply, sync and save actions specifying is not relevant.
       */
      vdirect_commit?: {
        /**
         * Default: 2189
         *
         * vDirect server HTTPS port number, may be set as C(VDIRECT_HTTPS_PORT) environment variable.
         */
        vdirect_https_port?: number | string;
        /**
         * Default: 2188
         *
         * vDirect server HTTP port number, may be set as C(VDIRECT_HTTP_PORT) environment variable.
         */
        vdirect_http_port?: number | string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated,
         * may be set as C(VDIRECT_VALIDATE_CERTS) or C(VDIRECT_VERIFY) environment variable.
         * This should only set to C(no) used on personally controlled sites using self-signed certificates.
         */
        vdirect_validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 60
         *
         * Amount of time to wait for async operation completion [seconds],
         * may be set as C(VDIRECT_TIMEOUT) environment variable.
         */
        vdirect_timeout?: number | string;
        /**
         * Default: yes
         *
         * Wait for async operation to complete, may be set as C(VDIRECT_WAIT) environment variable.
         */
        vdirect_wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * If C(no), sync action will not be performed. Relevant for ADC devices only.
         */
        sync?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of Radware Alteon device names for commit operations.
         */
        devices:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Primary vDirect server IP address, may be set as C(VDIRECT_IP) environment variable.
         */
        vdirect_ip: string;
        /**
         * vDirect server username, may be set as C(VDIRECT_USER) environment variable.
         */
        vdirect_user: string;
        /**
         * Default: yes
         *
         * If C(no), apply action will not be performed. Relevant for ADC devices only.
         */
        apply?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Secondary vDirect server IP address, may be set as C(VDIRECT_SECONDARY_IP) environment variable.
         */
        vdirect_secondary_ip?: string;
        /**
         * Default: yes
         *
         * If C(no), save action will not be performed. Relevant for ADC devices only.
         */
        save?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * If C(no), an HTTP connection will be used instead of the default HTTPS connection,
         * may be set as C(VDIRECT_HTTPS) or C(VDIRECT_USE_SSL) environment variable.
         */
        vdirect_use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * vDirect server password, may be set as C(VDIRECT_PASSWORD) environment variable.
         */
        vdirect_password: string;
        [k: string]: unknown;
      };
      /**
       * Manage RabbitMQ plugins.
       */
      rabbitmq_plugin?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Create or remove a Distributed vSwitch portgroup.
       */
      vmware_dvs_portgroup?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Copies an EC2 Snapshot from a source region to a destination region.
       */
      ec2_snapshot_copy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * The Users resource represents a database user in a Cloud SQL instance.
       */
      gcp_sql_user?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The name of the user in the Cloud SQL instance.
         */
        name: string;
        service_account_email?: string;
        /**
         * The host name from which the user can connect. For insert operations, host defaults to an empty string. For update operations, host is specified as part of the request URL. The host name cannot be updated after insertion.
         */
        host: string;
        project?: string;
        /**
         * The name of the Cloud SQL instance. This does not include the project ID.
         */
        instance: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        /**
         * The password for the user.
         */
        password?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Manage user accounts and user attributes on a BIG-IP. Typically this module operates only on the REST API users and not the CLI users. When specifying C(root), you may only change the password. Your other parameters will be ignored in this case. Changing the C(root) password is not an idempotent operation. Therefore, it will change it every time this module attempts to change it.
       */
      bigip_user?: {
        /**
         * Default: always
         *
         * C(always) will allow to update passwords if the user chooses to do so. C(on_create) will only set the password for newly created users. When C(username_credential) is C(root), this value will be forced to C(always).
         */
        update_password?: string;
        /**
         * Optionally set the users shell.
         */
        shell?: string;
        /**
         * Set the users password to this unencrypted value. C(password_credential) is required when creating a new account.
         */
        password_credential?: string;
        /**
         * Specifies the administrative partition to which the user has access. C(partition_access) is required when creating a new account. Should be in the form "partition:role". Valid roles include C(acceleration-policy-editor), C(admin), C(application-editor), C(auditor) C(certificate-manager), C(guest), C(irule-manager), C(manager), C(no-access) C(operator), C(resource-admin), C(user-manager), C(web-application-security-administrator), and C(web-application-security-editor). Partition portion of tuple should be an existing partition or the value 'all'.
         */
        partition_access?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Default: present
         *
         * Whether the account should exist or not, taking action if the state is different from what is stated.
         */
        state?: string;
        /**
         * Full name of the user.
         */
        full_name?: string;
        /**
         * Name of the user to create, remove or modify.
         * The C(root) user may not be removed.
         */
        username_credential?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of the local usernames configured on network devices. It allows playbooks to manage either individual usernames or the collection of usernames in the current running config. It also supports purging usernames from the configuration that are not explicitly defined.
       */
      vyos_user?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update, suspend, activate and remove projects.
       */
      cs_project?: {
        [k: string]: unknown;
      };
      /**
       * Create, update, delete pods.
       */
      cs_pod?: {
        api_key?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Gateway for the Pod.
         * Required on C(state=present)
         */
        gateway?: string;
        /**
         * Default: present
         *
         * State of the pod.
         */
        state?: "present" | "enabled" | "disabled" | "absent";
        /**
         * Ending IP address for the Pod.
         */
        end_ip?: string;
        /**
         * Starting IP address for the Pod.
         * Required on C(state=present)
         */
        start_ip?: string;
        /**
         * Name of the zone in which the pod belongs to.
         * If not set, default zone is used.
         */
        zone?: string;
        /**
         * Netmask for the Pod.
         * Required on C(state=present)
         */
        netmask?: string;
        /**
         * uuid of the existing pod.
         */
        id?: string;
        /**
         * Name of the pod.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure SnmpTrapProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_snmptrapprofile?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Uuid of the snmp trap profile object.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * The ip address or hostname of the snmp trap destination server.
         */
        trap_servers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * A user-friendly name of the snmp trap configuration.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete instance of Web App.
       */
      azure_rm_webapp?: {
        /**
         * Name of the resource group to which the resource belongs.
         */
        resource_group: string;
        cloud_environment?: string;
        /**
         * If true web app hostname is not registered with DNS on creation.
         */
        dns_registration?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: started
         *
         * Start/Stop/Restart the web app.
         */
        app_state?: "started" | "stopped" | "restarted";
        /**
         * Default: True
         *
         * True to enable client affinity; False to stop sending session affinity cookies, which route client requests in the same session to the same instance.
         */
        client_affinity_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        /**
         * If true, custom (non *.azurewebsites.net) domains associated with web app are not verified.
         */
        skip_custom_domain_verification?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        cert_validation_mode?: "validate" | "ignore";
        /**
         * Resource location. If not set, location from the resource group will be used as default.
         */
        location?: string;
        /**
         * Configure web app application settings. Suboptions are in key value pair format.
         */
        app_settings?: {
          [k: string]: unknown;
        };
        /**
         * The web's startup file.
         * This only applies for linux web app.
         */
        startup_file?: string;
        subscription_id?: string;
        /**
         * Web app container settings.
         */
        container_settings?: {
          [k: string]: unknown;
        };
        profile?: string;
        /**
         * Configures web site to accept only https requests.
         */
        https_only?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tags?: {
          [k: string]: unknown;
        };
        /**
         * Repository type of deployment source. Eg. LocalGit, GitHub.
         * Please see U(https://docs.microsoft.com/en-us/rest/api/appservice/webapps/createorupdate#scmtype) for more info.
         */
        scm_type?: string;
        /**
         * Default: present
         *
         * Assert the state of the Web App.
         * Use 'present' to create or update a Web App and 'absent' to delete it.
         */
        state?: "absent" | "present";
        /**
         * App service plan. Required for creation.
         * It can be name of existing app service plan in same resource group as web app.
         * It can be resource id of existing app service plan. eg., /subscriptions/<subs_id>/resourceGroups/<resource_group>/providers/Microsoft.Web/serverFarms/<plan_name>
         * It can be a dict which contains C(name), C(resource_group), C(sku), C(is_linux) and C(number_of_workers).
         * C(name). Name of app service plan.
         * C(resource_group). Resource group name of app service plan.
         * C(sku). SKU of app service plan. For allowed sku, please refer to U(https://azure.microsoft.com/en-us/pricing/details/app-service/linux/).
         * C(is_linux). Indicates Linux app service plan. type bool. default False.
         * C(number_of_workers). Number of workers.
         */
        plan?: string;
        client_id?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        adfs_authority_url?: string;
        password?: string;
        /**
         * Deployment source for git
         */
        deployment_source?: {
          [k: string]: unknown;
        };
        tenant?: string;
        /**
         * Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.
         */
        name: string;
        /**
         * Purge any existing application settings. Replace web app application settings with app_settings.
         */
        purge_app_settings?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        secret?: string;
        /**
         * Set of run time framework settings. Each setting is a dictionary.
         * See U(https://docs.microsoft.com/en-us/azure/app-service/app-service-web-overview) for more info.
         */
        frameworks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_profile?: string;
        /**
         * Time to live in seconds for web app default domain name.
         */
        ttl_in_seconds?: number | string;
        [k: string]: unknown;
      };
      /**
       * An Ansible module to add or delete public ip addresses on an existing server or servers in CenturyLink Cloud.
       */
      clc_publicip?: {
        /**
         * A list of servers to create public ips on.
         */
        server_ids:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Determine whether to create or delete public IPs. If present module will not create a second public ip if one already exists.
         */
        state?: "present" | "absent";
        /**
         * Default: TCP
         *
         * The protocol that the public IP will listen for.
         */
        protocol?: "TCP" | "UDP" | "ICMP";
        /**
         * A list of ports to expose. This is required when state is 'present'
         */
        ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: yes
         *
         * Whether to wait for the tasks to finish before returning.
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage OneConnect profiles on a BIG-IP.
       */
      bigip_profile_oneconnect?: {
        /**
         * Specifies the number of seconds that a connection is idle before the connection flow is eligible for deletion.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         * You may specify a number of seconds for the timeout override.
         * When C(disabled), specifies that there is no timeout override for the connection.
         * When C(indefinite), Specifies that a connection may be idle with no timeout override.
         */
        idle_timeout_override?: string;
        /**
         * Specifies a value that the system applies to the source address to determine its eligibility for reuse.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         * The system applies the value of this setting to the server-side source address to determine its eligibility for reuse.
         * A mask of C(0) causes the system to share reused connections across all source addresses. A host mask of C(32) causes the system to share only those reused connections originating from the same source address.
         * When you are using a SNAT or SNAT pool, the server-side source address is translated first and then the OneConnect mask is applied to the translated address.
         */
        source_mask?: string;
        /**
         * Specifies the name of the OneConnect profile.
         */
        name?: string;
        /**
         * Specifies the profile from which this profile inherits settings.
         * When creating a new profile, if this parameter is not specified, the default is the system-supplied C(oneconnect) profile.
         */
        parent?: string;
        /**
         * Specifies the maximum number of times that a server-side connection can be reused.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        maximum_reuse?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the maximum number of seconds allowed for a connection in the connection reuse pool.
         * For any connection with an age higher than this value, the system removes that connection from the re-use pool.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        maximum_age?: string;
        /**
         * When C(none), simultaneous in-flight requests and responses over TCP connections to a pool member are counted toward the limit. This is the historical behavior.
         * When C(idle), idle connections will be dropped as the TCP connection limit is reached. For short intervals, during the overlap of the idle connection being dropped and the new connection being established, the TCP connection limit may be exceeded.
         * When C(strict), the TCP connection limit is honored with no exceptions. This means that idle connections will prevent new TCP connections from being made until they expire, even if they could otherwise be reused.
         * C(strict) is not a recommended configuration except in very special cases with short expiration timeouts.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        limit_type?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the profile exists.
         * When C(absent), ensures the profile is removed.
         */
        state?: string;
        /**
         * Specifies the maximum number of connections that the system holds in the connection reuse pool.
         * If the pool is already full, then a server-side connection closes after the response is completed.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        maximum_size?: string;
        /**
         * Indicates that connections may be shared not only within a virtual server, but also among similar virtual servers
         * When C(yes), all virtual servers that use the same OneConnect and other internal network profiles can share connections.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        share_pools?: string;
        /**
         * Description of the profile.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * An Ansible module to Create or Delete Anti Affinity Policies at CenturyLink Cloud.
       */
      clc_aa_policy?: {
        /**
         * Default: present
         *
         * Whether to create or delete the policy.
         */
        state?: "present" | "absent";
        /**
         * Datacenter in which the policy lives/should live.
         */
        location: string;
        /**
         * The name of the Anti Affinity Policy.
         */
        name: string;
        /**
         * Default: True
         *
         * Whether to wait for the tasks to finish before returning.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * Get facts for a virtual machine scale set
       */
      azure_rm_virtualmachine_scaleset_facts?: {
        profile?: string;
        /**
         * Limit results to a specific virtual machine scale set
         */
        name?: string;
        /**
         * The resource group to search for the desired virtual machine scale set
         */
        resource_group?: string;
        /**
         * List of tags to be matched
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        cloud_environment?: string;
        /**
         * Default: raw
         *
         * Format of the data returned.
         * If C(raw) is selected information will be returned in raw format from Azure Python SDK.
         * If C(curated) is selected the structure will be identical to input parameters of azure_rm_virtualmachine_scaleset module.
         * In Ansible 2.5 and lower facts are always returned in raw format.
         * Please note that this option will be deprecated in 2.10 when curated format will become the only supported format.
         */
        format?: "curated" | "raw";
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about clusters in VMWare infrastructure.
       * All values and VMware object names are case sensitive.
       */
      vmware_cluster_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides platform agnostic way of pushing text based configuration to network devices over network_cli connection plugin.
       */
      cli_config?: {
        /**
         * This argument is used when pushing a multiline configuration element to the device. It specifies the character to use as the delimiting character. This only applies to the configuration action.
         */
        multiline_delimiter?: string;
        /**
         * The C(rollback) argument instructs the module to rollback the current configuration to the identifier specified in the argument.  If the specified rollback identifier does not exist on the remote device, the module will fail. To rollback to the most recent commit, set the C(rollback) argument to 0. This option is mutually exclusive with C(config).
         */
        rollback?: number | string;
        /**
         * The C(commit_comment) argument specifies a text string to be used when committing the configuration. If the C(commit) argument is set to False, this argument is silently ignored. This argument is only valid for the platforms that support commit operation with comment.
         */
        commit_comment?: string;
        /**
         * The config to be pushed to the network device. This argument is mutually exclusive with C(rollback) and either one of the option should be given as input. The config should have indentation that the device uses.
         */
        config?: string;
        /**
         * If the C(replace) argument is set to C(yes), it will replace the entire running-config of the device with the C(config) argument value. For NXOS devices, C(replace) argument takes path to the file on the device that will be used for replacing the entire running-config. Nexus 9K devices only support replace. Use I(net_put) or I(nxos_file_copy) module to copy the flat file to remote device and then use set the fullpath to this argument.
         */
        replace?: string;
        /**
         * Default: no
         *
         * The I(defaults) argument will influence how the running-config is collected from the device.  When the value is set to true, the command used to collect the running-config is append with the all keyword.  When the value is set to false, the command is issued without the all keyword.
         */
        defaults?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The C(commit) argument instructs the module to push the configuration to the device. This is mapped to module check mode.
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Instructs the module on the way to perform the matching of the set of commands against the current device config. If C(diff_match) is set to I(line), commands are matched line by line. If C(diff_match) is set to I(strict), command lines are matched with respect to position. If C(diff_match) is set to I(exact), command lines must be an equal match. Finally, if C(diff_match) is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device. Note that this parameter will be ignored if the platform has onbox diff support.
         */
        diff_match?: "line" | "strict" | "exact" | "none";
        /**
         * Instructs the module on the way to perform the configuration on the device. If the C(diff_replace) argument is set to I(line) then the modified lines are pushed to the device in configuration mode. If the argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct. Note that this parameter will be ignored if the platform has onbox diff support.
         */
        diff_replace?: "line" | "block" | "config";
        /**
         * Use this argument to specify one or more lines that should be ignored during the diff. This is used for lines in the configuration that are automatically updated by the system. This argument takes a list of regular expressions or exact line matches. Note that this parameter will be ignored if the platform has onbox diff support.
         */
        diff_ignore_lines?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * This module executes AWS Lambda functions, allowing synchronous and asynchronous invocation.
       */
      execute_lambda?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Apstra AOS ASN Pool module let you manage your ASN Pool easily. You can create and delete ASN Pool by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.
       */
      aos_asn_pool?: {
        /**
         * List of ASNs ranges to add to the ASN Pool. Each range must have 2 values.
         */
        ranges?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the ASN Pool to manage. Only one of I(name), I(id) or I(content) can be set.
         */
        name?: string;
        /**
         * Datastructure of the ASN Pool to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).
         */
        content?: string;
        /**
         * Default: present
         *
         * Indicate what is the expected state of the ASN Pool (present or not).
         */
        state?: "present" | "absent";
        /**
         * An existing AOS session as obtained by M(aos_login) module.
         */
        session: {
          [k: string]: unknown;
        };
        /**
         * AOS Id of the ASN Pool to manage. Only one of I(name), I(id) or I(content) can be set.
         */
        id?: string;
        [k: string]: unknown;
      };
      /**
       * Change dpkg package selection state via --get-selections and --set-selections.
       */
      dpkg_selections?: {
        /**
         * The selection state to set the package to.
         */
        selection?: "install" | "hold" | "deinstall" | "purge";
        /**
         * Name of the package
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create/delete/assign a floating IP.
       */
      digital_ocean_floating_ip?: {
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP HttpHealthCheck
       */
      gcp_compute_http_health_check_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * An Ansible module to Create or Delete Alert Policies at CenturyLink Cloud.
       */
      clc_alert_policy?: {
        /**
         * The name of the alert policy. This is mutually exclusive with id
         */
        name?: string;
        /**
         * The metric on which to measure the condition that will trigger the alert. This is required for state 'present'
         */
        metric?: "cpu" | "memory" | "disk";
        /**
         * The alert policy id. This is mutually exclusive with name
         */
        id?: string;
        /**
         * The alias of your CLC Account
         */
        alias: string;
        /**
         * Default: present
         *
         * Whether to create or delete the policy.
         */
        state?: "present" | "absent";
        /**
         * The threshold that will trigger the alert when the metric equals or exceeds it. This is required for state 'present' This number represents a percentage and must be a value between 5.0 - 95.0 that is a multiple of 5.0
         */
        threshold?: number | string;
        /**
         * A list of recipient email ids to notify the alert. This is required for state 'present'
         */
        alert_recipients?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The length of time in minutes that the condition must exceed the threshold. This is required for state 'present'
         */
        duration?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about plans available to boot servers.
       */
      vultr_plan_facts?: {
        api_retries?: number | string;
        api_timeout?: number | string;
        api_endpoint?: string;
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Load configuration on PAN-OS device
       */
      panos_loadcfg?: {
        username?: string;
        /**
         * Default: yes
         *
         * commit if changed
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password: string;
        ip_address: string;
        /**
         * configuration file to load
         */
        file?: string;
        [k: string]: unknown;
      };
      /**
       * Manage OpenStack DNS zones. Zones can be created, deleted or updated. Only the I(email), I(description), I(ttl) and I(masters) values can be updated.
       */
      os_zone?: {
        /**
         * Master nameservers (only applies if zone_type is secondary)
         */
        masters?: string;
        /**
         * Zone description
         */
        description?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * TTL (Time To Live) value in seconds
         */
        ttl?: string;
        /**
         * Zone type
         */
        zone_type?: string;
        /**
         * Email of the zone owner (only applies if zone_type is primary)
         */
        email?: string;
        /**
         * Zone name
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Executes the given operation on the YANG object, using CPS API in the networking device running OpenSwitch (OPX). It uses the YANG models provided in https://github.com/open-switch/opx-base-model.
       */
      opx_cps?: {
        /**
         * Default: target
         *
         * A qualifier provides the type of object data to retrieve or act on.
         */
        qualifier?: "target" | "observed" | "proposed" | "realtime" | "registration" | "running" | "startup";
        /**
         * Default: no
         *
         * Attempts to force the auto-commit event to the specified yang object.
         */
        commit_event?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Queries/Writes the specified yang path from/to the db.
         */
        db?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Attribute Yang type.
         */
        attr_type?: {
          [k: string]: unknown;
        };
        /**
         * Yang path to be configured.
         */
        module_name: string;
        /**
         * Default: create
         *
         * Operation to be performed on the object.
         */
        operation?: "delete" | "create" | "set" | "action" | "get";
        /**
         * Attribute Yang path and their corresponding data.
         */
        attr_data: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 instances in AWS
       */
      ec2_instance_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, Update or Destroy a Target_Proxy. See U(https://cloud.google.com/compute/docs/load-balancing/http/target-proxies) for an overview. More details on the Target_Proxy API can be found at U(https://cloud.google.com/compute/docs/reference/latest/targetHttpProxies#resource-representations).
       */
      gcp_target_proxy?: {
        service_account_email?: string;
        service_account_permissions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the Url Map.  Required if type is HTTP or HTTPS proxy.
         */
        url_map_name?: string;
        pem_file?: string;
        state: "absent" | "present";
        /**
         * Name of the Target_Proxy.
         */
        target_proxy_name: string;
        credentials_file?: string;
        /**
         * Type of Target_Proxy. HTTP, HTTPS or SSL. Only HTTP is currently supported.
         */
        target_proxy_type: "HTTP";
        project_id?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 volumes in AWS
       */
      ec2_vol_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts about OSes available to boot servers.
       */
      vultr_os_facts?: {
        api_retries?: number | string;
        api_timeout?: number | string;
        api_endpoint?: string;
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Gather facts about availability zones in AWS.
       */
      aws_az_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add, modify or delete sudo command group within IPA server using IPA API.
       */
      ipa_sudocmdgroup?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Register and remove ISO images.
       */
      cs_iso?: {
        [k: string]: unknown;
      };
      /**
       * Manages NTP authentication.
       */
      nxos_ntp_auth?: {
        /**
         * Default: text
         *
         * Whether the given md5string is in cleartext or has been encrypted. If in cleartext, the device will encrypt it before storing it.
         */
        auth_type?: "text" | "encrypt";
        username?: string;
        ssh_keyfile?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        auth_pass?: string;
        /**
         * Authentication key identifier (numeric).
         */
        key_id?: string;
        host?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Turns NTP authentication on or off.
         */
        authentication?: "on" | "off";
        /**
         * Default: false
         *
         * Whether the given key is required to be supplied by a time source for the device to synchronize to the time source.
         */
        trusted_key?: "false" | "true";
        /**
         * MD5 String.
         */
        md5string?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Manages OpenNebula images
       */
      one_image?: {
        /**
         * A name that will be assigned to the existing or new image.
         * In the case of cloning, by default C(new_name) will take the name of the origin image with the prefix 'Copy of'.
         */
        new_name?: string;
        /**
         * URL of the OpenNebula RPC server.
         * It is recommended to use HTTPS so that the username/password are not
         * transferred over the network unencrypted.
         * If not set then the value of the C(ONE_URL) environment variable is used.
         */
        api_url?: string;
        /**
         * Whether the image should be enabled or disabled.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Password of the user to login into OpenNebula RPC server. If not set
         * then the value of the C(ONE_PASSWORD) environment variable is used.
         */
        api_password?: string;
        /**
         * Default: present
         *
         * C(present) - state that is used to manage the image
         * C(absent) - delete the image
         * C(cloned) - clone the image
         * C(renamed) - rename the image to the C(new_name)
         */
        state?: "present" | "absent" | "cloned" | "renamed";
        /**
         * Name of the user to login into the OpenNebula RPC server. If not set
         * then the value of the C(ONE_USERNAME) environment variable is used.
         */
        api_username?: string;
        /**
         * A C(id) of the image you would like to manage.
         */
        id?: number | string;
        /**
         * A C(name) of the image you would like to manage.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove ONTAP broadcast domain ports.  Existing ports that are not listed are kept.
       */
      na_ontap_broadcast_domain_ports?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module allows you to restart the switch using the current startup configuration. The module is usually invoked after the running configuration has been saved over the startup configuration. This module uses SSH to manage network device configuration. The results of the operation can be viewed in results directory.
       */
      cnos_reload?: {
        username?: string;
        outputfile: string;
        host?: string;
        deviceType: string;
        password?: string;
        enablePassword?: string;
        [k: string]: unknown;
      };
      /**
       * Manages configuration on Cisco FTD devices including creating, updating, removing configuration objects, scheduling and staring jobs, deploying pending changes, etc. All operation are performed over REST API.
       */
      ftd_configuration?: {
        /**
         * Key-value pairs that should be sent as query parameters in a REST API call.
         */
        query_params?: {
          [k: string]: unknown;
        };
        /**
         * Key-value pairs that should be sent as path parameters in a REST API call.
         */
        path_params?: {
          [k: string]: unknown;
        };
        /**
         * Specifies Ansible fact name that is used to register received response from the FTD device.
         */
        register_as?: string;
        /**
         * Key-value dict that represents equality filters. Every key is a property name and value is its desired value. If multiple filters are present, they are combined with logical operator AND.
         */
        filters?: {
          [k: string]: unknown;
        };
        /**
         * The name of the operation to execute. Commonly, the operation starts with 'add', 'edit', 'get', 'upsert' or 'delete' verbs, but can have an arbitrary name too.
         */
        operation: string;
        /**
         * Key-value pairs that should be sent as body parameters in a REST API call
         */
        data?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Manipulate metadata for Rackspace Cloud Servers
       */
      rax_meta?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Controls daemontools services on remote hosts using the svc utility.
       */
      svc?: {
        dist?: string;
        /**
         * Name of the service to manage.
         */
        name: string;
        /**
         * Default: no
         *
         * Should a 'down' file exist or not, if it exists it disables auto startup. defaults to no. Downed does not imply stopped.
         */
        downed?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Wheater the service is enabled or not, if disabled it also implies stopped. Make note that a service can be enabled and downed (no auto restart).
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: /service
         *
         * directory svscan watches for services
         */
        service_dir?: string;
        /**
         * C(Started)/C(stopped) are idempotent actions that will not run commands unless necessary.  C(restarted) will always bounce the svc (svc -t) and C(killed) will always bounce the svc (svc -k). C(reloaded) will send a sigusr1 (svc -1). C(once) will run a normally downed svc once (svc -o), not really an idempotent operation.
         */
        state?: "killed" | "once" | "reloaded" | "restarted" | "started" | "stopped";
        /**
         * directory where services are defined, the source of symlinks to service_dir.
         */
        service_src?: string;
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running OS10.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      dellos10_facts?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        host?: string;
        /**
         * Default: ['!config']
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages DNS records via the v2 REST API of the DNS Made Easy service.  It handles records only; there is no manipulation of domains or monitor/account support yet. See: U(https://www.dnsmadeeasy.com/integration/restapi/)
       *
       */
      dnsmadeeasy?: {
        /**
         * The fully qualified domain name used by the monitor.
         */
        httpFqdn?: string;
        /**
         * Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNS Made Easy (e.g. "839989") for faster resolution
         */
        domain: string;
        /**
         * Default: HTTP
         *
         * Protocol used by the monitor.
         */
        protocol?: "TCP" | "UDP" | "HTTP" | "DNS" | "SMTP" | "HTTPS";
        /**
         * Default: no
         *
         * If true, fallback to the primary IP address is manual after a failover.
         * If false, fallback to the primary IP address is automatic after a failover.
         */
        autoFailover?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: Medium
         *
         * Number of checks the monitor performs before a failover occurs where Low = 8, Medium = 5,and High = 3.
         */
        sensitivity?: "Low" | "Medium" | "High";
        /**
         * Name or id of the contact list that the monitor will notify.
         * The default C('') means the Account Owner.
         */
        contactList?: string;
        /**
         * Account API Key.
         */
        account_key: string;
        /**
         * Record type.
         */
        record_type?: "A" | "AAAA" | "CNAME" | "ANAME" | "HTTPRED" | "MX" | "NS" | "PTR" | "SRV" | "TXT";
        /**
         * Default: 80
         *
         * Port used by the monitor.
         */
        port?: number | string;
        /**
         * Default: no
         *
         * If C(yes), add or change the monitor.  This is applicable only for A records.
         */
        monitor?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The string in the httpFile that the monitor queries for HTTP or HTTPS.
         */
        httpQueryString?: string;
        /**
         * whether the record should exist or not
         */
        state: "present" | "absent";
        /**
         * Description used by the monitor.
         */
        systemDescription?: string;
        /**
         * The file at the Fqdn that the monitor queries for HTTP or HTTPS.
         */
        httpFile?: string;
        /**
         * Record name to get/create/delete/update. If record_name is not specified; all records for the domain will be returned in "result" regardless of the state argument.
         */
        record_name?: string;
        /**
         * Default: 1800
         *
         * record's "Time to live".  Number of seconds the record remains cached in DNS servers.
         */
        record_ttl?: number | string;
        /**
         * Account Secret Key.
         */
        account_secret: string;
        /**
         * Secondary IP address for the failover.
         * Required if adding or changing the failover.
         */
        ip2?: string;
        /**
         * Tertiary IP address for the failover.
         */
        ip3?: string;
        /**
         * Primary IP address for the failover.
         * Required if adding or changing the monitor or failover.
         */
        ip1?: string;
        /**
         * Quaternary IP address for the failover.
         */
        ip4?: string;
        /**
         * Quinary IP address for the failover.
         */
        ip5?: string;
        /**
         * Default: no
         *
         * If C(yes), add or change the failover.  This is applicable only for A records.
         */
        failover?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * Number of emails sent to the contact list by the monitor.
         */
        maxEmails?: number | string;
        /**
         * Default: no
         *
         * Decides if the sandbox API should be used. Otherwise (default) the production API of DNS Made Easy is used.
         */
        sandbox?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Record value. HTTPRED: <redirection URL>, MX: <priority> <target name>, NS: <name server>, PTR: <target name>, SRV: <priority> <weight> <port> <target name>, TXT: <text value>"
         *
         * If record_value is not specified; no changes will be made and the record will be returned in 'result' (in other words, this module can be used to fetch a record's current id, type, and ttl)
         *
         */
        record_value?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage the state of a program monitored via I(Monit)
       */
      monit?: {
        /**
         * The state of service
         */
        state: "present" | "started" | "stopped" | "restarted" | "monitored" | "unmonitored" | "reloaded";
        /**
         * The name of the I(monit) program/process to manage
         */
        name: string;
        /**
         * Default: 300
         *
         * If there are pending actions for the service monitored by monit, then Ansible will check for up to this many seconds to verify the requested action has been performed. Ansible will sleep for five seconds between each check.
         */
        timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * An SslCertificate resource. This resource provides a mechanism to upload an SSL key and certificate to the load balancer to serve secure connections from the user.
       */
      gcp_compute_ssl_certificate?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The private key in PEM format.
         */
        private_key?: string;
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name?: string;
        /**
         * The certificate in PEM format.
         * The certificate chain must be no greater than 5 certs long.
         * The chain must include at least one intermediate cert.
         */
        certificate?: string;
        service_account_email?: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * An optional description of this resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Use this module to schedule a command or script file to run once in the future.
       * All jobs are executed in the 'a' queue.
       */
      at?: {
        /**
         * The count of units in the future to execute the command or script file.
         */
        count?: number | string;
        /**
         * Default: present
         *
         * The state dictates if the command or script file should be evaluated as present(added) or absent(deleted).
         */
        state?: "absent" | "present";
        /**
         * A command to be executed in the future.
         */
        command?: string;
        /**
         * The type of units in the future to execute the command or script file.
         */
        units?: "minutes" | "hours" | "days" | "weeks";
        /**
         * Default: no
         *
         * If a matching job is present a new job will not be added.
         */
        unique?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * An existing script file to be executed in the future.
         */
        script_file?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, and remove public IPs. This module has a dependency on 1and1 >= 1.0
       */
      oneandone_public_ip?: {
        /**
         * ID of the datacenter where the IP will be created (only for unassigned IPs).
         */
        datacenter?: "US" | "ES" | "DE" | "GB";
        /**
         * Custom API URL. Overrides the ONEANDONE_API_URL environement variable.
         */
        api_url?: string;
        /**
         * Default: 5
         *
         * Defines the number of seconds to wait when using the _wait_for methods
         */
        wait_interval?: number | string;
        /**
         * Authenticating API token provided by 1&1.
         */
        auth_token?: string;
        /**
         * Reverse DNS name. maxLength=256
         */
        reverse_dns?: string;
        /**
         * Default: present
         *
         * Define a public ip state to create, remove, or update.
         */
        state?: "present" | "absent" | "update";
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * The ID of the public IP used with update and delete states.
         */
        public_ip_id?: string;
        /**
         * Default: IPV4
         *
         * Type of IP. Currently, only IPV4 is available.
         */
        type?: "IPV4" | "IPV6";
        /**
         * Default: yes
         *
         * wait for the instance to be in state 'running' before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages UDLD global configuration params.
       */
      nxos_udld?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource. When set to 'absent', aggressive and msg_time are set to their default values.
         */
        state?: "present" | "absent";
        /**
         * Default: no
         *
         * Ability to reset all ports shut down by UDLD. 'state' parameter cannot be 'absent' when this is present.
         */
        reset?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Message time in seconds for UDLD packets or keyword 'default'.
         */
        msg_time?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Toggles aggressive mode.
         */
        aggressive?: "enabled" | "disabled";
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * This module allows you to search for Zabbix hostgroup entries.
       */
      zabbix_group_facts?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Creates or terminates ecs clusters.
       */
      ecs_cluster?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Get facts of PostgreSQL Server.
       */
      azure_rm_postgresqlserver_facts?: {
        profile?: string;
        /**
         * The name of the server.
         */
        name?: string;
        /**
         * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
         */
        resource_group: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP Instance
       */
      gcp_compute_instance_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A reference to the zone where the machine resides.
         */
        zone: string;
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running Ironware.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      ironware_facts?: {
        /**
         * Default: ['!config', '!mpls']
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, mpls and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        provider?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Create, update and delete instance of PostgreSQL Database.
       */
      azure_rm_postgresqldatabase?: {
        profile?: string;
        /**
         * Default: no
         *
         * When set to C(true), will delete and recreate the existing PostgreSQL database if any of the properties don't match what is set.
         * When set to C(false), no change will occur to the database even if any of the properties do not match.
         */
        force_update?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the database.
         */
        name: string;
        /**
         * The name of the server.
         */
        server_name: string;
        cloud_environment?: string;
        /**
         * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
         */
        resource_group: string;
        /**
         * The charset of the database. Check PostgreSQL documentation for possible values.
         * This is only set on creation, use I(force_update) to recreate a database if the values don't match.
         */
        charset?: string;
        ad_user?: string;
        secret?: string;
        adfs_authority_url?: string;
        /**
         * Default: present
         *
         * Assert the state of the PostgreSQL database. Use 'present' to create or update a database and 'absent' to delete it.
         */
        state?: "absent" | "present";
        client_id?: string;
        cert_validation_mode?: "validate" | "ignore";
        /**
         * The collation of the database. Check PostgreSQL documentation for possible values.
         * This is only set on creation, use I(force_update) to recreate a database if the values don't match.
         */
        collation?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        api_profile?: string;
        [k: string]: unknown;
      };
      /**
       * Manage I(libvirt) storage pools.
       */
      virt_pool?: {
        [k: string]: unknown;
      };
      /**
       * This module creates, deletes or modifys NFS client(s) for existing exports on Infinibox.
       */
      infini_export_client?: {
        /**
         * Default: present
         *
         * Creates/Modifies client when present and removes when absent.
         */
        state?: string;
        /**
         * Default: RW
         *
         * Read Write or Read Only Access.
         */
        access_mode?: string;
        /**
         * Name of the export.
         */
        export?: string;
        /**
         * Don't squash root user to anonymous. Will be set to "no" on creation if not specified explicitly.
         */
        no_root_squash?: string;
        /**
         * Client IP or Range. Ranges can be defined as follows 192.168.0.1-192.168.0.254.
         */
        client?: string;
        [k: string]: unknown;
      };
      /**
       * Manage content switching policy.
       * This module is intended to run either on the ansible  control node or a bastion (jumpserver) with access to the actual netscaler instance.
       */
      netscaler_cs_policy?: {
        /**
         * Name for the content switching policy. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Cannot be changed after a policy is created.
         * The following requirement applies only to the NetScaler CLI:
         * If the name includes one or more spaces, enclose the name in double or single quotation marks (for example, my policy or my policy).
         * Minimum length = 1
         */
        policyname?: string;
        /**
         * The domain name. The string value can range to 63 characters.
         * Minimum length = 1
         */
        domain?: string;
        /**
         * URL string that is matched with the URL of a request. Can contain a wildcard character. Specify the string value in the following format: C([[prefix] [*]] [.suffix]).
         * Minimum length = 1
         * Maximum length = 208
         */
        url?: string;
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        state?: "present" | "absent";
        /**
         * Expression, or name of a named expression, against which traffic is evaluated. Written in the classic or default syntax.
         * Note:
         * Maximum length of a string literal in the expression is 255 characters. A longer string can be split into smaller strings of up to 255 characters each, and the smaller strings concatenated with the + operator. For example, you can create a 500-character string as follows: '"<string of 255 characters>" + "<string of 245 characters>"'
         */
        rule?: string;
        nitro_protocol?: "http" | "https";
        nsip: string;
        nitro_user: string;
        /**
         * Content switching action that names the target load balancing virtual server to which the traffic is switched.
         */
        action?: string;
        nitro_pass: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_timeout?: number;
        [k: string]: unknown;
      };
      /**
       * This module can be used for calling any resources defined in Avi REST API. U(https://avinetworks.com/)
       * This module is useful for invoking HTTP Patch methods and accessing resources that do not have an REST object associated with them.
       */
      avi_gslbservice_patch_member?: {
        username?: string;
        /**
         * Name of the GSLB Service
         */
        name: string;
        /**
         * Default: present
         *
         * The state that should be applied to the member. Member is
         * identified using field member.ip.addr.
         */
        state?: "absent" | "present";
        avi_credentials?: {
          [k: string]: unknown;
        };
        controller?: string;
        /**
         * Query parameters passed to the HTTP API.
         */
        params?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * HTTP body of GSLB Service Member in YAML or JSON format.
         */
        data?: {
          [k: string]: unknown;
        };
        tenant_uuid?: string;
        api_version?: string;
        [k: string]: unknown;
      };
      /**
       * Controls OpenWrt services on remote hosts.
       */
      openwrt_init?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Gather facts about AWS KMS keys including tags and grants
       */
      aws_kms_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module offers the ability to configure a BGP EVPN peer relationship on HUAWEI CloudEngine switches.
       */
      ce_evpn_bgp?: {
        username?: string;
        /**
         * Configures a device to advertise routes to its BGP EVPN peers.
         */
        advertise_router_type?: "arp" | "irb";
        ssh_keyfile?: string;
        /**
         * Enable or disable a device to advertise IP routes imported to a VPN instance to its EVPN instance.
         */
        advertise_l2vpn_evpn?: "enable" | "disable";
        /**
         * Specifies integral AS number. The value is an integer ranging from 1 to 4294967295.
         */
        as_number?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Associates a specified VPN instance with the IPv4 address family. The value is a string of 1 to 31 case-sensitive characters, spaces not supported.
         */
        vpn_name?: string;
        /**
         * Specify the name of a peer group that BGP peers need to join. The value is a string of 1 to 47 case-sensitive characters, spaces not supported.
         */
        peer_group_name?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Name of a BGP instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported.
         */
        bgp_instance: string;
        /**
         * Enable or disable a BGP device to exchange routes with a specified peer or peer group in the address family view.
         */
        peer_enable?: "true" | "false";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        host?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        /**
         * Specifies the IPv4 address of a BGP EVPN peer. The value is in dotted decimal notation.
         */
        peer_address?: string;
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of LLDP interfaces configuration on Juniper JUNOS network devices.
       */
      junos_lldp_interface?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Name of the interface LLDP should be configured on.
         */
        name?: string;
        /**
         * Default: present
         *
         * Value of C(present) ensures given LLDP configured on given I(interfaces) and is enabled, for value of C(absent) LLDP configuration on given I(interfaces) deleted. Value C(enabled) ensures LLDP protocol is enabled on given I(interfaces) and for value of C(disabled) it ensures LLDP is disabled on given I(interfaces).
         */
        state?: "present" | "absent" | "enabled" | "disabled";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: True
         *
         * Specifies whether or not the configuration is active or deactivated
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * The C(git_config) module changes git configuration by invoking 'git config'. This is needed if you don't want to use M(template) for the entire git config file (e.g. because you need to change just C(user.email) in /etc/.git/config).  Solutions involving M(command) are cumbersome or don't work correctly in check mode.
       */
      git_config?: {
        /**
         * Path to a git repository for reading and writing values from a specific repo.
         */
        repo?: string;
        /**
         * Specify which scope to read/set values from. This is required when setting config values. If this is set to local, you must also specify the repo parameter. It defaults to system only when not using I(list_all)=yes.
         */
        scope?: "local" | "global" | "system";
        /**
         * Default: no
         *
         * List all settings (optionally limited to a given I(scope))
         */
        list_all?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the setting. If no value is supplied, the value will be read from the config if it has been set.
         */
        name?: string;
        /**
         * When specifying the name of a single setting, supply a value to set that setting to the given value.
         */
        value?: string;
        [k: string]: unknown;
      };
      /**
       * Manages VXLAN Network Virtualization Endpoint (NVE) overlay interface that terminates VXLAN tunnels.
       */
      nxos_vxlan_vtep?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        timeout?: number | string;
        ssh_keyfile?: string;
        /**
         * Description of the NVE interface.
         */
        description?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * Specify the loopback interface whose IP address should be used for the NVE interface.
         */
        source_interface?: string;
        auth_pass?: string;
        /**
         * Specify mechanism for host reachability advertisement.
         */
        host_reachability?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Suppresses advertisement of the NVE loopback address until the overlay has converged.
         */
        source_interface_hold_down_time?: string;
        host?: string;
        /**
         * Administratively shutdown the NVE interface.
         */
        shutdown?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Interface name for the VXLAN Network Virtualization Endpoint.
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * An isolated set of Cloud Spanner resources on which databases can be hosted.
       */
      gcp_spanner_instance?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The descriptive name for this instance as it appears in UIs. Must be unique per project and between 4 and 30 characters in length.
         */
        display_name: string;
        /**
         * A unique identifier for the instance, which cannot be changed after the instance is created. Values are of the form projects/<project>/instances/[a-z][-a-z0-9]*[a-z0-9]. The final segment of the name must be between 6 and 30 characters in length.
         */
        name?: string;
        service_account_email?: string;
        /**
         * Cloud Labels are a flexible and lightweight mechanism for organizing cloud resources into groups that reflect a customer's organizational needs and deployment strategies. Cloud Labels can be used to filter collections of resources. They can be used to control how resource metrics are aggregated. And they can be used as arguments to policy management rules (e.g. route, firewall, load balancing, etc.).
         * Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
         * Label values must be between 0 and 63 characters long and must conform to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
         * No more than 64 labels can be associated with a given resource.
         * See U(https://goo.gl/xmQnxf) for more information on and examples of labels.
         * If you plan to use labels in your own code, please note that additional characters may be allowed in the future. And so you are advised to use an internal label representation, such as JSON, which doesn't rely upon specific characters being disallowed. For example, representing labels as the string: name + "_" + value would prove problematic if we were to allow "_" in a future release.
         * An object containing a list of "key": value pairs.
         * Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
         */
        labels?: {
          [k: string]: unknown;
        };
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * A reference to the instance configuration.
         */
        config?: string;
        /**
         * The number of nodes allocated to this instance.
         */
        node_count?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage cache security groups in Amazon Elasticache.
       * Returns information about the specified cache cluster.
       */
      elasticache_parameter_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages registration key (regkey) pools on a BIG-IQ. These pools function as a container in-which you will add lists of registration keys. To add registration keys, use the C(bigiq_regkey_license) module.
       */
      bigiq_regkey_pool?: {
        /**
         * Default: present
         *
         * The state of the regkey pool on the system.
         * When C(present), guarantees that the pool exists.
         * When C(absent), removes the pool, and the licenses it contains, from the system.
         */
        state?: string;
        /**
         * Specifies the name of the registration key pool.
         * You must be mindful to name your registration pools unique names. While BIG-IQ does not require this, this module does. If you do not do this, the behavior of the module is undefined and you may end up putting licenses in the wrong registration key pool.
         */
        name?: string;
        /**
         * A description to attach to the pool.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove PostgreSQL schema from a remote host.
       */
      postgresql_schema?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage taboo contracts on Cisco ACI fabrics.
       */
      aci_taboo_contract?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manages BIG-IQ applications used for load balancing an HTTPS application on port 443 with a Web Application Firewall (WAF) using an ASM Rapid Deployment policy.
       */
      bigiq_application_https_waf?: {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV affinity labels.
       */
      ovirt_affinity_label_facts?: {
        /**
         * Name of the host, which affinity labels should be listed.
         */
        host?: string;
        /**
         * Name of the affinity labels which should be listed.
         */
        name?: string;
        /**
         * Name of the VM, which affinity labels should be listed.
         */
        vm?: string;
        [k: string]: unknown;
      };
      /**
       * Certain E-Series systems have the capability to send email notifications on potentially critical events.
       * This module will allow the owner of the system to specify email recipients for these messages.
       */
      netapp_e_alerts?: {
        ssid: string;
        /**
         * This is the sender that the recipient will see. It doesn't necessarily need to be a valid email account.
         * Required when I(state=enabled).
         */
        sender?: string;
        /**
         * The email addresses that will receive the email notifications.
         * Required when I(state=enabled).
         */
        recipients?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Path to a file on the Ansible control node to be used for debug logging
         */
        log_path?: string;
        api_password: string;
        /**
         * A fully qualified domain name, IPv4 address, or IPv6 address of a mail server.
         * To use a fully qualified domain name, you must configure a DNS server on both controllers using M(netapp_e_mgmt_interface). - Required when I(state=enabled).
         */
        server?: string;
        /**
         * Default: enabled
         *
         * Enable/disable the sending of email-based alerts.
         */
        state?: "enabled" | "disabled";
        /**
         * Allows the owner to specify some free-form contact information to be included in the emails.
         * This is typically utilized to provide a contact phone number.
         */
        contact?: string;
        api_username: string;
        /**
         * When a change is detected in the configuration, a test email will be sent.
         * This may take a few minutes to process.
         * Only applicable if I(state=enabled).
         */
        test?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of link aggregation groups on network devices.
       */
      net_linkagg?: {
        username?: string;
        eth_trunk_id?: string;
        ssh_keyfile?: string;
        provider?: {
          [k: string]: unknown;
        };
        pseudo_priority?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        priority_id?: string;
        peer_link_id?: string;
        vpn_instance_name?: string;
        nickname?: string;
        /**
         * Default: present
         *
         * State of the link aggregation group.
         */
        state?: "present" | "absent";
        pseudo_nickname?: string;
        timeout?: number | string;
        dfs_group_id?: string;
        host?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        ip_address?: string;
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Manages BIG-IQ applications used for load balancing an HTTP application on port 80 on BIG-IP.
       */
      bigiq_application_http?: {
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about regions.
       */
      digital_ocean_region_facts?: {
        [k: string]: unknown;
      };
      /**
       * Manages SNMP contact configurations on HUAWEI CloudEngine switches.
       */
      ce_snmp_contact?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * Contact information.
         */
        contact: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 security groups in AWS.
       */
      ec2_group_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and remove Rundeck ACL policies through HTTP API.
       */
      rundeck_acl_policy?: {
        /**
         * Sets the project name.
         */
        name: string;
        /**
         * Sets the rundeck instance URL.
         */
        url: string;
        /**
         * Sets the token to authenticate against Rundeck API.
         */
        token: string;
        /**
         * Sets the project which receive the ACL policy.
         * If unset, it's a system ACL policy.
         */
        project?: string;
        /**
         * Default: present
         *
         * Create or remove Rundeck project.
         */
        state?: "present" | "absent";
        /**
         * Sets the ACL policy content.
         * ACL policy content is a YAML object as described in http://rundeck.org/docs/man5/aclpolicy.html.
         * It can be a YAML string or a pure Ansible inventory YAML object.
         */
        policy?: string;
        /**
         * Default: 14
         *
         * Sets the API version used by module.
         * API version must be at least 14.
         */
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * creates an EC2 snapshot from an existing EBS volume
       */
      ec2_snapshot?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage Layer 2 interface policies on Cisco ACI fabrics.
       */
      aci_interface_policy_l2?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Use this module to manage crontab and environment variables entries. This module allows you to create environment variables and named crontab entries, update, or delete them.
       * When crontab jobs are managed: the module includes one line with the description of the crontab entry C("#Ansible: <name>") corresponding to the "name" passed to the module, which is used by future ansible/module calls to find/check the state. The "name" parameter should be unique, and changing the "name" value will result in a new cron task being created (or a different one being removed).
       * When environment variables are managed: no comment line is added, but, when the module needs to find/check the state, it uses the "name" parameter to find the environment variable definition line.
       * When using symbols such as %, they must be properly escaped.
       */
      cron?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Configure an s3 bucket as a website
       */
      s3_website?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and delete instance of Application Gateway.
       */
      azure_rm_appgateway?: {
        /**
         * Backend http settings of the application gateway resource.
         */
        backend_http_settings_collection?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Authentication certificates of the application gateway resource.
         */
        authentication_certificates?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * SSL policy of the application gateway resource.
         */
        ssl_policy?: {
          [k: string]: unknown;
        };
        /**
         * The name of the resource group.
         */
        resource_group: string;
        ad_user?: string;
        secret?: string;
        /**
         * List of subnets used by the application gateway.
         */
        gateway_ip_configurations?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * SKU of the application gateway resource.
         */
        sku?: {
          [k: string]: unknown;
        };
        /**
         * SSL certificates of the application gateway resource.
         */
        ssl_certificates?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        cloud_environment?: string;
        /**
         * Default: present
         *
         * Assert the state of the Public IP. Use 'present' to create or update a and 'absent' to delete.
         */
        state?: "absent" | "present";
        /**
         * Frontend IP addresses of the application gateway resource.
         */
        frontend_ip_configurations?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        cert_validation_mode?: "validate" | "ignore";
        /**
         * List of HTTP listeners of the application gateway resource.
         */
        http_listeners?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Resource location. If not set, location from the resource group will be used as default.
         */
        location?: string;
        subscription_id?: string;
        profile?: string;
        tags?: {
          [k: string]: unknown;
        };
        client_id?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        adfs_authority_url?: string;
        /**
         * List of request routing rules of the application gateway resource.
         */
        request_routing_rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        tenant?: string;
        /**
         * The name of the application gateway.
         */
        name: string;
        /**
         * List of backend address pool of the application gateway resource.
         */
        backend_address_pools?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_profile?: string;
        /**
         * List of frontend ports of the application gateway resource.
         */
        frontend_ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Security policies allow you to enforce rules and take action, and can be as general or specific as needed.
       */
      panos_match_rule?: {
        /**
         * Default: admin
         *
         * Username credentials to use for auth unless I(api_key) is set.
         */
        username?: string;
        /**
         * Default: security
         *
         * Type of rule. Valid types are I(security) or I(nat).
         */
        rule_type: "security" | "nat";
        /**
         * The destination IP address.
         */
        destination_ip?: string;
        /**
         * API key that can be used instead of I(username)/I(password) credentials.
         */
        api_key?: string;
        /**
         * The IP protocol number from 1 to 255.
         */
        protocol?: string;
        /**
         * URL category
         */
        category?: string;
        /**
         * Default: vsys1
         *
         * ID of the VSYS object.
         */
        vsys_id?: string;
        /**
         * The source zone.
         */
        source_zone?: string;
        /**
         * The source IP address.
         */
        source_ip?: string;
        /**
         * The source user or group.
         */
        source_user?: string;
        /**
         * The application.
         */
        application?: string;
        /**
         * The destination zone.
         */
        destination_zone?: string;
        /**
         * The source port.
         */
        source_port?: string;
        /**
         * The destination port.
         */
        destination_port?: string;
        /**
         * Password credentials to use for auth unless I(api_key) is set.
         */
        password?: string;
        /**
         * IP address (or hostname) of PAN-OS device being configured.
         */
        ip_address: string;
        /**
         * The inbound interface in a NAT rule.
         */
        to_interface?: string;
        [k: string]: unknown;
      };
      /**
       * Manages Layer 2 interfaces
       */
      nxos_switchport?: {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of logging on Arista Eos devices.
       */
      eos_logging?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * If value of C(dest) is I(host) C(name) should be specified, which indicates hostname or IP address.
         */
        name?: string;
        /**
         * Set logging facility.
         */
        facility?: string;
        /**
         * Destination of the logs.
         */
        dest?: "on" | "host" | "console" | "monitor" | "buffered";
        auth_pass?: string;
        /**
         * Set logging severity levels.
         */
        level?:
          | "emergencies"
          | "alerts"
          | "critical"
          | "errors"
          | "warnings"
          | "notifications"
          | "informational"
          | "debugging";
        /**
         * Default: present
         *
         * State of the logging configuration.
         */
        state?: "present" | "absent";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of logging definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "eapi";
        /**
         * Size of buffer. The acceptable value is in range from 10 to 2147483647 bytes.
         */
        size?: number | string;
        [k: string]: unknown;
      };
      /**
       * Deploy applications to JBoss standalone using the filesystem
       */
      jboss?: {
        /**
         * The remote path of the application ear or war to deploy
         */
        src?: string;
        /**
         * Default: present
         *
         * Whether the application should be deployed or undeployed
         */
        state?: "present" | "absent";
        /**
         * Default: /var/lib/jbossas/standalone/deployments
         *
         * The location in the filesystem where the deployment scanner listens
         */
        deploy_path?: string;
        /**
         * The name of the deployment
         */
        deployment: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure SystemConfiguration object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_systemconfiguration?: {
        /**
         * Boolean flag to set docker_mode.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        docker_mode?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Proxyconfiguration settings for systemconfiguration.
         */
        proxy_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Allowed hmac list for ssh to the management interface on the controller and service engines.
         * If this is not specified, all the default hmacs are allowed.
         * Ssh -q mac provides the list of default hmacs supported.
         */
        ssh_hmacs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Portalconfiguration settings for systemconfiguration.
         */
        portal_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        tenant?: string;
        /**
         * Ntpconfiguration settings for systemconfiguration.
         */
        ntp_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Allowed ciphers list for ssh to the management interface on the controller and service engines.
         * If this is not specified, all the default ciphers are allowed.
         * Ssh -q cipher provides the list of default ciphers supported.
         */
        ssh_ciphers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_version?: string;
        username?: string;
        /**
         * Tenantconfiguration settings for systemconfiguration.
         */
        global_tenant_config?: {
          [k: string]: unknown;
        };
        /**
         * Dnsconfiguration settings for systemconfiguration.
         */
        dns_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Linuxconfiguration settings for systemconfiguration.
         */
        linux_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Emailconfiguration settings for systemconfiguration.
         */
        email_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Dns virtualservices hosting fqdn records for applications across avi vantage.
         * If no virtualservices are provided, avi vantage will provide dns services for configured applications.
         * Switching back to avi vantage from dns virtualservices is not allowed.
         * It is a reference to an object of type virtualservice.
         */
        dns_virtualservice_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Specifies the default license tier which would be used by new clouds.
         * Enum options - ENTERPRISE_16, ENTERPRISE_18.
         * Field introduced in 17.2.5.
         * Default value when not specified in API or module is interpreted by Avi Controller as ENTERPRISE_18.
         */
        default_license_tier?: string;
        controller?: string;
        /**
         * Snmpconfiguration settings for systemconfiguration.
         */
        snmp_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Adminauthconfiguration settings for systemconfiguration.
         */
        admin_auth_configuration?: {
          [k: string]: unknown;
        };
        /**
         * Configure ip access control for controller to restrict open access.
         */
        mgmt_ip_access_control?: {
          [k: string]: unknown;
        };
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * This module will let you trigger, acknowledge or resolve a PagerDuty incident by sending events
       */
      pagerduty_alert?: {
        /**
         * The URL of the monitoring client that is triggering this event.
         */
        client_url?: string;
        /**
         * PagerDuty unique subdomain. Obsolete. It is not used with PagerDuty REST v2 API.
         */
        name?: string;
        /**
         * Type of event to be sent.
         */
        state: "triggered" | "acknowledged" | "resolved";
        /**
         * Identifies the incident to which this I(state) should be applied.
         * For C(triggered) I(state) - If there's no open (i.e. unresolved) incident with this key, a new one will be created. If there's already an open incident with a matching key, this event will be appended to that incident's log. The event key provides an easy way to "de-dup" problem reports.
         * For C(acknowledged) or C(resolved) I(state) - This should be the incident_key you received back when the incident was first opened by a trigger event. Acknowledge events referencing resolved or nonexistent incidents will be discarded.
         */
        incident_key?: string;
        /**
         * The name of the monitoring client that is triggering this event.
         */
        client?: string;
        /**
         * The GUID of one of your "Generic API" services.
         * This is the "integration key" listed on a "Integrations" tab of PagerDuty service.
         */
        integration_key?: string;
        /**
         * ID of PagerDuty service when incidents will be triggered, acknowledged or resolved.
         */
        service_id: string;
        /**
         * The GUID of one of your "Generic API" services. Obsolete. Please use I(integration_key).
         */
        service_key?: string;
        /**
         * The pagerduty API key (readonly access), generated on the pagerduty site.
         */
        api_key: string;
        /**
         * Default: Created via Ansible
         *
         * For C(triggered) I(state) - Required. Short description of the problem that led to this trigger. This field (or a truncated version) will be used when generating phone calls, SMS messages and alert emails. It will also appear on the incidents tables in the PagerDuty UI. The maximum length is 1024 characters.
         * For C(acknowledged) or C(resolved) I(state) - Text that will appear in the incident's log associated with this event.
         */
        desc?: string;
        [k: string]: unknown;
      };
      /**
       * Set or erase configuration for the directory service. There is no facility to SSL certificates at this time. Use the FlashArray GUI for this additional configuration work.
       * To modify an existing directory service configuration you must first delete an exisitng configuration and then recreate with new settings.
       */
      purefa_ds?: {
        /**
         * Sets the user name that can be used to bind to and query the directory.
         * For Active Directory, enter the username - often referred to as sAMAccountName or User Logon Name - of the account that is used to perform directory lookups.
         * For OpenLDAP, enter the full DN of the user.
         */
        bind_user?: string;
        /**
         * Specifies where the configured groups are located in the directory tree. This field consists of Organizational Units (OUs) that combine with the base DN attribute and the configured group CNs to complete the full Distinguished Name of the groups. The group base should specify OU= for each OU and multiple OUs should be separated by commas. The order of OUs is important and should get larger in scope from left to right. Each OU should not exceed 64 characters in length.
         */
        group_base?: string;
        /**
         * Whether to enable or disable directory service support.
         */
        enable?: string;
        /**
         * A list of up to 30 URIs of the directory servers. Each URI must include the scheme ldap:// or ldaps:// (for LDAP over SSL), a hostname, and a domain name or IP address. For example, ldap://ad.company.com configures the directory service with the hostname "ad" in the domain "company.com" while specifying the unencrypted LDAP protocol.
         */
        uri?: string;
        /**
         * Sets the common Name (CN) of the directory service group containing administrators with full privileges when managing the FlashArray. The name should be just the Common Name of the group without the CN= specifier. Common Names should not exceed 64 characters in length.
         */
        aa_group?: string;
        /**
         * Sets the common Name (CN) of the configured directory service group containing users with read-only privileges on the FlashArray. This name should be just the Common Name of the group without the CN= specifier. Common Names should not exceed 64 characters in length.
         */
        ro_group?: string;
        /**
         * Default: present
         *
         * Create or delete directory service configuration
         */
        state?: string;
        /**
         * Sets the password of the bind_user user name account.
         */
        bind_password?: string;
        /**
         * Sets the base of the Distinguished Name (DN) of the directory service groups. The base should consist of only Domain Components (DCs). The base_dn will populate with a default value when a URI is entered by parsing domain components from the URI. The base DN should specify DC= for each domain component and multiple DCs should be separated by commas.
         */
        base_dn?: string;
        /**
         * Sets the common Name (CN) of the configured directory service group containing administrators with storage-related privileges on the FlashArray. This name should be just the Common Name of the group without the CN= specifier. Common Names should not exceed 64 characters in length.
         */
        sa_group?: string;
        [k: string]: unknown;
      };
      /**
       * Provides an interface to manage SAN Manager resources. Can create, update, or delete.
       */
      oneview_san_manager?: {
        username?: string;
        image_streamer_hostname?: string;
        hostname?: string;
        config?: string;
        validate_etag?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Indicates the desired state for the Uplink Set resource. - C(present) ensures data properties are compliant with OneView. - C(absent) removes the resource from OneView, if it exists. - C(connection_information_set) updates the connection information for the SAN Manager. This operation is non-idempotent.
         */
        state?: "present" | "absent" | "connection_information_set";
        password?: string;
        /**
         * List with SAN Manager properties.
         */
        data: {
          [k: string]: unknown;
        };
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create an annotation event with a given category, title and description. Optionally start, end or durations can be provided
       */
      circonus_annotation?: {
        /**
         * Annotation Category
         */
        category: string;
        /**
         * Description of annotation
         */
        description: string;
        /**
         * Title of annotation
         */
        title: string;
        /**
         * Default: I(now) + I(duration)
         *
         * Unix timestamp of event end
         */
        stop?: number | string;
        /**
         * Default: I(now)
         *
         * Unix timestamp of event start
         */
        start?: number | string;
        /**
         * Duration in seconds of annotation
         */
        duration?: number | string;
        /**
         * Circonus API key
         */
        api_key: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about snapshot facts based upon provided values such as droplet, volume and snapshot id.
       */
      digital_ocean_snapshot_facts?: {
        [k: string]: unknown;
      };
      /**
       * Create, update and remove clusters.
       */
      cs_cluster?: {
        /**
         * Username for the cluster.
         */
        username?: string;
        /**
         * Ovm3 native OCFS2 clustering enabled for cluster.
         */
        ovm3_cluster?: string;
        /**
         * Ovm3 native pooling enabled for cluster.
         */
        ovm3_pool?: string;
        api_http_method?: "get" | "post";
        /**
         * Name of the pod in which the cluster belongs to.
         */
        pod?: string;
        /**
         * Type of virtual switch used for public traffic in the cluster.
         * Allowed values are, vmwaresvs (for VMware standard vSwitch) and vmwaredvs (for VMware distributed vSwitch)
         */
        public_vswitch_type?: "vmwaresvs" | "vmwaredvs";
        api_url?: string;
        /**
         * Name of the zone in which the cluster belongs to.
         * If not set, default zone is used.
         */
        zone?: string;
        /**
         * Type of the cluster.
         * Required if C(state=present)
         */
        cluster_type?: "CloudManaged" | "ExternalManaged";
        /**
         * Ovm3 vip to use for pool (and cluster).
         */
        ovm3_vip?: string;
        /**
         * IP address of the VSM associated with this cluster.
         */
        vms_ip_address?: string;
        /**
         * Default: present
         *
         * State of the cluster.
         */
        state?: "present" | "absent" | "disabled" | "enabled";
        api_key?: string;
        /**
         * Type of virtual switch used for guest traffic in the cluster.
         * Allowed values are, vmwaresvs (for VMware standard vSwitch) and vmwaredvs (for VMware distributed vSwitch)
         */
        guest_vswitch_type?: "vmwaresvs" | "vmwaredvs";
        /**
         * Name of virtual switch used for guest traffic in the cluster.
         * This would override zone wide traffic label setting.
         */
        guest_vswitch_name?: string;
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Password for the cluster.
         */
        password?: string;
        /**
         * Username for the VSM associated with this cluster.
         */
        vms_username?: string;
        /**
         * name of the cluster.
         */
        name: string;
        /**
         * URL for the cluster
         */
        url?: string;
        /**
         * Name the hypervisor to be used.
         * Required if C(state=present).
         */
        hypervisor?:
          | "KVM"
          | "kvm"
          | "VMware"
          | "vmware"
          | "BareMetal"
          | "baremetal"
          | "XenServer"
          | "xenserver"
          | "LXC"
          | "lxc"
          | "HyperV"
          | "hyperv"
          | "UCS"
          | "ucs"
          | "OVM"
          | "ovm"
          | "Simulator"
          | "simulator";
        api_region?: string;
        /**
         * Name of virtual switch used for public traffic in the cluster.
         * This would override zone wide traffic label setting.
         */
        public_vswitch_name?: string;
        /**
         * Password for the VSM associated with this cluster.
         */
        vms_password?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of VLANs on Juniper JUNOS network devices.
       */
      junos_vlan?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Text description of VLANs.
         */
        description?: string;
        /**
         * List of interfaces to check the VLAN has been configured correctly.
         */
        interfaces?: string;
        /**
         * Name of logical layer 3 interface.
         */
        l3_interface?: string;
        /**
         * Default: present
         *
         * State of the VLAN configuration.
         */
        state?: "present" | "absent";
        /**
         * List of VLANs definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        /**
         * ID of the VLAN. Range 1-4094.
         */
        vlan_id?: number | string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: True
         *
         * Specifies whether or not the configuration is active or deactivated
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        port?: number | string;
        transport?: string;
        /**
         * Name of the VLAN.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manages SNMP community configuration.
       */
      nxos_snmp_community?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Group to which the community belongs.
         */
        group?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Case-sensitive community string.
         */
        community: string;
        /**
         * ACL name to filter snmp requests or keyword 'default'.
         */
        acl?: string;
        /**
         * Access type for community.
         */
        access?: "ro" | "rw";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Creates or cancels SoftLayer instances.
       * When created, optionally waits for it to be 'running'.
       */
      sl_vm?: {
        /**
         * Default: no
         *
         * Flag to determine if the instance should be deployed in dedicated space.
         */
        dedicated?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Count of cpus to be assigned to new virtual instance.
         */
        cpus?: number | string;
        /**
         * Default: no
         *
         * Flag to determine if the instance should be private only.
         */
        private?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Domain name to be provided to a virtual instance.
         */
        domain?: string;
        /**
         * VLAN by its Id to be assigned to the private NIC.
         */
        private_vlan?: string;
        /**
         * Default: yes
         *
         * Flag to determine if the instance should be hourly billed.
         */
        hourly?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of ssh keys by their Id to be assigned to a virtual instance.
         */
        ssh_keys?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Hostname to be provided to a virtual instance.
         */
        hostname?: string;
        /**
         * OS Code to be used for new virtual instance.
         */
        os_code?: string;
        /**
         * Default: 600
         *
         * Time in seconds before wait returns.
         */
        wait_time?: number | string;
        /**
         * Default: present
         *
         * Create, or cancel a virtual instance.
         * Specify C(present) for create, C(absent) to cancel.
         */
        state?: "absent" | "present";
        /**
         * URL of a post provisioning script to be loaded and executed on virtual instance.
         */
        post_uri?: string;
        /**
         * Amount of memory to be assigned to new virtual instance.
         */
        memory?: number | string;
        /**
         * Tag or list of tags to be provided to a virtual instance.
         */
        tags?: string;
        /**
         * Image Template to be used for new virtual instance.
         */
        image_id?: string;
        /**
         * Default: 10
         *
         * NIC Speed to be assigned to new virtual instance.
         */
        nic_speed?: number | string;
        /**
         * VLAN by its Id to be assigned to the public NIC.
         */
        public_vlan?: string;
        /**
         * Default: yes
         *
         * Flag used to wait for active status before returning.
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Datacenter for the virtual instance to be deployed.
         */
        datacenter?:
          | "ams01"
          | "ams03"
          | "che01"
          | "dal01"
          | "dal05"
          | "dal06"
          | "dal09"
          | "dal10"
          | "dal12"
          | "dal13"
          | "fra02"
          | "fra04"
          | "fra05"
          | "hkg02"
          | "hou02"
          | "lon02"
          | "lon04"
          | "lon06"
          | "mel01"
          | "mex01"
          | "mil01"
          | "mon01"
          | "osl01"
          | "par01"
          | "sao01"
          | "sea01"
          | "seo01"
          | "sjc01"
          | "sjc03"
          | "sjc04"
          | "sng01"
          | "syd01"
          | "syd04"
          | "tok02"
          | "tor01"
          | "wdc01"
          | "wdc04"
          | "wdc06"
          | "wdc07";
        /**
         * Default: [25]
         *
         * List of disk sizes to be assigned to new virtual instance.
         */
        disks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Instance Id of the virtual instance to perform action option.
         */
        instance_id?: string;
        /**
         * Default: yes
         *
         * Flag to determine if local disk should be used for the new instance.
         */
        local_disk?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create or destroy Qtrees.
       */
      na_cdot_qtree?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Creates, modifies, and deletes RDS parameter groups. This module has a dependency on python-boto >= 2.5.
       */
      rds_param_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Reads data out of XenAPI, can be used instead of multiple xe commands.
       */
      xenserver_facts?: {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of link aggregation groups on Juniper JUNOS network devices.
       */
      junos_linkagg?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Description of Interface.
         */
        description?: string;
        /**
         * Minimum members that should be up before bringing up the link aggregation group.
         */
        min_links?: number | string;
        /**
         * Default: present
         *
         * State of the link aggregation group.
         */
        state?: "present" | "absent" | "up" | "down";
        /**
         * Number of aggregated ethernet devices that can be configured. Acceptable integer value is between 1 and 128.
         */
        device_count?: number | string;
        /**
         * List of members interfaces of the link aggregation group. The value can be single interface or list of interfaces.
         */
        members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List of link aggregation definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        /**
         * Mode of the link aggregation group. A value of C(on) will enable LACP in C(passive) mode. C(active) configures the link to actively information about the state of the link, or it can be configured in C(passive) mode ie. send link state information only when received them from another link. A value of C(off) will disable LACP.
         */
        mode?: "on" | "off" | "active" | "passive";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: True
         *
         * Specifies whether or not the configuration is active or deactivated
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        port?: number | string;
        transport?: string;
        /**
         * Name of the link aggregation group.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Updates Vertica configuration parameters.
       */
      vertica_configuration?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * List details of EC2 Placement Group(s).
       */
      ec2_placement_group_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of node system attributes on Cisco NXOS devices.  It provides an option to configure host system parameters or remove those parameters from the device active configuration.
       */
      nxos_system?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Default: present
         *
         * State of the configuration values in the device's current active configuration.  When set to I(present), the values should be configured in the device active configuration and when set to I(absent) the values should not be in the device active configuration
         */
        state?: "present" | "absent";
        /**
         * Configures a list of domain name suffixes to search when performing DNS name resolution. This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name or keyword 'default'. See examples.
         */
        domain_search?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_pass?: string;
        /**
         * Specifies the mtu, must be an integer or keyword 'default'.
         */
        system_mtu?: string;
        /**
         * Configures the default domain name suffix to be used when referencing this node by its FQDN.  This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name or keyword 'default'. See examples.
         */
        domain_name?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Enables or disables the DNS lookup feature in Cisco NXOS.  This argument accepts boolean values.  When enabled, the system will try to resolve hostnames using DNS and when disabled, hostnames will not be resolved.
         */
        domain_lookup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        /**
         * Configure the device hostname parameter. This option takes an ASCII string value or keyword 'default'
         */
        hostname?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name or keyword 'default'. See examples.
         */
        name_servers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Creates, deletes, or modifies rds instances.  When creating an instance it can be either a new instance or a read-only replica of an existing instance. This module has a dependency on python-boto >= 2.5. The 'promote' command requires boto >= 2.18.0. Certain features such as tags rely on boto.rds2 (boto >= 2.26.0)
       */
      rds?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of VLANs on Cisco IOS network devices.
       */
      ios_vlan?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * List of VLANs definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the VLAN.
         */
        name?: string;
        /**
         * List of interfaces that should be associated to the VLAN.
         */
        interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of the VLAN configuration.
         */
        state?: "present" | "absent" | "active" | "suspend";
        /**
         * Default: 10
         *
         * Delay the play should wait to check for declarative intent params values.
         */
        delay?: number | string;
        /**
         * Purge VLANs not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vlan interfaces on device it will result in failure.
         */
        associated_interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        /**
         * ID of the VLAN. Range 1-4094.
         */
        vlan_id?: number | string;
        [k: string]: unknown;
      };
      /**
       * Add or remove a host to Icinga2 through the API.
       * See U(https://www.icinga.com/docs/icinga2/latest/doc/12-icinga2-api/)
       */
      icinga2_host?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module works like M(copy), but in reverse. It is used for fetching files from remote machines and storing them locally in a file tree, organized by hostname.
       * This module is also supported for Windows targets.
       */
      fetch?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allows the retrieval, addition, modification and deletion of key/value entries in a consul cluster via the agent. The entire contents of the record, including the indices, flags and session are returned as 'value'.
       * If the key represents a prefix then Note that when a value is removed, the existing value if any is returned as part of the results.
       * See http://www.consul.io/docs/agent/http.html#kv for more details.
       */
      consul_kv?: {
        retrieve?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Used when acquiring a lock with a session. If the C(cas) is C(0), then Consul will only put the key if it does not already exist. If the C(cas) value is non-zero, then the key is only set if the index matches the ModifyIndex of that key.
         */
        cas?: string;
        /**
         * Default: no
         *
         * If the key represents a prefix, each entry with the prefix can be retrieved by setting this to C(yes).
         */
        recurse?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * The action to take with the supplied key and value. If the state is 'present' and `value` is set, the key contents will be set to the value supplied and `changed` will be set to `true` only if the value was different to the current contents. If the state is 'present' and `value` is not set, the existing value associated to the key will be returned. The state 'absent' will remove the key/value pair, again 'changed' will be set to true only if the key actually existed prior to the removal. An attempt can be made to obtain or free the lock associated with a key/value pair with the states 'acquire' or 'release' respectively. a valid session must be supplied to make the attempt changed will be true if the attempt is successful, false otherwise.
         */
        state?: "absent" | "acquire" | "present" | "release";
        /**
         * The value should be associated with the given key, required if C(state) is C(present).
         */
        value?: string;
        /**
         * The token key indentifying an ACL rule set that controls access to the key value pair
         */
        token?: string;
        /**
         * The session that should be used to acquire or release a lock associated with a key/value pair.
         */
        session?: string;
        /**
         * Opaque integer value that can be passed when setting a value.
         */
        flags?: string;
        /**
         * The key at which the value should be stored.
         */
        key: string;
        /**
         * Default: localhost
         *
         * Host of the consul agent.
         */
        host?: string;
        /**
         * Default: http
         *
         * The protocol scheme on which the consul agent is running.
         */
        scheme?: string;
        /**
         * Default: yes
         *
         * Whether to verify the tls certificate of the consul agent.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 8500
         *
         * The port on which the consul agent is running.
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Run commands (remotely) through the PsExec service
       * Run commands as another (domain) user (with elevated privileges)
       */
      win_psexec?: {
        /**
         * Used to run the command at a different priority.
         */
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        /**
         * Default: psexec.exe
         *
         * The location of the PsExec utility (in case it is not located in your PATH).
         */
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Run the program so that it interacts with the desktop on the remote system.
         */
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides user management for ejabberd servers
       */
      ejabberd_user?: {
        /**
         * the name of the user to manage
         */
        username?: string;
        /**
         * Default: present
         *
         * describe the desired state of the user to be managed
         */
        state?: "present" | "absent";
        /**
         * the password to assign to the username
         */
        password?: string;
        /**
         * enables or disables the local syslog facility for this module
         */
        logging?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * the ejabberd host associated with this username
         */
        host?: string;
        [k: string]: unknown;
      };
      /**
       * Configure the rollback feature on remote Nokia devices running the SR OS operating system.  this module provides a stateful implementation for managing the configuration of the rollback feature
       */
      sros_rollback?: {
        username?: string;
        provider?: {
          [k: string]: unknown;
        };
        ssh_keyfile?: string;
        /**
         * The I(local_max_checkpoints) argument configures the maximum number of rollback files that can be saved on the devices local compact flash.  Valid values for this argument are in the range of 1 to 50
         */
        local_max_checkpoints?: number | string;
        /**
         * Default: present
         *
         * The I(state) argument specifies the state of the configuration entries in the devices active configuration.  When the state value is set to C(true) the configuration is present in the devices active configuration.  When the state value is set to C(false) the configuration values are removed from the devices active configuration.
         */
        state?: "present" | "absent";
        /**
         * The I(rollback_location) specifies the location and filename of the rollback checkpoint files.   This argument supports any valid local or remote URL as specified in SR OS
         */
        rollback_location?: string;
        host?: string;
        /**
         * The I(rescue_location) specifies the location of the rescue file.  This argument supports any valid local or remote URL as specified in SR OS
         */
        rescue_location?: string;
        timeout?: number | string;
        /**
         * The I(remote_max_checkpoints) argument configures the maximum number of rollback files that can be transferred and saved to a remote location.  Valid values for this argument are in the range of 1 to 50
         */
        remote_max_checkpoints?: number | string;
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module boots a system through its HP iLO interface. The boot media can be one of: cdrom, floppy, hdd, network or usb.
       * This module requires the hpilo python module.
       */
      hpilo_boot?: {
        /**
         * Whether to force a reboot (even when the system is already booted).
         * As a safeguard, without force, hpilo_boot will refuse to reboot a server that is already running.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: network
         *
         * The boot media to boot the system from
         */
        media?: "cdrom" | "floppy" | "rbsu" | "hdd" | "network" | "normal" | "usb";
        /**
         * The URL of a cdrom, floppy or usb boot media image. protocol://username:password@hostname:port/filename
         * protocol is either 'http' or 'https'
         * username:password is optional
         * port is optional
         */
        image?: string;
        /**
         * Default: TLSv1
         *
         * Change the ssl_version used.
         */
        ssl_version?: "SSLv3" | "SSLv23" | "TLSv1" | "TLSv1_1" | "TLSv1_2";
        /**
         * Default: boot_once
         *
         * The state of the boot media.
         * no_boot: Do not boot from the device
         * boot_once: Boot from the device once and then notthereafter
         * boot_always: Boot from the device each time the serveris rebooted
         * connect: Connect the virtual media device and set to boot_always
         * disconnect: Disconnects the virtual media device and set to no_boot
         * poweroff: Power off the server
         */
        state?: "boot_always" | "boot_once" | "connect" | "disconnect" | "no_boot" | "poweroff";
        /**
         * The HP iLO hostname/address that is linked to the physical system.
         */
        host: string;
        /**
         * Default: Administrator
         *
         * The login name to authenticate to the HP iLO interface.
         */
        login?: string;
        /**
         * Default: admin
         *
         * The password to authenticate to the HP iLO interface.
         */
        password?: string;
        [k: string]: unknown;
      };
      /**
       * Gathers various details related to Lambda functions, including aliases, versions and event source mappings. Use module M(lambda) to manage the lambda function itself, M(lambda_alias) to manage function aliases and M(lambda_event) to manage lambda event source mappings.
       */
      lambda_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Execute vrouter-loopback-interface-add, vrouter-loopback-interface-remove commands.
       * Each fabric, cluster, standalone switch, or virtual network (VNET) can provide its tenants with a virtual router (vRouter) service that forwards traffic between networks and implements Layer 3 protocols.
       */
      pn_vrouterlbif?: {
        /**
         * Specify the name of the vRouter.
         */
        pn_vrouter_name: string;
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Specify the IP address.
         */
        pn_interface_ip?: string;
        /**
         * State the action to perform. Use 'present' to add vrouter loopback interface and 'absent' to remove vrouter loopback interface.
         */
        state: "present" | "absent";
        /**
         * Specify the interface index from 1 to 255.
         */
        pn_index?: number | string;
        /**
         * Target switch(es) to run the cli on.
         */
        pn_cliswitch?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure GslbGeoDbProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_gslbgeodbprofile?: {
        username?: string;
        controller?: string;
        /**
         * Uuid of the geodb profile.
         * Field introduced in 17.1.1.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Field introduced in 17.1.1.
         */
        description?: string;
        /**
         * List of geodb entries.
         * An entry can either be a geodb file or an ip address group with geo properties.
         * Field introduced in 17.1.1.
         */
        entries?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.1.1.
         */
        tenant_ref?: string;
        /**
         * This field indicates that this object is replicated across gslb federation.
         * Field introduced in 17.1.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        is_federated?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * A user-friendly name for the geodb profile.
         * Field introduced in 17.1.1.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Handles the EVPN control plane for VXLAN.
       */
      nxos_evpn_global?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * EVPN control plane.
         */
        nv_overlay_evpn:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Manages I(apt) packages (such as for Debian/Ubuntu).
       */
      apt?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages I(apk) packages for Alpine Linux.
       */
      apk?: {
        /**
         * Default: no
         *
         * During upgrade, reset versioned world dependencies and change logic to prefer replacing or downgrading packages (instead of holding them) if the currently installed package is no longer available from any repository.
         */
        available?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Upgrade all installed packages to their latest version.
         */
        upgrade?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A package name, like C(foo), or multiple packages, like C(foo, bar).
         */
        name?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A package repository or multiple repositories. Unlike with the underlying apk command, this list will override the system repositories rather than supplement them.
         */
        repository?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Indicates the desired package(s) state.
         * C(present) ensures the package(s) is/are present.
         * C(absent) ensures the package(s) is/are absent.
         * C(latest) ensures the package(s) is/are present and the latest version(s).
         */
        state?: "present" | "installed" | "absent" | "removed" | "latest";
        /**
         * Default: no
         *
         * Update repository indexes. Can be run with other steps or on it's own.
         */
        update_cache?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Creates, removes, and configures IIS web applications.
       */
      win_iis_webapplication?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Composer is a tool for dependency management in PHP. It allows you to declare the dependent libraries your project needs and it will install them in your project for you.
       *
       */
      composer?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows Ansible to interface with the PubNub BLOCKS infrastructure by providing the following operations: create / remove, start / stop and rename for blocks and create / modify / remove for event handlers
       */
      pubnub_blocks?: {
        /**
         * Name of PubNub account for from which C(application) will be used to manage blocks.
         * User's account will be used if value not set or empty.
         */
        account?: string;
        /**
         * Default: New block
         *
         * Short block description which will be later visible on admin.pubnub.com. Used only if block doesn't exists and won't change description for existing block.
         */
        description?: string;
        /**
         * Name of target PubNub application for which blocks configuration on specific C(keyset) will be done.
         */
        application: string;
        /**
         * Default: True
         *
         * This key allow to try skip certificates check when performing REST API calls. Sometimes host may have issues with certificates on it and this will cause problems to call PubNub REST API.
         * If check should be ignored C(False) should be passed to this parameter.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * In case if single play use blocks management module few times it is preferred to enabled 'caching' by making previous module to share gathered artifacts and pass them to this parameter.
         *
         */
        cache?: {
          [k: string]: unknown;
        };
        /**
         * Name of application's keys set which is bound to managed blocks.
         */
        keyset: string;
        /**
         * Default: started
         *
         * Intended block state after event handlers creation / update process will be completed.
         */
        state?: "started" | "stopped" | "present" | "absent";
        /**
         * Password which match to account to which specified C(email) belong.
         * Not required if C(cache) contains result of previous module call (in same play).
         */
        password?: string;
        /**
         * List of fields which should be changed by block itself (doesn't affect any event handlers).
         * Possible options for change is: C(name).
         */
        changes?: {
          [k: string]: unknown;
        };
        /**
         * Email from account for which new session should be started.
         * Not required if C(cache) contains result of previous module call (in same play).
         */
        email?: string;
        /**
         * List of event handlers which should be updated for specified block C(name).
         * Each entry for new event handler should contain: C(name), C(src), C(channels), C(event). C(name) used as event handler name which can be used later to make changes to it.
         * C(src) is full path to file with event handler code.
         * C(channels) is name of channel from which event handler is waiting for events.
         * C(event) is type of event which is able to trigger event handler: I(js-before-publish), I(js-after-publish), I(js-after-presence).
         * Each entry for existing handlers should contain C(name) (so target handler can be identified). Rest parameters (C(src), C(channels) and C(event)) can be added if changes required for them.
         * It is possible to rename event handler by adding C(changes) key to event handler payload and pass dictionary, which will contain single key C(name), where new name should be passed.
         * To remove particular event handler it is possible to set C(state) for it to C(absent) and it will be removed.
         */
        event_handlers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of managed block which will be later visible on admin.pubnub.com.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Collect facts information from a Pure Storage Flasharray running the Purity//FA operating system. By default, the module will collect basic fact information including hosts, host groups, protection groups and volume counts. Additional fact information can be collected based on the configured set of arguements.
       */
      purefa_facts?: {
        /**
         * Default: minimum
         *
         * When supplied, this argument will define the facts to be collected. Possible values for this include all, minimum, config, performance, capacity, network, subnet, interfaces, hgroups, pgroups, hosts, volumes and snapshots.
         */
        gather_subset?: string;
        [k: string]: unknown;
      };
      /**
       * Sends an arbitrary command to an BIG-IP node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module is B(not) idempotent, nor will it ever be. It is intended as a stop-gap measure to satisfy automation requirements until such a time as a real module has been developed to configure in the way you need.
       * If you are using this module, you should probably also be filing an issue to have a B(real) module created for your needs.
       */
      bigip_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditionals.
         */
        retries?: string;
        /**
         * The commands to send to the remote BIG-IP device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries as expired.
         * Only C(tmsh) commands are supported. If you are piping or adding additional logic that is outside of C(tmsh) (such as grep'ing, awk'ing or other shell related things that are not C(tmsh), this behavior is not supported.
         */
        commands?: string;
        /**
         * Change into this directory before running the command.
         */
        chdir?: string;
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditional, the interval indicates how to long to wait before trying the command again.
         */
        interval?: string;
        /**
         * Default: True
         *
         * Whether the module should raise warnings related to command idempotency or not.
         * Note that the F5 Ansible developers specifically leave this on to make you aware that your usage of this module may be better served by official F5 Ansible modules. This module should always be used as a last resort.
         */
        warn?: string;
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy. Valid values are C(all) or C(any). If the value is set to C(all) then all conditionals in the I(wait_for) must be satisfied. If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: string;
        /**
         * Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward. If the conditional is not true by the configured retries, the task fails. See examples.
         */
        wait_for?: string;
        /**
         * Default: rest
         *
         * Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or rest.
         */
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure StringGroup object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_stringgroup?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Uuid of the string group.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * User defined description for the object.
         */
        description?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Configure key value in the string group.
         */
        kv?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_context?: {
          [k: string]: unknown;
        };
        tenant?: string;
        password?: string;
        /**
         * Type of stringgroup.
         * Enum options - SG_TYPE_STRING, SG_TYPE_KEYVAL.
         * Default value when not specified in API or module is interpreted by Avi Controller as SG_TYPE_STRING.
         */
        type: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Name of the string group.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Creates, deletes, or updates CloudTrail configuration. Ensures logging is also enabled.
       */
      cloudtrail?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Uses .NET libraries to convert text to speech and optionally play .wav sounds.  Audio Service needs to be running and some kind of speakers or headphones need to be attached to the windows target(s) for the speech to be audible.
       */
      win_say?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, update, or delete OpenStack host aggregates. If a aggregate with the supplied name already exists, it will be updated with the new name, new availability zone, new metadata and new list of hosts.
       */
      os_nova_host_aggregate?: {
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Availability zone to create aggregate into.
         */
        availability_zone?: string;
        /**
         * List of hosts to set for an aggregate.
         */
        hosts?: string;
        /**
         * Name of the aggregate.
         */
        name?: string;
        /**
         * Metadata dict.
         */
        metadata?: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an aruba node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(aruba_config) to configure Aruba devices.
       */
      aruba_command?: {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about available OpenStack instance flavors. By default, facts about ALL flavors are retrieved. Filters can be applied to get facts for only matching flavors. For example, you can filter on the amount of RAM available to the flavor, or the number of virtual CPUs available to the flavor, or both. When specifying multiple filters, *ALL* filters must match on a flavor before that flavor is returned as a fact.
       */
      os_flavor_facts?: {
        /**
         * A flavor name. Cannot be used with I(ram) or I(vcpus) or I(ephemeral).
         */
        name?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Default: no
         *
         * A string used for filtering flavors based on the amount of RAM (in MB) desired. This string accepts the following special values: 'MIN' (return flavors with the minimum amount of RAM), and 'MAX' (return flavors with the maximum amount of RAM).
         * A specific amount of RAM may also be specified. Any flavors with this exact amount of RAM will be returned.
         * A range of acceptable RAM may be given using a special syntax. Simply prefix the amount of RAM with one of these acceptable range values: '<', '>', '<=', '>='. These values represent less than, greater than, less than or equal to, and greater than or equal to, respectively.
         */
        ram?: string;
        /**
         * Default: no
         *
         * A string used for filtering flavors based on the amount of ephemeral storage. Format is the same as the I(ram) parameter
         */
        ephemeral?: string;
        /**
         * Default: no
         *
         * A string used for filtering flavors based on the number of virtual CPUs desired. Format is the same as the I(ram) parameter.
         */
        vcpus?: string;
        /**
         * Limits the number of flavors returned. All matching flavors are returned by default.
         */
        limit?: string;
        [k: string]: unknown;
      };
      /**
       * Create or Remove Ironic nodes from OpenStack.
       */
      os_ironic?: {
        /**
         * globally unique identifier (UUID) to be given to the resource. Will be auto-generated if not specified, and name is specified.
         * Definition of a UUID will always take precedence to a name value.
         */
        uuid?: string;
        /**
         * Information for this server's driver. Will vary based on which driver is in use. Any sub-field which is populated will be validated during creation.
         */
        driver_info?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * A list of network interface cards, eg, " - mac: aa:bb:cc:aa:bb:cc"
         */
        nics?: string;
        /**
         * The name of the Ironic Driver to use with this node.
         */
        driver?: string;
        /**
         * If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.
         */
        ironic_url?: string;
        /**
         * Default: present
         *
         * Indicates desired state of the resource
         */
        state?: string;
        /**
         * Associate the node with a pre-defined chassis.
         */
        chassis_uuid?: string;
        /**
         * Default: no
         *
         * Allows the code that would assert changes to nodes to skip the update if the change is a single line consisting of the password field.  As of Kilo, by default, passwords are always masked to API requests, which means the logic as a result always attempts to re-assert the password field.
         */
        skip_update_of_driver_password?: string;
        /**
         * Definition of the physical characteristics of this server, used for scheduling purposes
         */
        properties?: string;
        /**
         * unique name identifier to be given to the resource.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Return basic facts pertaining to a vSphere virtual machine guest.
       * Cluster name as fact is added in version 2.7.
       */
      vmware_vm_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Adds and/or removes instances of host record objects from Infoblox NIOS servers.  This module manages NIOS C(record:host) objects using the Infoblox WAPI interface over REST.
       * Updates instances of host record object from Infoblox NIOS servers.
       */
      nios_host_record?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure Pool object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_pool?: {
        /**
         * The load balancing algorithm will pick a server within the pool's list of available servers.
         * Enum options - LB_ALGORITHM_LEAST_CONNECTIONS, LB_ALGORITHM_ROUND_ROBIN, LB_ALGORITHM_FASTEST_RESPONSE, LB_ALGORITHM_CONSISTENT_HASH,
         * LB_ALGORITHM_LEAST_LOAD, LB_ALGORITHM_FEWEST_SERVERS, LB_ALGORITHM_RANDOM, LB_ALGORITHM_FEWEST_TASKS, LB_ALGORITHM_NEAREST_SERVER,
         * LB_ALGORITHM_CORE_AFFINITY.
         * Default value when not specified in API or module is interpreted by Avi Controller as LB_ALGORITHM_LEAST_CONNECTIONS.
         */
        lb_algorithm?: string;
        /**
         * Do not translate the client's destination port when sending the connection to the server.
         * The pool or servers specified service port will still be used for health monitoring.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        use_service_port?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Header name for custom header persistence.
         */
        prst_hdr_name?: string;
        /**
         * Server autoscale.
         * Not used anymore.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        server_auto_scale?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Degree of non-affinity for core afffinity based server selection.
         * Allowed values are 1-65535.
         * Field introduced in 17.1.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as 2.
         */
        lb_algorithm_core_nonaffinity?: number | string;
        /**
         * Enable or disable the pool.
         * Disabling will terminate all open connections and pause health monitors.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * If sni server name is specified, rewrite incoming host header to the sni server name.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        rewrite_host_header_to_sni?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Inline estimation of capacity of servers.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        capacity_estimation?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Rate limit connections to each server.
         */
        max_conn_rate_per_server?: {
          [k: string]: unknown;
        };
        /**
         * The pool directs load balanced traffic to this list of destination servers.
         * The servers can be configured by ip address, name, network or via ip address group.
         */
        servers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Periodicity of feedback for fewest tasks server selection algorithm.
         * Allowed values are 1-300.
         * Default value when not specified in API or module is interpreted by Avi Controller as 10.
         * Units(SEC).
         */
        fewest_tasks_feedback_delay?: number | string;
        /**
         * Rewrite incoming host header to server name of the server to which the request is proxied.
         * Enabling this feature rewrites host header for requests to all servers in the pool.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        rewrite_host_header_to_server_name?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Manually select the networks and subnets used to provide reachability to the pool's servers.
         * Specify the subnet using the following syntax  10-1-1-0/24.
         * Use static routes in vrf configuration when pool servers are not directly connected butroutable from the service engine.
         */
        placement_networks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Inherited config from virtualservice.
         */
        east_west?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The maximum time-to-first-byte of a server.
         * Allowed values are 1-5000.
         * Special values are 0 - 'automatic'.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         * Units(MILLISECONDS).
         */
        capacity_estimation_ttfb_thresh?: number | string;
        /**
         * A/b pool configuration.
         */
        ab_pool?: {
          [k: string]: unknown;
        };
        /**
         * Enable an action - close connection, http redirect or local http response - when a pool failure happens.
         * By default, a connection will be closed, in case the pool experiences a failure.
         */
        fail_action?: {
          [k: string]: unknown;
        };
        /**
         * Allow server lookup by name.
         * Field introduced in 17.1.11,17.2.4.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        lookup_server_by_name?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * (internal-use) networks designated as containing servers for this pool.
         * The servers may be further narrowed down by a filter.
         * This field is used internally by avi, not editable by the user.
         */
        networks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Criteria used as a key for determining the hash between the client and  server.
         * Enum options - LB_ALGORITHM_CONSISTENT_HASH_SOURCE_IP_ADDRESS, LB_ALGORITHM_CONSISTENT_HASH_SOURCE_IP_ADDRESS_AND_PORT,
         * LB_ALGORITHM_CONSISTENT_HASH_URI, LB_ALGORITHM_CONSISTENT_HASH_CUSTOM_HEADER, LB_ALGORITHM_CONSISTENT_HASH_CUSTOM_STRING.
         * Default value when not specified in API or module is interpreted by Avi Controller as LB_ALGORITHM_CONSISTENT_HASH_SOURCE_IP_ADDRESS.
         */
        lb_algorithm_hash?: string;
        /**
         * Uuid of the pool.
         */
        uuid?: string;
        /**
         * Fully qualified dns hostname which will be used in the tls sni extension in server connections if sni is enabled.
         * If no value is specified, avi will use the incoming host header instead.
         */
        server_name?: string;
        /**
         * Verify server health by applying one or more health monitors.
         * Active monitors generate synthetic traffic from each service engine and mark a server up or down based on the response.
         * The passive monitor listens only to client to server communication.
         * It raises or lowers the ratio of traffic destined to a server based on successful responses.
         * It is a reference to an object of type healthmonitor.
         */
        health_monitor_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * It is a reference to an object of type cloud.
         */
        cloud_ref?: string;
        /**
         * Enable common name check for server certificate.
         * If enabled and no explicit domain name is specified, avi will use the incoming host header to do the match.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        host_check_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Reference to server autoscale policy.
         * It is a reference to an object of type serverautoscalepolicy.
         */
        autoscale_policy_ref?: string;
        /**
         * When enabled, avi re-encrypts traffic to the backend servers.
         * The specific ssl profile defines which ciphers and ssl versions will be supported.
         * It is a reference to an object of type sslprofile.
         */
        ssl_profile_ref?: string;
        /**
         * Use list of servers from ip address group.
         * It is a reference to an object of type ipaddrgroup.
         */
        ipaddrgroup_ref?: string;
        /**
         * Synchronize cisco apic epg members with pool servers.
         */
        apic_epg_name?: string;
        /**
         * Used to gracefully disable a server.
         * Virtual service waits for the specified time before terminating the existing connections  to the servers that are disabled.
         * Allowed values are 1-7200.
         * Special values are 0 - 'immediate', -1 - 'infinite'.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.
         * Units(MIN).
         */
        graceful_disable_timeout?: number | string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * A list of nsx service groups where the servers for the pool are created.
         * Field introduced in 17.1.1.
         */
        nsx_securitygroup?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Name of container cloud application that constitutes a pool in a a-b pool configuration, if different from vs app.
         */
        a_pool?: string;
        /**
         * Avi will validate the ssl certificate present by a server against the selected pki profile.
         * It is a reference to an object of type pkiprofile.
         */
        pki_profile_ref?: string;
        api_version?: string;
        /**
         * Virtual routing context that the pool is bound to.
         * This is used to provide the isolation of the set of networks the pool is attached to.
         * The pool inherits the virtual routing conext of the virtual service, and this field is used only internally, and is set by pb-transform.
         * It is a reference to an object of type vrfcontext.
         */
        vrf_ref?: string;
        username?: string;
        /**
         * Persistence will ensure the same user sticks to the same server for a desired duration of time.
         * It is a reference to an object of type applicationpersistenceprofile.
         */
        application_persistence_profile_ref?: string;
        /**
         * The passive monitor will monitor client to server connections and requests and adjust traffic load to servers based on successful responses.
         * This may alter the expected behavior of the lb method, such as round robin.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        inline_health_monitor?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Traffic sent to servers will use this destination server port unless overridden by the server's specific port attribute.
         * The ssl checkbox enables avi to server encryption.
         * Allowed values are 1-65535.
         * Default value when not specified in API or module is interpreted by Avi Controller as 80.
         */
        default_server_port?: number | string;
        /**
         * A description of the pool.
         */
        description?: string;
        /**
         * Minimum number of requests to be queued when pool is full.
         * Default value when not specified in API or module is interpreted by Avi Controller as 128.
         */
        request_queue_depth?: number | string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Server reselect configuration for http requests.
         */
        server_reselect?: {
          [k: string]: unknown;
        };
        /**
         * Comma separated list of domain names which will be used to verify the common names or subject alternative names presented by server certificates.
         * It is performed only when common name check host_check_enabled is enabled.
         */
        domain_name?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Service engines will present a client ssl certificate to the server.
         * It is a reference to an object of type sslkeyandcertificate.
         */
        ssl_key_and_certificate_ref?: string;
        tenant?: string;
        /**
         * Enable tls sni for server connections.
         * If disabled, avi will not send the sni extension as part of the handshake.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        sni_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Priority of this pool in a a-b pool pair.
         * Internally used.
         */
        ab_priority?: number | string;
        /**
         * Enable request queue when pool is full.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        request_queue_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the pool.
         */
        name: string;
        /**
         * The maximum number of concurrent connections allowed to each server within the pool.
         * Note  applied value will be no less than the number of service engines that the pool is placed on.
         * If set to 0, no limit is applied.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         */
        max_concurrent_connections_per_server?: number | string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * If configured then avi will trigger orchestration of pool server creation and deletion.
         * It is only supported for container clouds like mesos, opensift, kubernates, docker etc.
         * It is a reference to an object of type autoscalelaunchconfig.
         */
        autoscale_launch_config_ref?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        controller?: string;
        /**
         * Number of server_count.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         */
        server_count?: number | string;
        /**
         * Network ids for the launch configuration.
         */
        autoscale_networks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Http header name to be used for the hash key.
         */
        lb_algorithm_consistent_hash_hdr?: string;
        /**
         * Duration for which new connections will be gradually ramped up to a server recently brought online.
         * Useful for lb algorithms that are least connection based.
         * Allowed values are 1-300.
         * Special values are 0 - 'immediate'.
         * Default value when not specified in API or module is interpreted by Avi Controller as 10.
         * Units(MIN).
         */
        connection_ramp_duration?: number | string;
        /**
         * Checksum of cloud configuration for pool.
         * Internally set by cloud connector.
         */
        cloud_config_cksum?: string;
        /**
         * Names of external auto-scale groups for pool servers.
         * Currently available only for aws and azure.
         * Field introduced in 17.1.2.
         */
        external_autoscale_groups?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        tenant_uuid?: string;
        /**
         * Creator name.
         */
        created_by?: string;
        /**
         * Indicates if the pool is a site-persistence pool.
         * Field introduced in 17.2.1.
         */
        gslb_sp_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages the assignment of regkey licenses on a BIG-IQ. Assignment means that the license is assigned to a BIG-IP, or, it needs to be assigned to a BIG-IP. Additionally, this module supported revoking the assignments from BIG-IP devices.
       */
      bigiq_regkey_license_assignment?: {
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP TargetHttpsProxy
       */
      gcp_compute_target_https_proxy_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about VMware tag categories.
       * Tag feature is introduced in vSphere 6 version, so this module is not supported in earlier versions of vSphere.
       * All variables and VMware object names are case sensitive.
       */
      vmware_category_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 instances in AWS
       */
      ec2_remote_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or Remove key pair from OpenStack
       */
      os_keypair?: {
        /**
         * The public key that would be uploaded to nova and injected into VMs upon creation.
         */
        public_key?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Path to local file containing ssh public key. Mutually exclusive with public_key.
         */
        public_key_file?: string;
        /**
         * Name that has to be given to the key pair
         */
        name?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 VPC route tables in AWS
       */
      ec2_vpc_route_table_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Arista EOS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with EOS configuration sections in a deterministic way.  This module works with either CLI or eAPI transports.
       */
      eos_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module fetches data from the metadata API in CloudStack. The module must be called from within the instance itself.
       */
      cs_facts?: {
        /**
         * Filter for a specific fact.
         */
        filter?:
          | "cloudstack_service_offering"
          | "cloudstack_availability_zone"
          | "cloudstack_public_hostname"
          | "cloudstack_public_ipv4"
          | "cloudstack_local_hostname"
          | "cloudstack_local_ipv4"
          | "cloudstack_instance_id"
          | "cloudstack_user_data";
        /**
         * Host or IP of the meta data API service.
         * If not set, determination by parsing the dhcp lease file.
         */
        meta_data_host?: string;
        [k: string]: unknown;
      };
      /**
       * Manage OpenStack Identity Groups. Groups can be created, deleted or updated. Only the I(description) value can be updated.
       */
      os_group?: {
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Group description
         */
        description?: string;
        /**
         * Group name
         */
        name?: string;
        /**
         * Domain id to create the group in if the cloud supports domains.
         */
        domain_id?: string;
        [k: string]: unknown;
      };
      /**
       * Manages NTP authentication configuration on HUAWEI CloudEngine switches.
       */
      ce_ntp_auth?: {
        /**
         * Default: encrypt
         *
         * Whether the given password is in cleartext or has been encrypted. If in cleartext, the device will encrypt it before storing it.
         */
        auth_type?: "text" | "encrypt";
        username?: string;
        ssh_keyfile?: string;
        /**
         * Plain text with length of 1 to 255, encrypted text with length of 20 to 392.
         */
        auth_pwd?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Authentication key identifier (numeric).
         */
        key_id: string;
        host?: string;
        /**
         * Specify authentication algorithm.
         */
        auth_mode?: "hmac-sha256" | "md5";
        /**
         * Default: disable
         *
         * Whether the given key is required to be supplied by a time source for the device to synchronize to the time source.
         */
        trusted_key?: "enable" | "disable";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Configure ntp authentication enable or unconfigure ntp authentication enable.
         */
        authentication?: "enable" | "disable";
        [k: string]: unknown;
      };
      /**
       * Get DLL or EXE file build version.
       */
      win_file_version?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Builds Redfish URIs locally and sends them to remote OOB controllers to perform an action.
       * Manages OOB controller ex. reboot, log management.
       * Manages OOB controller users ex. add, remove, update.
       * Manages system power ex. on, off, graceful and forced reboot.
       */
      redfish_command?: {
        /**
         * name of user to add/delete/modify
         */
        username?: string;
        /**
         * Category to execute on OOB controller
         */
        category: string;
        /**
         * password of user to add/delete/modify
         */
        userpswd?: string;
        /**
         * Base URI of OOB controller
         */
        baseuri: string;
        /**
         * ID of user to add/delete/modify
         */
        userid?: string;
        /**
         * List of commands to execute on OOB controller
         */
        command:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * role of user to add/delete/modify
         */
        userrole?: string;
        /**
         * Password for authentication with OOB controller
         */
        password: string;
        /**
         * bootdevice when setting boot configuration
         */
        bootdevice?: string;
        /**
         * User for authentication with OOB controller
         */
        user: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to a Dell OS6 node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(dellos6_config) to configure Dell OS6 devices.
       */
      dellos6_command?: {
        username?: string;
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should be tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        /**
         * List of commands to send to the remote dellos6 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: "any" | "all";
        [k: string]: unknown;
      };
      /**
       * Creates, removes and lists tags for any EC2 resource.  The resource is referenced by its resource id (e.g. an instance being i-XXXXXXX). It is designed to be used with complex args (tags), see the examples.
       */
      ec2_tag?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates, modifies, and deletes RDS database subnet groups. This module has a dependency on python-boto >= 2.5.
       */
      rds_subnet_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote Lenovo device running on ENOS.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      enos_facts?: {
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        provider?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * This will configure both exec and motd banners on remote devices running Cisco NXOS. It allows playbooks to add or remote banner text from the active running configuration.
       */
      nxos_banner?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * The banner text that should be present in the remote device running configuration. This argument accepts a multiline string, with no empty lines. Requires I(state=present).
         */
        text?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Specifies whether or not the configuration is present in the current devices active running configuration.
         */
        state?: "present" | "absent";
        /**
         * Specifies which banner that should be configured on the remote device.
         */
        banner: "exec" | "motd";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Fetch metadata about GitHub Releases
       */
      github_release?: {
        /**
         * Description of the release when creating a release
         */
        body?: string;
        /**
         * Name of release when creating a release
         */
        name?: string;
        /**
         * Repository name
         */
        repo: string;
        /**
         * GitHub Personal Access Token for authenticating
         */
        token?: string;
        /**
         * Tag name when creating a release. Required when using action is set to C(create_release).
         */
        tag?: string;
        /**
         * Default: no
         *
         * Sets if the release is a draft or not. (boolean)
         */
        draft?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The GitHub account that owns the repository
         */
        user: string;
        /**
         * Action to perform
         */
        action: "latest_release" | "create_release";
        /**
         * Default: no
         *
         * Sets if the release is a prerelease or not. (boolean)
         */
        prerelease?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The GitHub account password for the user
         */
        password?: string;
        /**
         * Target of release when creating a release
         */
        target?: string;
        [k: string]: unknown;
      };
      /**
       * Configure an E-Series system to allow authentication via an LDAP server
       */
      netapp_e_ldap?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create and delete snapshots images on volume groups for NetApp E-series storage arrays.
       */
      netapp_e_volume_copy?: {
        status: "present" | "absent";
        /**
         * Default: True
         *
         * Defines if a copy pair will be created if it does not exist.
         * If set to True destination_volume_id and source_volume_id are required.
         */
        create_copy_pair_if_does_not_exist?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Searches for all valid potential target and source volumes that could be used in a copy_pair
         * Mutually exclusive with volume_copy_pair_id, destination_volume_id and source_volume_id
         */
        search_volume_id?: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API, for example C(https://prod-1.wahoo.acme.com/devmgr/v2).
         */
        api_url: string;
        /**
         * The id of a given volume copy pair
         * Mutually exclusive with destination_volume_id, source_volume_id, and search_volume_id
         * Can use to delete or check presence of volume pairs
         * Must specify this or (destination_volume_id and source_volume_id)
         */
        volume_copy_pair_id?: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password?: string;
        /**
         * The id of the volume copy source.
         * If used, must be paired with destination_volume_id
         * Mutually exclusive with volume_copy_pair_id, and search_volume_id
         */
        source_volume_id?: string;
        /**
         * The id of the volume copy destination.
         * If used, must be paired with source_volume_id
         * Mutually exclusive with volume_copy_pair_id, and search_volume_id
         */
        destination_volume_id?: string;
        copy_priority?: number | string;
        onlineCopy?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username?: string;
        /**
         * starts a re-copy or stops a copy in progress
         * Note: If you stop the initial file copy before it it done the copy pair will be destroyed
         * Requires volume_copy_pair_id
         */
        start_stop_copy?: "start" | "stop";
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?: string;
        targetWriteProtected?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssid: string;
        [k: string]: unknown;
      };
      /**
       * Create backup
       */
      na_elementsw_backup?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Management of LXD containers
       */
      lxd_container?: {
        description?: string;
        /**
         * The source for the container (e.g. { "type": "image", "mode": "pull", "server": "https://images.linuxcontainers.org", "protocol": "lxd", "alias": "ubuntu/xenial/amd64" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
         */
        source?: {
          [k: string]: unknown;
        };
        /**
         * Default: unix:/var/lib/lxd/unix.socket
         *
         * The unix domain socket path or the https URL for the LXD server.
         */
        url?: string;
        /**
         * The config for the container (e.g. {"limits.cpu": "2"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
         * If the container already exists and its "config" value in metadata obtained from GET /1.0/containers/<name> U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#10containersname) are different, they this module tries to apply the configurations.
         * The key starts with 'volatile.' are ignored for this comparison.
         * Not all config values are supported to apply the existing container. Maybe you need to delete and recreate a container.
         */
        config?: {
          [k: string]: unknown;
        };
        /**
         * Default: "{}/.config/lxc/client.crt" .format(os.environ["HOME"])
         *
         * The client certificate file path.
         */
        cert_file?: string;
        /**
         * Whether or not the container is ephemeral (e.g. true or false). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
         */
        ephemeral?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The architecture for the container (e.g. "x86_64" or "i686"). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
         */
        architecture?: string;
        /**
         * The devices for the container (e.g. { "rootfs": { "path": "/dev/kvm", "type": "unix-char" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
         */
        devices?: {
          [k: string]: unknown;
        };
        /**
         * If this is true, the C(lxd_container) waits until IPv4 addresses are set to the all network interfaces in the container after starting or restarting.
         */
        wait_for_ipv4_addresses?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: started
         *
         * Define the state of a container.
         */
        state?: "started" | "stopped" | "restarted" | "absent" | "frozen";
        profiles?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 30
         *
         * A timeout for changing the state of the container.
         * This is also used as a timeout for waiting until IPv4 addresses are set to the all network interfaces in the container after starting or restarting.
         */
        timeout?: number | string;
        /**
         * Default: "{}/.config/lxc/client.key" .format(os.environ["HOME"])
         *
         * The client certificate key file path.
         */
        key_file?: string;
        /**
         * The client trusted password.
         * You need to set this password on the LXD server before running this module using the following command. lxc config set core.trust_password <some random password> See U(https://www.stgraber.org/2016/04/18/lxd-api-direct-interaction/)
         * If trust_password is set, this module send a request for authentication before sending any requests.
         */
        trust_password?: string;
        /**
         * If this is true, the C(lxd_container) forces to stop the container when it stops or restarts the container.
         */
        force_stop?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of a container.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Get interface link status on HUAWEI CloudEngine switches.
       */
      ce_link_status?: {
        username?: string;
        ssh_keyfile?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * For the interface parameter, you can enter C(all) to display information about all interface, an interface type such as C(40GE) to display information about interfaces of the specified type, or full name of an interface such as C(40GE1/0/22) or C(vlanif10) to display information about the specific interface.
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Creates or terminates Google Compute Engine (GCE) instances.  See U(https://cloud.google.com/compute) for an overview. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.
       */
      gce?: {
        [k: string]: unknown;
      };
      /**
       * Manages Gentoo packages
       */
      portage?: {
        [k: string]: unknown;
      };
      /**
       * The standard package manager for SmartOS, but also usable on NetBSD or any OS that uses C(pkgsrc).  (Home: U(http://pkgin.net/))
       */
      pkgin?: {
        [k: string]: unknown;
      };
      /**
       * Create or remove disk groups and disk pools for NetApp E-series storage arrays.
       */
      netapp_e_storagepool?: {
        /**
         * Default: gb
         *
         * The unit used to interpret size parameters
         */
        criteria_size_unit?: string;
        /**
         * Whether full disk encryption ability is required for drives to be added to the storage pool
         */
        criteria_drive_require_fde?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The minimum size of the storage pool (in size_unit). The pool will be expanded if this value exceeds itscurrent size.
         */
        criteria_min_usable_capacity?: number | string;
        ssid: string;
        log_path?: string;
        remove_drives?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Whether to convert to a secure storage pool. Will only work if all drives in the pool are security capable.
         */
        secure_pool?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_password: string;
        /**
         * Only required when the requested state is 'present'.  The RAID level of the storage pool to be created.
         */
        raid_level?: "raidUnsupported" | "raidAll" | "raid0" | "raid1" | "raid3" | "raid5" | "raid6" | "raidDiskPool";
        /**
         * The minimum individual drive size (in size_unit) to consider when choosing drives for the storage pool.
         */
        criteria_drive_min_size?: number | string;
        /**
         * The name of the storage pool to manage
         */
        name: string;
        /**
         * Whether the specified storage pool should exist or not.
         * Note that removing a storage pool currently requires the removal of all defined volumes first.
         */
        state: "present" | "absent";
        /**
         * Prior to removing a storage pool, delete all volumes in the pool.
         */
        remove_volumes?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The type of disk (hdd or ssd) to use when searching for candidates to use.
         */
        criteria_drive_type?: "hdd" | "ssd";
        /**
         * The number of disks to use for building the storage pool. The pool will be expanded if this number exceeds the number of disks already in place
         */
        criteria_drive_count?: number | string;
        api_username: string;
        /**
         * Whether to erase secured disks before adding to storage pool
         */
        erase_secured_drives?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The interface type to use when selecting drives for the storage pool (no value means all interface types will be considered)
         */
        criteria_drive_interface_type?: "sas" | "sas4k" | "fibre" | "fibre520b" | "scsi" | "sata" | "pata";
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set the number of drives reserved by the storage pool for reconstruction operations. Only valide on raid disk pools.
         */
        reserve_drive_count?: number | string;
        api_url: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts for WAF ACLs, Rule , Conditions and Filters.
       */
      aws_waf_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage an AWS customer gateway
       */
      ec2_customer_gateway?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module gets the status of an asynchronous task.
       * This module is also supported for Windows targets.
       */
      async_status?: {
        /**
         * Job or task identifier
         */
        jid: string;
        /**
         * Default: status
         *
         * if C(status), obtain the status; if C(cleanup), clean up the async job cache (by default in C(~/.ansible_async/)) for the specified job I(jid).
         */
        mode?: "status" | "cleanup";
        [k: string]: unknown;
      };
      /**
       * Rename an ONTAP node.
       */
      na_ontap_node?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage node.js packages with Node Package Manager (npm)
       */
      npm?: {
        /**
         * The executable location for npm.
         * This is useful if you are using a version manager, such as nvm
         */
        executable?: string;
        /**
         * The name of a node.js library to install
         */
        name?: string;
        /**
         * Install the node.js library globally
         */
        global?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Use the C(--ignore-scripts) flag when installing.
         */
        ignore_scripts?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * The state of the node.js library
         */
        state?: "present" | "absent" | "latest";
        /**
         * Install dependencies in production mode, excluding devDependencies
         */
        production?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The registry to install modules from.
         */
        registry?: string;
        /**
         * The version to be installed
         */
        version?: string;
        /**
         * The base path where to install the node.js libraries
         */
        path?: string;
        [k: string]: unknown;
      };
      /**
       * Manage the containers on the atomic host platform
       * Allows to manage the lifecycle of a container on the atomic host platform
       */
      atomic_container?: {
        /**
         * Name of the container
         */
        name: string;
        /**
         * The image to use to install the container
         */
        image: string;
        /**
         * Default: latest
         *
         * State of the container
         */
        state?: "latest" | "present" | "absent" | "rollback";
        /**
         * Values for the installation of the container.  This option is permitted only with mode 'user' or 'system'. The values specified here will be used at installation time as --set arguments for atomic install.
         */
        values?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Define if it is an user or a system container
         */
        mode?: "user" | "system";
        /**
         * Define the rootfs of the image
         */
        rootfs?: string;
        /**
         * Define the backend to use for the container
         */
        backend: "docker" | "ostree";
        [k: string]: unknown;
      };
      /**
       * Manages mount behavior for a specified ISO, VHD, or VHDX image on a Windows host. When C(state) is C(present), the image will be mounted under a system-assigned drive letter, which will be returned in the C(mount_path) value of the module result. Requires Windows 8+ or Windows Server 2012+.
       */
      win_disk_image?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create or Delete objects and containers from OpenStack
       */
      os_object?: {
        /**
         * The name of the container in which to create the object
         */
        container?: string;
        /**
         * Name to be give to the object. If omitted, operations will be on the entire container
         */
        name?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Path to local file to be uploaded.
         */
        filename?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: private
         *
         * desired container access level.
         */
        container_access?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV virtual machines relate to a storage domain.
       */
      ovirt_storage_vm_facts?: {
        /**
         * Flag which indicates whether to get unregistered virtual machines which contain one or more disks which reside on a storage domain or diskless virtual machines.
         */
        unregistered?: string;
        /**
         * The storage domain name where the virtual machines should be listed.
         */
        storage_domain?: string;
        /**
         * Sets the maximum number of virtual machines to return. If not specified all the virtual machines are returned.
         */
        max?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete a resource group.
       */
      azure_rm_resourcegroup?: {
        profile?: string;
        /**
         * Default: no
         *
         * Remove a resource group and all associated resources. Use with state 'absent' to delete a resource group that contains resources.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the resource group.
         */
        name: string;
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        /**
         * Default: present
         *
         * Assert the state of the resource group. Use 'present' to create or update and 'absent' to delete. When 'absent' a resource group containing resources will not be removed unless the force option is used.
         */
        state?: "absent" | "present";
        /**
         * Azure location for the resource group. Required when creating a new resource group. Cannot be changed once resource group is created.
         */
        location?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP ForwardingRule
       */
      gcp_compute_forwarding_rule_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * A reference to the region where the regional forwarding rule resides.
         * This field is not applicable to global forwarding rules.
         */
        region: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        service_account_file?: string;
        [k: string]: unknown;
      };
      /**
       * Manages port-channel specific configuration parameters.
       */
      nxos_portchannel?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        provider?: {
          [k: string]: unknown;
        };
        ssh_keyfile?: string;
        /**
         * Default: false
         *
         * When true it forces port-channel members to match what is declared in the members param. This can be used to remove members.
         */
        force?: "false" | "true";
        timeout?: number | string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Channel-group number for the port-channel.
         */
        group: string;
        host?: string;
        /**
         * Default: True
         *
         * Mode for the port-channel, i.e. on, active, passive.
         */
        mode?: "active" | "passive" | "on";
        /**
         * List of interfaces that will be managed in a given portchannel.
         */
        members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Min links required to keep portchannel up.
         */
        min_links?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Manage VMware ESXi DNS Configuration
       */
      vmware_dns_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure ServiceEngine object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_serviceengine?: {
        /**
         * Vnic settings for serviceengine.
         */
        mgmt_vnic?: {
          [k: string]: unknown;
        };
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Flavor of serviceengine.
         */
        flavor?: string;
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * It is a reference to an object of type cloud.
         */
        cloud_ref?: string;
        /**
         * It is a reference to an object of type serviceenginegroup.
         */
        se_group_ref?: string;
        /**
         * Boolean flag to set container_mode.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        container_mode?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Enum options - container_type_bridge, container_type_host, container_type_host_dpdk.
         * Default value when not specified in API or module is interpreted by Avi Controller as CONTAINER_TYPE_HOST.
         */
        container_type?: string;
        /**
         * It is a reference to an object of type vimgrhostruntime.
         */
        host_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        tenant?: string;
        api_version?: string;
        username?: string;
        /**
         * Boolean flag to set controller_created.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        controller_created?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Inorder to disable se set this field appropriately.
         * Enum options - SE_STATE_ENABLED, SE_STATE_DISABLED_FOR_PLACEMENT, SE_STATE_DISABLED, SE_STATE_DISABLED_FORCE.
         * Default value when not specified in API or module is interpreted by Avi Controller as SE_STATE_ENABLED.
         */
        enable_state?: string;
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Name of the object.
         * Default value when not specified in API or module is interpreted by Avi Controller as VM name unknown.
         */
        name?: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Enum options - default, vmware_esx, kvm, vmware_vsan, xen.
         */
        hypervisor?: string;
        /**
         * List of vnic.
         */
        data_vnics?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Seresources settings for serviceengine.
         */
        resources?: {
          [k: string]: unknown;
        };
        /**
         * Availability_zone of serviceengine.
         */
        availability_zone?: string;
        /**
         * Controller_ip of serviceengine.
         */
        controller_ip?: string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific managed disk or all managed disks.
       */
      azure_rm_managed_disk_facts?: {
        profile?: string;
        /**
         * Limit results to a specific managed disk
         */
        name?: string;
        /**
         * Limit results to a specific resource group
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?: string;
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Manages dns records via the Cloudflare API, see the docs: U(https://api.cloudflare.com/)
       */
      cloudflare_dns?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * An Ansible module to deploy blue print package on a set of servers in CenturyLink Cloud.
       */
      clc_blueprint_package?: {
        /**
         * A list of server Ids to deploy the blue print package.
         */
        server_ids:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Whether to install or un-install the package. Currently it supports only "present" for install action.
         */
        state?: "present";
        /**
         * The dictionary of arguments required to deploy the blue print.
         */
        package_params?: {
          [k: string]: unknown;
        };
        /**
         * The package id of the blue print.
         */
        package_id: string;
        /**
         * Default: True
         *
         * Whether to wait for the tasks to finish before returning.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * The manageiq_policies module supports adding and deleting policy_profiles in ManageIQ.
       */
      manageiq_policies?: {
        manageiq_connection?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * absent - policy_profiles should not exist,
         * present - policy_profiles should exist,
         * list - list current policy_profiles and policies.
         */
        state?: "absent" | "present" | "list";
        /**
         * the name of the resource to which the profile should be [un]assigned
         */
        resource_name: string;
        /**
         * list of dictionaries, each includes the policy_profile 'name' key.
         * required if state is present or absent.
         */
        policy_profiles?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * the type of the resource to which the profile should be [un]assigned
         *
         * Possible choices:
         * provider
         * host
         * vm
         * blueprint
         * category
         * cluster
         * data store
         * group
         * resource pool
         * service
         * service template
         * template
         * tenant
         * user
         */
        resource_type: string;
        [k: string]: unknown;
      };
      /**
       * Add model devices on the FortiManager using jsonrpc API and have them pre-configured, so when central management is configured, the configuration is pushed down to the registering devices
       */
      fmgr_provisioning?: {
        /**
         * The username to log into the FortiManager
         */
        username?: string;
        /**
         * The name of the device group the provisioned device can belong to.
         */
        group?: string;
        /**
         * The name of the device to be provisioned.
         */
        name?: string;
        /**
         * The administrative domain (admon) the configuration belongs to
         */
        adom?: string;
        /**
         * The patch release number such as 6.0.X, as X being the patch release.
         */
        patch_release?: string;
        /**
         * The Fortinet OS version to be used for the device, such as 5.0 or 6.0.
         */
        os_version?: string;
        /**
         * The FortiManager's Address.
         */
        host?: string;
        /**
         * The minor release number such as 6.X.1, as X being the minor release.
         */
        minor_release?: string;
        /**
         * The platform of the device, such as model number or VM.
         */
        platform?: string;
        /**
         * The name of the policy package to be assigned to the device.
         */
        policy_package?: string;
        /**
         * The serial number of the device that will be provisioned.
         */
        serial?: string;
        /**
         * The password associated with the username account.
         */
        password?: string;
        /**
         * The Fortinet OS type to be pushed to the device, such as 'FOS' for FortiOS.
         */
        os_type?: string;
        /**
         * The virtual domain (vdom) the configuration belongs to
         */
        vdom?: string;
        /**
         * Description of the device to be provisioned.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Create and modify issues in a JIRA instance.
       */
      jira?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Provides an interface to manage Ethernet Network resources. Can create, update, or delete.
       */
      oneview_ethernet_network?: {
        username?: string;
        image_streamer_hostname?: string;
        hostname?: string;
        config?: string;
        validate_etag?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Indicates the desired state for the Ethernet Network resource. - C(present) will ensure data properties are compliant with OneView. - C(absent) will remove the resource from OneView, if it exists. - C(default_bandwidth_reset) will reset the network connection template to the default.
         */
        state?: "present" | "absent" | "default_bandwidth_reset";
        password?: string;
        /**
         * List with Ethernet Network properties.
         */
        data: {
          [k: string]: unknown;
        };
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Add, modify and delete vaults and secret vaults.
       * KRA service should be enabled to use this module.
       */
      ipa_vault?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Cisco NXOS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with NXOS configuration sections in a deterministic way.  This module works with either CLI or NXAPI transports.
       */
      nxos_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or destroy volumes on NetApp cDOT
       */
      na_cdot_volume?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Retrieve facts about one or more oVirt/RHV tags.
       */
      ovirt_tag_facts?: {
        /**
         * Name of the host, which tags should be listed.
         */
        host?: string;
        /**
         * Name of the tag which should be listed.
         */
        name?: string;
        /**
         * Name of the VM, which tags should be listed.
         */
        vm?: string;
        [k: string]: unknown;
      };
      /**
       * An HttpHealthCheck resource. This resource defines a template for how individual VMs should be checked for health, via HTTP.
       */
      gcp_compute_http_health_check?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage Elastic Container Registry repositories
       */
      ecs_ecr?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Apstra AOS Blueprint module let you manage your Blueprint easily. You can create create and delete Blueprint by Name or ID. You can also use it to retrieve all data from a blueprint. This module is idempotent and support the I(check) mode. It's using the AOS REST API.
       */
      aos_blueprint?: {
        /**
         * Name of the Blueprint to manage. Only one of I(name) or I(id) can be set.
         */
        name?: string;
        /**
         * Default: present
         *
         * Indicate what is the expected state of the Blueprint.
         */
        state?: "present" | "absent" | "build-ready";
        /**
         * An existing AOS session as obtained by M(aos_login) module.
         */
        session: {
          [k: string]: unknown;
        };
        /**
         * When creating a blueprint, this value identifies a known AOS reference architecture value. I(Refer to AOS-server documentation for available values).
         */
        reference_arch?: string;
        /**
         * Default: 5
         *
         * When I(state=build-ready), this timeout identifies timeout in seconds to wait before declaring a failure.
         */
        timeout?: number | string;
        /**
         * AOS Id of the IP Pool to manage (can't be used to create a new IP Pool). Only one of I(name) or I(id) can be set.
         */
        id?: string;
        /**
         * When creating a blueprint, this value identifies, by name, an existing engineering design template within the AOS-server.
         */
        template?: string;
        [k: string]: unknown;
      };
      /**
       * Creates and removes VPN site-to-site gateways.
       */
      cs_vpn_gateway?: {
        /**
         * Account the VPN gateway is related to.
         */
        account?: string;
        api_key?: string;
        /**
         * Default: yes
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Name of the project the VPN gateway is related to.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the VPN gateway.
         */
        state?: "present" | "absent";
        /**
         * Name of the VPC.
         */
        vpc: string;
        /**
         * Domain the VPN gateway is related to.
         */
        domain?: string;
        /**
         * Name of the zone the VPC is related to.
         * If not set, default zone is used.
         */
        zone?: string;
        [k: string]: unknown;
      };
      /**
       * Add and remove nic to and from network
       */
      cs_instance_nic?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Create, update and remove hosts.
       */
      cs_host?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Create or remove SSD caches on a NetApp E-Series storage array.
       */
      netapp_e_flashcache?: {
        /**
         * The minimum size (in size_units) of the ssd cache. The cache will be expanded if this exceeds the current size of the cache.
         */
        cache_size_min?: number | string;
        /**
         * The name of the SSD cache to manage
         */
        name: string;
        log_path?: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * Default: filesystem
         *
         * The type of workload to optimize the cache for.
         */
        io_type?: "filesystem" | "database" | "media";
        /**
         * The minimum number of disks to use for building the cache. The cache will be expanded if this number exceeds the number of disks already in place
         */
        disk_count?: number | string;
        /**
         * Default: gb
         *
         * The unit to be applied to size arguments
         */
        size_unit?: "bytes" | "b" | "kb" | "mb" | "gb" | "tb" | "pb" | "eb" | "zb" | "yb";
        log_mode?: string;
        /**
         * Default: present
         *
         * Whether the specified SSD cache should exist or not.
         */
        state?: "present" | "absent";
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        disk_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        criteria_disk_phy_type?: "sas" | "sas4k" | "fibre" | "fibre520b" | "scsi" | "sata" | "pata";
        /**
         * The ID of the array to manage (as configured on the web services proxy).
         */
        ssid: string;
        [k: string]: unknown;
      };
      /**
       * Add, modify or remove systems in Cobbler
       */
      cobbler_system?: {
        /**
         * Default: cobbler
         *
         * The username to log in to Cobbler.
         */
        username?: string;
        /**
         * The system name to manage.
         */
        name?: string;
        /**
         * A list of dictionaries containing interface options.
         */
        interfaces?: {
          [k: string]: unknown;
        };
        /**
         * Sync on changes.
         * Concurrently syncing Cobbler is bound to fail.
         */
        sync?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Port number to be used for REST connection.
         * The default value depends on parameter C(use_ssl).
         */
        port?: number | string;
        /**
         * Default: present
         *
         * Whether the system should be present, absent or a query is made.
         */
        state?: "absent" | "present" | "query";
        /**
         * Default: 127.0.0.1
         *
         * The name or IP address of the Cobbler system.
         */
        host?: string;
        /**
         * Default: yes
         *
         * If C(no), an HTTP connection will be used instead of the default HTTPS connection.
         */
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The password to log in to Cobbler.
         */
        password?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated.
         * This should only set to C(no) when used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A dictionary with system properties.
         */
        properties?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about vmnics available on the given ESXi host.
       * If C(cluster_name) is provided, then vmnic facts about all hosts from given cluster will be returned.
       * If C(esxi_hostname) is provided, then vmnic facts about given host system will be returned.
       * Additional details about vswitch and dvswitch with respective vmnic is also provided which is added in 2.7 version.
       */
      vmware_host_vmnic_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or remove applications on a Webfaction host. Further documentation at U(https://github.com/quentinsf/ansible-webfaction).
       */
      webfaction_app?: {
        /**
         * The name of the application
         */
        name: string;
        /**
         * Default: no
         *
         * IF the port should be opened
         */
        port_open?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The machine name to use (optional for accounts with only one machine)
         */
        machine?: string;
        /**
         * Default: present
         *
         * Whether the application should exist
         */
        state?: "present" | "absent";
        /**
         * Default: no
         *
         * Whether the app should restart with an C(autostart.cgi) script
         */
        autostart?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The webfaction password to use
         */
        login_password: string;
        /**
         * The type of application to create. See the Webfaction docs at U(https://docs.webfaction.com/xmlrpc-api/apps.html) for a list.
         */
        type: string;
        /**
         * The webfaction account to use
         */
        login_name: string;
        /**
         * Any extra parameters required by the app
         */
        extra_info?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Interfaces on network devices.
       */
      net_interface?: {
        username?: string;
        eth_trunk_id?: string;
        ssh_keyfile?: string;
        provider?: {
          [k: string]: unknown;
        };
        pseudo_priority?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        priority_id?: string;
        peer_link_id?: string;
        vpn_instance_name?: string;
        nickname?: string;
        /**
         * Default: present
         *
         * State of the Interface configuration, C(up) indicates present and operationally up and C(down) indicates present and operationally C(down)
         */
        state?: "present" | "absent";
        pseudo_nickname?: string;
        timeout?: number | string;
        dfs_group_id?: string;
        host?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        ip_address?: string;
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Publish a message on an MQTT topic.
       */
      mqtt?: {
        /**
         * Username to authenticate against the broker.
         */
        username?: string;
        /**
         * The path pointing to the PEM encoded client certificate. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.
         */
        certfile?: string;
        /**
         * Default: 1883
         *
         * MQTT broker port number
         */
        port?: number | string;
        /**
         * Default: localhost
         *
         * MQTT broker address/name
         */
        server?: string;
        /**
         * MQTT topic name
         */
        topic: string;
        /**
         * Default: hostname + pid
         *
         * MQTT client identifier
         */
        client_id?: string;
        /**
         * The path to the Certificate Authority certificate files that are to be treated as trusted by this client. If this is the only option given then the client will operate in a similar manner to a web browser. That is to say it will require the broker to have a certificate signed by the Certificate Authorities in ca_certs and will communicate using TLS v1, but will not attempt any form of authentication. This provides basic network encryption but may not be sufficient depending on how the broker is configured.
         */
        ca_certs?: string;
        /**
         * Default: no
         *
         * Setting this flag causes the broker to retain (i.e. keep) the message so that applications that subsequently subscribe to the topic can received the last retained message immediately.
         */
        retain?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Password for C(username) to authenticate against the broker.
         */
        password?: string;
        /**
         * The path pointing to the PEM encoded client private key. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.
         */
        keyfile?: string;
        /**
         * Payload. The special string C("None") may be used to send a NULL (i.e. empty) payload which is useful to simply notify with the I(topic) or to clear previously retained messages.
         */
        payload: string;
        /**
         * QoS (Quality of Service)
         */
        qos?: "0" | "1" | "2";
        [k: string]: unknown;
      };
      /**
       * Retrieve the attributes of a server certificate
       */
      iam_server_certificate_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module offers the ability to set a configuration checkpoint file or rollback to a configuration checkpoint file on HUAWEI CloudEngine switches.
       */
      ce_rollback?: {
        /**
         * Specifies the label of the configuration rollback point to which system configurations are expected to roll back. The value is an integer that the system generates automatically.
         */
        commit_id?: string;
        username?: string;
        password?: string;
        /**
         * Specifies the number of configuration rollback points. The value is an integer that ranges from 1 to 80.
         */
        last?: string;
        /**
         * Specifies a user label for a configuration rollback point. The value is a string of 1 to 256 case-sensitive ASCII characters, spaces not supported. The value must start with a letter and cannot be presented in a single hyphen (-).
         */
        label?: string;
        /**
         * Specifies a configuration file for configuration rollback. The value is a string of 5 to 64 case-sensitive characters in the format of *.zip, *.cfg, or *.dat, spaces not supported.
         */
        filename?: string;
        host?: string;
        ssh_keyfile?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * The operation of configuration rollback.
         */
        action?: "rollback" | "clear" | "set" | "display" | "commit";
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies the number of configuration rollback points. The value is an integer that ranges from 1 to 80.
         */
        oldest?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * This module allows one to (re)generate OpenSSL certificates. It implements a notion of provider (ie. C(selfsigned), C(ownca), C(acme), C(assertonly)) for your certificate. The 'assertonly' provider is intended for use cases where one is only interested in checking properties of a supplied certificate. The 'ownca' provider is intended for generate OpenSSL certificate signed with your own CA (Certificate Authority) certificate (self-signed certificate). Many properties that can be specified in this module are for validation of an existing or newly generated certificate. The proper place to specify them, if you want to receive a certificate with these properties is a CSR (Certificate Signing Request). It uses the pyOpenSSL python library to interact with OpenSSL.
       */
      openssl_certificate?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Can create, update, or delete Spotinst AWS Elastigroups Launch configuration is part of the elastigroup configuration, so no additional modules are necessary for handling the launch configuration. You will have to have a credentials file in this location - <home>/.spotinst/credentials The credentials file must contain a row that looks like this token = <YOUR TOKEN> Full documentation available at https://help.spotinst.com/hc/en-us/articles/115003530285-Ansible-
       */
      spotinst_aws_elastigroup?: {
        /**
         * (List of Objects) a list of hash/dictionaries of EBS devices to reattach to the elastigroup when available; '[{"key":"value", "key":"value"}]'; keys allowed are - volume_ids (List of Strings), device_name (String)
         */
        ebs_volume_pool?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (Object) The elastigroup OpsWorks integration configration.; Expects the following key - layer_id (String)
         */
        opsworks?: {
          [k: string]: unknown;
        };
        /**
         * (List of Strings) List of target group arns instances should be registered to
         */
        target_group_arns?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (Object) Roll configuration.; If you would like the group to roll after updating, please use this feature. Accepts the following keys - batch_size_percentage(Integer, Required), grace_period - (Integer, Required), health_check_type(String, Optional)
         */
        roll_config?: {
          [k: string]: unknown;
        };
        /**
         * (String) The Base64-encoded shutdown script that executes prior to instance termination. Encode before setting.
         */
        shutdown_script?: string;
        /**
         * (Object) The Rightscale integration configuration.; Expects the following keys - account_id (String), refresh_token (String)
         */
        right_scale?: {
          [k: string]: unknown;
        };
        /**
         * (List of Objects) a list of hash/dictionaries of scaling policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), metric_name (String, required), dimensions (List of Objects, Keys allowed are name (String, required) and value (String)), statistic (String, required) evaluation_periods (String, required), period (String, required), threshold (String, required), cooldown (String, required), unit (String, required), operator (String, required), action_type (String, required), adjustment (String), min_target_capacity (String), target (String), maximum (String), minimum (String)
         */
        up_scaling_policies?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (String) Base64-encoded MIME user data. Encode before setting the value.
         */
        user_data?: string;
        /**
         * (Boolean) terminate at the end of billing hour
         */
        terminate_at_end_of_billing_hour?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * (String) The instance profile iamRole name
         * Only use iam_role_arn, or iam_role_name
         */
        iam_role_name?: string;
        elastic_beanstalk?: {
          [k: string]: unknown;
        };
        /**
         * (Integer) spin up time, in seconds, for the instance
         */
        spin_up_time?: number | string;
        /**
         * (List of Objects) a list of hash/dictionaries of scheduled tasks to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - adjustment (Integer), scale_target_capacity (Integer), scale_min_capacity (Integer), scale_max_capacity (Integer), adjustment_percentage (Integer), batch_size_percentage (Integer), cron_expression (String), frequency (String), grace_period (Integer), task_type (String, required), is_enabled (Boolean)
         */
        scheduled_tasks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (String) The strategy orientation.
         */
        availability_vs_cost: string;
        /**
         * (String) The group id if it already exists and you want to update, or delete it. This will not work unless the uniqueness_by field is set to id. When this is set, and the uniqueness_by field is set, the group will either be updated or deleted, but not created.
         */
        id?: string;
        /**
         * (String) The capacity unit to launch instances by.
         */
        unit?: string;
        /**
         * (Integer) required if on demand is not set. The percentage of Spot instances to launch (0 - 100).
         */
        risk?: number | string;
        /**
         * (List of Objects) a list of hash/dictionaries of Availability Zones that are configured in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are name (String), subnet_id (String), placement_group_name (String),
         */
        availability_zones:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (Boolean) Describes whether instance Enhanced Monitoring is enabled
         */
        monitoring?: string;
        do_not_update?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        multai_load_balancers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 300
         *
         * (Integer) The amount of time, in seconds, after the instance has launched to start and check its health.
         */
        health_check_grace_period?: number | string;
        /**
         * (Object) The Kubernetes integration configuration. Expects the following keys - api_server (String), token (String)
         */
        kubernetes?: {
          [k: string]: unknown;
        };
        /**
         * (Integer) Time for instance to be drained from incoming requests and deregistered from ELB before termination.
         */
        draining_timeout?: number | string;
        /**
         * (Boolean) Enable EBS optimization for supported instances which are not enabled by default.; Note - additional charges will be applied.
         */
        ebs_optimized?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * (String) The instance profile iamRole arn
         * Only use iam_role_arn, or iam_role_name
         */
        iam_role_arn?: string;
        multai_token?: string;
        /**
         * (List of Objects) a list of hash/dictionaries of signals to configure in the elastigroup; keys allowed are - name (String, required), timeout (Integer)
         */
        signals?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (String) create or delete the elastigroup
         */
        state?: "present" | "absent";
        /**
         * (String) The service to use for the health check.
         */
        health_check_type?: string;
        /**
         * (String) Specify a Key Pair to attach to the instances
         */
        key_pair?: string;
        /**
         * (List of Objects) a list of hash/dictionaries of scaling policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), metric_name (String, required), dimensions ((List of Objects), Keys allowed are name (String, required) and value (String)), statistic (String, required), evaluation_periods (String, required), period (String, required), threshold (String, required), cooldown (String, required), unit (String, required), operator (String, required), action_type (String, required), adjustment (String), max_target_capacity (String), target (String), maximum (String), minimum (String)
         */
        down_scaling_policies?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (Integer) Minimal mount of time instance should be unhealthy for us to consider it unhealthy.
         */
        health_check_unhealthy_duration_before_replacement?: number | string;
        /**
         * (Object) The Rancher integration configuration.; Expects the following keys - access_key (String), secret_key (String), master_host (String)
         */
        rancher?: {
          [k: string]: unknown;
        };
        /**
         * (Integer) Required if risk is not set
         * Number of on demand instances to launch. All other instances will be spot instances.; Either set this parameter or the risk parameter
         */
        on_demand_count?: number | string;
        /**
         * (List of Objects) a list of hash/dictionaries of Block Device Mappings for elastigroup instances; You can specify virtual devices and EBS volumes.; '[{"key":"value", "key":"value"}]'; keys allowed are device_name (List of Strings), virtual_name (String), no_device (String), ebs (Object, expects the following keys- delete_on_termination(Boolean), encrypted(Boolean), iops (Integer), snapshot_id(Integer), volume_type(String), volume_size(Integer))
         */
        block_device_mappings?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (String) On-demand instance type that will be provisioned
         */
        on_demand_instance_type?: string;
        /**
         * (Object) The Stateful elastigroup configration.; Accepts the following keys - should_persist_root_device (Boolean), should_persist_block_devices (Boolean), should_persist_private_ip (Boolean)
         */
        persistence?: {
          [k: string]: unknown;
        };
        /**
         * (Object) The Mesosphere integration configuration. Expects the following key - api_server (String)
         */
        mesosphere?: {
          [k: string]: unknown;
        };
        /**
         * (String) Operation system type._
         */
        product: string;
        /**
         * (String) Optional parameter that allows to set an account-id inside the module configuration By default this is retrieved from the credentials path
         */
        account_id?: string;
        /**
         * (List of Objects) a list of hash/dictionaries of target tracking policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), source (String, required), metric_name (String, required), statistic (String, required), unit (String, required), cooldown (String, required), target (String, required)
         */
        target_tracking_policies?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (List of tagKey:tagValue paris) a list of tags to configure in the elastigroup. Please specify list of keys and values (key colon value);
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (List of Strings) List of ElasticIps Allocation Ids (Example C(eipalloc-9d4e16f8)) to associate to the group instances
         */
        elastic_ips?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (Integer) The lower limit number of instances that you can scale down to
         */
        min_size: number | string;
        /**
         * (String) The image Id used to launch the instance.; In case of conflict between Instance type and image type, an error will be returned
         */
        image_id: string;
        /**
         * (Integer) How long the module should wait for instances before failing the action.; Only works if wait_for_instances is True.
         */
        wait_timeout?: number | string;
        /**
         * (Object) The ECS integration configuration.; Expects the following key - cluster_name (String)
         */
        ecs?: {
          [k: string]: unknown;
        };
        /**
         * (List of Strings) List of classic ELB names
         */
        load_balancers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (List of Strings) One or more security group IDs. ; In case of update it will override the existing Security Group with the new given array
         */
        security_group_ids:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (Integer) The upper limit number of instances that you can scale up to
         */
        max_size: number | string;
        /**
         * (String) Unique name for elastigroup to be created, updated or deleted
         */
        name: string;
        /**
         * (String) If your group names are not unique, you may use this feature to update or delete a specific group. Whenever this property is set, you must set a group_id in order to update or delete a group, otherwise a group will be created.
         */
        uniqueness_by?: "id" | "name";
        /**
         * (String) Optional parameter that allows to set a non-default credentials path. Default is ~/.spotinst/credentials
         */
        credentials_path?: string;
        /**
         * (Integer) The number of instances to launch
         */
        target: number | string;
        /**
         * (Boolean) In case of no spots available, Elastigroup will launch an On-demand instance instead
         */
        fallback_to_od?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * (Object) The Chef integration configuration.; Expects the following keys - chef_server (String), organization (String), user (String), pem_key (String), chef_version (String)
         */
        chef?: {
          [k: string]: unknown;
        };
        /**
         * (List of Objects) a list of hash/dictionaries of network interfaces to add to the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - description (String), device_index (Integer), secondary_private_ip_address_count (Integer), associate_public_ip_address (Boolean), delete_on_termination (Boolean), groups (List of Strings), network_interface_id (String), private_ip_address (String), subnet_id (String), associate_ipv6_address (Boolean), private_ip_addresses (List of Objects, Keys are privateIpAddress (String, required) and primary (Boolean))
         */
        network_interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * (String) lifetime period
         */
        lifetime_period?: number | string;
        token?: string;
        /**
         * (String) dedicated vs shared tenancy
         */
        tenancy?: string;
        /**
         * (Boolean) In case of any available Reserved Instances, Elastigroup will utilize your reservations before purchasing Spot instances.
         */
        utilize_reserved_instances?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * (Boolean) Whether or not the elastigroup creation / update actions should wait for the instances to spin
         */
        wait_for_instances?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * (List of Strings) Spot instance type that will be provisioned.
         */
        spot_instance_types:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to a Dell OS9 node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(dellos9_config) to configure Dell OS9 devices.
       */
      dellos9_command?: {
        username?: string;
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should be tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        /**
         * List of commands to send to the remote dellos9 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: "any" | "all";
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP TargetVpnGateway
       */
      gcp_compute_target_vpn_gateway_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * The region this gateway should sit in.
         */
        region: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        service_account_file?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of link aggregation groups on Cisco IOS network devices.
       */
      ios_linkagg?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Channel-group number for the port-channel Link aggregation group. Range 1-255.
         */
        group?: number | string;
        /**
         * List of members of the link aggregation group.
         */
        members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of the link aggregation group.
         */
        state?: "present" | "absent";
        /**
         * Purge links not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        /**
         * Mode of the link aggregation group.
         */
        mode?: "active" | "on" | "passive" | "auto" | "desirable";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of link aggregation definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about an ESXi host's vswitch configurations when ESXi hostname or Cluster name is given.
       */
      vmware_vswitch_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage packages on OpenBSD using the pkg tools.
       */
      openbsd_pkg?: {
        /**
         * A name or a list of names of the packages.
         */
        name:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * C(present) will make sure the package is installed. C(latest) will make sure the latest version of the package is installed. C(absent) will make sure the specified package is not installed.
         */
        state?: "absent" | "installed" | "latest" | "present" | "removed";
        /**
         * Default: no
         *
         * Build the package from source instead of downloading and installing a binary. Requires that the port source tree is already installed. Automatically builds and installs the 'sqlports' package, if it is not already installed.
         */
        build?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * When updating or removing packages, delete the extra configuration file(s) in the old packages which are annotated with @extra in the packaging-list.
         */
        clean?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Replace or delete packages quickly; do not bother with checksums before removing normal files.
         */
        quick?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: /usr/ports
         *
         * When used in combination with the C(build) option, allows overriding the default ports source directory.
         */
        ports_dir?: string;
        [k: string]: unknown;
      };
      /**
       * Manage SNAT pools on a BIG-IP.
       */
      bigip_snat_pool?: {
        /**
         * Default: present
         *
         * Whether the SNAT pool should exist or not.
         */
        state?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * The name of the SNAT pool.
         */
        name?: string;
        /**
         * List of members to put in the SNAT pool. When a C(state) of present is provided, this parameter is required. Otherwise, it is optional.
         */
        members?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to add and delete datastore cluster in given VMware environment.
       * All parameters and VMware object values are case sensitive.
       */
      vmware_datastore_cluster?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running IOS XR.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      iosxr_facts?: {
        username?: string;
        ssh_keyfile?: string;
        host?: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages Javascript iApp packages on a BIG-IP. This module will allow you to deploy iAppLX packages to the BIG-IP and manage their lifecycle.
       */
      bigip_iapplx_package?: {
        /**
         * Default: present
         *
         * Whether the iAppLX package should exist or not.
         */
        state?: string;
        /**
         * The iAppLX package that you want to upload or remove. When C(state) is C(present), and you intend to use this module in a C(role), it is recommended that you use the C({{ role_path }}) variable. An example is provided in the C(EXAMPLES) section.
         * When C(state) is C(absent), it is not necessary for the package to exist on the Ansible controller. If the full path to the package is provided, the fileame will specifically be cherry picked from it to properly remove the package.
         */
        package?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove flavors from OpenStack.
       */
      os_nova_flavor?: {
        /**
         * Default: auto
         *
         * ID for the flavor. This is optional as a unique UUID will be assigned if a value is not specified.
         */
        flavorid?: string;
        /**
         * Flavor name.
         */
        name?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Amount of memory, in MB.
         */
        ram?: string;
        /**
         * Ephemeral space size, in GB.
         */
        ephemeral?: string;
        /**
         * Number of virtual CPUs.
         */
        vcpus?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource. When I(state) is 'present', then I(ram), I(vcpus), and I(disk) are all required. There are no default values for those parameters.
         */
        state?: string;
        /**
         * Metadata dictionary
         */
        extra_specs?: string;
        /**
         * Swap space size, in MB.
         */
        swap?: string;
        /**
         * Default: 1.0
         *
         * RX/TX factor.
         */
        rxtx_factor?: string;
        /**
         * Default: yes
         *
         * Make flavor accessible to the public.
         */
        is_public?: string;
        /**
         * Size of local disk, in GB.
         */
        disk?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows to manage dns zones on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
       */
      udm_dns_zone?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Gathers facts by reading the status.json and result.json of cloud-init.
       */
      cloud_init_data_facts?: {
        /**
         * Filter facts
         */
        filter?: "status" | "result";
        [k: string]: unknown;
      };
      /**
       * Manage fabric interface policy leaf profiles on Cisco ACI fabrics.
       */
      aci_interface_policy_leaf_profile?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * This module allows one to (re-)generate PKCS#12.
       */
      openssl_pkcs12?: {
        [k: string]: unknown;
      };
      /**
       * Change ACL (Access Control List) inheritance and optionally copy inherited ACE's (Access Control Entry) to dedicated ACE's or vice versa.
       */
      win_acl_inheritance?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure CustomIpamDnsProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_customipamdnsprofile?: {
        username?: string;
        /**
         * Parameters that are always passed to the ipam/dns script.
         * Field introduced in 17.1.1.
         */
        script_params?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Field introduced in 17.1.1.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.1.1.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Script uri of form controller //ipamdnsscripts/<file-name>.
         * Field introduced in 17.1.1.
         */
        script_uri: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Name of the custom ipam dns profile.
         * Field introduced in 17.1.1.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or delete a network security group. A security group contains Access Control List (ACL) rules that allow or deny network traffic to subnets or individual network interfaces. A security group is created with a set of default security rules and an empty set of security rules. Shape traffic flow by adding rules to the empty set of security rules.
       */
      azure_rm_securitygroup?: {
        /**
         * Default: no
         *
         * Remove any existing rules not matching those defined in the rules parameters.
         */
        purge_rules?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        cloud_environment?: string;
        secret?: string;
        /**
         * Name of the resource group the security group belongs to.
         */
        resource_group: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        /**
         * Default: present
         *
         * Assert the state of the security group. Set to 'present' to create or update a security group. Set to 'absent' to remove a security group.
         */
        state?: "absent" | "present";
        /**
         * The set of default rules automatically added to a security group at creation. In general default rules will not be modified. Modify rules to shape the flow of traffic to or from a subnet or NIC. See rules below for the makeup of a rule dict.
         */
        default_rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        cert_validation_mode?: "validate" | "ignore";
        /**
         * Valid azure location. Defaults to location of the resource group.
         */
        location?: string;
        subscription_id?: string;
        profile?: string;
        tags?: {
          [k: string]: unknown;
        };
        /**
         * Set of rules shaping traffic flow to or from a subnet or NIC. Each rule is a dictionary.
         */
        rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        tenant?: string;
        /**
         * Name of the security group to operate on.
         */
        name: string;
        /**
         * Default: no
         *
         * Remove any existing rules not matching those defined in the default_rules parameter.
         */
        purge_default_rules?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        [k: string]: unknown;
      };
      /**
       * Creates or terminates ec2 instances.
       */
      ec2?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Adds or removes firewall rules from a gateway in a vca environment
       */
      vca_fw?: {
        /**
         * A list of firewall rules to be added to the gateway, Please see examples on valid entries
         */
        fw_rules?: string;
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from an Ordnance Virtual router over SSH. This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      ordnance_facts?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Manages global attributes of VXLAN and bridge domain on HUAWEI CloudEngine devices.
       */
      ce_vxlan_global?: {
        username?: string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Set the tunnel mode to VXLAN when configuring the VXLAN feature.
         */
        tunnel_mode_vxlan?: "enable" | "disable";
        /**
         * Eth-Trunk from load balancing VXLAN packets in optimized mode.
         */
        nvo3_eth_trunk_hash?: "enable" | "disable";
        /**
         * Loop prevention of VXLAN traffic in non-enhanced mode. When the device works in non-enhanced mode, inter-card forwarding of VXLAN traffic may result in loops.
         */
        nvo3_prevent_loops?: "enable" | "disable";
        /**
         * Enabling or disabling the VXLAN ACL extension function.
         */
        nvo3_acl_extend?: "enable" | "disable";
        /**
         * Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.
         */
        bridge_domain_id?: string;
        /**
         * Configuring the Layer 3 VXLAN Gateway to Work in Non-loopback Mode.
         */
        nvo3_gw_enhanced?: "l2" | "l3";
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        ssh_keyfile?: string;
        timeout?: number | string;
        /**
         * Load balancing of VXLAN packets through ECMP in optimized mode.
         */
        nvo3_ecmp_hash?: "enable" | "disable";
        host?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enabling or disabling the VXLAN service extension function.
         */
        nvo3_service_extend?: "enable" | "disable";
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * creates / deletes a Rackspace Public Cloud queue.
       */
      rax_queue?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can be used to manage boot options for the given virtual machine.
       */
      vmware_guest_boot_manager?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Configure the settings of an E-Series iSCSI target
       */
      netapp_e_iscsi_target?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * allows you to upload/delete templates in Proxmox VE cluster
       */
      proxmox_template?: {
        /**
         * Proxmox VE node, when you will operate with template
         */
        node?: string;
        /**
         * path to uploaded file
         * required only for C(state=present)
         */
        src?: string;
        /**
         * Default: no
         *
         * can be used only with C(state=present), exists template will be overwritten
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * the host of the Proxmox VE cluster
         */
        api_host: string;
        /**
         * the user to authenticate with
         */
        api_user: string;
        /**
         * the password to authenticate with
         * you can use PROXMOX_PASSWORD environment variable
         */
        api_password?: string;
        /**
         * Default: local
         *
         * target storage
         */
        storage?: string;
        /**
         * Default: 30
         *
         * timeout for operations
         */
        timeout?: number | string;
        /**
         * Default: present
         *
         * Indicate desired state of the template
         */
        state?: "present" | "absent";
        /**
         * Default: vztmpl
         *
         * content type
         * required only for C(state=present)
         */
        content_type?: "vztmpl" | "iso";
        /**
         * Default: no
         *
         * enable / disable https certificate verification
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * the template name
         * required only for states C(absent), C(info)
         */
        template?: string;
        [k: string]: unknown;
      };
      /**
       * Consumes docker compose to start, shutdown and scale services.
       * Works with compose versions 1 and 2.
       * Compose can be read from a docker-compose.yml (or .yaml) file or inline using the C(definition) option.
       * See the examples for more details.
       * Supports check mode.
       */
      docker_service?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages a VRF for an OSPF router.
       */
      nxos_ospf_vrf?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        /**
         * Specify the max interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.
         */
        timer_throttle_lsa_max?: string;
        /**
         * Specify the maximum wait time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.
         */
        timer_throttle_spf_max?: string;
        /**
         * Specify the hold interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.
         */
        timer_throttle_lsa_hold?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of ospf vrf configuration.
         */
        state?: "present" | "absent";
        /**
         * Setting to C(yes) will suppress routing update on interface.
         */
        passive_interface?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Router Identifier (ID) of the OSPF router VRF instance.
         */
        router_id?: string;
        /**
         * Specifies the reference bandwidth used to assign OSPF cost. Valid values are an integer, in Mbps, or the keyword 'default'.
         */
        auto_cost?: string;
        /**
         * Specify the default Metric value. Valid values are an integer or the keyword 'default'.
         */
        default_metric?: string;
        host?: string;
        /**
         * Default: default
         *
         * Name of the resource instance. Valid value is a string. The name 'default' is a valid VRF representing the global OSPF.
         */
        vrf?: string;
        /**
         * Specify initial Shortest Path First (SPF) schedule delay. Valid values are an integer, in milliseconds, or the keyword 'default'.
         */
        timer_throttle_spf_start?: string;
        password?: string;
        /**
         * Specify minimum hold time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.
         */
        timer_throttle_spf_hold?: string;
        ssh_keyfile?: string;
        /**
         * Name of the OSPF instance.
         */
        ospf: string;
        /**
         * Controls the level of log messages generated whenever a neighbor changes state. Valid values are 'log', 'detail', and 'default'.
         */
        log_adjacency?: "log" | "detail" | "default";
        /**
         * Specify the start interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.
         */
        timer_throttle_lsa_start?: string;
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about a image image from OpenStack.
       */
      os_image_facts?: {
        /**
         * Name or ID of the image
         */
        image?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows you to reset a switch's startup configuration. The method provides a way to reset the startup configuration to its factory settings. This is helpful when you want to move the switch to another topology as a new network device. This module uses SSH to manage network device configuration. The result of the operation can be viewed in results directory.
       */
      cnos_factory?: {
        username?: string;
        outputfile: string;
        host?: string;
        deviceType: string;
        password?: string;
        enablePassword?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to configure VSAN clustering on an ESXi host
       */
      vmware_vsan_cluster?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allows for management of SSIDs in a Meraki wireless environment.
       */
      meraki_ssid?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create an annotation event on the given annotation stream :name. If the annotation stream does not exist, it will be created automatically
       */
      librato_annotation?: {
        /**
         * The annotation stream name
         * If the annotation stream does not exist, it will be created automatically
         */
        name?: string;
        /**
         * See examples
         */
        links?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The title of an annotation is a string and may contain spaces
         * The title should be a short, high-level summary of the annotation e.g. v45 Deployment
         */
        title: string;
        /**
         * The unix timestamp indicating the time at which the event referenced by this annotation started
         */
        start_time?: number | string;
        /**
         * A string which describes the originating source of an annotation when that annotation is tracked across multiple members of a population
         */
        source?: string;
        /**
         * The unix timestamp indicating the time at which the event referenced by this annotation ended
         * For events that have a duration, this is a useful way to annotate the duration of the event
         */
        end_time?: number | string;
        /**
         * Librato account username
         */
        user: string;
        /**
         * Librato account api key
         */
        api_key: string;
        /**
         * The description contains extra meta-data about a particular annotation
         * The description should contain specifics on the individual annotation e.g. Deployed 9b562b2 shipped new feature foo!
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manages Cisco Ethernet Virtual Private Network (EVPN) VXLAN Network Identifier (VNI) configurations of a Nexus device.
       */
      nxos_evpn_vni?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        provider?: {
          [k: string]: unknown;
        };
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Enables/Disables route-target settings for both import and export target communities using a single property.
         */
        route_target_both?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * The EVPN VXLAN Network Identifier.
         */
        vni: string;
        host?: string;
        /**
         * The VPN Route Distinguisher (RD). The RD is combined with the IPv4 or IPv6 prefix learned by the PE router to create a globally unique address.
         */
        route_distinguisher?: string;
        /**
         * Sets the route-target 'import' extended communities.
         */
        route_target_import?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        /**
         * Sets the route-target 'export' extended communities.
         */
        route_target_export?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Create or destroy user roles
       */
      na_cdot_user_role?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Configures server UUID pools and UUID blocks on Cisco UCS Manager.
       * Examples can be used with the L(UCS Platform Emulator,https://communities.cisco.com/ucspe).
       */
      ucs_uuid_pool?: {
        /**
         * The name of the UUID pool.
         * This name can be between 1 and 32 alphanumeric characters.
         * You cannot use spaces or any special characters other than - (hyphen), "_" (underscore), : (colon), and . (period).
         * You cannot change this name after the UUID pool is created.
         */
        name?: string;
        /**
         * Default: present
         *
         * If C(present), will verify UUID pool is present and will create if needed.
         * If C(absent), will verify UUID pool is absent and will delete if needed.
         */
        state?: string;
        /**
         * The last UUID in the block of UUIDs.
         * This is the To field in the UCS Manager Add UUID Blocks menu.
         */
        last_uuid?: string;
        /**
         * Default: org-root
         *
         * The distinguished name (dn) of the organization where the resource is assigned.
         */
        org_dn?: string;
        /**
         * UUID prefix used for the range of server UUIDs.
         * If no value is provided, the system derived prefix will be used (equivalent to selecting 'derived' option in UI).
         * If the user provides a value, the user provided prefix will be used (equivalent to selecting 'other' option in UI).
         * A user provided value should be in the format XXXXXXXX-XXXX-XXXX.
         */
        prefix?: string;
        /**
         * The first UUID in the block of UUIDs.
         * This is the From field in the UCS Manager UUID Blocks menu.
         */
        first_uuid?: string;
        /**
         * Default: default
         *
         * The Assignment Order field.
         * This can be one of the following:
         * default - Cisco UCS Manager selects a random identity from the pool.
         * sequential - Cisco UCS Manager selects the lowest available identity from the pool.
         */
        order?: string;
        /**
         * The user-defined description of the UUID pool.
         * Enter up to 256 characters.
         * You can use any characters or spaces except the following:
         * ` (accent mark),  (backslash), ^ (carat), " (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of link aggregation groups on Mellanox ONYX network devices.
       */
      onyx_linkagg?: {
        /**
         * Name of the link aggregation group.
         */
        name?: string;
        /**
         * Purge link aggregation groups not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * State of the link aggregation group.
         */
        state?: "present" | "absent";
        /**
         * Default: True
         *
         * Mode of the link aggregation group. A value of C(on) will enable LACP. C(active) configures the link to actively information about the state of the link, or it can be configured in C(passive) mode ie. send link state information only when received them from another link.
         */
        mode?: "on" | "active" | "passive";
        /**
         * List of members interfaces of the link aggregation group. The value can be single interface or list of interfaces.
         */
        members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List of link aggregation definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Gather facts about OpenNebula images
       */
      one_image_facts?: {
        [k: string]: unknown;
      };
      /**
       * Manage S3 buckets in AWS, Ceph, Walrus and FakeS3
       */
      s3_bucket?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage node.js packages with the Yarn package manager (https://yarnpkg.com/)
       */
      yarn?: {
        /**
         * The executable location for yarn.
         */
        executable?: string;
        /**
         * The name of a node.js library to install
         * If omitted all packages in package.json are installed.
         */
        name?: string;
        /**
         * Install the node.js library globally
         */
        global?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Use the --ignore-scripts flag when installing.
         */
        ignore_scripts?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Installation state of the named node.js library
         * If absent is selected, a name option must be provided
         */
        state?: "present" | "absent" | "latest";
        /**
         * Install dependencies in production mode.
         * Yarn will ignore any dependencies under devDependencies in package.json
         */
        production?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The registry to install modules from.
         */
        registry?: string;
        /**
         * The version of the library to be installed.
         * Must be in semver format. If "latest" is desired, use "state" arg instead
         */
        version?: string;
        /**
         * The base path where Node.js libraries will be installed.
         * This is where the node_modules folder lives.
         */
        path?: string;
        [k: string]: unknown;
      };
      /**
       * This module will change the power plan of a Windows system to the defined string.
       * Windows defaults to C(balanced) which will cause CPU throttling. In some cases it can be preferable to change the mode to C(high performance) to increase CPU performance.
       */
      win_power_plan?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Module manages AWS Config resources
       */
      aws_config_aggregator?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure Webhook object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_webhook?: {
        username?: string;
        /**
         * Callback url for the webhook.
         * Field introduced in 17.1.1.
         */
        callback_url?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Uuid of the webhook profile.
         * Field introduced in 17.1.1.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.1.1.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * The name of the webhook profile.
         * Field introduced in 17.1.1.
         */
        name: string;
        /**
         * Verification token sent back with the callback asquery parameters.
         * Field introduced in 17.1.1.
         */
        verification_token?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Field introduced in 17.1.1.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Create or delete or update firewall polices on Centurylink Cloud
       */
      clc_firewall_policy?: {
        /**
         * CLC alias for the destination account
         */
        destination_account_alias?: string;
        /**
         * The list of destination addresses for traffic on the terminating firewall. This is required when state is 'present'
         */
        destination?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: yes
         *
         * Whether the firewall policy is enabled or disabled
         */
        enabled?: true | false;
        /**
         * The list  of source addresses for traffic on the originating firewall. This is required when state is 'present'
         */
        source?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Whether to create or delete the firewall policy
         */
        state?: "present" | "absent";
        /**
         * Target datacenter for the firewall policy
         */
        location: string;
        /**
         * CLC alias for the source account
         */
        source_account_alias: string;
        /**
         * Id of the firewall policy. This is required to update or delete an existing firewall policy
         */
        firewall_policy_id?: string;
        /**
         * The list of ports associated with the policy. TCP and UDP can take in single ports or port ranges.
         */
        ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: yes
         *
         * Whether to wait for the provisioning tasks to finish before returning.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * Used to apply audit rules to files, folders or registry keys.
       * Once applied, it will begin recording the user who performed the operation defined into the Security Log in the Event viewer.
       * The behavior is designed to ignore inherited rules since those cannot be adjusted without first disabling the inheritance behavior. It will still print inherited rules in the output though for debugging purposes.
       */
      win_audit_rule?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module allows you to work with interface related configurations. The operators used are overloaded to ensure control over switch interface configurations. Apart from the regular device connection related attributes, there are seven interface arguments that will perform further configurations. They are interfaceArg1, interfaceArg2, interfaceArg3, interfaceArg4, interfaceArg5, interfaceArg6, and interfaceArg7. For more details on how to use these arguments, see [Overloaded Variables]. Interface configurations are taken care at six contexts in a regular CLI. They are 1. Interface Name - Configurations 2. Ethernet Interface - Configurations 3. Loopback Interface Configurations 4. Management Interface Configurations 5. Port Aggregation - Configurations 6. VLAN Configurations This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run.
       */
      cnos_interface?: {
        username?: string;
        password?: string;
        outputfile: string;
        /**
         * This specifies the attribute you specify subsequent to interface command
         */
        interfaceOption?: string;
        host?: string;
        deviceType: string;
        /**
         * This specifies the interface range in which the port channel is envisaged
         */
        interfaceRange?: string;
        /**
         * This is an overloaded interface fourth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg4?: string;
        /**
         * This is an overloaded interface fifth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg5?: string;
        /**
         * This is an overloaded interface sixth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg6?: string;
        /**
         * This is an overloaded interface seventh argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg7?: string;
        enablePassword?: string;
        /**
         * This is an overloaded interface first argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg1: string;
        /**
         * This is an overloaded interface second argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg2?: string;
        /**
         * This is an overloaded interface third argument. Usage of this argument can be found is the User Guide referenced above.
         */
        interfaceArg3?: string;
        [k: string]: unknown;
      };
      /**
       * This module can allocate or release an EIP.
       * This module can associate/disassociate an EIP with instances or network interfaces.
       */
      ec2_eip?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage server entities configuration.
       * This module is intended to run either on the ansible  control node or a bastion (jumpserver) with access to the actual netscaler instance.
       */
      netscaler_server?: {
        /**
         * Any information about the server.
         */
        comment?: string;
        /**
         * Time, in seconds, after which all the services configured on the server are disabled.
         * This option is meaningful only when setting the I(disabled) option to C(true)
         */
        delay?: number;
        /**
         * The netmask of the translation ip.
         */
        translationmask?: string;
        /**
         * Name for the server.
         * Must begin with an ASCII alphabetic or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters.
         * Can be changed after the name is created.
         * Minimum length = 1
         */
        name?: string;
        /**
         * Support IPv6 addressing mode. If you configure a server with the IPv6 addressing mode, you cannot use the server in the IPv4 addressing mode.
         */
        ipv6address?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        save_config?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 5
         *
         * Time, in seconds, for which the NetScaler appliance must wait, after DNS resolution fails, before sending the next DNS query to resolve the domain name.
         * Minimum value = C(5)
         * Maximum value = C(20939)
         */
        domainresolveretry?: number | string;
        state?: "present" | "absent";
        nitro_timeout?: number;
        /**
         * When set to C(true) the server state will be set to C(disabled).
         * When set to C(false) the server state will be set to C(enabled).
         * Note that due to limitations of the underlying NITRO API a C(disabled) state change alone does not cause the module result to report a changed status.
         */
        disabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nitro_protocol?: "http" | "https";
        nsip: string;
        /**
         * IP address used to transform the server's DNS-resolved IP address.
         */
        translationip?: string;
        nitro_user: string;
        /**
         * Domain name of the server. For a domain based configuration, you must create the server first.
         * Minimum length = 1
         */
        domain?: string;
        /**
         * Shut down gracefully, without accepting any new connections, and disabling each service when all of its connections are closed.
         * This option is meaningful only when setting the I(disabled) option to C(true)
         */
        graceful?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.
         * Minimum value = C(0)
         * Maximum value = C(4094)
         */
        td?: number;
        /**
         * IPv4 or IPv6 address of the server. If you create an IP address based server, you can specify the name of the server, instead of its IP address, when creating a service. Note: If you do not create a server entry, the server IP address that you enter when you create a service becomes the name of the server.
         */
        ipaddress?: string;
        nitro_pass: string;
        [k: string]: unknown;
      };
      /**
       * Runs I(puppet) agent or apply in a reliable manner.
       */
      puppet?: {
        [k: string]: unknown;
      };
      /**
       * This module allows you to work with virtual Link Aggregation Groups (vLAG) related configurations. The operators used are overloaded to ensure control over switch vLAG configurations. Apart from the regular device connection related attributes, there are four vLAG arguments which are overloaded variables that will perform further configurations. They are vlagArg1, vlagArg2, vlagArg3, and vlagArg4. For more details on how to use these arguments, see [Overloaded Variables]. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run.
       */
      cnos_vlag?: {
        username?: string;
        outputfile: string;
        /**
         * This is an overloaded vlag second argument. Usage of this argument can be found is the User Guide referenced above.
         */
        vlagArg2?: string;
        /**
         * This is an overloaded vlag third argument. Usage of this argument can be found is the User Guide referenced above.
         */
        vlagArg3?: string;
        /**
         * This is an overloaded vlag first argument. Usage of this argument can be found is the User Guide referenced above.
         */
        vlagArg1: string;
        /**
         * This is an overloaded vlag fourth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        vlagArg4?: string;
        host?: string;
        deviceType: string;
        password?: string;
        enablePassword?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or delete a network interface. When creating a network interface you must provide the name of an existing virtual network, the name of an existing subnet within the virtual network. A default security group and public IP address will be created automatically, or you can provide the name of an existing security group and public IP address. See the examples below for more details.
       */
      azure_rm_networkinterface?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Use the OpenShift Python client to perform CRUD operations on K8s objects.
       * Pass the object definition from a source file or inline. See examples for reading files and using Jinja templates.
       * Access to the full range of K8s APIs.
       * Use the M(k8s_facts) module to obtain a list of items about an object of type C(kind)
       * Authenticate using either a config file, certificates, password or token.
       * Supports check mode.
       */
      k8s?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows you to work with VLAN related configurations. The operators used are overloaded to ensure control over switch VLAN configurations. The first level of VLAN configuration allows to set up the VLAN range, the VLAN tag persistence, a VLAN access map and access map filter. After passing this level, there are five VLAN arguments that will perform further configurations. They are vlanArg1, vlanArg2, vlanArg3, vlanArg4, and vlanArg5. The value of vlanArg1 will determine the way following arguments will be evaluated. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run.
       */
      cnos_vlan?: {
        username?: string;
        outputfile: string;
        host?: string;
        /**
         * This is an overloaded vlan fifth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        vlanArg5?: string;
        /**
         * This is an overloaded vlan fourth argument. Usage of this argument can be found is the User Guide referenced above.
         */
        vlanArg4?: string;
        deviceType: string;
        /**
         * This is an overloaded vlan second argument. Usage of this argument can be found is the User Guide referenced above.
         */
        vlanArg2?: string;
        /**
         * This is an overloaded vlan first argument. Usage of this argument can be found is the User Guide referenced above.
         */
        vlanArg1: string;
        /**
         * This is an overloaded vlan third argument. Usage of this argument can be found is the User Guide referenced above.
         */
        vlanArg3?: string;
        password?: string;
        enablePassword?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or delete a route.
       */
      azure_rm_route?: {
        profile?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: none
         *
         * The type of Azure hop the packet should be sent to.
         */
        next_hop_type?: "virtual_network_gateway" | "vnet_local" | "internet" | "virtual_appliance" | "none";
        /**
         * name of the route.
         */
        name: string;
        /**
         * name of resource group.
         */
        resource_group: string;
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        /**
         * The IP address packets should be forwarded to.
         * Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
         */
        next_hop_ip_address?: string;
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        /**
         * Default: present
         *
         * Assert the state of the route. Use 'present' to create or update and 'absent' to delete.
         */
        state?: "absent" | "present";
        /**
         * The name of the route table.
         */
        route_table_name: string;
        /**
         * The destination CIDR to which the route applies.
         */
        address_prefix?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Add, modify or remove Windows share and set share permissions.
       */
      win_share?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        /**
         * Default: no
         *
         * Sets whether to encrypt the traffic to the share or not.
         */
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * The M(proxysql_global_variables) module gets or sets the proxysql global variables.
       */
      proxysql_global_variables?: {
        login_port?: number | string;
        config_file?: string;
        login_user?: string;
        login_host?: string;
        login_password?: string;
        /**
         * Defines a value the variable specified using I(variable) should be set to.
         */
        value?: string;
        login_unix_socket?: string;
        load_to_runtime?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        save_to_disk?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Defines which variable should be returned, or if I(value) is specified which variable should be updated.
         */
        variable: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about users available in Vultr.
       */
      vultr_user_facts?: {
        api_retries?: number | string;
        api_timeout?: number | string;
        api_endpoint?: string;
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create or delete VNICs on Solaris/illumos systems.
       */
      dladm_vnic?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Enable, disable ldap, and add ldap users
       */
      na_elementsw_ldap?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module provides declarative management of Layer-2 interface on Extreme slxos devices.
       */
      slxos_l2_interface?: {
        [k: string]: unknown;
      };
      /**
       * Use this module to add or remove hosts to a stacki front-end via API.
       * U(https://github.com/StackIQ/stacki)
       */
      stacki_host?: {
        /**
         * IP Address for the primary network interface.
         */
        prim_intf_ip?: string;
        network?: string;
        /**
         * Username for authenticating with Stacki API, but if not specified, the environment variable C(stacki_user) is used instead.
         */
        stacki_user: string;
        /**
         * URL for the Stacki API Endpoint.
         */
        stacki_endpoint: string;
        /**
         * Name of the primary network interface.
         */
        prim_intf?: string;
        appliance?: string;
        rank?: number | string;
        rack?: number | string;
        /**
         * Password for authenticating with Stacki API, but if not specified, the environment variable C(stacki_password) is used instead.
         */
        stacki_password: string;
        state?: "absent" | "present";
        /**
         * Set value to True to force node into install state if it already exists in stacki.
         */
        force_install?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * MAC Address for the primary PXE boot network interface.
         */
        prim_intf_mac?: string;
        /**
         * Name of the host to be added to Stacki.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of VRF definitions on Juniper JUNOS devices.  It allows playbooks to manage individual or the entire VRF collection.
       */
      junos_vrf?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * It configures VRF target community configuration. The target value takes the form of C(target:A:B) where C(A) and C(B) are both numeric values.
         */
        target?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Identifies the set of interfaces that should be configured in the VRF. Interfaces must be routed interfaces in order to be placed into a VRF.
         */
        interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Provides a short description of the VRF definition in the current active configuration.  The VRF definition value accepts alphanumeric characters used to provide additional information about the VRF.
         */
        description?: string;
        /**
         * Default: present
         *
         * Configures the state of the VRF definition as it relates to the device operational configuration.  When set to I(present), the VRF should be configured in the device active configuration and when set to I(absent) the VRF should not be in the device active configuration
         */
        state?: "present" | "absent";
        /**
         * The router-distinguisher value uniquely identifies the VRF to routing processes on the remote IOS system.  The RD value takes the form of C(A:B) where C(A) and C(B) are both numeric values.
         */
        rd?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The set of VRF definition objects to be configured on the remote JUNOS device.  Ths list entries can either be the VRF name or a hash of VRF definitions and attributes.  This argument is mutually exclusive with the C(name) argument.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Causes JUNOS to allocate a VPN label per VRF rather than per VPN FEC. This allows for forwarding of traffic to directly connected subnets, COS Egress filtering etc.
         */
        table_label?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        /**
         * Default: True
         *
         * Specifies whether or not the configuration is active or deactivated
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: string;
        /**
         * The name of the VRF definition to be managed on the remote IOS device.  The VRF definition name is an ASCII string name used to uniquely identify the VRF.  This argument is mutually exclusive with the C(aggregate) argument
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of VLANs on Extreme SLX-OS network devices.
       */
      slxos_vlan?: {
        /**
         * Default: 10
         *
         * Delay the play should wait to check for declarative intent params values.
         */
        delay?: number | string;
        /**
         * Name of the VLAN.
         */
        name?: string;
        /**
         * List of interfaces that should be associated to the VLAN.
         */
        interfaces?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Purge VLANs not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * State of the VLAN configuration.
         */
        state?: "present" | "absent";
        /**
         * List of VLANs definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * ID of the VLAN. Range 1-4094.
         */
        vlan_id?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure PKIProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_pkiprofile?: {
        username?: string;
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Creator name.
         */
        created_by?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * When enabled, avi will only validate the revocation status of the leaf certificate using crl.
         * To enable validation for the entire chain, disable this option and provide all the relevant crls.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        validate_only_leaf_crl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_version?: string;
        /**
         * Certificate revocation lists.
         */
        crls?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * When enabled, avi will not trust intermediate and root certs presented by a client.
         * Instead, only the chain certs configured in the certificate authority section will be used to verify trust of the client's cert.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        ignore_peer_chain?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant?: string;
        /**
         * Name of the pki profile.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * This field describes the object's replication scope.
         * If the field is set to false, then the object is visible within the controller-cluster and its associated service-engines.
         * If the field is set to true, then the object is replicated across the federation.
         * Field introduced in 17.1.3.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        is_federated?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of certificate authorities (root and intermediate) trusted that is used for certificate validation.
         */
        ca_certs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * When enabled, avi will verify via crl checks that certificates in the trust chain have not been revoked.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        crl_check?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Configure Element SW Node Network Interfaces for Bond 1G and 10G IP address.
       */
      na_elementsw_network_interfaces?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create, update, delete snapshot groups for NetApp E-series storage arrays
       */
      netapp_e_snapshot_group?: {
        /**
         * Default: 20
         *
         * The size of the repository in relation to the size of the base volume
         */
        repo_pct?: number | string;
        ssid: string;
        /**
         * Default: medium
         *
         * The importance of the rollback operation.
         * This value is overridden by consistency group setting if this snapshot group is associated with a consistency group
         */
        rollback_priority?: "highest" | "high" | "medium" | "low" | "lowest";
        /**
         * Default: 30
         *
         * The automatic deletion indicator.
         * If non-zero, the oldest snapshot image will be automatically deleted when creating a new snapshot image to keep the total number of snapshot images limited to the number specified.
         * This value is overridden by the consistency group setting if this snapshot group is associated with a consistency group.
         */
        delete_limit?: number | string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * The name to give the snapshot group
         */
        name: string;
        /**
         * Whether to ensure the group is present or absent.
         */
        state: "present" | "absent";
        /**
         * The name of the storage pool on which to allocate the repository volume.
         */
        storage_pool_name?: string;
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * The name of the base volume or thin volume to use as the base for the new snapshot group.
         * If a snapshot group with an identical C(name) already exists but with a different base volume an error will be returned.
         */
        base_volume_name: string;
        /**
         * Default: purgepit
         *
         * The behavior on when the data repository becomes full.
         * This value is overridden by consistency group setting if this snapshot group is associated with a consistency group
         */
        full_policy?: "unknown" | "failbasewrites" | "purgepit";
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 80
         *
         * The repository utilization warning threshold, as a percentage of the repository volume capacity.
         */
        warning_threshold?: number | string;
        [k: string]: unknown;
      };
      /**
       * Allows to post events to Datadog (www.datadoghq.com) service.
       * Uses http://docs.datadoghq.com/api/#events API.
       */
      datadog_event?: {
        /**
         * Default: now
         *
         * POSIX timestamp of the event.
         * Default value is now.
         */
        date_happened?: number | string;
        /**
         * Default: info
         *
         * Type of alert.
         */
        alert_type?: "error" | "warning" | "info" | "success";
        /**
         * The event title.
         */
        title: string;
        /**
         * The body of the event.
         */
        text: string;
        /**
         * Comma separated list of tags to apply to the event.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Your DataDog app key.
         */
        app_key: string;
        /**
         * Default: normal
         *
         * The priority of the event.
         */
        priority?: "normal" | "low";
        /**
         * Default: {{ ansible_hostname }}
         *
         * Host name to associate with the event.
         */
        host?: string;
        /**
         * An arbitrary string to use for aggregation.
         */
        aggregation_key?: string;
        /**
         * Your DataDog API key.
         */
        api_key: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Tests reachability using ping from switch to a remote destination.
       * For a general purpose network module, see the M(net_ping) module.
       * For Windows targets, use the M(win_ping) module instead.
       * For targets running Python, use the M(ping) module instead.
       */
      ios_ping?: {
        /**
         * Default: 5
         *
         * Number of packets to send.
         */
        count?: number | string;
        username?: string;
        ssh_keyfile?: string;
        /**
         * The IP Address or hostname (resolvable by switch) of the remote node.
         */
        dest: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Determines if the expected result is success or fail.
         */
        state?: "absent" | "present";
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The source IP Address.
         */
        source?: string;
        host?: string;
        /**
         * Default: default
         *
         * The VRF to use for forwarding.
         */
        vrf?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage local roles on an ESXi host
       */
      vmware_local_role_manager?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage BIG-IP global settings.
       */
      bigip_sys_global?: {
        /**
         * Specifies whether the system displays an advisory message on the login screen.
         */
        security_banner?: string;
        /**
         * Specifies, when C(enabled), that the next time you reboot the system, the system boots to an ISO image on the network, rather than an internal media drive.
         */
        net_reboot?: string;
        /**
         * Specifies the text to present in the advisory banner.
         */
        banner_text?: string;
        /**
         * Specifies the number of seconds of inactivity before the system logs off a user that is logged on.
         */
        console_timeout?: string;
        /**
         * Specifies, when C(enabled), that the system suppresses informational text on the console during the boot cycle. When C(disabled), the system presents messages and informational text on the console during the boot cycle.
         */
        quiet_boot?: string;
        /**
         * Specifies whether or not to enable DHCP client on the management interface
         */
        mgmt_dhcp?: string;
        /**
         * Default: present
         *
         * The state of the variable on the system. When C(present), guarantees that an existing variable is set to C(value).
         */
        state?: string;
        /**
         * C(enable) or C(disabled) the Setup utility in the browser-based Configuration utility.
         */
        gui_setup?: string;
        /**
         * Specifies, when C(enabled), that the system menu displays on the LCD screen on the front of the unit. This setting has no effect when used on the VE platform.
         */
        lcd_display?: string;
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running eos.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      eos_facts?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        host?: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "eapi";
        [k: string]: unknown;
      };
      /**
       * Used to register or deregister a target in a target group
       */
      elb_target?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * The C(slack) module sends notifications to U(http://slack.com) via the Incoming WebHook integration
       */
      slack?: {
        /**
         * Default: Ansible
         *
         * This is the sender of the message.
         */
        username?: string;
        /**
         * Slack (sub)domain for your environment without protocol. (i.e. C(example.slack.com)) In 1.8 and beyond, this is deprecated and may be ignored.  See token documentation for information.
         */
        domain?: string;
        /**
         * Define a list of attachments. This list mirrors the Slack JSON API.
         * For more information, see also in the (U(https://api.slack.com/docs/attachments)).
         */
        attachments?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: normal
         *
         * Allow text to use default colors - use the default of 'normal' to not send a custom color bar at the start of the message
         */
        color?: "normal" | "good" | "warning" | "danger";
        /**
         * Url for the message sender's icon (default C(https://www.ansible.com/favicon.ico))
         */
        icon_url?: string;
        /**
         * Setting for the message parser at Slack
         */
        parse?: "full" | "none";
        /**
         * Slack integration token.  This authenticates you to the slack service. Prior to 1.8, a token looked like C(3Ffe373sfhRE6y42Fg3rvf4GlK).  In 1.8 and above, ansible adapts to the new slack API where tokens look like C(G922VJP24/D921DW937/3Ffe373sfhRE6y42Fg3rvf4GlK).  If tokens are in the new format then slack will ignore any value of domain.  If the token is in the old format the domain is required.  Ansible has no control of when slack will get rid of the old API.  When slack does that the old format will stop working.  ** Please keep in mind the tokens are not the API tokens but are the webhook tokens.  In slack these are found in the webhook URL which are obtained under the apps and integrations. The incoming webhooks can be added in that area.  In some cases this may be locked by your Slack admin and you must request access.  It is there that the incoming webhooks can be added.  The key is on the end of the URL given to you in that section.
         */
        token: string;
        /**
         * Emoji for the message sender. See Slack documentation for options. (if I(icon_emoji) is set, I(icon_url) will not be used)
         */
        icon_emoji?: string;
        /**
         * Default: 1
         *
         * Automatically create links for channels and usernames in I(msg).
         */
        link_names?: number | string;
        /**
         * Message to send. Note that the module does not handle escaping characters. Plain-text angle brackets and ampersands should be converted to HTML entities (e.g. & to &amp;) before sending. See Slack's documentation (U(https://api.slack.com/docs/message-formatting)) for more.
         */
        msg?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Channel to send the message to. If absent, the message goes to the channel selected for the I(token).
         */
        channel?: string;
        [k: string]: unknown;
      };
      /**
       * Manages a variety of settings on GTM pool members. The settings that can be adjusted with this module are much more broad that what can be done in the C(bigip_gtm_pool) module. The pool module is intended to allow you to adjust the member order in the pool, not the various settings of the members. The C(bigip_gtm_pool_member) module should be used to adjust all of the other settings.
       */
      bigip_gtm_pool_member?: {
        /**
         * Specifies resource thresholds or limit requirements at the pool member level.
         * When you enable one or more limit settings, the system then uses that data to take members in and out of service.
         * You can define limits for any or all of the limit settings. However, when a member does not meet the resource threshold limit requirement, the system marks the member as unavailable and directs load-balancing traffic to another resource.
         */
        limits?: string;
        /**
         * Specifies the weight of the pool member for load balancing purposes.
         */
        ratio?: string;
        /**
         * Specifies the monitor assigned to this pool member.
         * Pool members only support a single monitor.
         * If the C(port) of the C(gtm_virtual_server) is C(*), the accepted values of this parameter will be affected.
         * When creating a new pool member, if this parameter is not specified, the default of C(default) will be used.
         * To remove the monitor from the pool member, use the value C(none).
         * For pool members created on different partitions, you can also specify the full path to the Common monitor. For example, C(/Common/tcp).
         */
        monitor?: string;
        /**
         * Specifies the GTM server which contains the C(virtual_server).
         */
        server_name?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the order in which the member will appear in the pool.
         * The system uses this number with load balancing methods that involve prioritizing pool members, such as the Ratio load balancing method.
         * When creating a new member using this module, if the C(member_order) parameter is not specified, it will default to C(0) (first member in the pool).
         */
        member_order?: string;
        /**
         * Default: present
         *
         * Pool member state. When C(present), ensures that the pool member is created and enabled. When C(absent), ensures that the pool member is removed from the system. When C(enabled) or C(disabled), ensures that the pool member is enabled or disabled (respectively) on the remote device.
         * It is recommended that you use the C(members) parameter of the C(bigip_gtm_pool) module when adding and removing members and it provides an easier way of specifying order. If this is not possible, then the C(state) parameter here should be used.
         * Remember that the order of the members will be affected if you add or remove them using this method. To some extent, this can be controlled using the C(member_order) parameter.
         */
        state?: string;
        /**
         * Specifies the name of the GTM virtual server which is assigned to the specified C(server).
         */
        virtual_server?: string;
        /**
         * The type of GTM pool that the member is in.
         */
        type?: string;
        /**
         * Name of the GTM pool.
         */
        pool?: string;
        /**
         * The description of the pool member.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running EXOS.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      exos_facts?: {
        /**
         * Default: ['!config']
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * This module provides an abstraction that enables and configures the netconf system service running on Cisco IOS-XR Software. This module can be used to easily enable the Netconf API. Netconf provides a programmatic interface for working with configuration and state resources as defined in RFC 6242.
       */
      iosxr_netconf?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * IPS packages are the native packages in Solaris 11 and higher.
       * This modules will configure which publishers a client will download IPS packages from.
       */
      pkg5_publisher?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Apstra AOS Device module let you manage your devices in AOS easily. You can approve devices and define in which state the device should be. Currently only the state I(normal) is supported but the goal is to extend this module with additional state. This module is idempotent and support the I(check) mode. It's using the AOS REST API.
       */
      aos_device?: {
        /**
         * The device serial-number; i.e. uniquely identifies the device in the AOS system. Only one of I(name) or I(id) can be set.
         */
        name?: string;
        /**
         * Default: normal
         *
         * Define in which state the device should be. Currently only I(normal) is supported but the goal is to add I(maint) and I(decomm).
         */
        state?: "normal";
        /**
         * An existing AOS session as obtained by M(aos_login) module.
         */
        session: {
          [k: string]: unknown;
        };
        /**
         * When approving a device using the I(approve) argument, it's possible define the location of the device.
         */
        location?: string;
        /**
         * Default: no
         *
         * The approve argument instruct the module to convert a device in quarantine mode into approved mode.
         */
        approve?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The AOS internal id for a device; i.e. uniquely identifies the device in the AOS system. Only one of I(name) or I(id) can be set.
         */
        id?: string;
        [k: string]: unknown;
      };
      /**
       * Manage BIG-IP partitions.
       */
      bigip_partition?: {
        /**
         * The default Route Domain to assign to the Partition. If no route domain is specified, then the default route domain for the system (typically zero) will be used only when creating a new partition.
         */
        route_domain?: string;
        /**
         * The description to attach to the Partition.
         */
        description?: string;
        /**
         * Name of the partition
         */
        name?: string;
        /**
         * Default: present
         *
         * Whether the partition should exist or not.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure HardwareSecurityModuleGroup object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_hardwaresecuritymodulegroup?: {
        username?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Uuid of the hsm group configuration object.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        controller?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Hardware security module configuration.
         */
        hsm: {
          [k: string]: unknown;
        };
        avi_credentials?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        /**
         * Name of the hsm group configuration object.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages VPN instance address family of HUAWEI CloudEngine switches.
       */
      ce_vrf_af?: {
        /**
         * VPN instance vpn target type.
         */
        vpn_target_type?: "export_extcommunity" | "import_extcommunity";
        username?: string;
        /**
         * Manage the state of the vpn target.
         */
        vpn_target_state?: "present" | "absent";
        ssh_keyfile?: string;
        /**
         * Default: v4
         *
         * VPN instance address family.
         */
        vrf_aftype?: "v4" | "v6";
        /**
         * VPN instance target value. Such as X.X.X.X:number<0-65535> or number<0-65535>:number<0-4294967295> or number<0-65535>.number<0-65535>:number<0-65535> or number<65536-4294967295>:number<0-65535> but not support 0:0 and 0.0:0.
         */
        vpn_target_value?: string;
        /**
         * Default: present
         *
         * Manage the state of the af.
         */
        state?: "present" | "absent";
        /**
         * Default: no
         *
         * Is extend vpn or normal vpn.
         */
        evpn?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        /**
         * VPN instance route distinguisher,the RD used to distinguish same route prefix from different vpn. The RD must be setted before setting vpn_target_value.
         */
        route_distinguisher?: string;
        /**
         * VPN instance.
         */
        vrf: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * This module can be used to manage acceptance level of an ESXi host.
       */
      vmware_host_acceptance?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about an ESXi host's services.
       */
      vmware_host_service_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Send code deploy and annotation events to Stackdriver
       */
      stackdriver?: {
        /**
         * The repository (or project) deployed
         */
        repository?: string;
        /**
         * Default: INFO
         *
         * one of INFO/WARN/ERROR, defaults to INFO if not supplied. May affect display.
         */
        level?: "INFO" | "WARN" | "ERROR";
        /**
         * Default: Ansible
         *
         * The person or robotwho the annotation should be attributed to.
         */
        annotated_by?: string;
        /**
         * Default: Ansible
         *
         * The person or robot responsible for deploying the code
         */
        deployed_by?: string;
        /**
         * The environment code was deployed to. (ie: development, staging, production)
         */
        deployed_to?: string;
        /**
         * id of an EC2 instance that this event should be attached to, which will limit the contexts where this event is shown
         */
        instance_id?: string;
        /**
         * API key.
         */
        key: string;
        /**
         * The contents of the annotation message, in plain text. Limited to 256 characters. Required for annotation.
         */
        msg?: string;
        /**
         * Unix timestamp of where the event should appear in the timeline, defaults to now. Be careful with this.
         */
        event_epoch?: string;
        /**
         * The revision of the code that was deployed. Required for deploy events
         */
        revision_id?: string;
        /**
         * The type of event to send, either annotation or deploy
         */
        event: "annotation" | "deploy";
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of static IP routes on Juniper JUNOS network devices.
       */
      junos_static_route?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or delete volumes and volume snapshots on Pure Storage FlashArray.
       */
      purefa_snap?: {
        /**
         * The name of the source volume.
         */
        name?: string;
        /**
         * Default: present
         *
         * Define whether the volume snapshot should exist or not.
         */
        state?: string;
        /**
         * Suffix of snapshot name.
         */
        suffix?: string;
        /**
         * Name of target volume if creating from snapshot.
         */
        target?: string;
        /**
         * Default: no
         *
         * Define whether to overwrite existing volume when creating from snapshot.
         */
        overwrite?: string;
        /**
         * Default: no
         *
         * Define whether to eradicate the snapshot on delete or leave in trash.
         */
        eradicate?: string;
        [k: string]: unknown;
      };
      /**
       * Manages filesystem user defined extended attributes, requires that they are enabled on the target filesystem and that the setfattr/getfattr utilities are present.
       */
      xattr?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manages MySQL server replication, slave, master status get and change master host.
       */
      mysql_replication?: {
        ssl_key?: string;
        /**
         * does the host uses GTID based replication or not
         */
        master_auto_position?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * same as mysql variable
         */
        master_ssl_cert?: string;
        login_user?: string;
        /**
         * same as mysql variable
         */
        master_port?: number | string;
        /**
         * same as mysql variable
         */
        master_host?: string;
        /**
         * same as mysql variable
         */
        master_ssl_ca?: string;
        /**
         * same as mysql variable
         */
        master_ssl_cipher?: string;
        /**
         * same as mysql variable
         */
        relay_log_file?: string;
        /**
         * same as mysql variable
         */
        master_log_pos?: number | string;
        connect_timeout?: number | string;
        /**
         * same as mysql variable
         */
        relay_log_pos?: number | string;
        /**
         * same as mysql variable
         */
        master_password?: string;
        config_file?: string;
        /**
         * same as mysql variable
         */
        master_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        login_host?: string;
        /**
         * same as mysql variable
         */
        master_ssl_capath?: string;
        login_unix_socket?: string;
        /**
         * same as mysql variable
         */
        master_connect_retry?: number | string;
        /**
         * same as mysql variable
         */
        master_user?: string;
        login_password?: string;
        /**
         * same as mysql variable
         */
        master_log_file?: string;
        login_port?: number | string;
        ssl_cert?: string;
        ssl_ca?: string;
        /**
         * same as mysql variable
         */
        master_ssl_key?: string;
        /**
         * Default: getslave
         *
         * module operating mode. Could be getslave (SHOW SLAVE STATUS), getmaster (SHOW MASTER STATUS), changemaster (CHANGE MASTER TO), startslave (START SLAVE), stopslave (STOP SLAVE), resetslave (RESET SLAVE), resetslaveall (RESET SLAVE ALL)
         */
        mode?: "getslave" | "getmaster" | "changemaster" | "stopslave" | "startslave" | "resetslave" | "resetslaveall";
        [k: string]: unknown;
      };
      /**
       * Manage UDP profiles on a BIG-IP. Many of UDP profiles exist; each with their own adjustments to the standard C(udp) profile. Users of this module should be aware that many of the adjustable knobs have no module default. Instead, the default is assigned by the BIG-IP system itself which, in most cases, is acceptable.
       */
      bigip_profile_udp?: {
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the name of the profile.
         */
        name?: string;
        /**
         * Specifies the profile from which this profile inherits settings.
         * When creating a new profile, if this parameter is not specified, the default is the system-supplied C(udp) profile.
         */
        parent?: string;
        /**
         * Specifies, when C(yes), that the system load balances UDP traffic packet-by-packet.
         */
        datagram_load_balancing?: string;
        /**
         * Specifies the length of time that a connection is idle (has no traffic) before the connection is eligible for deletion.
         * When creating a new profile, if this parameter is not specified, the remote device will choose a default value appropriate for the profile, based on its C(parent) profile.
         * When a number is specified, indicates the number of seconds that the UDP connection can remain idle before the system deletes it.
         * When C(0), or C(indefinite), specifies that UDP connections can remain idle indefinitely.
         * When C(immediate), specifies that you do not want the UDP connection to remain idle, and that it is therefore immediately eligible for deletion.
         */
        idle_timeout?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the profile exists.
         * When C(absent), ensures the profile is removed.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 Auto Scaling Groups (ASGs) in AWS
       */
      ec2_asg_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or Remove images from the OpenStack Image Repository
       */
      os_image?: {
        /**
         * The name of an existing ramdisk image that will be associated with this image
         */
        ramdisk?: string;
        /**
         * The name of an existing kernel image that will be associated with this image
         */
        kernel?: string;
        /**
         * Additional properties to be associated with this image
         */
        properties?: string;
        /**
         * Name that has to be given to the image
         */
        name?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Default: bare
         *
         * The format of the container
         */
        container_format?: string;
        /**
         * The minimum ram (in MB) required to boot this image
         */
        min_ram?: string;
        /**
         * Default: qcow2
         *
         * The format of the disk that is getting uploaded
         */
        disk_format?: string;
        /**
         * The path to the file which has to be uploaded
         */
        filename?: string;
        /**
         * The minimum disk space (in GB) required to boot this image
         */
        min_disk?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * The checksum of the image
         */
        checksum?: string;
        /**
         * The owner of the image
         */
        owner?: string;
        /**
         * Default: yes
         *
         * Whether the image can be accessed publicly. Note that publicizing an image requires admin role by default.
         */
        is_public?: string;
        /**
         * The Id of the image
         */
        id?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about firewall groups available in Vultr.
       */
      vultr_firewall_group_facts?: {
        api_retries?: number | string;
        api_timeout?: number | string;
        api_endpoint?: string;
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create or delete VLAN interfaces on Solaris/illumos systems.
       */
      dladm_vlan?: {
        [k: string]: unknown;
      };
      /**
       * Gather facts about regions available to boot servers.
       */
      vultr_region_facts?: {
        api_retries?: number | string;
        api_timeout?: number | string;
        api_endpoint?: string;
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages Elasticsearch plugins.
       */
      elasticsearch_plugin?: {
        /**
         * Optionally set the source location to retrieve the plugin from. This can be a file:// URL to install from a local file, or a remote URL. If this is not set, the plugin location is just based on the name.
         * The name parameter must match the descriptor in the plugin ZIP specified.
         * Is only used if the state would change, which is solely checked based on the name parameter. If, for example, the plugin is already installed, changing this has no effect.
         * For ES 1.x use url.
         */
        src?: string;
        /**
         * Force batch mode when installing plugins. This is only necessary if a plugin requires additional permissions and console detection fails.
         */
        force?: string;
        /**
         * Location of the plugin binary. If this file is not found, the default plugin binaries will be used.
         * The default changed in Ansible 2.4 to None.
         */
        plugin_bin?: string;
        /**
         * Proxy host to use during plugin installation
         */
        proxy_host?: string;
        /**
         * Set exact URL to download the plugin from (Only works for ES 1.x).
         * For ES 2.x and higher, use src.
         */
        url?: string;
        /**
         * Proxy port to use during plugin installation
         */
        proxy_port?: string;
        /**
         * Default: present
         *
         * Desired state of a plugin.
         */
        state?: "present" | "absent";
        /**
         * Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated
         */
        version?: string;
        /**
         * Default: 1m
         *
         * Timeout setting: 30s, 1m, 1h...
         * Only valid for Elasticsearch < 5.0. This option is ignored for Elasticsearch > 5.0.
         */
        timeout?: string;
        /**
         * Default: /usr/share/elasticsearch/plugins/
         *
         * Your configured plugin directory specified in Elasticsearch
         */
        plugin_dir?: string;
        /**
         * Name of the plugin to install.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * modify the UC adapter mode and type taking pending type and mode into account.
       */
      na_ontap_ucadapter?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module can be used to gather facts about NTP configurations on an ESXi host.
       */
      vmware_host_ntp_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP Router
       */
      gcp_compute_router_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * Region where the router resides.
         */
        region: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        service_account_file?: string;
        [k: string]: unknown;
      };
      /**
       * Used to test the management connection to the cluster.
       * The test pings the MVIP and SVIP, and executes a simple API method to verify connectivity.
       */
      na_elementsw_check_connections?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * The M(proxysql_mysql_users) module adds or removes mysql users using the proxysql admin interface.
       */
      proxysql_mysql_users?: {
        /**
         * If there is no matching rule for the queries sent by this user, the traffic it generates is sent to the specified hostgroup. If omitted the proxysql database default for I(use_ssl) is 0.
         */
        default_hostgroup?: number | string;
        /**
         * Name of the user connecting to the mysqld or ProxySQL instance.
         */
        username: string;
        /**
         * Default: True
         *
         * If I(frontend) is set to C(True), this (username, password) pair is used for authenticating to the mysqld servers against any hostgroup.
         */
        frontend?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The schema to which the connection should change to by default.
         */
        default_schema?: string;
        /**
         * If this is set for the user with which the MySQL client is connecting to ProxySQL (thus a "frontend" user), transactions started within a hostgroup will remain within that hostgroup regardless of any other rules. If omitted the proxysql database default for I(transaction_persistent) is C(False).
         */
        transaction_persistent?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        login_port?: number | string;
        login_user?: string;
        login_host?: string;
        login_password?: string;
        /**
         * If I(use_ssl) is set to C(True), connections by this user will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).
         */
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: True
         *
         * If I(backend) is set to C(True), this (username, password) pair is used for authenticating to the ProxySQL instance.
         */
        backend?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        login_unix_socket?: string;
        /**
         * Default: present
         *
         * When C(present) - adds the user, when C(absent) - removes the user.
         */
        state?: "present" | "absent";
        /**
         * If I(fast_forward) is set to C(True), I(fast_forward) will bypass the query processing layer (rewriting, caching) and pass through the query directly as is to the backend server. If omitted the proxysql database default for I(fast_forward) is C(False).
         */
        fast_forward?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_to_runtime?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        save_to_disk?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A user with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures. If omitted the proxysql database default for I(active) is C(True).
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        config_file?: string;
        /**
         * Password of the user connecting to the mysqld or ProxySQL instance.
         */
        password?: string;
        /**
         * The maximum number of connections ProxySQL will open to the backend for this user. If omitted the proxysql database default for I(max_connections) is 10000.
         */
        max_connections?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides configuration file management of VyOS devices.  It provides arguments for managing both the configuration file and state of the active configuration.   All configuration statements are based on `set` and `delete` commands in the device configuration.
       */
      vyos_config?: {
        /**
         * Default: configured by vyos_config
         *
         * Allows a commit description to be specified to be included when the configuration is committed.  If the configuration is not changed or committed, this argument is ignored.
         */
        comment?: string;
        /**
         * The C(src) argument specifies the path to the source config file to load.  The source config file can either be in bracket format or set format.  The source file can include Jinja2 template variables.
         */
        src?: string;
        ssh_keyfile?: string;
        /**
         * Default: no
         *
         * The C(save) argument controls whether or not changes made to the active configuration are saved to disk.  This is independent of committing the config.  When set to True, the active configuration is saved.
         */
        save?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The C(config) argument specifies the base configuration to use to compare against the desired configuration.  If this value is not specified, the module will automatically retrieve the current active configuration from the remote device.
         */
        config?: string;
        /**
         * The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.
         */
        lines?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        username?: string;
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Default: no
         *
         * The C(backup) argument will backup the current devices active configuration to the Ansible control host prior to making any changes.  The backup file will be located in the backup folder in the playbook root directory or role root directory, if playbook is part of an ansible role. If the directory does not exist, it is created.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        /**
         * Default: line
         *
         * The C(match) argument controls the method used to match against the current active configuration.  By default, the desired config is matched against the active config and the deltas are loaded.  If the C(match) argument is set to C(none) the active configuration is ignored and the configuration is always loaded.
         */
        match?: "line" | "none";
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Layer-3 interfaces on IOS network devices.
       */
      ios_l3_interface?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        provider?: {
          [k: string]: unknown;
        };
        ssh_keyfile?: string;
        /**
         * Name of the Layer-3 interface to be configured eg. GigabitEthernet0/2
         */
        name?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of the Layer-3 interface configuration. It indicates if the configuration should be present or absent on remote device.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * IPv4 address to be set for the Layer-3 interface mentioned in I(name) option. The address format is <ipv4 address>/<mask>, the mask is number in range 0-32 eg. 192.168.0.1/24
         */
        ipv4?: string;
        timeout?: number | string;
        /**
         * IPv6 address to be set for the Layer-3 interface mentioned in I(name) option. The address format is <ipv6 address>/<mask>, the mask is number in range 0-128 eg. fd5d:12c9:2201:1::1/64
         */
        ipv6?: string;
        /**
         * List of Layer-3 interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and a optional C(ipv4) or C(ipv6) address.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage OpenStack Projects. Projects can be created, updated or deleted using this module. A project will be updated if I(name) matches an existing project and I(state) is present. The value for I(name) cannot be updated without deleting and re-creating the project.
       */
      os_project?: {
        /**
         * Description for the project
         */
        description?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Default: yes
         *
         * Is the project enabled
         */
        enabled?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Domain id to create the project in if the cloud supports domains.
         */
        domain_id?: string;
        /**
         * Name for the project
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manage the SSHD settings of a BIG-IP.
       */
      bigip_device_sshd?: {
        /**
         * Specifies the minimum SSHD message level to include in the system log.
         */
        log_level?: string;
        /**
         * Specifies the text to include on the pre-login banner that displays when a user attempts to login to the system using SSH.
         */
        banner_text?: string;
        /**
         * Specifies, if you have enabled SSH access, the IP address or address range for other systems that can use SSH to communicate with this system.
         * To specify all addresses, use the value C(all).
         * IP address can be specified, such as 172.27.1.10.
         * IP rangees can be specified, such as 172.27.*.* or 172.27.0.0/255.255.0.0.
         */
        allow?: string;
        /**
         * Specifies the number of seconds before inactivity causes an SSH session to log out.
         */
        inactivity_timeout?: string;
        /**
         * Specifies, when checked C(enabled), that the system accepts SSH communications.
         */
        login?: string;
        /**
         * Whether to enable the banner or not.
         */
        banner?: string;
        /**
         * Port that you want the SSH daemon to run on.
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * Create, modify, and delete RDS instances.
       */
      rds_instance?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manages ZFS file systems, volumes, clones and snapshots
       */
      zfs?: {
        createparent?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Snapshot from which to create a clone.
         */
        origin?: string;
        /**
         * Whether to create (C(present)), or remove (C(absent)) a file system, snapshot or volume. All parents/children will be created/destroyed as needed to reach the desired state.
         */
        state: "absent" | "present";
        /**
         * A dictionary of zfs properties to be set.
         * See the zfs(8) man page for more information.
         */
        extra_zfs_properties?: {
          [k: string]: unknown;
        };
        /**
         * File system, snapshot or volume name e.g. C(rpool/myfs).
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and remove users.
       */
      vultr_user?: {
        [k: string]: unknown;
      };
      /**
       * Interacts with HTTP and HTTPS web services and supports Digest, Basic and WSSE HTTP authentication mechanisms.
       * For Windows targets, use the M(win_uri) module instead.
       */
      uri?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Collects facts from CloudEngine devices running the CloudEngine operating system.  Fact collection is supported over Cli transport.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      ce_facts?: {
        username?: string;
        ssh_keyfile?: string;
        host?: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * This module manage tags in oVirt/RHV. It can also manage assignments of those tags to entities.
       */
      ovirt_tag?: {
        /**
         * Name of the tag to manage.
         */
        name: string;
        /**
         * Name of the parent tag.
         */
        parent?: string;
        poll_interval?: number | string;
        fetch_nested?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        nested_attributes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Should the tag be present/absent/attached/detached.
         * C(Note): I(attached) and I(detached) states are supported since version 2.4.
         */
        state?: "present" | "absent" | "attached" | "detached";
        /**
         * List of the hosts names, which should have assigned this tag.
         */
        hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth: {
          [k: string]: unknown;
        };
        timeout?: number | string;
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of the VMs names, which should have assigned this tag.
         */
        vms?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Description of the tag to manage.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manages snapshots for GCE instances. This module manages snapshots for the storage volumes of a GCE compute instance. If there are multiple volumes, each snapshot will be prepended with the disk name
       */
      gce_snapshot?: {
        /**
         * GCP service account email for the project where the instance resides
         */
        service_account_email?: string;
        /**
         * Default: all
         *
         * A list of disks to create snapshots for. If none is provided, all of the volumes will be snapshotted
         */
        disks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The GCE instance to snapshot
         */
        instance_name: string;
        /**
         * Default: present
         *
         * Whether a snapshot should be C(present) or C(absent)
         */
        state?: "present" | "absent";
        /**
         * The name of the snapshot to manage
         */
        snapshot_name: string;
        /**
         * The path to the credentials file associated with the service account
         */
        credentials_file?: string;
        /**
         * The GCP project ID to use
         */
        project_id?: string;
        [k: string]: unknown;
      };
      /**
       * Manages configuration of an OSPF instance on HUAWEI CloudEngine switches.
       */
      ce_ospf?: {
        /**
         * Specifies the authentication type.
         */
        auth_mode?: "none" | "hmac-sha256" | "md5" | "hmac-md5" | "simple";
        /**
         * Specifies a password for simple authentication. The value is a string of 1 to 8 characters.
         */
        auth_text_simple?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Indicates the weight of the next hop. The smaller the value is, the higher the preference of the route is. It is an integer that ranges from 1 to 254.
         */
        nexthop_weight?: string;
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Specifies the address of the network segment where the interface resides. The value is in dotted decimal notation.
         */
        addr?: string;
        /**
         * Specifies the area ID. The area with the area-id being 0 is a backbone area. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer between 1 and 4294967295.
         */
        area?: string;
        /**
         * Authentication key id when C(auth_mode) is 'hmac-sha256', 'md5' or 'hmac-md5. Valid value is an integer is in the range from 1 to 255.
         */
        auth_key_id?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        timeout?: number | string;
        host?: string;
        /**
         * Specifies a process ID. The value is an integer ranging from 1 to 4294967295.
         */
        process_id: string;
        password?: string;
        ssh_keyfile?: string;
        /**
         * The maximum number of paths for forward packets over multiple paths. Valid value is an integer in the range from 1 to 64.
         */
        max_load_balance?: string;
        /**
         * IP network wildcard bits in decimal format between 0 and 32.
         */
        mask?: string;
        /**
         * IPv4 address for configure next-hop address's weight. Valid values are a string, formatted as an IP address.
         */
        nexthop_addr?: string;
        /**
         * Specifies a password for MD5, HMAC-MD5, or HMAC-SHA256 authentication. The value is a string of 1 to 255 case-sensitive characters, spaces not supported.
         */
        auth_text_md5?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Gather facts about DNS domains available in Vultr.
       */
      vultr_dns_domain_facts?: {
        api_retries?: number | string;
        api_timeout?: number | string;
        api_endpoint?: string;
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Add or remove a static route.
       */
      win_route?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Gathers facts from nginx from an URL having C(stub_status) enabled.
       */
      nginx_status_facts?: {
        /**
         * URL of the nginx status.
         */
        url: string;
        /**
         * Default: 10
         *
         * HTTP connection timeout in seconds.
         */
        timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Enable or disable NFS on ONTAP
       */
      na_ontap_nfs?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This is a wrapper module around keytool. Which can be used to import/remove certificates from a given java keystore.
       */
      java_cert?: {
        /**
         * Create keystore if it doesn't exist
         */
        keystore_create?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Imported certificate alias.
         */
        cert_alias?: string;
        /**
         * Default: keytool
         *
         * Path to keytool binary if not used we search in PATH for it.
         */
        executable?: string;
        /**
         * Password for importing from PKCS12 keystore.
         */
        pkcs12_password?: string;
        /**
         * Default: 443
         *
         * Port to connect to URL. This will be used to create server URL:PORT
         */
        cert_port?: number | string;
        /**
         * Default: 1
         *
         * Alias in the PKCS12 keystore.
         */
        pkcs12_alias?: string;
        /**
         * Default: present
         *
         * Defines action which can be either certificate import or removal.
         */
        state?: "absent" | "present";
        /**
         * Keystore password.
         */
        keystore_pass: string;
        /**
         * Local path to load certificate from. One of cert_url or cert_path is required to load certificate.
         */
        cert_path?: string;
        /**
         * Basic URL to fetch SSL certificate from. One of cert_url or cert_path is required to load certificate.
         */
        cert_url?: string;
        /**
         * Local path to load PKCS12 keystore from.
         */
        pkcs12_path?: string;
        /**
         * Path to keystore.
         */
        keystore_path?: string;
        [k: string]: unknown;
      };
      /**
       * Controls services on target hosts that use the SysV init system.
       */
      sysvinit?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Manage license installation and activation on a BIG-IP.
       */
      bigip_device_license?: {
        /**
         * The registration key to use to license the BIG-IP.
         * This parameter is required if the C(state) is equal to C(present).
         * This parameter is not required when C(state) is C(absent) and will be ignored if it is provided.
         */
        license_key?: string;
        /**
         * Default: activate.f5.com
         *
         * The F5 license server to use when getting a license and validating a dossier.
         * This parameter is required if the C(state) is equal to C(present).
         * This parameter is not required when C(state) is C(absent) and will be ignored if it is provided.
         */
        license_server?: string;
        /**
         * Declares whether you accept the BIG-IP EULA or not. By default, this value is C(no). You must specifically declare that you have viewed and accepted the license. This module will not present you with that EULA though, so it is incumbent on you to read it.
         * The EULA can be found here; https://support.f5.com/csp/article/K12902.
         * This parameter is not required when C(state) is C(absent) and will be ignored if it is provided.
         */
        accept_eula?: string;
        /**
         * Default: present
         *
         * The state of the license on the system.
         * When C(present), only guarantees that a license is there.
         * When C(latest), ensures that the license is always valid.
         * When C(absent), removes the license on the system.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * This module will insert/update/remove a block of multi-line text surrounded by customizable marker lines.
       */
      blockinfile?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Module manages AWS Config configuration recorder settings
       */
      aws_config_recorder?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Pauses playbook execution for a set amount of time, or until a prompt is acknowledged. All parameters are optional. The default behavior is to pause with a prompt.
       * To pause/wait/sleep per host, use the M(wait_for) module.
       * You can use C(ctrl+c) if you wish to advance a pause earlier than it is set to expire or if you need to abort a playbook run entirely. To continue early press C(ctrl+c) and then C(c). To abort a playbook press C(ctrl+c) and then C(a).
       * The pause module integrates into async/parallelized playbooks without any special considerations (see Rolling Updates). When using pauses with the C(serial) playbook parameter (as in rolling updates) you are only prompted once for the current group of hosts.
       * This module is also supported for Windows targets.
       */
      pause?: {
        active_connection_states?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        connect_timeout?: number | string;
        delay?: number | string;
        search_regex?: string;
        state?: "absent" | "drained" | "present" | "started" | "stopped";
        sleep?: number | string;
        timeout?: number | string;
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        msg?: string;
        path?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of L3 interfaces on Arista EOS network devices.
       */
      eos_l3_interface?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Name of the L3 interface to be configured eg. ethernet1
         */
        name?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of the L3 interface configuration. It indicates if the configuration should be present or absent on remote device.
         */
        state?: "present" | "absent";
        /**
         * IPv6 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv6 address>/<mask>, the mask is number in range 0-128 eg. fd5d:12c9:2201:1::1/64
         */
        ipv6?: string;
        host?: string;
        /**
         * IPv4 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv4 address>/<mask>, the mask is number in range 0-32 eg. 192.168.0.1/24
         */
        ipv4?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of L3 interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and a optional C(ipv4) or C(ipv6) address.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "eapi";
        [k: string]: unknown;
      };
      /**
       * Manages licenses in a BIG-IQ registration key pool.
       */
      bigiq_regkey_license?: {
        /**
         * The license key to put in the pool.
         */
        license_key?: string;
        /**
         * The registration key pool that you want to place the license in.
         * You must be mindful to name your registration pools unique names. While BIG-IQ does not require this, this module does. If you do not do this, the behavior of the module is undefined and you may end up putting licenses in the wrong registration key pool.
         */
        regkey_pool?: string;
        /**
         * A key that signifies that you accept the F5 EULA for this license.
         * A copy of the EULA can be found here https://askf5.f5.com/csp/article/K12902
         * This is required when C(state) is C(present).
         */
        accept_eula?: string;
        /**
         * Description of the license.
         */
        description?: string;
        /**
         * Default: present
         *
         * The state of the regkey license in the pool on the system.
         * When C(present), guarantees that the license exists in the pool.
         * When C(absent), removes the license from the pool.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of L2 interfaces on Arista EOS network devices.
       */
      eos_l2_interface?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add, modify and delete group within IPA server
       */
      ipa_group?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an Extreme EXOS device and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running configuration commands. Please use M(exos_config) to configure EXOS devices.
       */
      exos_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        /**
         * List of commands to send to the remote EXOS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: "any" | "all";
        [k: string]: unknown;
      };
      /**
       * Apply an authcode to a device.
       * The authcode should have been previously registered on the Palo Alto Networks support portal.
       * The device should have Internet access.
       */
      panos_lic?: {
        username?: string;
        ip_address: string;
        password: string;
        /**
         * Default: false
         *
         * whether to apply authcode even if device is already licensed
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * authcode to be applied
         */
        auth_code?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete records.
       */
      exo_dns_record?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module offers the ability to set the VNI and mapped to the BD, and configure an ingress replication list on HUAWEI CloudEngine devices.
       */
      ce_vxlan_tunnel?: {
        username?: string;
        /**
         * Specifies a VXLAN network identifier (VNI) ID. The value is an integer ranging from 1 to 16000000.
         */
        vni_id?: string;
        ssh_keyfile?: string;
        /**
         * Specifies the working mode of an NVE interface.
         */
        nve_mode?: "mode-l2" | "mode-l3";
        /**
         * Specifies an IP address for a source VTEP. The value is in dotted decimal notation.
         */
        source_ip?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.
         */
        bridge_domain_id?: string;
        /**
         * Specifies the number of an NVE interface. The value ranges from 1 to 2.
         */
        nve_name?: string;
        /**
         * Specifies the IP address of a remote VXLAN tunnel endpoints (VTEP). The value is in dotted decimal notation.
         */
        peer_list_ip?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        /**
         * The operation type of routing protocol.
         */
        protocol_type?: "bgp" | "null";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Manages configuration of an Protocol Independent Multicast (PIM) static rendezvous point (RP) address instance.
       */
      nxos_pim_rp_address?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        /**
         * Group range is treated in PIM bidirectional mode.
         */
        bidir?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Route map policy for static RP. Valid values are route-map policy names.
         */
        route_map?: string;
        auth_pass?: string;
        /**
         * Configures a Protocol Independent Multicast (PIM) static rendezvous point (RP) address. Valid values are unicast addresses.
         */
        rp_address: string;
        /**
         * Group range for static RP. Valid values are multicast addresses.
         */
        group_list?: string;
        /**
         * Prefix list policy for static RP. Valid values are prefix-list policy names.
         */
        prefix_list?: string;
        host?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * This module allows you to work with the running configuration of a switch. It provides a way to execute a set of CNOS commands on a switch by evaluating the current running configuration and executing the commands only if the specific settings have not been already configured. The configuration source can be a set of commands or a template written in the Jinja2 templating language. This module uses SSH to manage network device configuration. The results of the operation will be placed in a directory named 'results' that must be created by the user in their local directory to where the playbook is run.
       */
      cnos_template?: {
        username?: string;
        outputfile: string;
        host?: string;
        deviceType: string;
        password?: string;
        enablePassword?: string;
        /**
         * This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. Note The command file must contain the Ansible keyword {{ inventory_hostname }} in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_{{ inventory_hostname }}_commands.txt
         */
        commandfile: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove Pulp repos from a remote host.
       */
      pulp_repo?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Ordnance router configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with these configuration sections in a deterministic way.
       */
      ordnance_config?: {
        [k: string]: unknown;
      };
      /**
       * Sends a text message to a phone number through the Twilio messaging API.
       */
      twilio?: {
        /**
         * user's Twilio authentication token
         */
        auth_token: string;
        /**
         * one or more phone numbers to send the text message to, format +15551112222
         */
        to_number: string;
        /**
         * user's Twilio account token found on the account page
         */
        account_sid: string;
        /**
         * the Twilio number to send the text message from, format +15551112222
         */
        from_number: string;
        /**
         * the body of the text message
         */
        msg: string;
        /**
         * a URL with a picture, video or sound clip to send with an MMS (multimedia message) instead of a plain SMS
         */
        media_url?: string;
        [k: string]: unknown;
      };
      /**
       * Manages STP configurations on HUAWEI CloudEngine switches.
       */
      ce_stp?: {
        /**
         * Enable loop protection on the current port.
         */
        loop_protection?: "enable" | "disable";
        /**
         * Set the path cost of the current port. The default instance is 0.
         */
        cost?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Configure the TC BPDU protection function for an MSTP process.
         */
        tc_protection?: "enable" | "disable";
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Set an operation mode for the current MSTP process. The mode can be STP, RSTP, or MSTP.
         */
        stp_mode?: "stp" | "rstp" | "mstp";
        /**
         * Enable root protection on the current port.
         */
        root_protection?: "enable" | "disable";
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * STP convergence mode. Fast means set STP aging mode to Fast. Normal means set STP aging mode to Normal.
         */
        stp_converge?: "fast" | "normal";
        /**
         * Set the current port as an edge port.
         */
        edged_port?: "enable" | "disable";
        /**
         * Configure BPDU protection on an edge port. This function prevents network flapping caused by attack packets.
         */
        bpdu_protection?: "enable" | "disable";
        host?: string;
        /**
         * Enable or disable STP on a switch.
         */
        stp_enable?: "enable" | "disable";
        /**
         * Interface name. If the value is C(all), will apply configuration to all interfaces. if the value is a special name, only support input the full name.
         */
        interface?: string;
        password?: string;
        /**
         * Set the time the MSTP device takes to handle the maximum number of TC BPDUs and immediately refresh forwarding entries. The value is an integer ranging from 1 to 600, in seconds.
         */
        tc_protection_interval?: string;
        ssh_keyfile?: string;
        /**
         * Set the maximum number of TC BPDUs that the MSTP can handle. The value is an integer ranging from 1 to 255. The default value is 1 on the switch.
         */
        tc_protection_threshold?: string;
        /**
         * Specify a port as a BPDU filter port.
         */
        bpdu_filter?: "enable" | "disable";
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Perform server actions on an existing compute instance from OpenStack. This module does not return any data other than changed true/false. When I(action) is 'rebuild', then I(image) parameter is required.
       */
      os_server_action?: {
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Image the server should be rebuilt with
         */
        image?: string;
        /**
         * Name or ID of the instance
         */
        server?: string;
        /**
         * Default: 180
         *
         * The amount of time the module should wait for the instance to perform the requested action.
         */
        timeout?: string;
        /**
         * Default: present
         *
         * Perform the given action. The lock and unlock actions always return changed as the servers API does not provide lock status.
         */
        action?: string;
        /**
         * Default: yes
         *
         * If the module should wait for the instance action to be performed.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * This module will let you create PagerDuty maintenance windows
       */
      pagerduty?: {
        [k: string]: unknown;
      };
      /**
       * Manage binary packages for FreeBSD using 'pkgng' which is available in versions after 9.0.
       */
      pkgng?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Modify global configuration settings of a FreeIPA Server.
       */
      ipa_config?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP InstanceTemplate
       */
      gcp_compute_instance_template_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Send a SMS message via nexmo
       */
      nexmo?: {
        [k: string]: unknown;
      };
      /**
       * Create, update, and delete MCP 1.0 & 2.0 networks
       */
      dimensiondata_network?: {
        /**
         * Default: ESSENTIALS
         *
         * The service plan, either "ESSENTIALS" or "ADVANCED".
         * MCP 2.0 Only.
         */
        service_plan?: "ESSENTIALS" | "ADVANCED";
        mcp_user?: string;
        wait_poll_interval?: number | string;
        mcp_password?: string;
        region?: string;
        /**
         * The name of the network domain to create.
         */
        name: string;
        wait_time?: number | string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: "present" | "absent";
        location: string;
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Additional description of the network domain.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Configure a .deb package using debconf-set-selections. Or just query existing selections.
       */
      debconf?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create a security profile group
       */
      panos_pg?: {
        /**
         * name of the wildfire analysis profile
         */
        wildfire?: string;
        username?: string;
        /**
         * name of the data filtering profile
         */
        data_filtering?: string;
        /**
         * name of the file blocking profile
         */
        file_blocking?: string;
        /**
         * name of the security profile group
         */
        pg_name: string;
        /**
         * name of the vulnerability profile
         */
        vulnerability?: string;
        /**
         * name of the spyware profile
         */
        spyware?: string;
        /**
         * name of the url filtering profile
         */
        url_filtering?: string;
        /**
         * name of the anti-virus profile
         */
        virus?: string;
        /**
         * Default: yes
         *
         * commit if changed
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password: string;
        ip_address: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, or destroy Ansible Tower job templates. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_job_template?: {
        /**
         * Default: no
         *
         * Prompt user to enable diff mode (show changes) to files when supported by modules.
         */
        ask_diff_mode?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Prompt user for a limit on launch.
         */
        ask_limit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_password?: string;
        /**
         * The job type to use for the job template.
         */
        job_type: "run" | "check" | "scan";
        /**
         * Default: no
         *
         * Prompt user for job type on launch.
         */
        ask_job_type?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        /**
         * Comma separated list of the tags to skip for the job template.
         */
        skip_tags?: string;
        /**
         * Path to the playbook to use for the job template within the project provided.
         */
        playbook: string;
        tower_username?: string;
        /**
         * Default: no
         *
         * Enable a survey on the job template.
         */
        survey_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Comma separated list of the tags to use for the job template.
         */
        job_tags?: string;
        /**
         * Default: no
         *
         * Enable forcing playbook handlers to run even if a task fails.
         */
        force_handlers_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        /**
         * Name of the inventory to use for the job template.
         */
        inventory?: string;
        /**
         * Path to the C(extra_vars) YAML file.
         */
        extra_vars_path?: string;
        /**
         * The number of parallel or simultaneous processes to use while executing the playbook.
         */
        forks?: number | string;
        /**
         * Default: no
         *
         * Allow simultaneous runs of the job template.
         */
        concurrent_jobs_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the vault credential to use for the job template.
         */
        vault_credential?: string;
        diff_mode_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Activate privilege escalation.
         */
        become_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the credential to use for the job template.
         */
        credential?: string;
        /**
         * Default: no
         *
         * Prompt user to choose a verbosity level on launch.
         */
        ask_verbosity?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Description to use for the job template.
         */
        description?: string;
        /**
         * Default: no
         *
         * Enable use of fact caching for the job template.
         */
        fact_caching_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_host?: string;
        /**
         * Default: no
         *
         * Prompt user for job tags to skip on launch.
         */
        ask_skip_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Start the playbook at the task matching this name.
         */
        start_at_task?: string;
        /**
         * Default: no
         *
         * Propmt user for inventory on launch.
         */
        ask_inventory?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Allow provisioning callbacks using this host config key.
         */
        host_config_key?: string;
        /**
         * Default: no
         *
         * Prompt user for credential on launch.
         */
        ask_credential?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name to use for the job template.
         */
        name: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the project to use for the job template.
         */
        project: string;
        /**
         * Default: no
         *
         * Prompt user for (extra_vars) on launch.
         */
        ask_extra_vars?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A host pattern to further constrain the list of hosts managed or affected by the playbook
         */
        limit?: string;
        timeout?: number | string;
        /**
         * Default: no
         *
         * Prompt user for job tags on launch.
         */
        ask_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Control the output level Ansible produces as the playbook runs. 0 - Normal, 1 - Verbose, 2 - More Verbose, 3 - Debug, 4 - Connection Debug.
         */
        verbosity?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, update, or destroy Ansible Tower labels. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_label?: {
        /**
         * Name to use for the label.
         */
        name: string;
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        tower_password?: string;
        tower_username?: string;
        /**
         * Organization the label should be applied to.
         */
        organization: string;
        tower_host?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to manage firewall configurations about an ESXi host when ESXi hostname or Cluster name is given.
       */
      vmware_host_firewall_manager?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * You can wait for a set amount of time C(timeout), this is the default if nothing is specified.
       * Waiting for a port to become available is useful for when services are not immediately available after their init scripts return which is true of certain Java application servers.
       * You can wait for a file to exist or not exist on the filesystem.
       * This module can also be used to wait for a regex match string to be present in a file.
       * You can wait for active connections to be closed before continuing on a local port.
       */
      win_wait_for?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The port number to poll on C(host).
         */
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create or destroy users.
       */
      na_cdot_user?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages Layer 2 switchport interfaces on HUAWEI CloudEngine switches.
       */
      ce_switchport?: {
        /**
         * If C(mode=trunk), used as the trunk native VLAN ID, in the range from 1 to 4094.
         */
        native_vlan?: string;
        username?: string;
        ssh_keyfile?: string;
        /**
         * If C(mode=access), used as the access VLAN ID, in the range from 1 to 4094.
         */
        access_vlan?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent" | "unconfigured";
        host?: string;
        /**
         * If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk, such as 2-10 or 2,5,10-15, etc.
         */
        trunk_vlans?: string;
        /**
         * The link type of an interface.
         */
        mode?: "access" | "trunk";
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Full name of the interface, i.e. 40GE1/0/22.
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific app service plan or all app service plans in a resource group, or all app service plan in current subscription.
       */
      azure_rm_appserviceplan_facts?: {
        profile?: string;
        /**
         * Only show results for a specific app service plan.
         */
        name?: string;
        /**
         * Limit results by resource group.
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * A Cloud Spanner Database which is hosted on a Spanner instance.
       */
      gcp_spanner_database?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * An optional list of DDL statements to run inside the newly created database. Statements can create tables, indexes, etc. These statements execute atomically with the creation of the database: if there is an error in any statement, the database is not created.
         */
        extra_statements?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A unique identifier for the database, which cannot be changed after the instance is created. Values are of the form projects/<project>/instances/[a-z][-a-z0-9]*[a-z0-9]. The final segment of the name must be between 6 and 30 characters in length.
         */
        name?: string;
        service_account_email?: string;
        project?: string;
        /**
         * The instance to create the database on.
         */
        instance: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Installs packages using Web Platform Installer command-line (U(http://www.iis.net/learn/install/web-platform-installer/web-platform-installer-v4-command-line-webpicmdexe-rtw-release)).
       * Must be installed and present in PATH (see M(win_chocolatey) module; 'webpicmd' is the package name, and you must install 'lessmsi' first too)?
       * Install IIS first (see M(win_feature) module).
       */
      win_webpicmd?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Each network has its own firewall controlling access to and from the instances.
       * All traffic to instances, even from other instances, is blocked by the firewall unless firewall rules are created to allow it.
       * The default network has automatically created firewall rules that are shown in default firewall rules. No manually created network has automatically created firewall rules except for a default "allow" rule for outgoing traffic and a default "deny" for incoming traffic. For all networks except the default network, you must create any firewall rules you need.
       */
      gcp_compute_firewall?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name?: string;
        /**
         * If source tags are specified, the firewall will apply only to traffic with source IP that belongs to a tag listed in source tags. Source tags cannot be used to control traffic to an instance's external IP address. Because tags are associated with an instance, not an IP address. One or both of sourceRanges and sourceTags may be set. If both properties are set, the firewall will apply to traffic that has source IP address within sourceRanges OR the source IP that belongs to a tag listed in the sourceTags property. The connection does not need to match both properties for the firewall to apply.
         */
        source_tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        /**
         * An optional description of this resource. Provide this property when you create the resource.
         */
        description?: string;
        /**
         * A list of instance tags indicating sets of instances located in the network that may make network connections as specified in allowed[].
         * If no targetTags are specified, the firewall rule applies to all instances on the specified network.
         */
        target_tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * If source ranges are specified, the firewall will apply only to traffic that has source IP address in these ranges. These ranges must be expressed in CIDR format. One or both of sourceRanges and sourceTags may be set. If both properties are set, the firewall will apply to traffic that has source IP address within sourceRanges OR the source IP that belongs to a tag listed in the sourceTags property. The connection does not need to match both properties for the firewall to apply. Only IPv4 is supported.
         */
        source_ranges?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The list of ALLOW rules specified by this firewall. Each rule specifies a protocol and port-range tuple that describes a permitted connection.
         */
        allowed?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * URL of the network resource for this firewall rule. If not specified when creating a firewall rule, the default network is used: global/networks/default If you choose to specify this property, you can specify the network as a full or partial URL. For example, the following are all valid URLs: U(https://www.googleapis.com/compute/v1/projects/myproject/global/) networks/my-network projects/myproject/global/networks/my-network global/networks/default .
         */
        network?: string;
        [k: string]: unknown;
      };
      /**
       * Allows for managing both private and shared aliases on a BIG-IP.
       */
      bigip_cli_alias?: {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of LLDP service on Cisco IOS network devices.
       */
      ios_lldp?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of the LLDP configuration. If value is I(present) lldp will be enabled else if it is I(absent) it will be disabled.
         */
        state?: "present" | "absent" | "enabled" | "disabled";
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages local Windows user accounts.
       * For non-Windows targets, use the M(user) module instead.
       */
      win_user?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of link aggregation groups on Extreme Networks SLX-OS network devices.
       */
      slxos_linkagg?: {
        /**
         * Channel-group number for the port-channel Link aggregation group. Range 1-1024.
         */
        group?: number | string;
        /**
         * Purge links not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * State of the link aggregation group.
         */
        state?: "present" | "absent";
        /**
         * Mode of the link aggregation group.
         */
        mode?: "active" | "on" | "passive";
        /**
         * List of members of the link aggregation group.
         */
        members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List of link aggregation definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Manage packages using Chocolatey (U(http://chocolatey.org/)).
       * If Chocolatey is missing from the system, the module will install it.
       * List of packages can be found at U(http://chocolatey.org/packages).
       */
      win_chocolatey?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * A zone is a subtree of the DNS namespace under one administrative responsibility. A ManagedZone is a resource that represents a DNS zone hosted by the Cloud DNS service.
       */
      gcp_dns_managed_zone?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A mutable string of at most 1024 characters associated with this resource for the user's convenience. Has no effect on the managed zone's function.
         */
        description?: string;
        /**
         * Optionally specifies the NameServerSet for this ManagedZone. A NameServerSet is a set of DNS name servers that all host the same ManagedZones. Most users will leave this field unset.
         */
        name_server_set?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The DNS name of this managed zone, for instance "example.com.".
         */
        dns_name?: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        service_account_email?: string;
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * User assigned name for this resource.
         * Must be unique within the project.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Add, modify or delete an IPA HBAC rule using IPA API.
       */
      ipa_hbacrule?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manages Homebrew packages
       */
      homebrew?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Load or unload kernel modules.
       */
      modprobe?: {
        /**
         * Default: present
         *
         * Whether the module should be present or absent.
         */
        state?: "absent" | "present";
        /**
         * Modules parameters.
         */
        params?: string;
        /**
         * Name of kernel module to manage.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts for Rackspace Cloud Servers.
       */
      rax_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts for GCP Image
       */
      gcp_compute_image_facts?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_email?: string;
        project?: string;
        /**
         * A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters). Each additional filter in the list will act be added as an AND condition (filter1 and filter2)
         */
        filters?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM https monitors.
       */
      bigip_monitor_https?: {
        [k: string]: unknown;
      };
      /**
       * Install and remove Grafana plugins.
       */
      grafana_plugin?: {
        /**
         * Grafana repository. If not set, gafana-cli will use the default value C(https://grafana.net/api/plugins).
         */
        grafana_repo?: string;
        /**
         * Name of the plugin.
         */
        name: string;
        /**
         * Custom Grafana plugin URL.
         * Requires grafana 4.6.x or later.
         */
        grafana_plugin_url?: string;
        /**
         * Directory where Grafana plugin will be installed.
         */
        grafana_plugins_dir?: string;
        /**
         * Default: present
         *
         * Status of the Grafana plugin.
         * If latest is set, the version parameter will be ignored.
         */
        state?: "absent" | "present";
        /**
         * Version of the plugin to install.
         * Default to latest.
         */
        version?: string;
        [k: string]: unknown;
      };
      /**
       * The C(tempfile) module creates temporary files and directories. C(mktemp) command takes different parameters on various systems, this module helps to avoid troubles related to that. Files/directories created by module are accessible only by creator. In case you need to make them world-accessible you need to use M(file) module.
       * For Windows targets, use the M(win_tempfile) module instead.
       */
      tempfile?: {
        /**
         * Location where temporary file or directory should be created. If path is not specified default system temporary directory will be used.
         */
        path?: string;
        /**
         * Default: ansible.
         *
         * Prefix of file/directory name created by module.
         */
        prefix?: string;
        /**
         * Suffix of file/directory name created by module.
         */
        suffix?: string;
        /**
         * Default: file
         *
         * Whether to create file or directory.
         */
        state?: "directory" | "file";
        [k: string]: unknown;
      };
      /**
       * Gets various details related to AWS VPC Peers
       */
      ec2_vpc_peering_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module uses rabbitMQ Rest API to create/delete queues
       */
      rabbitmq_queue?: {
        /**
         * Default: 15672
         *
         * rabbitMQ management api port
         */
        login_port?: string;
        /**
         * Optional name of an exchange to which messages will be republished if they
         * are rejected or expire
         */
        dead_letter_exchange?: string;
        /**
         * Maximum number of priority levels for the queue to support.
         * If not set, the queue will not support message priorities.
         * Larger numbers indicate higher priority.
         */
        max_priority?: number | string;
        /**
         * Default: guest
         *
         * rabbitMQ user for connection
         */
        login_user?: string;
        /**
         * Default: localhost
         *
         * rabbitMQ host for connection
         */
        login_host?: string;
        /**
         * Default: forever
         *
         * How long a message can live in queue before it is discarded (milliseconds)
         */
        message_ttl?: number | string;
        /**
         * Default: /
         *
         * rabbitMQ virtual host
         */
        vhost?: string;
        /**
         * Default: present
         *
         * Whether the queue should be present or absent
         */
        state?: "present" | "absent";
        /**
         * Default: no limit
         *
         * How many messages can the queue contain before it starts rejecting
         */
        max_length?: number | string;
        /**
         * extra arguments for queue. If defined this argument is a key/value dictionary
         */
        arguments?: {
          [k: string]: unknown;
        };
        /**
         * Default: no
         *
         * if the queue should delete itself after all queues/queues unbound from it
         */
        auto_delete?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * rabbitMQ password for connection
         */
        login_password?: string;
        /**
         * Default: forever
         *
         * How long a queue can be unused before it is automatically deleted (milliseconds)
         */
        auto_expires?: number | string;
        /**
         * Optional replacement routing key to use when a message is dead-lettered.
         * Original routing key will be used if unset
         */
        dead_letter_routing_key?: string;
        /**
         * Default: yes
         *
         * whether queue is durable or not
         */
        durable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the queue to create
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manage domains on Rackspace Cloud DNS
       */
      rax_dns?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage port channel interface policies on Cisco ACI fabrics.
       */
      aci_interface_policy_port_channel?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * This module provides declarative management of BGP router and neighbors on Mellanox ONYX network devices.
       */
      onyx_bgp?: {
        /**
         * List of neighbors. Required if I(state=present).
         */
        neighbors?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Router IP address. Required if I(state=present).
         */
        router_id?: string;
        /**
         * Default: present
         *
         * BGP state.
         */
        state?: "present" | "absent";
        /**
         * List of advertised networks.
         */
        networks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Local AS number.
         */
        as_number: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages BGP neighbor Address-family configurations on HUAWEI CloudEngine switches.
       */
      ce_bgp_neighbor_af?: {
        /**
         * Specify the IPv4 filtering policy applied to the routes received from a specified peer. The value is a string of 1 to 169 characters.
         */
        import_pref_filt_name?: string;
        /**
         * Default: no_use
         *
         * If the value is true, advertised IRB routes are distinguished. If the value is false, advertised IRB routes are not distinguished.
         */
        advertise_irb?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, the function to replace a specified peer's AS number in the AS-Path attribute with the local AS number is enabled. If the value is false, the function to replace a specified peer's AS number in the AS-Path attribute with the local AS number is disabled.
         */
        substitute_as_enable?: "no_use" | "true" | "false";
        /**
         * Assign a preferred value for the routes learned from a specified peer. The value is an integer ranging from 0 to 65535.
         */
        preferred_value?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the extended community attribute is advertised to peers. If the value is false, the extended community attribute is not advertised to peers.
         */
        advertise_ext_community?: "no_use" | "true" | "false";
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no_use
         *
         * If the value is true, the remote next-hop attribute is advertised to peers. If the value is false, the remote next-hop attribute is not advertised to any peers.
         */
        advertise_remote_nexthop?: "no_use" | "true" | "false";
        /**
         * null, Null. matchall, Advertise the default route if all matching conditions are met. matchany, Advertise the default route if any matching condition is met.
         */
        default_rt_match_mode?: "null" | "matchall" | "matchany";
        /**
         * Default: no_use
         *
         * Redirect ip.
         */
        redirect_ip?: "no_use" | "true" | "false";
        /**
         * Configure the maximum number of routes that can be accepted from a peer. The value is an integer ranging from 1 to 4294967295.
         */
        route_limit?: string;
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Apply an AS_Path-based filtering policy to the routes received from a specified peer. The value is an integer ranging from 1 to 256.
         */
        import_as_path_filter?: string;
        /**
         * Default: no_use
         *
         * If the value is true, sent BGP update messages carry only the public AS number but do not carry private AS numbers. If the value is false, sent BGP update messages can carry private AS numbers.
         */
        public_as_only_force?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, vpls enable. If the value is false, vpls disable.
         */
        vpls_enable?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, repetitive local AS numbers are allowed. If the value is false, repetitive local AS numbers are not allowed.
         */
        allow_as_loop_enable?: "no_use" | "true" | "false";
        /**
         * Specify the IPv4 filtering policy applied to the routes to be advertised to a specified peer. The value is a string of 1 to 169 characters.
         */
        export_pref_filt_name?: string;
        /**
         * A routing strategy based on the AS path list for routing received by a designated peer.
         */
        import_as_path_name_or_num?: string;
        /**
         * Address family type of a BGP instance.
         */
        af_type: "ipv4uni" | "ipv4multi" | "ipv4vpn" | "ipv6uni" | "ipv6vpn" | "evpn";
        state?: "present" | "absent";
        /**
         * ORF mode. null, Default value. receive, ORF for incoming packets. send, ORF for outgoing packets. both, ORF for incoming and outgoing packets.
         */
        orf_mode?: "null" | "receive" | "send" | "both";
        /**
         * null, The next hop is not changed. local, The next hop is changed to the local IP address. invariable, Prevent the device from changing the next hop of each imported IGP route when advertising it to its BGP peers.
         */
        nexthop_configure?: "null" | "local" | "invariable";
        /**
         * Default: no_use
         *
         * If the value is true, the extended community attribute in the peer route information is discarded. If the value is false, the extended community attribute in the peer route information is not discarded.
         */
        discard_ext_community?: "no_use" | "true" | "false";
        /**
         * The number of addPath advertise route. The value is an integer ranging from 2 to 64.
         */
        adv_add_path_num?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the system stores all route update messages received from all peers (groups) after BGP connection setup. If the value is false, the system stores only BGP update messages that are received from peers and pass the configured import policy.
         */
        keep_all_routes?: "no_use" | "true" | "false";
        /**
         * ORF Type. The value is an integer ranging from 0 to 65535.
         */
        orftype?: string;
        /**
         * Specify the name of a used policy. The value is a string. The value is a string of 1 to 40 characters.
         */
        default_rt_adv_policy?: string;
        username?: string;
        /**
         * Application of a AS path list based filtering policy to the routing of a specified peer.
         */
        export_as_path_name_or_num?: string;
        /**
         * Default: no_use
         *
         * If the value is true, Non-standard capability codes are used during capability negotiation. If the value is false, RFC-defined standard ORF capability codes are used during capability negotiation.
         */
        is_nonstd_ipprefix_mod?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, the address prefix-based Outbound Route Filter (ORF) capability is enabled for peers. If the value is false, the address prefix-based Outbound Route Filter (ORF) capability is disabled for peers.
         */
        ipprefix_orf_enable?: "no_use" | "true" | "false";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: no_use
         *
         * If the value is true, Application results of route announcement. If the value is false, Routing application results are not notified.
         */
        origin_as_valid?: "no_use" | "true" | "false";
        /**
         * Specify the percentage of routes when a router starts to generate an alarm. The value is an integer ranging from 1 to 100.
         */
        route_limit_percent?: string;
        /**
         * IPv4 or IPv6 peer connection address.
         */
        remote_address: string;
        /**
         * null, Null. receive, Support receiving Add-Path routes. send, Support sending Add-Path routes. both, Support receiving and sending Add-Path routes.
         */
        add_path_mode?: "null" | "receive" | "send" | "both";
        /**
         * Default: no_use
         *
         * If the value is true, the local device functions as the route reflector and a peer functions as a client of the route reflector. If the value is false, the route reflector and client functions are not configured.
         */
        reflect_client?: "no_use" | "true" | "false";
        host?: string;
        /**
         * Default: no_use
         *
         * If the value is true, advertised ARP routes are distinguished. If the value is false, advertised ARP routes are not distinguished.
         */
        advertise_arp?: "no_use" | "true" | "false";
        /**
         * Specify the filtering policy applied to the routes learned from a peer. The value is a string of 1 to 40 characters.
         */
        import_rt_policy_name?: string;
        /**
         * Default: no_use
         *
         * Public as only skip peer as.
         */
        public_as_only_skip_peer_as?: "no_use" | "true" | "false";
        /**
         * Specify the filtering policy applied to the routes to be advertised to a peer. The value is a string of 1 to 40 characters.
         */
        export_rt_policy_name?: string;
        /**
         * Default: no_use
         *
         * If the value is true, sent BGP update messages carry only the public AS number but do not carry private AS numbers. If the value is false, sent BGP update messages can carry private AS numbers.
         */
        public_as_only?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * Redirect ip vaildation.
         */
        redirect_ip_vaildation?: "no_use" | "true" | "false";
        password?: string;
        /**
         * Apply an IPv4 ACL-based filtering policy to the routes received from a specified peer. The value is a string of 1 to 32 characters.
         */
        import_acl_name_or_num?: string;
        /**
         * Set the maximum number of repetitive local AS number. The value is an integer ranging from 1 to 10.
         */
        allow_as_loop_limit?: string;
        /**
         * Specify the value of the idle-timeout timer to automatically reestablish the connections after they are cut off when the number of routes exceeds the set threshold. The value is an integer ranging from 1 to 1200.
         */
        route_limit_idle_timeout?: string;
        ssh_keyfile?: string;
        /**
         * Default: no_use
         *
         * If the value is true, enable vpls-ad. If the value is false, disable vpls-ad.
         */
        vpls_ad_disable?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, When the vpnv4 multicast neighbor receives and updates the message, the message has no label. If the value is false, When the vpnv4 multicast neighbor receives and updates the message, the message has label.
         */
        update_pkt_standard_compatible?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * Limited use public as number.
         */
        public_as_only_limited?: "no_use" | "true" | "false";
        /**
         * Noparameter, After the number of received routes exceeds the threshold and the timeout timer expires,no action. AlertOnly, An alarm is generated and no additional routes will be accepted if the maximum number of routes allowed have been received. IdleForever, The connection that is interrupted is not automatically re-established if the maximum number of routes allowed have been received. IdleTimeout, After the number of received routes exceeds the threshold and the timeout timer expires, the connection that is interrupted is automatically re-established.
         */
        route_limit_type?: "noparameter" | "alertOnly" | "idleForever" | "idleTimeout";
        /**
         * Apply an IPv4 ACL-based filtering policy to the routes to be advertised to a specified peer. The value is a string of 1 to 32 characters.
         */
        export_acl_name_or_num?: string;
        /**
         * Configure the Site-of-Origin (SoO) extended community attribute. The value is a string of 3 to 21 characters.
         */
        soostring?: string;
        /**
         * Default: no_use
         *
         * Private as replaced by public as number.
         */
        public_as_only_replace?: "no_use" | "true" | "false";
        /**
         * Apply an AS_Path-based filtering policy to the routes to be advertised to a specified peer. The value is an integer ranging from 1 to 256.
         */
        export_as_path_filter?: string;
        /**
         * Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created.
         */
        vrf_name: string;
        /**
         * Default: no_use
         *
         * If the value is true, the community attribute is advertised to peers. If the value is false, the community attribute is not advertised to peers.
         */
        advertise_community?: "no_use" | "true" | "false";
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no_use
         *
         * If the value is true, the function to advertise default routes to peers is enabled. If the value is false, the function to advertise default routes to peers is disabled.
         */
        default_rt_adv_enable?: "no_use" | "true" | "false";
        /**
         * Specify the minimum interval at which Update packets are sent. The value is an integer, in seconds. The value is an integer ranging from 0 to 600.
         */
        rt_updt_interval?: string;
        [k: string]: unknown;
      };
      /**
       * Configure an RR in BGP-EVPN address family view on HUAWEI CloudEngine switches.
       */
      ce_evpn_bgp_rr?: {
        username?: string;
        /**
         * Specifies the number of the AS, in integer format. The value is an integer that ranges from 1 to 4294967295.
         */
        as_number: string;
        ssh_keyfile?: string;
        /**
         * Default: enable
         *
         * Enable or disable the BGP-EVPN address family.
         */
        bgp_evpn_enable?: "enable" | "disable";
        /**
         * Specify the peer type.
         */
        peer_type?: "group_name" | "ipv4_address";
        /**
         * Enable or disable the VPN-Target filtering.
         */
        policy_vpn_target?: "enable" | "disable";
        /**
         * Configure the local device as the route reflector and the peer or peer group as the client of the route reflector.
         */
        reflect_client?: "enable" | "disable";
        host?: string;
        /**
         * Specifies the name of a BGP instance. The value of instance-name can be an integer 1 or a string of 1 to 31.
         */
        bgp_instance?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Specifies the IPv4 address or the group name of a peer.
         */
        peer?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Allows to retrieve information on accounts a CA supporting the L(ACME protocol,https://tools.ietf.org/html/rfc8555), such as L(Let's Encrypt,https://letsencrypt.org/).
       * This module only works with the ACME v2 protocol.
       */
      acme_account_facts?: {
        [k: string]: unknown;
      };
      /**
       * Allow the auto-support settings to be configured for an individual E-Series storage-system
       */
      netapp_e_asup?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates, updates or removes a Scaling Policy
       */
      aws_application_scaling_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * The M(proxysql_global_variables) module writes the proxysql configuration settings between layers. Currently this module will always report a changed state, so should typically be used with WHEN however this will change in a future version when the CHECKSUM table commands are available for all tables in proxysql.
       */
      proxysql_manage_config?: {
        login_port?: number | string;
        /**
         * FROM - denotes we're reading values FROM the supplied I(config_layer) and writing to the next layer. TO - denotes we're reading from the previous layer and writing TO the supplied I(config_layer)."
         */
        direction: "FROM" | "TO";
        config_file?: string;
        /**
         * The I(config_settings) specifies which configuration we're writing.
         *
         * Possible choices:
         * MYSQL USERS
         * MYSQL SERVERS
         * MYSQL QUERY RULES
         * MYSQL VARIABLES
         * ADMIN VARIABLES
         * SCHEDULER
         */
        config_settings: string;
        login_user?: string;
        login_host?: string;
        login_unix_socket?: string;
        login_password?: string;
        /**
         * RUNTIME - represents the in-memory data structures of ProxySQL used by the threads that are handling the requests. MEMORY - (sometimes also referred as main) represents the in-memory SQLite3 database. DISK - represents the on-disk SQLite3 database. CONFIG - is the classical config file. You can only LOAD FROM the config file.
         */
        config_layer: "MEMORY" | "DISK" | "RUNTIME" | "CONFIG";
        /**
         * The supplied I(action) combines with the supplied I(direction) to provide the semantics of how we want to move the I(config_settings) between the I(config_layers).
         */
        action: "LOAD" | "SAVE";
        [k: string]: unknown;
      };
      /**
       * Manages BFD session view configuration on HUAWEI CloudEngine devices.
       */
      ce_bfd_view?: {
        /**
         * Specifies the local discriminator of a BFD session. The value is an integer that ranges from 1 to 16384.
         */
        local_discr?: number | string;
        username?: string;
        /**
         * Specifies the WTR time of a BFD session. The value is an integer that ranges from 1 to 60, in minutes. The default value is 0.
         */
        wtr_interval?: number | string;
        /**
         * Specifies the remote discriminator of a BFD session. The value is an integer that ranges from 1 to 4294967295.
         */
        remote_discr?: number | string;
        /**
         * Specifies the description of a BFD session. The value is a string of 1 to 51 case-sensitive characters with spaces.
         */
        description?: string;
        /**
         * Default: no
         *
         * Enables the BFD session to enter the AdminDown state. By default, a BFD session is enabled. The default value is bool type.
         */
        admin_down?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies a priority for BFD control packets. The value is an integer ranging from 0 to 7. The default value is 7, which is the highest priority.
         */
        tos_exp?: number | string;
        /**
         * Specifies the local detection multiplier of a BFD session. The value is an integer that ranges from 3 to 50.
         */
        detect_multi?: number | string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: "present" | "absent";
        /**
         * Specifies the minimum interval for receiving BFD packets. The value is an integer that ranges from 50 to 1000, in milliseconds.
         */
        min_tx_interval?: number | string;
        /**
         * Specifies the minimum interval for sending BFD packets. The value is an integer that ranges from 50 to 1000, in milliseconds.
         */
        min_rx_interval?: number | string;
        host?: string;
        ssh_keyfile?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies the name of a BFD session. The value is a string of 1 to 15 case-sensitive characters without spaces.
         */
        session_name: string;
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        [k: string]: unknown;
      };
      /**
       * Create/delete a droplet in DigitalOcean and optionally wait for it to be 'running', or deploy an SSH key.
       */
      digital_ocean?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of IGMP protocol params on Mellanox ONYX network devices.
       */
      onyx_igmp?: {
        /**
         * Configure the default operating version of the IGMP snooping
         */
        default_version?: "V2" | "V3";
        /**
         * Configure the last member query interval, range 1-25
         */
        last_member_query_interval?: number | string;
        /**
         * Configure the unregistered multicast mode Flood unregistered multicast Forward unregistered multicast to mrouter ports
         */
        unregistered_multicast?: "flood" | "forward-to-mrouter-ports";
        /**
         * IGMP state.
         */
        state: "enabled" | "disabled";
        /**
         * Configure the report suppression interval, range 1-25
         */
        report_suppression_interval?: number | string;
        /**
         * Configure ip igmp snooping proxy and enable reporting mode
         */
        proxy_reporting?: "enabled" | "disabled";
        /**
         * Configure the mrouter timeout, range 60-600
         */
        mrouter_timeout?: number | string;
        /**
         * Configure the host port purge timeout, range 130-1225
         */
        port_purge_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about DigitalOcean provided certificates.
       */
      digital_ocean_certificate_facts?: {
        [k: string]: unknown;
      };
      /**
       * Add or remove users to RabbitMQ and assign permissions
       */
      rabbitmq_user?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Add or Remove COE cluster template from the OpenStack Container Infra service.
       */
      os_coe_cluster_template?: {
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * One or more key/value pairs
         */
        labels?: string;
        /**
         * Default: yes
         *
         * Indicates whether created clusters should have a floating ip or not
         */
        floating_ip_enabled?: string;
        /**
         * The fixed subnet name to attach to the Cluster
         */
        fixed_subnet?: string;
        /**
         * The flavor of the master node for this ClusterTemplate
         */
        master_flavor_id?: string;
        /**
         * A comma separated list of IPs for which proxies should not be used in the cluster
         */
        no_proxy?: string;
        /**
         * Default: no
         *
         * Indicates whether the TLS should be disabled
         */
        tls_disabled?: string;
        /**
         * Address of a proxy that will receive all HTTPS requests and relay them. The format is a URL including a port number
         */
        https_proxy?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource.
         */
        state?: string;
        /**
         * Name or ID of the keypair to use.
         */
        keypair_id?: string;
        /**
         * Default: no
         *
         * Indicates whether the ClusterTemplate is public or not
         */
        public?: string;
        /**
         * Address of a proxy that will receive all HTTP requests and relay them The format is a URL including a port number
         */
        http_proxy?: string;
        /**
         * The size in GB of the docker volume
         */
        docker_volume_size?: string;
        /**
         * Default: vm
         *
         * Server type for this ClusterTemplate
         */
        server_type?: string;
        /**
         * The external network to attach to the Cluster
         */
        external_network_id?: string;
        /**
         * Image id the cluster will be based on
         */
        image_id?: string;
        /**
         * The name of the driver used for instantiating container volumes
         */
        volume_driver?: string;
        /**
         * Default: no
         *
         * Indicates whether the docker registry is enabled
         */
        registry_enabled?: string;
        /**
         * Docker storage driver
         */
        docker_storage_driver?: string;
        /**
         * Name that has to be given to the cluster template
         */
        name?: string;
        /**
         * The name of the driver used for instantiating container networks
         */
        network_driver?: string;
        /**
         * The fixed network name to attach to the Cluster
         */
        fixed_network?: string;
        /**
         * The Container Orchestration Engine for this clustertemplate
         */
        coe?: string;
        /**
         * The flavor of the minion node for this ClusterTemplate
         */
        flavor_id?: string;
        /**
         * Default: no
         *
         * Indicates whether created clusters should have a load balancer for master nodes or not
         */
        master_lb_enabled?: string;
        /**
         * Default: 8.8.8.8
         *
         * The DNS nameserver address
         */
        dns_nameserver?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about ports from OpenStack.
       */
      os_port_facts?: {
        /**
         * Unique name or ID of a port.
         */
        port?: string;
        /**
         * A dictionary of meta data to use for further filtering. Elements of this dictionary will be matched against the returned port dictionaries. Matching is currently limited to strings within the port dictionary, or strings within nested dictionaries.
         */
        filters?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        [k: string]: unknown;
      };
      /**
       * Manage which I(sensu channels) a machine should subscribe to
       */
      sensu_subscription?: {
        /**
         * Default: /etc/sensu/conf.d/subscriptions.json
         *
         * Path to the subscriptions json file
         */
        path?: string;
        /**
         * Default: present
         *
         * Whether the machine should subscribe or unsubscribe from the channel
         */
        state?: "present" | "absent";
        /**
         * Create a backup file (if yes), including the timestamp information so you
         * can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the channel
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module creates, removes or resizes AIX logical volumes. Inspired by lvol module.
       */
      aix_lvol?: {
        /**
         * Comma separated list of physical volumes e.g. C(hdisk1,hdisk2).
         */
        pvs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: jfs2
         *
         * The type of the logical volume.
         */
        lv_type?: string;
        /**
         * The volume group this logical volume is part of.
         */
        vg: string;
        /**
         * Default: 1
         *
         * The number of copies of the logical volume. Maximum copies are 3.
         */
        copies?: string;
        /**
         * The name of the logical volume.
         */
        lv: string;
        /**
         * Default: present
         *
         * Control if the logical volume exists. If C(present) and the volume does not already exist then the C(size) option is required.
         */
        state?: "absent" | "present";
        /**
         * Default: maximum
         *
         * Sets the interphysical volume allocation policy. C(maximum) allocates logical partitions across the maximum number of physical volumes. C(minimum) allocates logical partitions across the minimum number of physical volumes.
         */
        policy?: "maximum" | "minimum";
        /**
         * Free-form options to be passed to the mklv command.
         */
        opts?: string;
        /**
         * The size of the logical volume with one of the [MGT] units.
         */
        size?: string;
        [k: string]: unknown;
      };
      /**
       * A Google Container Engine cluster.
       */
      gcp_container_cluster?: {
        /**
         * The number of nodes to create in this cluster. You must ensure that your Compute Engine resource quota is sufficient for this number of instances. You must also have available firewall and routes quota. For requests, this field should only be used in lieu of a "nodePool" object, since this configuration (along with the "nodeConfig") will be used to create a "NodePool" object with an auto-generated name. Do not use this and a nodePool at the same time.
         */
        initial_node_count: number | string;
        /**
         * The monitoring service the cluster should use to write metrics.
         * Currently available options:  monitoring.googleapis.com - the Google Cloud Monitoring service.
         * none - no metrics will be exported from the cluster.
         * if left as an empty string, monitoring.googleapis.com will be used.
         */
        monitoring_service?: "monitoring.googleapis.com" | "none";
        /**
         * The name of the Google Compute Engine network to which the cluster is connected. If left unspecified, the default network will be used.
         * To ensure it exists and it is operations, configure the network using 'gcompute_network' resource.
         */
        network?: string;
        /**
         * The zone where the cluster is deployed.
         */
        zone: string;
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The IP address range of the container pods in this cluster, in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one automatically chosen or specify a /14 block in 10.0.0.0/8.
         */
        cluster_ipv4_cidr?: string;
        service_account_email?: string;
        /**
         * The authentication information for accessing the master endpoint.
         */
        master_auth?: {
          [k: string]: unknown;
        };
        /**
         * Parameters used in creating the cluster's nodes.
         * For requests, this field should only be used in lieu of a "nodePool" object, since this configuration (along with the "initialNodeCount") will be used to create a "NodePool" object with an auto-generated name. Do not use this and a nodePool at the same time. For responses, this field will be populated with the node configuration of the first node pool. If unspecified, the defaults are used.
         */
        node_config?: {
          [k: string]: unknown;
        };
        /**
         * The name of this cluster. The name must be unique within this project and zone, and can be up to 40 characters. Must be Lowercase letters, numbers, and hyphens only. Must start with a letter. Must end with a number or a letter.
         */
        name?: string;
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * The list of Google Compute Engine locations in which the cluster's nodes should be located.
         */
        location?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * Configurations for the various addons available to run in the cluster.
         */
        addons_config?: {
          [k: string]: unknown;
        };
        /**
         * The logging service the cluster should use to write logs. Currently available options:  logging.googleapis.com - the Google Cloud Logging service.
         * none - no logs will be exported from the cluster.
         * if left as an empty string,logging.googleapis.com will be used.
         */
        logging_service?: "logging.googleapis.com" | "none";
        /**
         * The name of the Google Compute Engine subnetwork to which the cluster is connected.
         */
        subnetwork?: string;
        /**
         * An optional description of this cluster.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Get facts of MySQL Database.
       */
      azure_rm_mysqldatabase_facts?: {
        profile?: string;
        /**
         * The name of the database.
         */
        name?: string;
        /**
         * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
         */
        resource_group: string;
        ad_user?: string;
        /**
         * The name of the server.
         */
        server_name: string;
        cloud_environment?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Modify ONTAP network routes.
       */
      na_ontap_net_routes?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages external LTM monitors on a BIG-IP.
       */
      bigip_monitor_external?: {
        [k: string]: unknown;
      };
      /**
       * This module asserts that given expressions are true with an optional custom message.
       * This module is also supported for Windows targets.
       */
      assert?: {
        active_connection_states?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        connect_timeout?: number | string;
        delay?: number | string;
        search_regex?: string;
        state?: "absent" | "drained" | "present" | "started" | "stopped";
        sleep?: number | string;
        timeout?: number | string;
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        msg?: string;
        path?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage(Enable/Disable) RHSM repositories to the Red Hat Subscription Management entitlement platform using the C(subscription-manager) command.
       */
      rhsm_repository?: {
        /**
         * Default: present
         *
         * If state is equal to present or disabled, indicates the desired repository state.
         */
        state?: "present" | "enabled" | "absent" | "disabled";
        /**
         * The ID of repositories to enable.
         * To operate on several repositories this can accept a comma separated list or a YAML list.
         */
        name:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of Interfaces on Juniper JUNOS network devices.
       */
      junos_interface?: {
        /**
         * Check the operational state of given interface C(name) for LLDP neighbor.
         * The following suboptions are available.
         */
        neighbors?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        username?: string;
        ssh_keyfile?: string;
        /**
         * Description of Interface.
         */
        description?: string;
        /**
         * Default: auto
         *
         * Interface link status.
         */
        duplex?: "full" | "half" | "auto";
        /**
         * Configure interface link status.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * State of the Interface configuration, C(up) idicates present and operationally up and C(down) indicates present and operationally C(down)
         */
        state?: "present" | "absent" | "up" | "down";
        /**
         * Maximum size of transmit packet.
         */
        mtu?: number | string;
        /**
         * Receiver rate in bits per second (bps).
         * This is state check parameter only.
         * Supports conditionals, see L(Conditionals in Networking Modules,../network/user_guide/network_working_with_command_output.html)
         */
        rx_rate?: string;
        /**
         * List of Interfaces definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        /**
         * Default: 10
         *
         * Time in seconds to wait before checking for the operational state on remote device. This wait is applicable for operational state argument which are I(state) with values C(up)/C(down), I(tx_rate) and I(rx_rate).
         */
        delay?: number | string;
        /**
         * Transmit rate in bits per second (bps).
         * This is state check parameter only.
         * Supports conditionals, see L(Conditionals in Networking Modules,../network/user_guide/network_working_with_command_output.html)
         */
        tx_rate?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: True
         *
         * Specifies whether or not the configuration is active or deactivated
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        /**
         * Interface link speed.
         */
        speed?: string;
        port?: number | string;
        transport?: string;
        /**
         * Name of the Interface.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about users present on the given ESXi host system in VMware infrastructure.
       * All variables and VMware object names are case sensitive.
       * User must hold the 'Authorization.ModifyPermissions' privilege to invoke this module.
       */
      vmware_local_user_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Get facts of Auto Scale Setting.
       */
      azure_rm_autoscale_facts?: {
        profile?: string;
        /**
         * The name of the Auto Scale Setting.
         */
        name?: string;
        /**
         * The name of the resource group.
         */
        resource_group: string;
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, or delete a Direct Connect connection between a network and a specific AWS Direct Connect location. Upon creation the connection may be added to a link aggregation group or established as a standalone connection. The connection may later be associated or disassociated with a link aggregation group.
       */
      aws_direct_connect_connection?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can be used to add/remove a resource pool to/from vCenter
       */
      vmware_resource_pool?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool, using HTTP POST and GET requests. The httpd mod_proxy balancer-member status page has to be enabled and accessible, as this module relies on parsing this page. This module supports ansible check_mode, and requires BeautifulSoup python module.
       */
      apache2_mod_proxy?: {
        /**
         * Default: no
         *
         * Use https to access balancer management page.
         */
        tls?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * (ipv4|ipv6|fqdn):port of the Apache httpd 2.4 mod_proxy balancer pool.
         */
        balancer_vhost: string;
        /**
         * Default: /balancer-manager/
         *
         * Suffix of the balancer pool url required to access the balancer pool status page (e.g. balancer_vhost[:port]/balancer_url_suffix).
         */
        balancer_url_suffix?: string;
        /**
         * (ipv4|ipv6|fqdn) of the balancer member to get or to set attributes to. Port number is autodetected and should not be specified here. If undefined, apache2_mod_proxy module will return a members list of dictionaries of all the current balancer pool members' attributes.
         */
        member_host?: string;
        /**
         * Desired state of the member host. (absent|disabled),drained,hot_standby,ignore_errors can be simultaneously invoked by separating them with a comma (e.g. state=drained,ignore_errors).
         */
        state?: string;
        /**
         * Default: yes
         *
         * Validate ssl/tls certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module is used to configure AnalyticsProfile object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_analyticsprofile?: {
        /**
         * Time window (in secs) within which only unique health change events should occur.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1209600.
         */
        hs_event_throttle_window?: number | string;
        /**
         * Tolerated client to avi round trip time(rtt) factor.
         * It is a multiple of apdex_rtt_tolerated_factor.
         * Allowed values are 1-1000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.0.
         */
        apdex_rtt_tolerated_factor?: number;
        /**
         * Disable node (service engine) level analytics forvs metrics.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        disable_se_analytics?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted due to timeout.
         * Allowed values are 1-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 20.
         * Units(PERCENT).
         */
        conn_server_lossy_timeo_rexmt_threshold?: number | string;
        /**
         * Tolerated client to avi round trip time(rtt) factor.
         * It is a multiple of apdex_rtt_tolerated_factor.
         * Allowed values are 1-1000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.0.
         */
        apdex_server_rtt_tolerated_factor?: number;
        /**
         * Score assigned when rc4 algorithm is used for encryption.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 2.5.
         */
        hs_security_encalgo_score_rc4?: number;
        /**
         * Score assigned when supporting tls1.2 encryption protocol.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 5.0.
         */
        hs_security_tls12_score?: number;
        /**
         * Exclude server tcp reset from errors.
         * It is common for applications like ms exchange.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_server_tcp_reset_as_error?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Dos connection rate below which the dos security assessment will not kick in.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1000.
         */
        hs_min_dos_rate?: number | string;
        /**
         * Exclude queries to domains that did not have configured services/records from the list of errors.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_no_dns_record_as_error?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Exclude invalid dns queries from the list of errors.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_invalid_dns_query_as_error?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Maximum penalty that may be deducted from health score for high resource utilization.
         * Allowed values are 0-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 25.
         */
        hs_max_resources_penalty?: number | string;
        /**
         * A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted.
         * Allowed values are 1-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 50.
         * Units(PERCENT).
         */
        conn_lossy_total_rexmt_threshold?: number | string;
        /**
         * Configure to stream logs to an external server.
         * Field introduced in 17.1.1.
         */
        client_log_streaming_config?: {
          [k: string]: unknown;
        };
        /**
         * Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.
         * Default value when not specified in API or module is interpreted by Avi Controller as 10.0.
         */
        hs_pscore_traffic_threshold_l4_client?: number;
        /**
         * Penalty for allowing weak signature algorithm(s).
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.0.
         */
        hs_security_weak_signature_algo_penalty?: number;
        /**
         * Exclude queries to gslb services that have no available members from the list of errors.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_no_valid_gs_member_as_error?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A server http response is considered satisfied if latency is less than the satisfactory latency threshold.
         * The response is considered tolerated when it is greater than satisfied but less than the tolerated latency factor * s_latency.
         * Greater than this number and the server response is considered frustrated.
         * Allowed values are 1-30000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 400.
         * Units(MILLISECONDS).
         */
        apdex_server_response_threshold?: number | string;
        /**
         * Score assigned when the minimum cipher strength is greater than equal to 128 bits.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 5.0.
         */
        hs_security_cipherscore_ge128b?: number;
        /**
         * Block of http response codes to be excluded from being classified as an error.
         * Enum options - AP_HTTP_RSP_4XX, AP_HTTP_RSP_5XX.
         */
        resp_code_block?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Adds free performance score credits to health score.
         * It can be used for compensating health score for known slow applications.
         * Allowed values are 0-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.
         */
        hs_performance_boost?: number | string;
        /**
         * Uuid of the analytics profile.
         */
        uuid?: string;
        /**
         * Exclude dns queries to domains outside the domains configured in the dns application profile from the list of errors.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_invalid_dns_domain_as_error?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of http status codes to be excluded from being classified as an error.
         * Error connections or responses impacts health score, are included as significant logs, and may be classified as part of a dos attack.
         */
        exclude_http_error_codes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Maximum penalty that may be deducted from health score for anomalies.
         * Allowed values are 0-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 10.
         */
        hs_max_anomaly_penalty?: number | string;
        /**
         * Score assigned when supporting tls1.1 encryption protocol.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 5.0.
         */
        hs_security_tls11_score?: number;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Exclude queries to gslb services that are operationally down from the list of errors.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_gs_down_as_error?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Server tolerated response latency factor.
         * Servermust response within this factor times the satisfactory threshold (apdex_server_response_threshold) to be considered tolerated.
         * Allowed values are 1-1000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.0.
         */
        apdex_server_response_tolerated_factor?: number;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Disable analytics on backend servers.
         * This may be desired in container environment when there are large number of  ephemeral servers.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        disable_server_analytics?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Exclude persistence server changed while load balancing' from the list of errors.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_persistence_change_as_error?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Exclude client closed connection before an http request could be completed from being classified as an error.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_client_close_before_request_as_error?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Penalty for allowing non-pfs handshakes.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.0.
         */
        hs_security_nonpfs_penalty?: number;
        /**
         * Penalty for not enabling hsts.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.0.
         */
        hs_security_hsts_penalty?: number;
        /**
         * Deprecated.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.0.
         */
        hs_security_selfsignedcert_penalty?: number;
        /**
         * A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted.
         * Allowed values are 1-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 50.
         * Units(PERCENT).
         */
        conn_server_lossy_total_rexmt_threshold?: number | string;
        /**
         * A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted due to timeout.
         * Allowed values are 1-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 20.
         * Units(PERCENT).
         */
        conn_lossy_timeo_rexmt_threshold?: number | string;
        api_version?: string;
        username?: string;
        /**
         * Score assigned when the certificate expires in more than 30 days.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 5.0.
         */
        hs_security_certscore_gt30d?: number;
        /**
         * User defined description for the object.
         */
        description?: string;
        /**
         * Score assigned when supporting ssl3.0 encryption protocol.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 3.5.
         */
        hs_security_ssl30_score?: number;
        /**
         * A connection between avi and server is considered lossy when more than this percentage of out of order packets are received.
         * Allowed values are 1-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 50.
         * Units(PERCENT).
         */
        conn_server_lossy_ooo_threshold?: number | string;
        /**
         * Configure which logs are sent to the avi controller from ses and how they are processed.
         */
        client_log_config?: {
          [k: string]: unknown;
        };
        /**
         * Score assigned when the minimum cipher strength is 0 bits.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.0.
         */
        hs_security_cipherscore_eq000b?: number;
        /**
         * Score assigned when the certificate expires in less than or equal to 30 days.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.0.
         */
        hs_security_certscore_le30d?: number;
        /**
         * Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.
         * Default value when not specified in API or module is interpreted by Avi Controller as 10.0.
         */
        hs_pscore_traffic_threshold_l4_server?: number;
        /**
         * Exclude 'server unanswered syns' from the list of errors.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_syn_retransmit_as_error?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of http status code ranges to be excluded from being classified as an error.
         */
        ranges?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Exclude dns policy drops from the list of errors.
         * Field introduced in 17.2.2.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_dns_policy_drop_as_significant?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        controller?: string;
        /**
         * Satisfactory client to avi round trip time(rtt).
         * Allowed values are 1-2000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 125.
         * Units(MILLISECONDS).
         */
        apdex_server_rtt_threshold?: number | string;
        api_context?: {
          [k: string]: unknown;
        };
        /**
         * Exclude server dns error response from the list of errors.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_server_dns_error_as_error?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Score assigned when the certificate expires in less than or equal to 7 days.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 2.0.
         */
        hs_security_certscore_le07d?: number;
        password?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        tenant?: string;
        /**
         * A client connection is considered lossy when percentage of times a packet could not be trasmitted due to tcp zero window is above this threshold.
         * Allowed values are 0-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 2.
         * Units(PERCENT).
         */
        conn_lossy_zero_win_size_event_threshold?: number | string;
        /**
         * If a client is able to load a page in less than the satisfactory latency threshold, the pageload is considered satisfied.
         * It is considered tolerated if it is greater than satisfied but less than the tolerated latency multiplied by satisifed latency.
         * Greater than this number and the client's request is considered frustrated.
         * A pageload includes the time for dns lookup, download of all http objects, and page render time.
         * Allowed values are 1-30000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 5000.
         * Units(MILLISECONDS).
         */
        apdex_rum_threshold?: number | string;
        /**
         * The name of the analytics profile.
         */
        name: string;
        /**
         * Penalty for allowing certificates with invalid chain.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 1.0.
         */
        hs_security_chain_invalidity_penalty?: number;
        /**
         * If a client receives an http response in less than the satisfactory latency threshold, the request is considered satisfied.
         * It is considered tolerated if it is not satisfied and less than tolerated latency factor multiplied by the satisfactory latency threshold.
         * Greater than this number and the client's request is considered frustrated.
         * Allowed values are 1-30000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 500.
         * Units(MILLISECONDS).
         */
        apdex_response_threshold?: number | string;
        /**
         * Score assigned when no algorithm is used for encryption.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.0.
         */
        hs_security_encalgo_score_none?: number;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Client tolerated response latency factor.
         * Client must receive a response within this factor times the satisfactory threshold (apdex_response_threshold) to be considered tolerated.
         * Allowed values are 1-1000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.0.
         */
        apdex_response_tolerated_factor?: number;
        tenant_uuid?: string;
        /**
         * Exclude tcp resets by client from the list of potential errors.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_tcp_reset_as_error?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Maximum penalty that may be deducted from health score based on security assessment.
         * Allowed values are 0-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 100.
         */
        hs_max_security_penalty?: number | string;
        /**
         * A server connection is considered lossy when percentage of times a packet could not be trasmitted due to tcp zero window is above this threshold.
         * Allowed values are 0-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 2.
         * Units(PERCENT).
         */
        conn_server_lossy_zero_win_size_event_threshold?: number | string;
        /**
         * A connection between client and avi is considered lossy when more than this percentage of out of order packets are received.
         * Allowed values are 1-100.
         * Default value when not specified in API or module is interpreted by Avi Controller as 50.
         * Units(PERCENT).
         */
        conn_lossy_ooo_threshold?: number | string;
        /**
         * Score assigned when the minimum cipher strength is less than 128 bits.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 3.5.
         */
        hs_security_cipherscore_lt128b?: number;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Score assigned when supporting tls1.0 encryption protocol.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 5.0.
         */
        hs_security_tls10_score?: number;
        /**
         * Score assigned when the certificate has expired.
         * Allowed values are 0-5.
         * Default value when not specified in API or module is interpreted by Avi Controller as 0.0.
         */
        hs_security_certscore_expired?: number;
        /**
         * Virtual service threshold factor for tolerated page load time (plt) as multiple of apdex_rum_threshold.
         * Allowed values are 1-1000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.0.
         */
        apdex_rum_tolerated_factor?: number;
        /**
         * Satisfactory client to avi round trip time(rtt).
         * Allowed values are 1-2000.
         * Default value when not specified in API or module is interpreted by Avi Controller as 250.
         * Units(MILLISECONDS).
         */
        apdex_rtt_threshold?: number | string;
        /**
         * Exclude unsupported dns queries from the list of errors.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_unsupported_dns_query_as_error?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of node system attributes on Cisco IOS XR devices. It provides an option to configure host system parameters or remove those parameters from the device active configuration.
       */
      iosxr_system?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * The C(lookup_source) argument provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.
         */
        lookup_source?: string;
        /**
         * Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
         */
        domain_search?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Configure the device hostname parameter. This option takes an ASCII string value.
         */
        hostname?: string;
        /**
         * Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
         */
        domain_name?: string;
        host?: string;
        /**
         * Default: present
         *
         * State of the configuration values in the device's current active configuration.  When set to I(present), the values should be configured in the device active configuration and when set to I(absent) the values should not be in the device active configuration
         */
        state?: "present" | "absent";
        /**
         * VRF name for domain services
         */
        vrf?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * The C(name_serves) argument accepts a list of DNS name servers by way of either FQDN or IP address to use to perform name resolution lookups.  This argument accepts wither a list of DNS servers See examples.
         */
        name_servers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        /**
         * Provides administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.
         */
        lookup_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Adds or removes SSH authorized keys for particular user accounts
       */
      authorized_key?: {
        /**
         * Change the comment on the public key. Rewriting the comment is useful in cases such as fetching it from GitHub or GitLab.
         * If no comment is specified, the existing comment will be kept.
         */
        comment?: string;
        /**
         * Default: no
         *
         * Whether to remove all other non-specified keys from the authorized_keys file. Multiple keys can be specified in a single C(key) string value by separating them by newlines.
         * This option is not loop aware, so if you use C(with_) , it will be exclusive per iteration of the loop, if you want multiple keys in the file you need to pass them all to C(key) in a single batch as mentioned above.
         */
        exclusive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A string of ssh key options to be prepended to the key in the authorized_keys file
         */
        key_options?: string;
        /**
         * Default: present
         *
         * Whether the given key (with the given key_options) should or should not be in the file
         */
        state?: "present" | "absent";
        /**
         * The username on the remote host whose authorized_keys file will be modified
         */
        user: string;
        /**
         * The SSH public key(s), as a string or (since 1.9) url (https://github.com/username.keys)
         */
        key: string;
        /**
         * Default: (homedir)+/.ssh/authorized_keys
         *
         * Alternate path to the authorized_keys file
         */
        path?: string;
        /**
         * Default: no
         *
         * Follow path symlink instead of replacing it
         */
        follow?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        unique?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * This only applies if using a https url as the source of the keys. If set to C(no), the SSL certificates will not be validated.
         * This should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.
         * Prior to 2.1 the code worked as if this was set to C(yes).
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Whether this module should manage the directory of the authorized key file.  If set, the module will create the directory, as well as set the owner and permissions of an existing directory. Be sure to set C(manage_dir=no) if you are using an alternate directory for authorized_keys, as set with C(path), since you could lock yourself out of SSH access. See the example below.
         */
        manage_dir?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Add or Remove a member for a pool from the OpenStack load-balancer service.
       */
      os_member?: {
        /**
         * Name that has to be given to the member
         */
        name?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * The subnet ID the member service is accessible from.
         */
        subnet_id?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: 180
         *
         * The amount of time the module should wait for the load balancer to get into ACTIVE state.
         */
        timeout?: string;
        /**
         * The IP address of the member.
         */
        address?: string;
        /**
         * Default: 80
         *
         * The protocol port number for the member.
         */
        protocol_port?: string;
        /**
         * The name or id of the pool that this member belongs to.
         */
        pool?: string;
        /**
         * Default: yes
         *
         * If the module should wait for the load balancer to be ACTIVE.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * Manages BIG-IQ applications used for load balancing an HTTPS application on port 443 with SSL offloading on BIG-IP.
       */
      bigiq_application_https_offload?: {
        [k: string]: unknown;
      };
      /**
       * Send a message to a flowdock team inbox or chat using the push API (see https://www.flowdock.com/api/team-inbox and https://www.flowdock.com/api/chat)
       */
      flowdock?: {
        /**
         * (inbox only) Name of the message sender
         */
        from_name?: string;
        /**
         * (inbox only - required) Email address of the message sender
         */
        from_address?: string;
        /**
         * tags of the message, separated by commas
         */
        tags?: string;
        /**
         * Whether to post to 'inbox' or 'chat'
         */
        type: "inbox" | "chat";
        /**
         * (chat only - required) Name of the "user" sending the message
         */
        external_user_name?: string;
        /**
         * (inbox only) Human readable identifier for more detailed message categorization
         */
        project?: string;
        /**
         * (inbox only - required) Human readable identifier of the application that uses the Flowdock API
         */
        source?: string;
        /**
         * API token.
         */
        token: string;
        /**
         * (inbox only) Link associated with the message. This will be used to link the message subject in Team Inbox.
         */
        link?: string;
        /**
         * (inbox only) Email address for replies
         */
        reply_to?: string;
        /**
         * (inbox only - required) Subject line of the message
         */
        subject?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Content of the message
         */
        msg: string;
        [k: string]: unknown;
      };
      /**
       * Manage route domains on a BIG-IP.
       */
      bigip_routedomain?: {
        /**
         * The eviction policy to use with this route domain. Apply an eviction policy to provide customized responses to flow overflows and slow flows on the route domain.
         */
        flow_eviction_policy?: string;
        /**
         * Service policy to associate with the route domain.
         */
        service_policy?: string;
        /**
         * Specifies descriptive text that identifies the route domain.
         */
        description?: string;
        /**
         * Specifies the route domain the system searches when it cannot find a route in the configured domain.
         */
        parent?: string;
        /**
         * Default: Common
         *
         * Partition to create the route domain on. Partitions cannot be updated once they are created.
         */
        partition?: string;
        /**
         * The maximum number of concurrent connections allowed for the route domain. Setting this to C(0) turns off connection limits.
         */
        connection_limit?: string;
        /**
         * Specifies whether the system enforces cross-routing restrictions or not.
         */
        strict?: string;
        /**
         * Default: present
         *
         * Whether the route domain should exist or not.
         */
        state?: string;
        /**
         * Dynamic routing protocols for the system to use in the route domain.
         */
        routing_protocol?: string;
        /**
         * The bandwidth controller for the route domain.
         */
        bwc_policy?: string;
        /**
         * VLANs for the system to use in the route domain.
         */
        vlans?: string;
        /**
         * The unique identifying integer representing the route domain.
         * This field is required when creating a new route domain.
         * In version 2.5, this value is no longer used to reference a route domain when making modifications to it (for instance during update and delete operations). Instead, the C(name) parameter is used. In version 2.6, the C(name) value will become a required parameter.
         */
        id?: string;
        /**
         * The name of the route domain.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about the user.
       */
      online_user_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module can be used to add and remove custom attributes definitions for the given virtual machine from VMWare.
       */
      vmware_guest_custom_attribute_defs?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages virtual machines supported by I(libvirt).
       */
      virt?: {
        [k: string]: unknown;
      };
      /**
       * Wraps the msg.exe command in order to send messages to Windows hosts.
       */
      win_msg?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manage monitoring policies on Cisco ACI fabrics.
       */
      aci_epg_monitoring_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Create, update and delete instance of PostgreSQL Server.
       */
      azure_rm_postgresqlserver?: {
        /**
         * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
         */
        resource_group: string;
        cloud_environment?: string;
        /**
         * The maximum storage allowed for a server.
         */
        storage_mb?: number | string;
        cert_validation_mode?: "validate" | "ignore";
        /**
         * Enable SSL enforcement.
         */
        enforce_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The SKU (pricing tier) of the server.
         */
        sku?: {
          [k: string]: unknown;
        };
        ad_user?: string;
        /**
         * Default: present
         *
         * Assert the state of the PostgreSQL server. Use 'present' to create or update a server and 'absent' to delete it.
         */
        state?: "present" | "absent";
        /**
         * Default: Default
         *
         * Create mode of SQL Server
         */
        create_mode?: string;
        secret?: string;
        /**
         * Server version.
         */
        version?: "9.5" | "9.6";
        /**
         * The password of the administrator login.
         */
        admin_password?: string;
        subscription_id?: string;
        /**
         * Resource location. If not set, location from the resource group will be used as default.
         */
        location?: string;
        profile?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        tenant?: string;
        /**
         * The name of the server.
         */
        name: string;
        /**
         * The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
         */
        admin_username?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        [k: string]: unknown;
      };
      /**
       * Manage the trust relationships between BIG-IPs. Devices, once peered, cannot be updated. If updating is needed, the peer must first be removed before it can be re-added to the trust.
       */
      bigip_device_trust?: {
        /**
         * The API username of the remote peer device that you are trusting. Note that the CLI user cannot be used unless it too has an API account. If this value is not specified, then the value of C(user), or the environment variable C(F5_USER) will be used.
         */
        peer_user?: string;
        /**
         * The password of the API username of the remote peer device that you are trusting. If this value is not specified, then the value of C(password), or the environment variable C(F5_PASSWORD) will be used.
         */
        peer_password?: string;
        /**
         * Default: present
         *
         * When C(present), ensures the specified devices are trusted.
         * When C(absent), removes the device trusts.
         */
        state?: string;
        /**
         * The peer address to connect to and trust for synchronizing configuration. This is typically the management address of the remote device, but may also be a Self IP.
         */
        peer_server?: string;
        /**
         * Default: peer
         *
         * Specifies whether the device you are adding is a Peer or a Subordinate. The default is C(peer).
         * The difference between the two is a matter of mitigating risk of compromise.
         * A subordinate device cannot sign a certificate for another device.
         * In the case where the security of an authority device in a trust domain is compromised, the risk of compromise is minimized for any subordinate device.
         * Designating devices as subordinate devices is recommended for device groups with a large number of member devices, where the risk of compromise is high.
         */
        type?: string;
        /**
         * The hostname that you want to associate with the device. This value will be used to easily distinguish this device in BIG-IP configuration.
         * When trusting a new device, if this parameter is not specified, the value of C(peer_server) will be used as a default.
         */
        peer_hostname?: string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure SeProperties object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_seproperties?: {
        username?: string;
        /**
         * Seagentproperties settings for seproperties.
         */
        se_agent_properties?: {
          [k: string]: unknown;
        };
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Unique object identifier of the object.
         * Default value when not specified in API or module is interpreted by Avi Controller as default.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * Seruntimeproperties settings for seproperties.
         */
        se_runtime_properties?: {
          [k: string]: unknown;
        };
        controller?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Sebootupproperties settings for seproperties.
         */
        se_bootup_properties?: {
          [k: string]: unknown;
        };
        tenant?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        api_version?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete VPCs.
       */
      cs_vpc?: {
        [k: string]: unknown;
      };
      /**
       * This module allows you to gather various information about ONTAP configuration
       */
      na_ontap_gather_facts?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Notify Rollbar about app deployments (see https://rollbar.com/docs/deploys_other/)
       */
      rollbar_deployment?: {
        /**
         * Deploy comment (e.g. what is being deployed).
         */
        comment?: string;
        /**
         * Rollbar username of the user who deployed.
         */
        rollbar_user?: string;
        /**
         * Default: https://api.rollbar.com/api/1/deploy/
         *
         * Optional URL to submit the notification to.
         */
        url?: string;
        /**
         * Name of the environment being deployed, e.g. 'production'.
         */
        environment: string;
        /**
         * Your project access token.
         */
        token: string;
        /**
         * User who deployed.
         */
        user?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Revision number/sha being deployed.
         */
        revision: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about DigitalOcean provided load balancers.
       */
      digital_ocean_load_balancer_facts?: {
        [k: string]: unknown;
      };
      /**
       * Configures storage profiles on Cisco UCS Manager.
       * Examples can be used with the L(UCS Platform Emulator,https://communities.cisco.com/ucspe).
       */
      ucs_storage_profile?: {
        /**
         * Default: org-root
         *
         * The distinguished name (dn) of the organization where the resource is assigned.
         */
        org_dn?: string;
        /**
         * List of Local LUNs used by the storage profile.
         */
        local_luns?: string;
        /**
         * The user-defined description of the storage profile.
         * Enter up to 256 characters.
         * You can use any characters or spaces except the following:
         * ` (accent mark),  (backslash), ^ (carat), " (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).
         */
        description?: string;
        /**
         * The name of the storage profile.
         * This name can be between 1 and 16 alphanumeric characters.
         * You cannot use spaces or any special characters other than - (hyphen), "_" (underscore), : (colon), and . (period).
         * You cannot change this name after profile is created.
         */
        name?: string;
        /**
         * Default: present
         *
         * If C(present), will verify that the storage profile is present and will create if needed.
         * If C(absent), will verify that the storage profile is absent and will delete if needed.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * Query data points from InfluxDB.
       */
      influxdb_query?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module manages whole lifecycle of the Virtual Machine(VM) in oVirt/RHV.
       * Since VM can hold many states in oVirt/RHV, this see notes to see how the states of the VM are handled.
       */
      ovirt_vm?: {
        [k: string]: unknown;
      };
      /**
       * Manage Linode Public Cloud instances and optionally wait for it to be 'running'.
       */
      linode?: {
        [k: string]: unknown;
      };
      /**
       * Builds Redfish URIs locally and sends them to remote OOB controllers to set or update a configuration attribute.
       * Manages BIOS configuration settings.
       * Manages OOB controller configuration settings.
       */
      redfish_config?: {
        /**
         * Category to execute on OOB controller
         */
        category: string;
        /**
         * Base URI of OOB controller
         */
        baseuri: string;
        /**
         * Default: null
         *
         * name of BIOS attribute to update
         */
        bios_attr_name?: string;
        /**
         * Default: null
         *
         * value of BIOS attribute to update
         */
        bios_attr_value?: string;
        /**
         * Default: null
         *
         * name of Manager attribute to update
         */
        mgr_attr_name?: string;
        /**
         * Default: null
         *
         * value of Manager attribute to update
         */
        mgr_attr_value?: string;
        /**
         * User for authentication with OOB controller
         */
        user: string;
        /**
         * List of commands to execute on OOB controller
         */
        command:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Password for authentication with OOB controller
         */
        password: string;
        [k: string]: unknown;
      };
      /**
       * The C(wakeonlan) module sends magic Wake-on-LAN (WoL) broadcast packets.
       */
      wakeonlan?: {
        /**
         * Default: 255.255.255.255
         *
         * Network broadcast address to use for broadcasting magic Wake-on-LAN packet.
         */
        broadcast?: string;
        /**
         * MAC address to send Wake-on-LAN broadcast packet for.
         */
        mac: string;
        /**
         * Default: 7
         *
         * UDP port to use for magic Wake-on-LAN packet.
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, destroy, or update access groups on Element Software Cluster.
       */
      na_elementsw_access_group?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Interface to the Network Command Line Utility, developed to make it easier to configure operating systems running ifupdown2 and Quagga, such as Cumulus Linux. Command documentation is available at U(https://docs.cumulusnetworks.com/display/DOCS/Network+Command+Line+Utility)
       */
      nclu?: {
        /**
         * A list of strings containing the net commands to run. Mutually exclusive with I(template).
         */
        commands?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: Ansible-originated commit
         *
         * Commit description that will be recorded to the commit log if I(commit) or I(atomic) are true.
         */
        description?: string;
        /**
         * Boolean. When true, perform a 'net abort' before the block. This cleans out any uncommitted changes in the buffer. Mutually exclusive with I(atomic).
         */
        abort?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * When true, equivalent to both I(commit) and I(abort) being true. Mutually exclusive with I(commit) and I(atomic).
         */
        atomic?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A single, multi-line string with jinja2 formatting. This string will be broken by lines, and each line will be run through net. Mutually exclusive with I(commands).
         */
        template?: string;
        /**
         * When true, performs a 'net commit' at the end of the block. Mutually exclusive with I(atomic).
         */
        commit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create, update, or delete OpenStack Identity service endpoints. If a service with the same combination of I(service), I(interface) and I(region) exist, the I(url) and I(state) (C(present) or C(absent)) will be updated.
       */
      os_keystone_endpoint?: {
        /**
         * Name or id of the service.
         */
        service?: string;
        /**
         * URL of the service.
         */
        url?: string;
        /**
         * Region that the service belongs to. Note that I(region_name) is used for authentication.
         */
        region?: string;
        /**
         * Default: True
         *
         * Is the service enabled.
         */
        enabled?: string;
        /**
         * Default: present
         *
         * Should the resource be C(present) or C(absent).
         */
        state?: string;
        /**
         * Interface of the service.
         */
        interface?: string;
        [k: string]: unknown;
      };
      /**
       * Configures LAN Connectivity Policies on Cisco UCS Manager.
       * Examples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).
       */
      ucs_lan_connectivity?: {
        /**
         * The name of the LAN Connectivity Policy.
         * This name can be between 1 and 16 alphanumeric characters.
         * You cannot use spaces or any special characters other than - (hyphen), "_" (underscore), : (colon), and . (period).
         * You cannot change this name after the policy is created.
         */
        name?: string;
        /**
         * Default: present
         *
         * If C(present), will verify LAN Connectivity Policies are present and will create if needed.
         * If C(absent), will verify LAN Connectivity Policies are absent and will delete if needed.
         */
        state?: string;
        /**
         * A description of the LAN Connectivity Policy.
         * Cisco recommends including information about where and when to use the policy.
         * Enter up to 256 characters.
         * You can use any characters or spaces except the following:
         * ` (accent mark),  (backslash), ^ (carat), " (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).
         */
        description?: string;
        /**
         * List of vNICs used by the LAN Connectivity Policy.
         * vNICs used by the LAN Connectivity Policy must be created from a vNIC template.
         * Each list element has the following suboptions:
         * = name
         *   The name of the vNIC (required).
         * = vnic_template
         *   The name of the vNIC template (required).
         * - adapter_policy
         *   The name of the Ethernet adapter policy.
         *   A user defined policy can be used, or one of the system defined policies.
         * - order
         *   String specifying the vNIC assignment order (e.g., '1', '2').
         *   [Default: unspecified]
         */
        vnic_list?: string;
        /**
         * Default: org-root
         *
         * Org dn (distinguished name)
         */
        org_dn?: string;
        [k: string]: unknown;
      };
      /**
       * Apstra AOS Ip Pool module let you manage your IP Pool easily. You can create create and delete IP Pool by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.
       */
      aos_ip_pool?: {
        /**
         * List of subnet that needs to be part of the IP Pool.
         */
        subnets?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the IP Pool to manage. Only one of I(name), I(id) or I(content) can be set.
         */
        name?: string;
        /**
         * Datastructure of the IP Pool to manage. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).
         */
        content?: string;
        /**
         * Default: present
         *
         * Indicate what is the expected state of the IP Pool (present or not).
         */
        state?: "present" | "absent";
        /**
         * An existing AOS session as obtained by M(aos_login) module.
         */
        session: {
          [k: string]: unknown;
        };
        /**
         * AOS Id of the IP Pool to manage (can't be used to create a new IP Pool), Only one of I(name), I(id) or I(content) can be set.
         */
        id?: string;
        [k: string]: unknown;
      };
      /**
       * Manage Infinity IPAM using REST API
       */
      infinity?: {
        /**
         * Username to access Infinity
         * The user must have Rest API privileges
         */
        username: string;
        /**
         * Network bitmask (e.g. 255.255.255.220) or CIDR format (e.g., /26)
         */
        network_size?: string;
        /**
         * Default: -1
         *
         * the parent network id for a given network
         */
        network_location?: number | string;
        /**
         * Default: 4
         *
         * Network family defined by Infinity, e.g. IPv4, IPv6 and Dual stack
         */
        network_family?: "4" | "6" | "dual";
        /**
         * Network ID
         */
        network_id?: string;
        /**
         * IP Address for a reservation or a release
         */
        ip_address?: string;
        /**
         * Network address with CIDR format (e.g., 192.168.310.0)
         */
        network_address?: string;
        /**
         * Infinity server_ip with IP address
         */
        server_ip: string;
        /**
         * Action to perform
         */
        action:
          | "get_network"
          | "reserve_next_available_ip"
          | "release_ip"
          | "delete_network"
          | "reserve_network"
          | "release_network"
          | "add_network"
          | "get_network_id";
        /**
         * Infinity password
         */
        password: string;
        /**
         * The name of a network
         */
        network_name?: string;
        /**
         * Default: lan
         *
         * Network type defined by Infinity
         */
        network_type?: "lan" | "shared_lan" | "supernet";
        [k: string]: unknown;
      };
      /**
       * Create or destroy svm on NetApp cDOT
       */
      na_cdot_svm?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages BGP peer configurations on HUAWEI CloudEngine switches.
       */
      ce_bgp_neighbor?: {
        /**
         * The value can be Connect-only, Listen-only, or Both.
         */
        connect_mode?: "listenOnly" | "connectOnly" | "null";
        /**
         * Default: no_use
         *
         * Add the global AS number to the Update packets to be advertised.
         */
        prepend_global_as?: "no_use" | "true" | "false";
        /**
         * Maximum number of hops in an indirect EBGP connection. The value is an ranging from 1 to 255.
         */
        ebgp_max_hop?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the session with a specified peer is torn down and all related routing entries are cleared. If the value is false, the session with a specified peer is retained.
         */
        is_ignore?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * Add the Fake AS number to received Update packets.
         */
        prepend_fake_as?: "no_use" | "true" | "false";
        /**
         * Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string of 1 to 47 case-insensitive characters.
         */
        key_chain_name?: string;
        /**
         * Default: no_use
         *
         * If the value is true, the system is enabled to preferentially use the single-hop mode for BFD session setup between IBGP peers. If the value is false, the system is disabled from preferentially using the single-hop mode for BFD session setup between IBGP peers.
         */
        is_single_hop?: "no_use" | "true" | "false";
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "netconf";
        /**
         * Default: no_use
         *
         * If the value is true, the router has all extended capabilities. If the value is false, the router does not have all extended capabilities.
         */
        conventional?: "no_use" | "true" | "false";
        /**
         * AS number of a peer. The value is a string of 1 to 11 characters.
         */
        remote_as: string;
        /**
         * Specify the Hold time of a peer or peer group. The value is 0 or an integer ranging from 3 to 65535.
         */
        hold_time?: string;
        /**
         * Specify the minimum interval at which BFD packets are sent. The value is an integer ranging from 50 to 1000, in milliseconds.
         */
        tx_interval?: string;
        /**
         * The character string in a password identifies the contents of the password, spaces not supported. The value is a string of 1 to 255 characters.
         */
        pswd_cipher_text?: string;
        /**
         * Name of a source interface that sends BGP packets. The value is a string of 1 to 63 characters.
         */
        local_if_name?: string;
        /**
         * Specify the minimum interval at which BFD packets are received. The value is an integer ranging from 50 to 1000, in milliseconds.
         */
        rx_interval?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created.
         */
        vrf_name: string;
        /**
         * Default: no_use
         *
         * If the value is true, the EBGP peer can use either a fake AS number or the actual AS number. If the value is false, the EBGP peer can only use a fake AS number.
         */
        dual_as?: "no_use" | "true" | "false";
        username?: string;
        /**
         * Description of a peer, which can be letters or digits. The value is a string of 1 to 80 characters.
         */
        description?: string;
        /**
         * Default: no_use
         *
         * If the value is true, BGP is enabled to record peer session status and event information. If the value is false, BGP is disabled from recording peer session status and event information.
         */
        is_log_change?: "no_use" | "true" | "false";
        /**
         * Specify the Keepalive time of a peer or peer group. The value is an integer ranging from 0 to 21845. The default value is 60.
         */
        keep_alive_time?: string;
        /**
         * Fake AS number that is specified for a local peer. The value is a string of 1 to 11 characters.
         */
        fake_as?: string;
        four_byte_as?: "no_use" | "true" | "false";
        host?: string;
        /**
         * Connection address of a peer, which can be an IPv4 or IPv6 address.
         */
        peer_addr: string;
        /**
         * Specify the Min hold time of a peer or peer group.
         */
        min_hold_time?: string;
        /**
         * Specify the detection multiplier. The default value is 3. The value is an integer ranging from 3 to 50.
         */
        multiplier?: string;
        password?: string;
        /**
         * Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. The value is an integer ranging from 1 to 255.
         */
        valid_ttl_hops?: string;
        /**
         * Default: no_use
         *
         * If the value is true, peers are enabled to inherit the BFD function from the peer group. If the value is false, peers are disabled to inherit the BFD function from the peer group.
         */
        is_bfd_block?: "no_use" | "true" | "false";
        /**
         * Maximum TCP MSS value used for TCP connection establishment for a peer. The value is an integer ranging from 176 to 4096.
         */
        tcp_MSS?: string;
        /**
         * ConnectRetry interval. The value is an integer ranging from 1 to 65535.
         */
        conn_retry_time?: string;
        /**
         * Default: no_use
         *
         * If the value is true, BGP is enabled to advertise REFRESH packets. If the value is false, the route refresh function is enabled.
         */
        route_refresh?: "no_use" | "true" | "false";
        ssh_keyfile?: string;
        /**
         * Default: no_use
         *
         * If the value is true, BFD is enabled. If the value is false, BFD is disabled.
         */
        is_bfd_enable?: "no_use" | "true" | "false";
        /**
         * Default: no_use
         *
         * If the value is true, peer create MPLS Local IFNET disable. If the value is false, peer create MPLS Local IFNET enable.
         */
        mpls_local_ifnet_disable?: "no_use" | "true" | "false";
        /**
         * Enable BGP peers to establish a TCP connection and perform the Message Digest 5 (MD5) authentication for BGP messages.
         */
        pswd_type?: "null" | "cipher" | "simple";
        timeout?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Gather facts about Redshift cluster(s)
       */
      redshift_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Launches/updates/deletes AWS CloudFormation Stack Sets
       */
      cloudformation_stack_set?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * The BIG-IP has an SNMP data collecting agent (DCA) that can query remote SNMP agents of various types, including the UC Davis agent (UCD) and the Windows 2000 Server agent (WIN2000).
       */
      bigip_monitor_snmp_dca?: {
        [k: string]: unknown;
      };
      /**
       * Modify ONTAP SVM Options
       * Only Options that appear on "vserver options show" can be set
       */
      na_ontap_svm_options?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * IPS packages are the native packages in Solaris 11 and higher.
       */
      pkg5?: {
        [k: string]: unknown;
      };
      /**
       * This module is used to configure Network object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_network?: {
        /**
         * It is a reference to an object of type vimgrnwruntime.
         */
        vimgrnw_ref?: string;
        /**
         * Boolean flag to set vcenter_dvs.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        vcenter_dvs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of subnet.
         */
        configured_subnets?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * It is a reference to an object of type vrfcontext.
         */
        vrf_context_ref?: string;
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * It is a reference to an object of type cloud.
         */
        cloud_ref?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        tenant?: string;
        api_version?: string;
        username?: string;
        /**
         * When selected, excludes all discovered subnets in this network from consideration for virtual service placement.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        exclude_discovered_subnets?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        /**
         * Name of the object.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Boolean flag to set synced_from_se.
         * Default value when not specified in API or module is interpreted by Avi Controller as False.
         */
        synced_from_se?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Select the ip address management scheme for this network.
         * Default value when not specified in API or module is interpreted by Avi Controller as True.
         */
        dhcp_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * This module creates a filesystem.
       */
      filesystem?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Apstra AOS Blueprint Parameter module let you manage your Blueprint Parameter easily. You can create access, define and delete Blueprint Parameter. The list of Parameters supported is different per Blueprint. The option I(get_param_list) can help you to access the list of supported Parameters for your blueprint. This module is idempotent and support the I(check) mode. It's using the AOS REST API.
       */
      aos_blueprint_param?: {
        /**
         * Blueprint Name or Id as defined in AOS.
         */
        blueprint: string;
        /**
         * Name of blueprint parameter, as defined by AOS design template. You can use the option I(get_param_list) to get the complete list of supported parameters for your blueprint.
         */
        name?: string;
        /**
         * Blueprint parameter value.  This value may be transformed by using the I(param_map) field; used when the blueprint parameter requires an AOS unique ID value.
         */
        value?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Indicate what is the expected state of the Blueprint Parameter (present or not).
         */
        state?: "present" | "absent";
        /**
         * An existing AOS session as obtained by M(aos_login) module.
         */
        session: {
          [k: string]: unknown;
        };
        /**
         * Defines the aos-pyez collection that will is used to map the user-defined item name into the AOS unique ID value.  For example, if the caller provides an IP address pool I(param_value) called "Server-IpAddrs", then the aos-pyez collection is 'IpPools'. Some I(param_map) are already defined by default like I(logical_device_maps).
         */
        param_map?: string;
        /**
         * Get the complete list of supported parameters for this blueprint and the description of those parameters.
         */
        get_param_list?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create, update and delete instance of SQL Server
       */
      azure_rm_sqlserver?: {
        /**
         * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
         */
        resource_group: string;
        cloud_environment?: string;
        secret?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        /**
         * Default: present
         *
         * Assert the state of the SQL server. Use 'present' to create or update a server and 'absent' to delete a server.
         */
        state?: "absent" | "present";
        cert_validation_mode?: "validate" | "ignore";
        /**
         * The version of the server. For example '12.0'.
         */
        version?: string;
        /**
         * Resource location.
         */
        location?: string;
        subscription_id?: string;
        /**
         * The administrator login password (required for server creation).
         */
        admin_password?: string;
        profile?: string;
        tags?: {
          [k: string]: unknown;
        };
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        password?: string;
        /**
         * The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resour ce. Possible values include: 'SystemAssigned'
         */
        identity?: string;
        tenant?: string;
        /**
         * The name of the server.
         */
        name: string;
        /**
         * Administrator username for the server. Once created it cannot be changed.
         */
        admin_username?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        [k: string]: unknown;
      };
      /**
       * Manages a Django application using the I(manage.py) application frontend to I(django-admin). With the I(virtualenv) parameter, all management commands will be executed by the given I(virtualenv) installation.
       */
      django_manage?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Execute vrouter-create, vrouter-delete, vrouter-modify command.
       * Each fabric, cluster, standalone switch, or virtual network (VNET) can provide its tenants with a virtual router (vRouter) service that forwards traffic between networks and implements Layer 3 protocols.
       * C(vrouter-create) creates a new vRouter service.
       * C(vrouter-delete) deletes a vRouter service.
       * C(vrouter-modify) modifies a vRouter service.
       */
      pn_vrouter?: {
        /**
         * Specify how OSPF routes are redistributed.
         */
        pn_ospf_redistribute?: "static" | "connected" | "bgp" | "rip";
        /**
         * Specify the name of the vRouter.
         */
        pn_name: string;
        /**
         * Target switch(es) to run the CLI on.
         */
        pn_cliswitch?: string;
        /**
         * State the action to perform. Use 'present' to create vrouter, 'absent' to delete vrouter and 'update' to modify vrouter.
         */
        state: "present" | "absent" | "update";
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Specify how BGP routes are redistributed.
         */
        pn_bgp_redistribute?: "static" | "connected" | "rip" | "ospf";
        /**
         * Specify if the vRouter uses software or hardware.
         * Note that if you specify hardware as router type, you cannot assign IP addresses using DHCP. You must specify a static IP address.
         */
        pn_router_type?: "hardware" | "software";
        /**
         * Specifies the VRRP ID for a hardware vrouter.
         */
        pn_hw_vrrp_id?: number | string;
        /**
         * Specify the name of the VNET.
         * Required for vrouter-create.
         */
        pn_vnet?: string;
        /**
         * Specify other OSPF options as a whitespaces separated string within single quotes ''.
         */
        pn_ospf_options?: string;
        /**
         * Specify how RIP routes are redistributed.
         */
        pn_rip_redistribute?: "static" | "connected" | "ospf" | "bgp";
        /**
         * Specify other BGP options as a whitespaces separated string within single quotes ''.
         */
        pn_bgp_options?: string;
        /**
         * Specify the vRouter IP address.
         */
        pn_router_id?: string;
        /**
         * Specify the maximum number of paths for BGP. This is a number between 1 and 255 or 0 to unset.
         */
        pn_bgp_max_paths?: number | string;
        /**
         * Specify to enable or disable vRouter service.
         */
        pn_service_state?: "enable" | "disable";
        /**
         * Specify if the vRouter is a dedicated or shared VNET service.
         */
        pn_service_type?: "dedicated" | "shared";
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        pn_vrrp_track_port?: string;
        /**
         * Specify the Autonomous System Number(ASN) if the vRouter runs Border Gateway Protocol(BGP).
         */
        pn_bgp_as?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create or delete local protection group snapshots on Pure Storage FlashArray.
       * This module only supports local protection groups.
       */
      purefa_pgsnap?: {
        /**
         * Restore a specific volume from a protection group snapshot. This implies overwrite of the current full volume. USE WITH CARE!!
         */
        restore?: string;
        /**
         * Default: present
         *
         * Define whether the protection group snapshot should exist or not. Copy (added in 2.7) will force an overwrite of an exisitng volume from a snapshot.
         */
        state?: string;
        /**
         * Default: no
         *
         * Define whether to eradicate the snapshot on delete or leave in trash.
         */
        eradicate?: string;
        /**
         * Suffix of snapshot name.
         */
        suffix?: string;
        /**
         * The name of the source protection group.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manages TCL iApp templates on a BIG-IP. This module will allow you to deploy iApp templates to the BIG-IP and manage their lifecycle. The conventional way to use this module is to import new iApps as needed or by extracting the contents of the iApp archive that is provided at downloads.f5.com and then importing all the iApps with this module. This module can also update existing iApps provided that the source of the iApp changed while the name stayed the same. Note however that this module will not reconfigure any services that may have been created using the C(bigip_iapp_service) module. iApps are normally not updated in production. Instead, new versions are deployed and then existing services are changed to consume that new template. As such, the ability to update templates in-place requires the C(force) option to be used.
       */
      bigip_iapp_template?: {
        /**
         * Sets the contents of an iApp template directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. C(content) must be provided when creating new templates.
         */
        content?: string;
        /**
         * Default: present
         *
         * Whether the iApp template should exist or not.
         */
        state?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies whether or not to force the uploading of an iApp. When C(yes), will force update the iApp even if there are iApp services using it. This will not update the running service though. Use C(bigip_iapp_service) to do that. When C(no), will update the iApp only if there are no iApp services using the template.
         */
        force?: string;
        /**
         * The name of the iApp template that you want to delete. This option is only available when specifying a C(state) of C(absent) and is provided as a way to delete templates that you may no longer have the source of.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Creates and deletes DNS records in Amazons Route53 service
       */
      route53?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Allows for the creation, removal and updating of Asynchronous Mirror Groups for NetApp E-series storage arrays
       */
      netapp_e_amg?: {
        new_name?: string;
        ssid: string;
        api_url: string;
        /**
         * Default: 10
         *
         * The synchronization interval in minutes
         */
        syncIntervalMinutes?: number | string;
        /**
         * Default: 20
         *
         * Recovery point warning threshold (minutes). The user will be warned when the age of the last good failures point exceeds this value
         */
        recoveryWarnThresholdMinutes?: number | string;
        /**
         * The ID of the secondary array to be used in mirroing process
         */
        secondaryArrayId: string;
        api_password: string;
        /**
         * Default: 80
         *
         * Recovery point warning threshold
         */
        repoUtilizationWarnThreshold?: number | string;
        /**
         * A C(state) of present will either create or update the async mirror group.
         * A C(state) of absent will remove the async mirror group.
         */
        state: "absent" | "present";
        /**
         * The intended protocol to use if both Fibre and iSCSI are available.
         */
        interfaceType?: "iscsi" | "fibre";
        /**
         * Default: no
         *
         * Setting this to true will cause other synchronization values to be ignored
         */
        manualSync?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_username: string;
        /**
         * Default: 10
         *
         * The threshold (in minutes) for notifying the user that periodic synchronization has taken too long to complete.
         */
        syncWarnThresholdMinutes?: number | string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the async array you wish to target, or create.
         * If C(state) is present and the name isn't found, it will attempt to create.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module allows for the manipulation of GNOME 2 Configuration via gconftool-2.  Please see the gconftool-2(1) man pages for more details.
       */
      gconftool2?: {
        /**
         * Default: no
         *
         * Access the config database directly, bypassing server.  If direct is specified then the config_source must be specified as well. See man gconftool-2(1)
         */
        direct?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Preference keys typically have simple values such as strings, integers, or lists of strings and integers. This is ignored if the state is "get". See man gconftool-2(1)
         */
        value?: string;
        /**
         * Specify a configuration source to use rather than the default path. See man gconftool-2(1)
         */
        config_source?: string;
        /**
         * The action to take upon the key/value.
         */
        state: "absent" | "get" | "present";
        /**
         * The type of value being set. This is ignored if the state is "get".
         */
        value_type?: "bool" | "float" | "int" | "string";
        /**
         * A GConf preference key is an element in the GConf repository that corresponds to an application preference. See man gconftool-2(1)
         */
        key: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about ELB target groups in AWS
       */
      elb_target_group_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module manipulates files privileges using the Linux capabilities(7) system.
       */
      capabilities?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages Layer 3 attributes for IPv4 and IPv6 interfaces.
       */
      nxos_ip_interface?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: no
         *
         * Allow to configure IPv4 secondary addresses on interface.
         */
        allow_secondary?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * IPv4 or IPv6 Address.
         */
        addr?: string;
        /**
         * Configures IEEE 802.1Q VLAN encapsulation on the subinterface. The range is from 2 to 4093.
         */
        dot1q?: number | string;
        /**
         * Route tag for IPv4 or IPv6 Address in integer format.
         */
        tag?: number | string;
        auth_pass?: string;
        /**
         * Subnet mask for IPv4 or IPv6 Address in decimal format.
         */
        mask?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * Default: v4
         *
         * Version of IP address. If the IP address is IPV4 version should be v4. If the IP address is IPV6 version should be v6.
         */
        version?: "v4" | "v6";
        timeout?: number | string;
        ssh_keyfile?: string;
        /**
         * Full name of interface, i.e. Ethernet1/1, vlan10.
         */
        interface: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * This module allows an e-series storage system owner to set audit-log configuration parameters.
       */
      netapp_e_auditlog?: {
        /**
         * Forces the audit-log configuration to delete log history when log messages fullness cause immediate warning or full condition.
         * Warning! This will cause any existing audit-log messages to be deleted.
         * This is only applicable for I(full_policy=preventSystemAccess).
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url: string;
        /**
         * A local path to a file to be used for debug logging.
         */
        log_path?: string;
        /**
         * Default: 50000
         *
         * The maximum number log messages audit-log will retain.
         * Max records must be between and including 100 and 50000.
         */
        max_records?: number | string;
        api_password: string;
        api_username: string;
        /**
         * Default: 90
         *
         * This is the memory full percent threshold that audit-log will start issuing warning messages.
         * Percent range must be between and including 60 and 90.
         */
        threshold?: number | string;
        /**
         * Default: writeOnly
         *
         * Filters the log messages according to the specified log level selection.
         */
        log_level?: "all" | "writeOnly";
        /**
         * Default: overWrite
         *
         * Specifies what audit-log should do once the number of entries approach the record limit.
         */
        full_policy?: "overWrite" | "preventSystemAccess";
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssid: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about EC2 Elastic Load Balancers in AWS
       */
      ec2_elb_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Initialize Element Software node ownership to form a cluster.
       */
      na_elementsw_cluster?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module can be used to gather facts about datastores in VMWare infrastructure.
       * All values and VMware object names are case sensitive.
       */
      vmware_datastore_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Uses .net Environment to set or remove environment variables and can set at User, Machine or Process level.
       * User level environment variables will be set, but not available until the user has logged off and on again.
       */
      win_environment?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts aboyt boot options for the given virtual machine.
       */
      vmware_guest_boot_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module manages a basic AIX mksysb (image) of rootvg.
       */
      mksysb?: {
        /**
         * Default: no
         *
         * Excludes files using C(/etc/rootvg.exclude).
         */
        exclude_files?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Backup name
         */
        name: string;
        /**
         * Default: no
         *
         * Exclude files from packing option listed in C(/etc/exclude_packing.rootvg).
         */
        software_packing?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Creates backup using snapshots.
         */
        use_snapshot?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Creates a new MAP files.
         */
        create_map_files?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Backup extended attributes.
         */
        extended_attrs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Back up DMAPI filesystem files.
         */
        backup_dmapi_fs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Creates a new file data.
         */
        new_image_data?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Excludes WPAR files.
         */
        exclude_wpar_files?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Backup encrypted files.
         */
        backup_crypt_files?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Storage path where the mksysb will stored.
         */
        storage_path: string;
        [k: string]: unknown;
      };
      /**
       * Add, modify, enable, disable and delete an IPA Lightweight Sub Certificate Authorities using IPA API.
       */
      ipa_subca?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This command module allows running one or more commands on a remote device running EdgeOS, such as the Ubiquiti EdgeRouter.
       * This module does not support running commands in configuration mode.
       * Certain C(show) commands in EdgeOS produce many lines of output and use a custom pager that can cause this module to hang.  If the value of the environment variable C(ANSIBLE_EDGEOS_TERMINAL_LENGTH) is not set, the default number of 10000 is used.
       * This is a network module and requires C(connection: network_cli) in order to work properly.
       * For more information please see the L(Network Guide,../network/getting_started/index.html).
       */
      edgeos_command?: {
        /**
         * Default: 10
         *
         * Number of times a command should be tried before it is considered failed. The command is run on the target device and evaluated against the C(wait_for) conditionals.
         */
        retries?: number | string;
        /**
         * The commands or ordered set of commands that should be run against the remote device. The output of the command is returned to the playbook. If the C(wait_for) argument is provided, the module is not returned until the condition is met or the number of retries is exceeded.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 1
         *
         * The number of seconds to wait between C(retries) of the command.
         */
        interval?: number | string;
        /**
         * Causes the task to wait for a specific condition to be met before moving forward. If the condition is not met before the specified number of retries is exceeded, the task will fail.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: all
         *
         * Used in conjunction with C(wait_for) to create match policy. If set to C(all), then all conditions in C(wait_for) must be met. If set to C(any), then only one condition must match.
         */
        match?: "any" | "all";
        [k: string]: unknown;
      };
      /**
       * Manages SNMP contact information.
       */
      nxos_snmp_contact?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: "present" | "absent";
        host?: string;
        /**
         * Contact information.
         */
        contact: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Notify Honeybadger.io about app deployments (see http://docs.honeybadger.io/article/188-deployment-tracking)
       */
      honeybadger_deployment?: {
        /**
         * URL of the project repository
         */
        repo?: string;
        /**
         * Default: https://api.honeybadger.io/v1/deploys
         *
         * Optional URL to submit the notification to.
         */
        url?: string;
        /**
         * The environment name, typically 'production', 'staging', etc.
         */
        environment: string;
        /**
         * API token.
         */
        token: string;
        /**
         * The username of the person doing the deployment
         */
        user?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A hash, number, tag, or other identifier showing what revision was deployed
         */
        revision?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of MLAG virtual IPs on Mellanox ONYX network devices.
       */
      onyx_mlag_vip?: {
        /**
         * Default: 12
         *
         * Delay interval, in seconds, waiting for the changes on mlag VIP to take effect.
         */
        delay?: number | string;
        /**
         * MLAG VIP state.
         */
        state?: "present" | "absent";
        /**
         * MLAG system MAC address. Required if I(state=present).
         */
        mac_address?: string;
        /**
         * Virtual IP address of the MLAG. Required if I(state=present).
         */
        ipaddress?: string;
        /**
         * MLAG group name. Required if I(state=present).
         */
        group_name?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more oVirt/RHV virtual machine snapshots.
       */
      ovirt_snapshot_facts?: {
        /**
         * Id of the snapshot we want to retrieve facts about.
         */
        snapshot_id?: string;
        /**
         * Description of the snapshot, can be used as glob expression.
         */
        description?: string;
        /**
         * Name of the VM with snapshot.
         */
        vm?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management configuration of system logging (syslog) on Cisco IOS XR devices.
       */
      iosxr_logging?: {
        [k: string]: unknown;
      };
      /**
       * Create/Delete/Initialize SnapMirror volume/vserver relationships
       * Modify schedule for a SnapMirror relationship
       */
      na_ontap_snapmirror?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Uses boto3 to set TTL.
       * requires botocore version 1.5.24 or higher.
       */
      dynamodb_ttl?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Sends a command to a network device and returns the result read from the device.
       */
      cli_command?: {
        /**
         * The boolean value, that when set to true will send I(command) to the device but not wait for a result.
         */
        sendonly?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The answer to reply with if I(prompt) is matched. The value can be a single answer or a list of answer for multiple prompts. In case the command execution results in multiple prompts the sequence of the prompt and excepted answer should be in same order.
         */
        answer?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * A single regex pattern or a sequence of patterns to evaluate the expected prompt from I(command).
         */
        prompt?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The command to send to the remote network device.  The resulting output from the command is returned, unless I(sendonly) is set.
         */
        command: string;
        /**
         * By default if any one of the prompts mentioned in C(prompt) option is matched it won't check for other prompts. This boolean flag, that when set to I(True) will check for all the prompts mentioned in C(prompt) option in the given order. If the option is set to I(True) all the prompts should be received from remote host if not it will result in timeout.
         */
        check_all?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manipulate static routes on a BIG-IP.
       */
      bigip_static_route?: {
        [k: string]: unknown;
      };
      /**
       * Grant and revoke roles in either project or domain context for OpenStack Identity Users.
       */
      os_user_role?: {
        /**
         * ID of the domain to scope the role association to. Valid only with keystone version 3, and required if I(project) is not specified.
         */
        domain?: string;
        /**
         * Name or ID for the group. Valid only with keystone version 3. If I(group) is not specified, then I(user) is required. Both may not be specified.
         */
        group?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Name or ID of the project to scope the role association to. If you are using keystone version 2, then this value is required.
         */
        project?: string;
        /**
         * Default: present
         *
         * Should the roles be present or absent on the user.
         */
        state?: string;
        /**
         * Name or ID for the role.
         */
        role?: string;
        /**
         * Name or ID for the user. If I(user) is not specified, then I(group) is required. Both may not be specified.
         */
        user?: string;
        [k: string]: unknown;
      };
      /**
       * Manage iRules across different modules on a BIG-IP.
       */
      bigip_irule?: {
        /**
         * The iRule file to interpret and upload to the BIG-IP. Either one of C(src) or C(content) must be provided.
         */
        src?: string;
        /**
         * The name of the iRule.
         */
        name?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * The BIG-IP module to add the iRule to.
         */
        module?: string;
        /**
         * When used instead of 'src', sets the contents of an iRule directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. Either one of C(src) or C(content) must be provided.
         */
        content?: string;
        /**
         * Default: present
         *
         * Whether the iRule should exist or not.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * Create and delete service offerings for guest and system VMs.
       * Update display_text of existing service offering.
       */
      cs_service_offering?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and delete instance of MySQL Database.
       */
      azure_rm_mysqldatabase?: {
        profile?: string;
        /**
         * Default: no
         *
         * When set to C(true), will delete and recreate the existing MySQL database if any of the properties don't match what is set.
         * When set to C(false), no change will occur to the database even if any of the properties do not match.
         */
        force_update?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the database.
         */
        name: string;
        /**
         * The name of the server.
         */
        server_name: string;
        cloud_environment?: string;
        /**
         * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
         */
        resource_group: string;
        /**
         * The charset of the database. Check MySQL documentation for possible values.
         * This is only set on creation, use I(force_update) to recreate a database if the values don't match.
         */
        charset?: string;
        ad_user?: string;
        secret?: string;
        adfs_authority_url?: string;
        /**
         * Default: present
         *
         * Assert the state of the MySQL Database. Use 'present' to create or update a database and 'absent' to delete it.
         */
        state?: "absent" | "present";
        client_id?: string;
        cert_validation_mode?: "validate" | "ignore";
        /**
         * The collation of the database. Check MySQL documentation for possible values.
         * This is only set on creation, use I(force_update) to recreate a database if the values don't match.
         */
        collation?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        api_profile?: string;
        [k: string]: unknown;
      };
      /**
       * Manage DNS profiles on a BIG-IP. Many DNS profiles; each with their own adjustments to the standard C(dns) profile. Users of this module should be aware that many of the adjustable knobs have no module default. Instead, the default is assigned by the BIG-IP system itself which, in most cases, is acceptable.
       */
      bigip_profile_dns?: {
        /**
         * Specifies whether DNS firewall capability is enabled.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        enable_dns_firewall?: string;
        /**
         * Specifies whether the system answers zone transfer requests for a DNS zone created on the system.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         * The C(enable_dns_express) and C(enable_zone_transfer) settings on a DNS profile affect how the system responds to zone transfer requests.
         * When the C(enable_dns_express) and C(enable_zone_transfer) settings are both C(yes), if a zone transfer request matches a DNS Express zone, then DNS Express answers the request.
         * When the C(enable_dns_express) setting is C(no) and the C(enable_zone_transfer) setting is C(yes), the BIG-IP system processes zone transfer requests based on the last action and answers the request from local BIND or a pool member.
         */
        enable_zone_transfer?: string;
        /**
         * Specifies the name of the DNS profile.
         */
        name?: string;
        /**
         * Specifies the profile from which this profile inherits settings.
         * When creating a new profile, if this parameter is not specified, the default is the system-supplied C(dns) profile.
         */
        parent?: string;
        /**
         * Specifies whether to process client-side DNS packets with Recursion Desired set in the header.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         * If set to C(no), processing of the packet is subject to the unhandled-query-action option.
         */
        process_recursion_desired?: string;
        /**
         * Specifies the action to take when a query does not match a Wide IP or a DNS Express Zone.
         * When C(allow), the BIG-IP system forwards queries to a DNS server or pool member. If a pool is not associated with a listener and the Use BIND Server on BIG-IP setting is set to Enabled, requests are forwarded to the local BIND server.
         * When C(drop), the BIG-IP system does not respond to the query.
         * When C(reject), the BIG-IP system returns the query with the REFUSED return code.
         * When C(hint), the BIG-IP system returns the query with a list of root name servers.
         * When C(no-error), the BIG-IP system returns the query with the NOERROR return code.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        unhandled_query_action?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the profile exists.
         * When C(absent), ensures the profile is removed.
         */
        state?: string;
        /**
         * Specifies whether the DNS Express engine is enabled.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         * The DNS Express engine receives zone transfers from the authoritative DNS server for the zone. If the C(enable_zone_transfer) setting is also C(yes) on this profile, the DNS Express engine also responds to zone transfer requests made by the nameservers configured as zone transfer clients for the DNS Express zone.
         */
        enable_dns_express?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies whether the system caches DNS responses.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         * When C(yes), the BIG-IP system caches DNS responses handled by the virtual servers associated with this profile. When you enable this setting, you must also specify a value for C(cache_name).
         * When C(no), the BIG-IP system does not cache DNS responses handled by the virtual servers associated with this profile. However, the profile retains the association with the DNS cache in the C(cache_name) parameter. Disable this setting when you want to debug the system.
         */
        enable_cache?: string;
        /**
         * Specifies whether the system forwards non-wide IP queries to the local BIND server on the BIG-IP system.
         * For best performance, disable this setting when using a DNS cache.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        use_local_bind?: string;
        /**
         * Specifies whether the system uses Global Traffic Manager to manage the response.
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        enable_gtm?: string;
        /**
         * Specifies whether the system signs responses with DNSSEC keys and replies to DNSSEC specific queries (e.g., DNSKEY query type).
         * When creating a new profile, if this parameter is not specified, the default is provided by the parent profile.
         */
        enable_dnssec?: string;
        /**
         * Specifies the user-created cache that the system uses to cache DNS responses.
         * When you select a cache for the system to use, you must also set C(enable_dns_cache) to C(yes)
         */
        cache_name?: string;
        [k: string]: unknown;
      };
      /**
       * This module provices support for executing Cisco NSO actions and then verifying that the output is as expected.
       */
      nso_action?: {
        username: string;
        url: string;
        /**
         * List of result parameter names that will cause the task to fail if they are present.
         *
         */
        output_invalid?: {
          [k: string]: unknown;
        };
        /**
         * Required output parameters.
         *
         */
        output_required?: {
          [k: string]: unknown;
        };
        timeout?: string;
        /**
         * NSO action parameters.
         *
         */
        input?: {
          [k: string]: unknown;
        };
        /**
         * Path to NSO action.
         */
        path: string;
        password: string;
        /**
         * If set to true, the task will fail if any output parameters not in output_required is present in the output.
         *
         */
        validate_strict?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module can be used to gather facts about all resource configuration information.
       */
      vmware_resource_pool_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides support for managing configuration in Cisco NSO and can also ensure services are in sync.
       */
      nso_config?: {
        username: string;
        url: string;
        password: string;
        /**
         * NSO data in format as | display json converted to YAML. List entries can be annotated with a __state entry. Set to in-sync/deep-in-sync for services to verify service is in sync with the network. Set to absent in list entries to ensure they are deleted if they exist in NSO.
         *
         */
        data: {
          [k: string]: unknown;
        };
        timeout?: string;
        [k: string]: unknown;
      };
      /**
       * Apstra AOS Logical Device module let you manage your Logical Devices easily. You can create create and delete Logical Device by Name, ID or by using a JSON File. This module is idempotent and support the I(check) mode. It's using the AOS REST API.
       */
      aos_logical_device?: {
        /**
         * Datastructure of the Logical Device to create. The data can be in YAML / JSON or directly a variable. It's the same datastructure that is returned on success in I(value).
         */
        content?: string;
        /**
         * Default: present
         *
         * Indicate what is the expected state of the Logical Device (present or not).
         */
        state?: "present" | "absent";
        /**
         * An existing AOS session as obtained by M(aos_login) module.
         */
        session: {
          [k: string]: unknown;
        };
        /**
         * AOS Id of the Logical Device to manage (can't be used to create a new Logical Device), Only one of I(name), I(id) or I(content) can be set.
         */
        id?: string;
        /**
         * Name of the Logical Device to manage. Only one of I(name), I(id) or I(content) can be set.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Create NetApp ONTAP volume clones.
       * A FlexClone License is required to use this module
       */
      na_ontap_volume_clone?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * With the module you can retrieve and output detailed information about the attached disks of the target and its volumes and partitions if existent.
       */
      win_disk_facts?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * C(synchronize) is a wrapper around rsync to make common tasks in your playbooks quick and easy. It is run and originates on the local host where Ansible is being run. Of course, you could just use the C(command) action to call rsync yourself, but you also have to add a fair number of boilerplate options and host facts. C(synchronize) is not intended to provide access to the full power of rsync, but does make the most common invocations easier to implement. You `still` may need to call rsync directly via C(command) or C(shell) depending on your use case.
       */
      synchronize?: {
        /**
         * Default: no
         *
         * Tells rsync to keep the partial file which should make a subsequent transfer of the rest of the file much faster.
         */
        partial?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * add a destination to hard link against during the rsync.
         */
        link_dest?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: no
         *
         * Copy symlinks as the item that they point to (the referent) is copied, rather than the symlink.
         */
        copy_links?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: the value of the archive option
         *
         * Preserve permissions.
         */
        perms?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: the value of the archive option
         *
         * Preserve owner (super user only)
         */
        owner?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Skip creating new files on receiver.
         */
        existing_only?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Mirrors the rsync archive flag, enables recursive, links, perms, times, owner, group flags and -D.
         */
        archive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: Value of ansible_ssh_port for this host, remote_port config setting, or the value from ssh client configuration if none of those are set
         *
         * Port number for ssh on the destination host. Prior to ansible 2.0, the ansible_ssh_port inventory var took precedence over this value.
         */
        dest_port?: number | string;
        _local_rsync_path?: string;
        /**
         * Default: the value of the archive option
         *
         * Preserve group
         */
        group?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: the value of the archive option
         *
         * Copy symlinks as symlinks.
         */
        links?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the rsync command to run on the remote host. See C(--rsync-path) on the rsync man page.
         * To specify the rsync command to run on the local host, you need to set this your task var C(ansible_rsync_path).
         */
        rsync_path?: string;
        /**
         * Path on the destination host that will be synchronized from the source; The path can be absolute or relative.
         */
        dest: string;
        /**
         * Default: no
         *
         * Verify destination host key.
         */
        verify_host?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Transfer directories without recursing
         */
        dirs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the private key to use for SSH-based rsync connections (e.g. C(~/.ssh/id_rsa))
         */
        private_key?: string;
        _substitute_controller?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Compress file data during the transfer. In most cases, leave this enabled unless it causes problems.
         */
        compress?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify a C(--timeout) for the rsync command in seconds.
         */
        rsync_timeout?: number | string;
        /**
         * Specify additional rsync options by passing in an array.
         */
        rsync_opts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: True
         *
         * put user@ for the remote paths. If you have a custom ssh config to define the remote user for a host that does not match the inventory user, you should set this parameter to "no".
         */
        set_remote_user?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: the value of the archive option
         *
         * Recurse into directories.
         */
        recursive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Path on the source host that will be synchronized to the destination; The path can be absolute or relative.
         */
        src: string;
        /**
         * Default: no
         *
         * Skip based on checksum, rather than mod-time & size; Note that that "archive" option is still enabled by default - the "checksum" option will not disable it.
         */
        checksum?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: the value of the archive option
         *
         * Preserve modification times
         */
        times?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: push
         *
         * Specify the direction of the synchronization. In push mode the localhost or delegate is the source; In pull mode the remote host in context is the source.
         */
        mode?: "pull" | "push";
        ssh_args?: string;
        /**
         * Default: no
         *
         * Delete files in C(dest) that don't exist (after transfer, not before) in the C(src) path. This option requires C(recursive=yes).
         */
        delete?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module is used to configure BackupConfiguration object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_backupconfiguration?: {
        /**
         * Remote destination.
         */
        remote_hostname?: string;
        /**
         * Directory at remote destination with write permission for ssh user.
         */
        remote_directory?: string;
        /**
         * Unique object identifier of the object.
         */
        uuid?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * Access credentials for remote destination.
         * It is a reference to an object of type cloudconnectoruser.
         */
        ssh_user_ref?: string;
        /**
         * Remote backup.
         */
        upload_to_remote_host?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Prefix of the exported configuration file.
         * Field introduced in 17.1.1.
         */
        backup_file_prefix?: string;
        api_version?: string;
        /**
         * Local backup.
         */
        save_local?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Passphrase of backup configuration.
         */
        backup_passphrase?: string;
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        tenant?: string;
        /**
         * Name of backup configuration.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        /**
         * It is a reference to an object of type tenant.
         */
        tenant_ref?: string;
        /**
         * Rotate the backup files based on this count.
         * Allowed values are 1-20.
         * Default value when not specified in API or module is interpreted by Avi Controller as 4.
         */
        maximum_backups_stored?: number | string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Manage initial Contract Subjects on Cisco ACI fabrics.
       */
      aci_contract_subject?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * This module can be used to obtain the version of the Avi REST API. U(https://avinetworks.com/)
       */
      avi_api_version?: {
        username?: string;
        controller?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        api_version?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        tenant_uuid?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Send a message to Campfire.
       * Messages with newlines will result in a "Paste" message being sent.
       */
      campfire?: {
        /**
         * The message body.
         */
        msg: string;
        /**
         * API token.
         */
        token: string;
        /**
         * The subscription name to use.
         */
        subscription: string;
        /**
         * Room number to which the message should be sent.
         */
        room: string;
        /**
         * Send a notification sound before the message.
         */
        notify?:
          | "56k"
          | "bell"
          | "bezos"
          | "bueller"
          | "clowntown"
          | "cottoneyejoe"
          | "crickets"
          | "dadgummit"
          | "dangerzone"
          | "danielsan"
          | "deeper"
          | "drama"
          | "greatjob"
          | "greyjoy"
          | "guarantee"
          | "heygirl"
          | "horn"
          | "horror"
          | "inconceivable"
          | "live"
          | "loggins"
          | "makeitso"
          | "noooo"
          | "nyan"
          | "ohmy"
          | "ohyeah"
          | "pushit"
          | "rimshot"
          | "rollout"
          | "rumble"
          | "sax"
          | "secret"
          | "sexyback"
          | "story"
          | "tada"
          | "tmyk"
          | "trololo"
          | "trombone"
          | "unix"
          | "vuvuzela"
          | "what"
          | "whoomp"
          | "yeah"
          | "yodel";
        [k: string]: unknown;
      };
      /**
       * This module manage affinity labels in oVirt/RHV. It can also manage assignments of those labels to hosts and VMs.
       */
      ovirt_affinity_label?: {
        /**
         * Name of the affinity label to manage.
         */
        name: string;
        poll_interval?: number | string;
        /**
         * Default: present
         *
         * Should the affinity label be present or absent.
         */
        state?: "present" | "absent";
        nested_attributes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the cluster where vms and hosts resides.
         */
        cluster?: string;
        fetch_nested?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of the hosts names, which should have assigned this affinity label.
         */
        hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        auth: {
          [k: string]: unknown;
        };
        timeout?: number | string;
        /**
         * List of the VMs names, which should have assigned this affinity label.
         */
        vms?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * The manageiq_alerts module supports adding, updating and deleting alerts in ManageIQ.
       */
      manageiq_alerts?: {
        /**
         * The unique alert description in ManageIQ.
         * Required when state is "absent" or "present".
         */
        description?: string;
        /**
         * Default: hash
         *
         * Expression type.
         */
        expression_type?: "hash" | "miq";
        /**
         * Enable or disable the alert. Required if state is "present".
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * absent - alert should not exist,
         * present - alert should exist,
         */
        state?: "absent" | "present";
        manageiq_connection?: {
          [k: string]: unknown;
        };
        /**
         * The alert expression for ManageIQ.
         * Can either be in the "Miq Expression" format or the "Hash Expression format".
         * Required if state is "present".
         */
        expression?: {
          [k: string]: unknown;
        };
        /**
         * Additional alert options, such as notification type and frequency
         */
        options?: {
          [k: string]: unknown;
        };
        /**
         * The entity type for the alert in ManageIQ. Required when state is "present".
         */
        resource_type?:
          | "Vm"
          | "ContainerNode"
          | "MiqServer"
          | "Host"
          | "Storage"
          | "EmsCluster"
          | "ExtManagementSystem"
          | "MiddlewareServer";
        [k: string]: unknown;
      };
      /**
       * Modify a ONTAP network port.
       */
      na_ontap_net_port?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module supports two different workflows for copying a file to flash (or bootflash) on NXOS devices.  Files can either be (1) pushed from the Ansible controller to the device or (2) pulled from a remote SCP file server to the device.  File copies are initiated from the NXOS device to the remote SCP server.  This module only supports the use of connection C(network_cli) or C(Cli) transport with connection C(local).
       */
      nxos_file_copy?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * When (file_pull is False) this is the path to the local file on the Ansible controller. The local directory must exist.
         * When (file_pull is True) this is the file name used on the NXOS device.
         */
        local_file?: string;
        /**
         * The remote scp server address which is used to pull the file. This is required if file_pull is True.
         */
        remote_scp_server?: string;
        /**
         * When (False) file is copied from the Ansible controller to the NXOS device.
         * When (True) file is copied from a remote SCP server to the NXOS device. In this mode, the file copy is initiated from the NXOS device.
         * If the file is already present on the device it will be overwritten and therefore the operation is NOT idempotent.
         */
        file_pull?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        auth_pass?: string;
        /**
         * Default: 22
         *
         * SSH port to connect to server during transfer of file
         */
        connect_ssh_port?: number | string;
        /**
         * Default: 300
         *
         * Use this parameter to set timeout in seconds, when transferring large files or when the network is slow.
         */
        file_pull_timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        username?: string;
        /**
         * The remote scp server username which is used to pull the file. This is required if file_pull is True.
         */
        remote_scp_server_user?: string;
        /**
         * The remote scp server password which is used to pull the file. This is required if file_pull is True.
         */
        remote_scp_server_password?: string;
        host?: string;
        password?: string;
        /**
         * Default: bootflash:
         *
         * The remote file system of the device. If omitted, devices that support a I(file_system) parameter will use their default values.
         */
        file_system?: string;
        ssh_keyfile?: string;
        /**
         * When (file_pull is True) file is copied from a remote SCP server to the NXOS device, and written to this directory on the NXOS device. If the directory does not exist, it will be created under the file_system. This is an optional parameter.
         * When (file_pull is False), this not used.
         */
        local_file_directory?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        timeout?: number | string;
        /**
         * When (file_pull is False) this is the remote file path on the NXOS device. If omitted, the name of the local file will be used. The remote directory must exist.
         * When (file_pull is True) this is the full path to the file on the remote SCP server to be copied to the NXOS device.
         */
        remote_file?: string;
        [k: string]: unknown;
      };
      /**
       * Add or Remove rule from an existing security group
       */
      os_security_group_rule?: {
        /**
         * Default: ingress
         *
         * The direction in which the security group rule is applied. Not all providers support egress.
         */
        direction?: string;
        /**
         * IP protocols TCP UDP ICMP 112 (VRRP)
         */
        protocol?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Source IP address(es) in CIDR notation (exclusive with remote_group)
         */
        remote_ip_prefix?: string;
        /**
         * Ending port
         */
        port_range_max?: string;
        /**
         * Unique name or ID of the project.
         */
        project?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Starting port
         */
        port_range_min?: string;
        /**
         * Default: IPv4
         *
         * Must be IPv4 or IPv6, and addresses represented in CIDR must match the ingress or egress rules. Not all providers support IPv6.
         */
        ethertype?: string;
        /**
         * Name or ID of the security group
         */
        security_group?: string;
        /**
         * Name or ID of the Security group to link (exclusive with remote_ip_prefix)
         */
        remote_group?: string;
        [k: string]: unknown;
      };
      /**
       * Get facts for one storage account or all storage accounts within a resource group.
       */
      azure_rm_storageaccount_facts?: {
        [k: string]: unknown;
      };
      /**
       * Enable, disable, drain and set weights for HAProxy backend servers using socket commands.
       */
      haproxy?: {
        /**
         * Wait until the server has no active connections or until the timeout determined by wait_interval and wait_retries is reached.  Continue only after the status changes to 'MAINT'.  This overrides the shutdown_sessions option.
         */
        drain?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: /var/run/haproxy.sock
         *
         * Path to the HAProxy socket file.
         */
        socket?: string;
        /**
         * The value passed in argument. If the value ends with the `%` sign, then the new weight will be relative to the initially configured weight. Relative weights are only permitted between 0 and 100% and absolute weights are permitted between 0 and 256.
         */
        weight?: string;
        /**
         * Default: 5
         *
         * Number of seconds to wait between retries.
         */
        wait_interval?: number | string;
        /**
         * Desired state of the provided backend host.
         * Note that C(drain) state was added in version 2.4. It is supported only by HAProxy version 1.5 or later, if used on versions < 1.5, it will be ignored.
         */
        state: "enabled" | "disabled" | "drain";
        /**
         * Default: auto-detected
         *
         * Name of the HAProxy backend pool.
         */
        backend?: string;
        /**
         * Default: 25
         *
         * Number of times to check for status after changing the state.
         */
        wait_retries?: number | string;
        /**
         * Name of the backend host to change.
         */
        host: string;
        /**
         * Default: no
         *
         * Fail whenever trying to enable/disable a backend host that does not exist
         */
        fail_on_not_found?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * When disabling a server, immediately terminate all the sessions attached to the specified server. This can be used to terminate long-running sessions after a server is put into maintenance mode. Overridden by the drain option.
         */
        shutdown_sessions?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Wait until the server reports a status of 'UP' when `state=enabled`, status of 'MAINT' when `state=disabled` or status of 'DRAIN' when `state=drain`
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module offers the ability to set a configuration checkpoint file or rollback to a configuration checkpoint file on Cisco NXOS switches.
       */
      nxos_rollback?: {
        /**
         * Name of checkpoint file to create. Mutually exclusive with rollback_to.
         */
        checkpoint_file?: string;
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        /**
         * Name of checkpoint file to rollback to. Mutually exclusive with checkpoint_file.
         */
        rollback_to?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Represents a TargetSslProxy resource, which is used by one or more global forwarding rule to route incoming SSL requests to a backend service.
       */
      gcp_compute_target_ssl_proxy?: {
        scopes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
         */
        name: string;
        /**
         * A reference to the BackendService resource.
         */
        service: {
          [k: string]: unknown;
        };
        /**
         * A list of SslCertificate resources that are used to authenticate connections between users and the load balancer. Currently, exactly one SSL certificate must be specified.
         */
        ssl_certificates:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        project?: string;
        /**
         * Default: present
         *
         * Whether the given object should exist in GCP
         */
        state?: "present" | "absent";
        /**
         * Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
         */
        proxy_header?: "NONE" | "PROXY_V1";
        service_account_email?: string;
        service_account_file?: string;
        auth_kind?: "machineaccount" | "serviceaccount" | "application";
        /**
         * An optional description of this resource.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * This module fetches data from the instance metadata endpoint in ec2 as per http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html. The module must be called from within the EC2 instance itself.
       */
      ec2_metadata_facts?: {
        [k: string]: unknown;
      };
      /**
       * Module to manage users in oVirt/RHV.
       */
      ovirt_user?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage an AWS Application Elastic Load Balancer. See U(https://aws.amazon.com/blogs/aws/new-aws-application-load-balancer/) for details.
       */
      elb_application_lb?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts about SSH keys available.
       */
      vultr_ssh_key_facts?: {
        api_retries?: number | string;
        api_timeout?: number | string;
        api_endpoint?: string;
        api_account?: string;
        api_key?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create or Destroy a Backend Service.  See U(https://cloud.google.com/compute/docs/load-balancing/http/backend-service) for an overview. Full install/configuration instructions for the Google Cloud modules can be found in the comments of ansible/test/gce_tests.py.
       */
      gcp_backend_service?: {
        /**
         * The protocol this Backend Service uses to communicate with backends. Possible values are HTTP, HTTPS, TCP, and SSL. The default is HTTP.
         */
        protocol?: "HTTP" | "HTTPS" | "SSL" | "TCP";
        /**
         * If true, enable Cloud CDN for this Backend Service.
         */
        enable_cdn?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Service account email
         */
        service_account_email?: string;
        service_account_permissions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        pem_file?: string;
        /**
         * Default: present
         *
         * Desired state of the resource
         */
        state?: "absent" | "present";
        /**
         * List of backends that make up the backend service. A backend is made up of an instance group and optionally several other parameters.  See U(https://cloud.google.com/compute/docs/reference/latest/backendServices) for details.
         */
        backends:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the port on the managed instance group (MIG) that backend services can forward data to. Required for external load balancing.
         */
        port_name?: string;
        /**
         * How many seconds to wait for the backend before considering it a failed request. Default is 30 seconds. Valid range is 1-86400.
         */
        timeout?: number | string;
        /**
         * Path to the JSON file associated with the service account email.
         */
        credentials_file?: string;
        /**
         * List of healthchecks. Only one healthcheck is supported.
         */
        healthchecks:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the Backend Service.
         */
        backend_service_name: string;
        /**
         * GCE project ID.
         */
        project_id?: string;
        [k: string]: unknown;
      };
      /**
       * Write log entries to a given event log from a specified source.
       */
      win_eventlog_entry?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Attach or Detach volumes from OpenStack VM's
       */
      os_server_volume?: {
        /**
         * Name or id of volume you want to attach to a server
         */
        volume?: string;
        /**
         * Device you want to attach. Defaults to auto finding a device name.
         */
        device?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Name or ID of server you want to attach a volume to
         */
        server?: string;
        [k: string]: unknown;
      };
      /**
       * Manages OpenNebula instances
       */
      one_vm?: {
        [k: string]: unknown;
      };
      /**
       * Gather facts about customer gateways in AWS
       */
      ec2_customer_gateway_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allows for creation, management, and visibility into layer 3 firewalls implemented on Meraki MX firewalls.
       */
      meraki_mx_l3_firewall?: {
        [k: string]: unknown;
      };
      /**
       * Manages advanced ACL configurations on HUAWEI CloudEngine switches.
       */
      ce_acl_advance?: {
        /**
         * ACL step. The value is an integer ranging from 1 to 20. The default value is 5.
         */
        acl_step?: string;
        /**
         * Protocol type.
         */
        protocol?: "ip" | "icmp" | "igmp" | "ipinip" | "tcp" | "udp" | "gre" | "ospf";
        /**
         * Data packets can be filtered based on the priority field. The value is an integer ranging from 0 to 7.
         */
        precedence?: string;
        /**
         * Range type of the source port.
         */
        src_port_op?: "lt" | "eq" | "gt" | "range";
        /**
         * Default: no
         *
         * Flag of logging matched data packets.
         */
        log_flag?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of a time range in which an ACL rule takes effect.
         */
        time_range?: string;
        /**
         * Start port number of the source port. The value is an integer ranging from 0 to 65535.
         */
        src_port_begin?: string;
        /**
         * Type of packet fragmentation.
         */
        frag_type?: "fragment" | "clear_fragment";
        /**
         * Name of a destination port pool. The value is a string of 1 to 32 characters.
         */
        dest_port_pool_name?: string;
        /**
         * Name of a destination pool. The value is a string of 1 to 32 characters.
         */
        dest_pool_name?: string;
        /**
         * ACL description. The value is a string of 1 to 127 characters.
         */
        acl_description?: string;
        /**
         * Default: no
         *
         * Whether TTL Expired is matched, with the TTL value of 1.
         */
        ttl_expired?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * ICMP type. This parameter is available only when the packet protocol is ICMP. The value is an integer ranging from 0 to 255.
         */
        icmp_type?: string;
        port?: number | string;
        /**
         * ICMP name.
         */
        icmp_name?:
          | "unconfiged"
          | "echo"
          | "echo-reply"
          | "fragmentneed-DFset"
          | "host-redirect"
          | "host-tos-redirect"
          | "host-unreachable"
          | "information-reply"
          | "information-request"
          | "net-redirect"
          | "net-tos-redirect"
          | "net-unreachable"
          | "parameter-problem"
          | "port-unreachable"
          | "protocol-unreachable"
          | "reassembly-timeout"
          | "source-quench"
          | "source-route-failed"
          | "timestamp-reply"
          | "timestamp-request"
          | "ttl-exceeded"
          | "address-mask-reply"
          | "address-mask-request"
          | "custom";
        /**
         * Default: no
         *
         * Match established connections.
         */
        established?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Internet Group Management Protocol.
         */
        igmp_type?:
          | "host-query"
          | "mrouter-adver"
          | "mrouter-solic"
          | "mrouter-termi"
          | "mtrace-resp"
          | "mtrace-route"
          | "v1host-report"
          | "v2host-report"
          | "v2leave-group"
          | "v3host-report";
        /**
         * ToS value on which data packet filtering is based. The value is an integer ranging from 0 to 15.
         */
        tos?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: "present" | "absent" | "delete_acl";
        /**
         * Source IP address mask. The value is an integer ranging from 1 to 32.
         */
        src_mask?: string;
        /**
         * Matching mode of basic ACL rules.
         */
        rule_action?: "permit" | "deny";
        /**
         * ACL number. The value is an integer ranging from 3000 to 3999.
         */
        acl_num?: string;
        /**
         * TCP flag mask value. The value is an integer ranging from 0 to 63.
         */
        tcp_flag_mask?: string;
        transport?: "cli" | "netconf";
        provider?: {
          [k: string]: unknown;
        };
        /**
         * End port number of the source port. The value is an integer ranging from 0 to 65535.
         */
        src_port_end?: string;
        /**
         * Destination IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.
         */
        dest_ip?: string;
        /**
         * ICMP message code. Data packets can be filtered based on the ICMP message code. The value is an integer ranging from 0 to 255.
         */
        icmp_code?: string;
        /**
         * End port number of the destination port. The value is an integer ranging from 0 to 65535.
         */
        dest_port_end?: string;
        /**
         * ACL number or name. For a numbered rule group, the value ranging from 3000 to 3999 indicates a advance ACL. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.
         */
        acl_name: string;
        /**
         * Differentiated Services Code Point. The value is an integer ranging from 0 to 63.
         */
        dscp?: string;
        /**
         * Name of a basic ACL rule. The value is a string of 1 to 32 characters.
         */
        rule_name?: string;
        host?: string;
        password?: string;
        /**
         * Description about an ACL rule.
         */
        rule_description?: string;
        ssh_keyfile?: string;
        /**
         * Destination IP address mask. The value is an integer ranging from 1 to 32.
         */
        dest_mask?: string;
        /**
         * Name of a source port pool. The value is a string of 1 to 32 characters.
         */
        src_port_pool_name?: string;
        /**
         * Source IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.
         */
        source_ip?: string;
        username?: string;
        /**
         * TCP flag value. The value is an integer ranging from 0 to 63.
         */
        syn_flag?: string;
        /**
         * VPN instance name. The value is a string of 1 to 31 characters.The default value is _public_.
         */
        vrf_name?: string;
        /**
         * Name of a source pool. The value is a string of 1 to 32 characters.
         */
        src_pool_name?: string;
        timeout?: number | string;
        /**
         * Start port number of the destination port. The value is an integer ranging from 0 to 65535.
         */
        dest_port_begin?: string;
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Range type of the destination port.
         */
        dest_port_op?: "lt" | "eq" | "gt" | "range";
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * ID of a basic ACL rule in configuration mode. The value is an integer ranging from 0 to 4294967294.
         */
        rule_id?: string;
        [k: string]: unknown;
      };
      /**
       * Creates or terminates ecs services.
       */
      ecs_service?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Waits for a total of C(timeout) seconds.
       * Retries the transport connection after a timeout of C(connect_timeout).
       * Tests the transport connection every C(sleep) seconds.
       * This module makes use of internal ansible transport (and configuration) and the ping/win_ping module to guarantee correct end-to-end functioning.
       * This module is also supported for Windows targets.
       */
      wait_for_connection?: {
        active_connection_states?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        host?: string;
        /**
         * Default: 5
         *
         * Maximum number of seconds to wait for a connection to happen before closing and retrying.
         */
        connect_timeout?: number | string;
        /**
         * Number of seconds to wait before starting to poll.
         */
        delay?: number | string;
        search_regex?: string;
        state?: "absent" | "drained" | "present" | "started" | "stopped";
        /**
         * Default: 1
         *
         * Number of seconds to sleep between checks.
         */
        sleep?: number | string;
        /**
         * Default: 600
         *
         * Maximum number of seconds to wait for.
         */
        timeout?: number | string;
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        msg?: string;
        path?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module is used to configure WafPolicy object
       * more examples at U(https://github.com/avinetworks/devops)
       */
      avi_wafpolicy?: {
        /**
         * Waf rules are categorized in to groups based on their characterization.
         * These groups are created by the user and will be  enforced before the crs groups.
         * Field introduced in 17.2.1.
         */
        pre_crs_groups?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Field introduced in 17.2.1.
         */
        uuid?: string;
        /**
         * Waf rules are categorized in to groups based on their characterization.
         * These groups are created by the user and will be enforced after the crs groups.
         * Field introduced in 17.2.1.
         */
        post_crs_groups?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * The state that should be applied on the entity.
         */
        state?: "absent" | "present";
        /**
         * Creator name.
         * Field introduced in 17.2.4.
         */
        created_by?: string;
        /**
         * Patch operation to use when using avi_api_update_method as patch.
         */
        avi_api_patch_op?: "add" | "replace" | "delete";
        /**
         * Default: put
         *
         * Default method for object update is HTTP PUT.
         * Setting to patch will override that behavior to use HTTP PATCH.
         */
        avi_api_update_method?: "put" | "patch";
        api_version?: string;
        username?: string;
        /**
         * Field introduced in 17.2.1.
         */
        description?: string;
        /**
         * Waf rules are categorized in to groups based on their characterization.
         * These groups are system created with crs groups.
         * Field introduced in 17.2.1.
         */
        crs_groups?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        controller?: string;
        api_context?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * Waf ruleset paranoia  mode.
         * This is used to select rules based on the paranoia-level tag.
         * Enum options - WAF_PARANOIA_LEVEL_LOW, WAF_PARANOIA_LEVEL_MEDIUM, WAF_PARANOIA_LEVEL_HIGH, WAF_PARANOIA_LEVEL_EXTREME.
         * Field introduced in 17.2.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as WAF_PARANOIA_LEVEL_LOW.
         */
        paranoia_level?: string;
        tenant?: string;
        /**
         * Waf profile for waf policy.
         * It is a reference to an object of type wafprofile.
         * Field introduced in 17.2.1.
         */
        waf_profile_ref: string;
        /**
         * Field introduced in 17.2.1.
         */
        name: string;
        /**
         * Avi controller URL of the object.
         */
        url?: string;
        avi_credentials?: {
          [k: string]: unknown;
        };
        /**
         * It is a reference to an object of type tenant.
         * Field introduced in 17.2.1.
         */
        tenant_ref?: string;
        /**
         * Waf policy mode.
         * This can be detection or enforcement.
         * Enum options - WAF_MODE_DETECTION_ONLY, WAF_MODE_ENFORCEMENT.
         * Field introduced in 17.2.1.
         * Default value when not specified in API or module is interpreted by Avi Controller as WAF_MODE_DETECTION_ONLY.
         */
        mode: string;
        tenant_uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Return a list of files based on specified criteria.
       * Multiple criteria are AND'd together.
       * For non-Windows targets, use the M(find) module instead.
       */
      win_find?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to move virtual machines between folders.
       */
      vmware_guest_move?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add and delete vCenter license keys.
       */
      vcenter_license?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Collects facts from Cisco Nexus devices running the NX-OS operating system.  Fact collection is supported over both Cli and Nxapi transports.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      nxos_facts?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        host?: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, legacy, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "nxapi";
        [k: string]: unknown;
      };
      /**
       * Manage packages with the XBPS package manager.
       */
      xbps?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Unzips compressed files and archives.
       * Supports .zip files natively.
       * Supports other formats supported by the Powershell Community Extensions (PSCX) module (basically everything 7zip supports).
       * For non-Windows targets, use the M(unarchive) module instead.
       */
      win_unzip?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manipulate SNMP trap information on a BIG-IP.
       */
      bigip_snmp_trap?: {
        /**
         * Specifies to which Simple Network Management Protocol (SNMP) version the trap destination applies.
         */
        snmp_version?: string;
        /**
         * Default: Common
         *
         * Device partition to manage resources on.
         */
        partition?: string;
        /**
         * Specifies the name of the trap network. This option is not supported in versions of BIG-IP < 12.1.0. If used on versions < 12.1.0, it will simply be ignored.
         * The value C(default) was removed in BIG-IP version 13.1.0. Specifying this value when configuring a BIG-IP will cause the module to stop and report an error. The usual remedy is to choose one of the other options, such as C(management).
         */
        network?: string;
        /**
         * Specifies the address for the trap destination. This can be either an IP address or a hostname.
         */
        destination?: string;
        /**
         * Specifies the community name for the trap destination.
         */
        community?: string;
        /**
         * Default: present
         *
         * When C(present), ensures that the resource exists.
         * When C(absent), ensures that the resource does not exist.
         */
        state?: string;
        /**
         * Specifies the port for the trap destination.
         */
        port?: string;
        /**
         * Name of the SNMP configuration endpoint.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Module to copy a file to a VM, fetch a file from a VM and create or delete a directory in the guest OS.
       */
      vmware_guest_file_operation?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Runs getent against one of it's various databases and returns information into the host's facts, in a getent_<database> prefixed variable.
       */
      getent?: {
        /**
         * Default: yes
         *
         * If a supplied key is missing this will make the task fail if C(yes).
         */
        fail_key?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Character used to split the database values into lists/arrays such as ':' or '	', otherwise  it will try to pick one depending on the database.
         */
        split?: string;
        /**
         * Key from which to return values from the specified database, otherwise the full contents are returned.
         */
        key?: string;
        /**
         * The name of a getent database supported by the target system (passwd, group, hosts, etc).
         */
        database: string;
        [k: string]: unknown;
      };
      /**
       * This module will actively managed vCloud Air vApp instances.  Instances can be created and deleted as well as both deployed and undeployed.
       */
      vca_vapp?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages Mercurial (hg) repositories. Supports SSH, HTTP/S and local address.
       */
      hg?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of link aggregation groups on Arista EOS network devices.
       */
      eos_linkagg?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        provider?: {
          [k: string]: unknown;
        };
        ssh_keyfile?: string;
        /**
         * Channel-group number for the port-channel Link aggregation group. Range 1-2000.
         */
        group?: number | string;
        timeout?: number | string;
        auth_pass?: string;
        /**
         * Default: present
         *
         * State of the link aggregation group.
         */
        state?: "present" | "absent";
        /**
         * Purge links not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        /**
         * Mode of the link aggregation group.
         */
        mode?: "active" | "on" | "passive";
        /**
         * List of members of the link aggregation group.
         */
        members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Minimum number of ports required up before bringing up the link aggregation group.
         */
        min_links?: number | string;
        /**
         * List of link aggregation definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        use_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        password?: string;
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "cli" | "eapi";
        [k: string]: unknown;
      };
      /**
       * Installs or uninstalls a package in either an MSI or EXE format.
       * These packages can be sources from the local file system, network file share or a url.
       * Please read the notes section around some caveats with this module.
       */
      win_package?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        /**
         * Any arguments the installer needs to either install or uninstall the package.
         * If the package is an MSI do not supply the C(/qn), C(/log) or C(/norestart) arguments.
         * As of Ansible 2.5, this parameter can be a list of arguments and the module will escape the arguments as necessary, it is recommended to use a string when dealing with MSI packages due to the unique escaping issues with msiexec.
         */
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages software images on a BIG-IP. These images may include both base images and hotfix images.
       */
      bigip_software_image?: {
        [k: string]: unknown;
      };
      /**
       * Creates/Deletes/Updates a single record in ServiceNow
       */
      snow_record?: {
        /**
         * User to connect to ServiceNow as
         */
        username: string;
        /**
         * Password for username
         */
        password: string;
        /**
         * Record number to update. Required for C(state:absent)
         */
        number?: string;
        /**
         * The service now instance name
         */
        instance: string;
        /**
         * If C(present) is supplied with a C(number) argument, the module will attempt to update the record with the supplied data.  If no such record exists, a new one will be created.  C(absent) will delete a record.
         */
        state: "present" | "absent";
        /**
         * Attach a file to the record
         */
        attachment?: string;
        /**
         * Default: incident
         *
         * Table to query for records
         */
        table?: string;
        /**
         * Default: number
         *
         * Changes the field that C(number) uses to find records
         */
        lookup_field?: string;
        /**
         * key, value pairs of data to load into the record. See Examples. Required for C(state:present)
         */
        data?: {
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      /**
       * Add or Remove a listener for a load balancer from the OpenStack load-balancer service.
       */
      os_listener?: {
        /**
         * Default: HTTP
         *
         * The protocol for the listener.
         */
        protocol?: string;
        /**
         * Name that has to be given to the listener
         */
        name?: string;
        /**
         * Ignored. Present for backwards compatibility
         */
        availability_zone?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: 180
         *
         * The amount of time the module should wait for the load balancer to get into ACTIVE state.
         */
        timeout?: string;
        /**
         * Default: 80
         *
         * The protocol port number for the listener.
         */
        protocol_port?: string;
        /**
         * The name or id of the load balancer that this listener belongs to.
         */
        loadbalancer?: string;
        /**
         * Default: yes
         *
         * If the module should wait for the load balancer to be ACTIVE.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * Create, modify or delete svm on NetApp ONTAP
       */
      na_ontap_svm?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module creates, removes or resizes volume groups.
       */
      lvg?: {
        /**
         * Additional options to pass to C(vgcreate) when creating the volume group.
         */
        vg_options?: string;
        /**
         * List of comma-separated devices to use as physical devices in this volume group. Required when creating or resizing volume group.
         * The module will take care of running pvcreate if needed.
         */
        pvs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: no
         *
         * If C(yes), allows to remove volume group with logical volumes.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the volume group.
         */
        vg: string;
        /**
         * Default: present
         *
         * Control if the volume group exists.
         */
        state?: "absent" | "present";
        /**
         * Default: 4
         *
         * The size of the physical extent. pesize must be a power of 2, or multiple of 128KiB. Since version 2.6, pesize can be optionally suffixed by a UNIT (k/K/m/M/g/G), default unit is megabyte.
         */
        pesize?: string;
        /**
         * Additional options to pass to C(pvcreate) when creating the volume group.
         */
        pv_options?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of the local usernames configured on network devices. It allows playbooks to manage either individual usernames or the aggregate of usernames in the current running config. It also supports purging usernames from the configuration that are not explicitly defined.
       */
      ios_user?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update, or destroy Ansible Tower credential type. See U(https://www.ansible.com/tower) for an overview.
       */
      tower_credential_type?: {
        /**
         * Enter inputs using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax.
         */
        inputs?: {
          [k: string]: unknown;
        };
        /**
         * The type of credential type being added. Note that only cloud and net can be used for creating credential types. Refer to the Ansible for more information.
         */
        kind?: "ssh" | "vault" | "net" | "scm" | "cloud" | "insights";
        tower_host?: string;
        /**
         * The name of the credential type.
         */
        name: string;
        /**
         * Tower option to avoid certificates check.
         */
        tower_verify_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tower_config_file?: string;
        /**
         * Default: present
         *
         * Desired state of the resource.
         */
        state?: "present" | "absent";
        tower_password?: string;
        tower_username?: string;
        /**
         * Enter injectors using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax.
         */
        injectors?: {
          [k: string]: unknown;
        };
        /**
         * The description of the credential type to give more detail about it.
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manage the system authentication configuration. This module can assist in configuring a number of different system authentication types. Note that this module can not be used to configure APM authentication types.
       */
      bigip_device_auth?: {
        [k: string]: unknown;
      };
      /**
       * Manage an AWS Elastic Load Balancer target group. See U(http://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html) or U(http://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-target-groups.html) for details.
       */
      elb_target_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can be used to deploy a VMware VM from an OVF or OVA file
       */
      vmware_deploy_ovf?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * obtain facts about one or more RDS snapshots. These can be for unclustered snapshots or snapshots of clustered DBs (Aurora)
       * Aurora snapshot facts may be obtained if no identifier parameters are passed or if one of the cluster parameters are passed.
       */
      rds_snapshot_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, read, update and delete computers in Active Directory using a windows bridge computer to launch New-ADComputer, Get-ADComputer, Set-ADComputer, Remove-ADComputer and Move-ADObject powershell commands.
       */
      win_domain_computer?: {
        priority?: "above_normal" | "below_normal" | "high" | "idle" | "normal" | "realtime";
        executable: string;
        connection_password?: string;
        show_ui_on_logon_screen?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        load_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        interactive_session?: number | string;
        hostname: string;
        integrity_level?: "default" | "elevated" | "limited";
        connection_username?: string;
        working_directory?: string;
        arguments?: string;
        process_username?: string;
        asynchronous?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        process_password?: string;
        connection_timeout?: number | string;
        encrypt?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        stdin?: string;
        process_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running IOS.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      ios_facts?: {
        username?: string;
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssh_keyfile?: string;
        auth_pass?: string;
        host?: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Run an arbitrary 'xapi' command taking an XPath (i.e get) or XPath and element (i.e set).
       * See https://github.com/kevinsteves/pan-python/blob/master/doc/pan.xapi.rst for details
       * Runs a 'set' command by default
       * This should support _all_ commands that your PAN-OS device accepts vi it's cli
       * cli commands are found as
       * Once logged in issue 'debug cli on'
       * Enter configuration mode by issuing 'configure'
       * Enter your set (or other) command, for example 'set deviceconfig system timezone Australia/Melbourne'
       * returns
       * "<request cmd="set" obj="/config/devices/entry[@name='localhost.localdomain']/deviceconfig/system" cookie=XXXX><timezone>Australia/Melbourne</timezone></request>
       *
       * The 'xpath' is  "/config/devices/entry[@name='localhost.localdomain']/deviceconfig/system"
       * The 'element' is "<timezone>Australia/Melbourne</timezone>"
       */
      panos_set?: {
        /**
         * The 'xpath' for the commands configurable
         */
        xpath: string;
        /**
         * Default: admin
         *
         * User name for a user with admin rights on the PAN-OS NVA
         */
        username?: string;
        /**
         * The 'element' for the 'xpath' if required
         */
        element?: string;
        /**
         * Default: set
         *
         * Xapi method name which supports 'xpath' or 'xpath' and 'element'
         */
        command?: "set" | "edit" | "delete" | "get" | "show" | "override";
        /**
         * Password for the given 'username'
         */
        password: string;
        /**
         * IP address or host FQDN of the target PAN-OS NVA
         */
        ip_address: string;
        [k: string]: unknown;
      };
      /**
       * Manage Python library dependencies. To use this module, one of the following keys is required: C(name) or C(requirements).
       */
      pip?: {
        /**
         * An optional path to a I(virtualenv) directory to install into. It cannot be specified together with the 'executable' parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtualenv_site_packages, virtualenv_command, and virtualenv_python options affect the creation of the virtualenv.
         */
        virtualenv?: string;
        /**
         * Default: no
         *
         * Whether the virtual environment will inherit packages from the global site-packages directory.  Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created.
         */
        virtualenv_site_packages?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The explicit executable or a pathname to the executable to be used to run pip for a specific version of Python installed in the system. For example C(pip-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation. It cannot be specified together with the 'virtualenv' parameter (added in 2.1). By default, it will take the appropriate version for the python interpreter use by ansible, e.g. pip3 on python 3, and pip2 or pip on python 2.
         */
        executable?: string;
        /**
         * cd into this directory before running the command
         */
        chdir?: string;
        /**
         * The path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option.
         */
        requirements?: string;
        /**
         * The name of a Python library to install or the url(bzr+,hg+,git+,svn+) of the remote package.
         * This can be a list (since 2.2) and contain version specifiers (since 2.7).
         */
        name?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The Python executable used for creating the virtual environment. For example C(python3.5), C(python2.7). When not specified, the Python version used to run the ansible module is used. This parameter should not be used when C(virtualenv_command) is using C(pyvenv) or the C(-m venv) module.
         */
        virtualenv_python?: string;
        /**
         * The system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., "0077") and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode as an octal string, (e.g., "0022").
         */
        umask?: string;
        /**
         * Default: no
         *
         * Pass the editable flag.
         */
        editable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: virtualenv
         *
         * The command or a pathname to the command to create the virtual environment with. For example C(pyvenv), C(virtualenv), C(virtualenv2), C(~/bin/virtualenv), C(/usr/local/bin/virtualenv).
         */
        virtualenv_command?: string;
        use_mirrors?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Extra arguments passed to pip.
         */
        extra_args?: string;
        /**
         * Default: present
         *
         * The state of module
         * The 'forcereinstall' option is only available in Ansible 2.1 and above.
         */
        state?: "absent" | "forcereinstall" | "latest" | "present";
        /**
         * The version number to install of the Python library specified in the I(name) parameter.
         */
        version?: string;
        [k: string]: unknown;
      };
      /**
       * Read the AWS documentation for Network ACLS U(http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html)
       */
      ec2_vpc_nacl?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of node system attributes on Juniper JUNOS devices.  It provides an option to configure host system parameters or remove those parameters from the device active configuration.
       */
      junos_system?: {
        username?: string;
        ssh_keyfile?: string;
        /**
         * Default: present
         *
         * State of the configuration values in the device's current active configuration.  When set to I(present), the values should be configured in the device active configuration and when set to I(absent) the values should not be in the device active configuration
         */
        state?: "present" | "absent";
        /**
         * Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.
         */
        domain_search?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Configure the device hostname parameter. This option takes an ASCII string value.
         */
        hostname?: string;
        /**
         * Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.
         */
        domain_name?: string;
        /**
         * Default: True
         *
         * Specifies whether or not the configuration is active or deactivated
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host?: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.
         */
        name_servers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Create and remove Docker secrets in a Swarm environment. Similar to `docker secret create` and `docker secret rm`.
       * Adds to the metadata of new secrets 'ansible_key', an encrypted hash representation of the data, which is then used
       * in future runs to test if a secret has changed.
       * If 'ansible_key is not present, then a secret will not be updated unless the C(force) option is set.
       * Updates to secrets are performed by removing the secret and creating it again.
       */
      docker_secret?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module provides declarative management of VLANs on Mellanox ONYX network devices.
       */
      onyx_vlan?: {
        /**
         * Purge VLANs not defined in the I(aggregate) parameter.
         */
        purge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of VLANs definitions.
         */
        aggregate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * State of the VLAN configuration.
         */
        state?: "present" | "absent";
        /**
         * Name of the VLAN.
         */
        name?: string;
        /**
         * ID of the VLAN.
         */
        vlan_id?: number | string;
        [k: string]: unknown;
      };
      /**
       * Control Linux encrypted block devices that are set up during system boot in C(/etc/crypttab).
       */
      crypttab?: {
        /**
         * Name of the encrypted block device as it appears in the C(/etc/crypttab) file, or optionally prefixed with C(/dev/mapper/), as it appears in the filesystem. I(/dev/mapper/) will be stripped from I(name).
         */
        name: string;
        /**
         * Path to the underlying block device or file, or the UUID of a block-device prefixed with I(UUID=).
         */
        backing_device?: string;
        /**
         * Use I(present) to add a line to C(/etc/crypttab) or update it's definition if already present. Use I(absent) to remove a line with matching I(name). Use I(opts_present) to add options to those already present; options with different values will be updated. Use I(opts_absent) to remove options from the existing set.
         */
        state: "absent" | "opts_absent" | "opts_present" | "present";
        /**
         * Default: /etc/crypttab
         *
         * Path to file to use instead of C(/etc/crypttab). This might be useful in a chroot environment.
         */
        path?: string;
        /**
         * Default: none
         *
         * Encryption password, the path to a file containing the password, or C(none) or C(-) if the password should be entered at boot.
         */
        password?: string;
        /**
         * A comma-delimited list of options. See C(crypttab(5) ) for details.
         */
        opts?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to join nodes to a cluster, check the status of the cluster.
       */
      riak?: {
        /**
         * Default: riak@127.0.0.1
         *
         * The target node for certain operations (join, ping)
         */
        target_node?: string;
        /**
         * Default: /etc/riak
         *
         * The path to the riak configuration directory
         */
        config_dir?: string;
        /**
         * Waits for a riak service to come online before continuing.
         */
        wait_for_service?: "kv";
        /**
         * Default: 127.0.0.1:8098
         *
         * The ip address and port that is listening for Riak HTTP queries
         */
        http_conn?: string;
        /**
         * Number of seconds to wait for all nodes to agree on the ring.
         */
        wait_for_ring?: number | string;
        /**
         * Number of seconds to wait for handoffs to complete.
         */
        wait_for_handoffs?: number | string;
        /**
         * The command you would like to perform against the cluster.
         */
        command?: "ping" | "kv_test" | "join" | "plan" | "commit";
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Retrieves facts for a file similar to the linux/unix 'stat' command.
       * For Windows targets, use the M(win_stat) module instead.
       */
      stat?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage local users on an ESXi host
       */
      vmware_local_user_manager?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can manage Kubernetes resources on an existing cluster using the Kubernetes server API. Users can specify in-line API data, or specify an existing Kubernetes YAML file.
       * Currently, this module (1) Only supports HTTP Basic Auth (2) Only supports 'strategic merge' for update, http://goo.gl/fCPYxT SSL certs are not working, use C(validate_certs=off) to disable.
       */
      kubernetes?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM tcp echo monitors.
       */
      bigip_monitor_tcp_echo?: {
        [k: string]: unknown;
      };
      /**
       * Manage packages on SUSE and openSUSE using the zypper and rpm tools.
       */
      zypper?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Execute trunk-create or trunk-delete command.
       * Trunks can be used to aggregate network links at Layer 2 on the local switch. Use this command to create a new trunk.
       */
      pn_trunk?: {
        /**
         * Specify the name for the trunk configuration.
         */
        pn_name: string;
        /**
         * Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.
         */
        pn_lacp_fallback_timeout?: string;
        /**
         * Specify the LACP time out as slow (30 seconds) or fast (4seconds). The default value is slow.
         */
        pn_lacp_timeout?: string;
        /**
         * Host facing port control setting.
         */
        pn_host?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the MAC address of the port.
         */
        pn_port_macaddr?: string;
        /**
         * Specify the LACP fallback mode as bundles or individual.
         */
        pn_lacp_fallback?: "bundle" | "individual";
        /**
         * Specify if the port participates in routing on the network.
         */
        pn_routing?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify if the configuration receives mirrored traffic.
         */
        pn_mirror_receive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify an egress port data rate limit for the configuration.
         */
        pn_egress_rate_limit?: string;
        /**
         * State the action to perform. Use 'present' to create trunk, 'absent' to delete trunk and 'update' to modify trunk.
         */
        state: "present" | "absent" | "update";
        /**
         * Specify a broadcast level in percent. The default value is 100%.
         */
        pn_broadcast_level?: string;
        /**
         * Target switch(es) to run the cli on.
         */
        pn_cliswitch?: string;
        /**
         * Specify an unknown multicast level in percent. The default value is 100%.
         */
        pn_unknown_mcast_level?: string;
        /**
         * Specify an unknown unicast level in percent. The default value is 100%.
         */
        pn_unknown_ucast_level?: string;
        /**
         * Specify loopback if you want to use loopback.
         */
        pn_loopback?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the port speed or disable the port.
         */
        pn_speed?: "disable" | "10m" | "100m" | "1g" | "2.5g" | "10g" | "40g";
        /**
         * Specify if the switch is an edge switch.
         */
        pn_edge_switch?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify if the port can receive jumbo frames.
         */
        pn_jumbo?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Specify the port number(s) for the link(s) to aggregate into the trunk.
         * Required for trunk-create.
         */
        pn_ports?: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Specify the LACP mode for the configuration.
         */
        pn_lacp_mode?: "off" | "passive" | "active";
        /**
         * Specify a list of looping vlans.
         */
        pn_loopvlans?: string;
        /**
         * Specify the LACP priority. This is a number between 1 and 65535 with a default value of 32768.
         */
        pn_lacp_priority?: number | string;
        /**
         * Specify if pause frames are sent.
         */
        pn_pause?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify a description for the trunk configuration.
         */
        pn_description?: string;
        [k: string]: unknown;
      };
      /**
       * Get facts of SQL Server.
       */
      azure_rm_sqlserver_facts?: {
        profile?: string;
        /**
         * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
         */
        resource_group: string;
        /**
         * The name of the server.
         */
        server_name?: string;
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        cert_validation_mode?: "validate" | "ignore";
        secret?: string;
        client_id?: string;
        api_profile?: string;
        adfs_authority_url?: string;
        auth_source?: "auto" | "cli" | "env" | "credential_file" | "msi";
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Modify IP address properties on Solaris/illumos systems.
       */
      ipadm_addrprop?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Retrieve the facts about one or more of the Ethernet Networks from OneView.
       */
      oneview_ethernet_network_facts?: {
        username?: string;
        image_streamer_hostname?: string;
        /**
         * Ethernet Network name.
         */
        name?: string;
        hostname?: string;
        params?: {
          [k: string]: unknown;
        };
        password?: string;
        config?: string;
        /**
         * List with options to gather additional facts about an Ethernet Network and related resources. Options allowed: C(associatedProfiles) and C(associatedUplinkGroups).
         */
        options?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        api_version?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create/delete DigitalOcean SSH keys.
       */
      digital_ocean_sshkey?: {
        [k: string]: unknown;
      };
      /**
       * Create, delete, or modify mappings between a volume and a targeted host/host+ group.
       */
      netapp_e_lun_mapping?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manages monitors within Datadog
       * Options like described on http://docs.datadoghq.com/api/
       */
      datadog_monitor?: {
        /**
         * The designated state of the monitor.
         */
        state: string;
        /**
         * Default: no
         *
         * A boolean indicating whether tagged users will be notified on changes to this monitor.
         */
        notify_audit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * A boolean indicating whether changes to this monitor should be restricted to the creator or admins.
         */
        locked?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state.
         */
        timeout_h?: string;
        /**
         * A list of tags to associate with your monitor when creating or updating. This can help you categorize and filter monitors.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: {'warning': 1, 'ok': 1, 'critical': 1}
         *
         * A dictionary of thresholds by status. This option is only available for service checks and metric alerts. Because each of them can have multiple thresholds, we don't define them directly in the query."]
         */
        thresholds?: {
          [k: string]: unknown;
        };
        /**
         * Dictionary of scopes to timestamps or None. Each scope will be muted until the given POSIX timestamp or forever if the value is None.
         */
        silenced?: {
          [k: string]: unknown;
        };
        /**
         * A positive integer representing the number of seconds to wait before evaluating the monitor for new hosts. This gives the host time to fully initialize.
         */
        new_host_delay?: string;
        /**
         * Your DataDog app key.
         */
        app_key: string;
        /**
         * A boolean indicating whether this monitor needs a full window of data before it's evaluated. We highly recommend you set this to False for sparse metrics, otherwise some evaluations will be skipped.
         */
        require_full_window?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * A boolean indicating whether this monitor will notify when data stops reporting..
         */
        notify_no_data?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The number of minutes after the last notification before a monitor will re-notify on the current status. It will only re-notify if it's not resolved.
         */
        renotify_interval?: string;
        /**
         * Time to delay evaluation (in seconds). It is effective for sparse values.
         */
        evaluation_delay?: string;
        /**
         * Default: 2x timeframe for metric, 2 minutes for service
         *
         * The number of minutes before a monitor will notify when data stops reporting. Must be at least 2x the monitor timeframe for metric alerts or 2 minutes for service checks.
         */
        no_data_timeframe?: string;
        /**
         * A message to include with a re-notification. Supports the '@username' notification we allow elsewhere. Not applicable if renotify_interval is None
         */
        escalation_message?: string;
        /**
         * The monitor query to notify on with syntax varying depending on what type of monitor you are creating.
         */
        query?: string;
        /**
         * A message to include with notifications for this monitor. Email notifications can be sent to specific users by using the same '@username' notation as events. Monitor message template variables can be accessed by using double square brackets, i.e '[[' and ']]'.
         */
        message?: string;
        /**
         * Your DataDog API key.
         */
        api_key: string;
        /**
         * The type of the monitor.
         * The 'event alert'is available starting at Ansible 2.1
         */
        type?: string;
        /**
         * The id of the alert. If set, will be used instead of the name to locate the alert.
         */
        id?: string;
        /**
         * The name of the alert.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module allows the user to manage sending authorization policies associated with an SES identity (email or domain).
       * SES authorization sending policies can be used to control what actors are able to send email on behalf of the validated identity and what conditions must be met by the sent emails.
       */
      aws_ses_identity_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      [k: string]: unknown;
    }
)[];

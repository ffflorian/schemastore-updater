/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Unique string identification of the probe
 */
export type Id = string;
/**
 * A human-readible probe name
 */
export type Name = string;
/**
 * Description of the probe
 */
export type Description = string;
/**
 * The number of seconds to repeat the probe
 */
export type Interval = number;
/**
 * Postgres uri connection configuration
 */
export type URIConnection = string;
/**
 * Postgres port to connect to
 */
export type Port = Port1 & Port2;
export type Port1 = number;
export type Port2 = string;
/**
 * Name of the database
 */
export type Database = string;
/**
 * Username with access to the database
 */
export type Username = string;
/**
 * User's database password
 */
export type Password = string;
/**
 * Monitor postgres readiness
 */
export type Postgres = (
  | {
      uri: URIConnection;
    }
  | {
      /**
       * Postgres host address to connect to
       */
      host: string;
      port: Port;
      database: Database;
      username?: Username;
      password?: Password;
      [k: string]: unknown | undefined;
    }
)[];
/**
 * The hostname or IP address of the redis server
 */
export type RedisHost = string;
/**
 * Port number used for the redis
 */
export type PortNumber = PortNumber1 & PortNumber2;
export type PortNumber1 = number;
export type PortNumber2 = string;
/**
 * Password used for the redis AUTH, if set.
 */
export type Password1 = string;
/**
 * Username used for the redis AUTH, if set.
 */
export type Username1 = string;
/**
 * Monitor redis health
 */
export type Redis = {
  host: RedisHost;
  port: PortNumber;
  password?: Password1;
  username?: Username1;
  [k: string]: unknown | undefined;
}[];
/**
 * The hostname or IP address of the MongoDB server
 */
export type MongoDBURI = string;
/**
 * The hostname or IP address of the MongoDB server
 */
export type MongoDBHost = string;
/**
 * Port number used for the MongoDB
 */
export type PortNumber3 = PortNumber4 & PortNumber5;
export type PortNumber4 = number;
export type PortNumber5 = string;
/**
 * Password used for the MongoDB AUTH, if set.
 */
export type Password2 = string;
/**
 * Username used for the MongoDB AUTH, if set.
 */
export type Username2 = string;
/**
 * Monitor MongoDB health
 */
export type MongoDB = {
  uri?: MongoDBURI;
  host?: MongoDBHost;
  port?: PortNumber3;
  password?: Password2;
  username?: Username2;
  [k: string]: unknown | undefined;
}[];
/**
 * The hostname or IP address of the database server
 */
export type DatabaseHost = string;
/**
 * Port number used by your database server
 */
export type PortNumber6 = PortNumber7 & PortNumber8;
export type PortNumber7 = number;
export type PortNumber8 = string;
/**
 * User with access to the database
 */
export type Username3 = string;
/**
 * User password for authentication
 */
export type Password3 = string;
export type Database1 = string;
/**
 * Monitor MariaDB/Mysql health
 */
export type MariaDBMysql = {
  host: DatabaseHost;
  port: PortNumber6;
  username: Username3;
  password: Password3;
  database: Database1;
}[];
/**
 * The http method
 */
export type HTTPMethod = "GET" | "POST" | "DELETE" | "PUT" | "PATCH";
/**
 * The remote URL address to probe
 */
export type Url = string;
/**
 * Set the timeout for the request in milliseconds, default is 10 seconds
 */
export type Timeout = number;
/**
 * Should response body be saved in the database
 */
export type SaveBody = boolean;
/**
 * An expression that will trigger an alert when its is logically true. See the assertions here: https://monika.hyperjump.tech/guides/alerts#alert-query
 */
export type Assertion = string;
/**
 * Message that will be sent to the notification channel
 */
export type Message = string;
/**
 * Note: Query is deprecated, please use assertion
 */
export type Query = string;
/**
 * Message that will be sent to the notification channel
 */
export type Message1 = string;
/**
 * The condition which will trigger an alert and the subsequent notification
 */
export type Alerts = (
  | {
      assertion: Assertion;
      message: Message;
    }
  | {
      query: Query;
      message: Message1;
    }
)[];
/**
 * If defined and to true, the request is an ICMP ping
 */
export type Ping = boolean;
/**
 * If defined and to true, the request will ignore SSL certificate validity
 */
export type AllowUnauthorized = boolean;
/**
 * The http or ping request to probe for
 */
export type Requests = {
  method?: HTTPMethod;
  url: Url;
  timeout?: Timeout;
  saveBody?: SaveBody;
  alerts?: Alerts;
  ping?: Ping;
  allowUnauthorized?: AllowUnauthorized;
  body?: Body;
  headers?: Headers;
}[];
/**
 * Host port to connect to
 */
export type Port3 = number;
/**
 * Data payload for the request
 */
export type Data = string;
/**
 * Number of times an alert should return true before Monika sends incident notifications
 */
export type IncidentThreshold = number;
/**
 * Number of times an alert should return false before Monika sends recovery notifications
 */
export type RecoveryThreshold = number;
/**
 * Probe is a description of the target, methods, timing and payloads to begin monitoring/probing a target.
 */
export type Probes = {
  id: Id;
  name?: Name;
  description?: Description;
  interval?: Interval;
  postgres?: Postgres;
  redis?: Redis;
  mongo?: MongoDB;
  mariadb?: MariaDBMysql;
  mysql?: MariaDBMysql;
  requests?: Requests;
  socket?: Socket;
  incidentThreshold?: IncidentThreshold;
  recoveryThreshold?: RecoveryThreshold;
  alerts?: Alerts;
}[];
/**
 * Alerts of incidents and recoveries will be sent via these notification channels
 */
export type Notifications = (
  | Desktop
  | Discord
  | Workplace
  | GoogleChat
  | Lark
  | Mailgun
  | MicrosoftTeams
  | MonikaNotification
  | Pagerduty
  | Sendgrid
  | Slack
  | SMTP
  | Statuspage
  | Telegram
  | Webhook
  | WhatsAppForBusiness
  | Dingtalk
  | Pushover
  | Gotify
  | Opsgenie
  | Pushbullet
  | Instatus
)[];
/**
 * Sends status notification periodically according to a cron schedule. Set to false to disable.
 */
export type StatusNotification = string;

/**
 * Monika monitoring configuration schema
 */
export interface HttpsGithubComHyperjumptechMonikaMainMonikaConfigSchemaJson {
  probes?: Probes;
  notifications?: Notifications;
  /**
   * Database internal configuration
   */
  db_limit?: {
    /**
     * Maximum Monika database size
     */
    max_db_size: number;
    /**
     * Delete strategy when limit reached
     */
    deleted_data: number;
    /**
     * Schedule to trim the db in crontab
     */
    cron_schedule: string;
  };
  "status-notification"?: StatusNotification;
  certificate?: Certificate;
}
/**
 * The data bytes transmitted in an HTTP transaction message immediately following the headers if there are any
 */
export interface Body {
  [k: string]: unknown | undefined;
}
/**
 * A list of strings sent and received by both the client program and server on every HTTP request and response
 */
export interface Headers {
  /**
   * Media type(s) that is/are acceptable for the response
   */
  Accept?: string;
  /**
   * Character sets that are acceptable
   */
  "Accept-Charset"?: string;
  /**
   * List of acceptable encodings
   */
  "Accept-Encoding"?: string;
  /**
   * Authentication credentials for HTTP authentication
   */
  Authorization?: string;
  /**
   * Used to specify directives that must be obeyed by all caching mechanisms along the request-response chain
   */
  "Cache-Control"?: string;
  /**
   * An HTTP cookie previously sent by the server with Set-Cookie
   */
  Cookie?: string;
  /**
   * General header that allows the sender or client to specify options that are desired for that particular connection
   */
  Connection?: string;
  /**
   * The Media type of the body of the request (used with POST and PUT requests
   */
  "Content-Type"?: string;
  /**
   * General header used to inform how long a persistent connection should stay open
   */
  "Keep-Alive"?: string;
  /**
   * Initiates a request for cross-origin resource sharing (asks server for Access-Control-* response fields)
   */
  Origin?: string;
  /**
   * This is the address of the previous web page (referrer) from which a link to the currently requested page was followed
   */
  Referer?: string;
  /**
   * The user agent string of the user agent
   */
  "User-Agent"?: string;
  [k: string]: unknown | undefined;
}
/**
 * Socket is a TCP type request
 */
export interface Socket {
  /**
   * Address to your host
   */
  host: string;
  port: Port3;
  data: Data;
}
export interface Desktop {
  /**
   * Unique notification id
   */
  id: string;
  type: "desktop";
}
export interface Discord {
  /**
   * Unique notification id
   */
  id: string;
  type: "discord";
  /**
   * Data for your payload
   */
  data: {
    /**
     * The URL of the Discord Webhook that will receive notification
     */
    url: string;
  };
}
export interface Workplace {
  /**
   * Unique notification id
   */
  id: string;
  type: "workplace";
  /**
   * Data for your payload
   */
  data: {
    /**
     * Thread id is the set of numbers at the end of the url
     */
    thread_id: string;
    /**
     * Workplace access token for custom integration
     */
    access_token: string;
  };
}
export interface GoogleChat {
  /**
   * Unique notification id
   */
  id: string;
  type: "google-chat";
  /**
   * Data for your payload
   */
  data: {
    /**
     * The webhook URL for your google chat
     */
    url: string;
  };
}
export interface Lark {
  /**
   * Unique notification id
   */
  id: string;
  type: "lark";
  /**
   * Data for your payload
   */
  data: {
    /**
     * The webhook URL for your lark suite
     */
    url: string;
  };
}
export interface Mailgun {
  id: string;
  type: "mailgun";
  /**
   * Data for your payload
   */
  data: {
    /**
     * An array of email addresses that will receive the e-mail from Monika
     */
    recipients: string[];
    /**
     * Mailgun account API key, mailgun registered key to identify your account
     */
    apiKey: string;
    /**
     * The domain to set in Mailgun
     */
    domain: string;
  };
}
export interface MicrosoftTeams {
  /**
   * Unique notification id
   */
  id: string;
  type: "teams";
  /**
   * Data for your payload
   */
  data: {
    /**
     * Your teams webhook URL
     */
    url: string;
  };
}
export interface MonikaNotification {
  /**
   * Unique notification id
   */
  id: string;
  type: "monika-notif";
  /**
   * Data for your payload
   */
  data: {
    /**
     * Your Monika notification URL
     */
    url: string;
  };
}
export interface Pagerduty {
  /**
   * Unique pagerduty notif id
   */
  id: string;
  type: "pagerduty";
  /**
   * An array of email addresses that will receive the e-mail from Monika
   */
  data: {
    /**
     * Pagerduty integration key
     */
    key: string;
    /**
     * Monika Probe ID
     */
    probeID: string;
  }[];
}
export interface Sendgrid {
  /**
   * Unique sendgrid notification id
   */
  id: string;
  type: "sendgrid";
  /**
   * Data for your payload
   */
  data: {
    /**
     * A string of email addresses that has been verified in your sendgrid account
     */
    sender: string;
    /**
     * An array of email addresses that will receive the e-mail from Monika
     */
    recipients: string[];
    /**
     * Sendgrid account api key, sendgrid registered key to identify your account
     */
    apiKey: string;
  };
}
export interface Slack {
  /**
   * Unique slack notification id
   */
  id: string;
  type: "slack";
  /**
   * Data for your payload
   */
  data: {
    /**
     * The URL webhook for Slack
     */
    url: string;
  };
}
export interface SMTP {
  /**
   * Unique smtp notification id
   */
  id: string;
  type: "smtp";
  /**
   * Data for your payload
   */
  data: {
    /**
     * An array of email address that will receive the email from Monika
     */
    recipients: string[];
    /**
     * The smtp host that you will be using for sending the email
     */
    hostname: string;
    /**
     * The port allowed to be used for sending mail in your host
     */
    port: number;
    /**
     * Registered username on your smtp server
     */
    username: string;
    /**
     * The password set for your username
     */
    password: string;
  };
}
export interface Statuspage {
  /**
   * Notification identity number
   */
  id: string;
  type: "statuspage";
  /**
   * Data for your payload
   */
  data: {
    /**
     * Statuspage API key
     */
    apiKey: string;
    /**
     * Statuspage page ID
     */
    pageID: string;
  };
}
export interface Telegram {
  /**
   * Unique telegram notification id
   */
  id: string;
  type: "telegram";
  /**
   * Data for your payload
   */
  data: {
    /**
     * The ID of the group where the bot should send the messages
     */
    group_id: string;
    /**
     * Token for your telegram bot
     */
    bot_token: string;
  };
}
export interface Webhook {
  /**
   * Unique webhook notification id
   */
  id: string;
  type: "webhook";
  /**
   * Data for your payload
   */
  data: {
    /**
     * The URL of the server that will receive the webhook notification
     */
    url: string;
  };
}
export interface WhatsAppForBusiness {
  /**
   * Unique whatsapp notification id
   */
  id: string;
  type: "whatsapp";
  /**
   * Data for your payload
   */
  data: {
    /**
     * An array of phone numbers registered for WhatsApp, should start with your controu code number
     */
    recipients: string[];
    /**
     * The URL of the server that will receive the webhook notification
     */
    url: string;
    /**
     * Your WhatsApp API username
     */
    username: string;
    /**
     * Your Whatsapp API user password
     */
    password: string;
  };
}
export interface Dingtalk {
  /**
   * Unique Dingtalk notification id
   */
  id: string;
  type: "dingtalk";
  /**
   * Data for your payload
   */
  data: {
    /**
     * the token of your Dingtalk account
     */
    access_token: string;
  };
}
export interface Pushover {
  /**
   * Unique Pushover notification id
   */
  id: string;
  type: "pushover";
  /**
   * Data for your payload
   */
  data: {
    /**
     * Pushover application token
     */
    token: string;
    /**
     * Pushover user key
     */
    user: string;
  };
}
export interface Gotify {
  /**
   * Unique Gotify notification id
   */
  id: string;
  type: "gotify";
  /**
   * Data for your payload
   */
  data: {
    /**
     * Gotify application token
     */
    token: string;
    /**
     * Gotify base url
     */
    url: string;
  };
}
export interface Opsgenie {
  /**
   * Unique opsgenie notification id
   */
  id: string;
  type: "opsgenie";
  /**
   * Data for your payload
   */
  data: {
    /**
     * Opsgenie application token
     */
    geniekey: string;
  };
}
export interface Pushbullet {
  /**
   * Unique notification id
   */
  id: string;
  type: "pushbullet";
  /**
   * Data for your payload
   */
  data: {
    /**
     * Pushbullet application token.
     */
    token: string;
    /**
     * Pushbullet device identifier (optional)
     */
    deviceID?: string;
  };
}
export interface Instatus {
  /**
   * The type of notification
   */
  id: string;
  type: "instatus";
  /**
   * Data for your payload
   */
  data: {
    /**
     * Instatus API key
     */
    apiKey: string;
    /**
     * Instatus Page ID
     */
    pageID: string;
  };
}
/**
 * Check validity of your TLS certificate(s).
 */
export interface Certificate {
  /**
   * The list of domains to check
   */
  domains: (
    | string
    | {
        /**
         * Hostname to check
         */
        domain: string;
        /**
         * Custom HTTPs Options
         */
        options?: {
          path?: string;
          [k: string]: unknown | undefined;
        };
      }
  )[];
  /**
   * The number of days to send notification to user before the domain expires
   */
  reminder?: number;
}

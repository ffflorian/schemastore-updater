/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface JsonSchemaForTheGruntCssminTask {
  options?: Options;
  [k: string]: (
    | {
        files?:
          | {
              [k: string]: string[];
            }
          | {
              /**
               * Must be set to true to use properties other than 'src' and 'dest'
               */
              expand?: boolean;
              /**
               * All 'src' matches are relative to (but don't include) this path
               */
              cwd?: string;
              /**
               * Destination path prefix.
               */
              dest?: string;
              /**
               * Replace any existing extension with this value in generated 'dest' paths.
               */
              ext?: string;
              /**
               * Used to indicate where the period indicating the extension is located.
               */
              extDot?: "first" | "last";
              /**
               * The 'filter' property can help you target files with a greater level of detail
               */
              filter?:
                | "isFile"
                | "isDirectory"
                | "isBlockDevice"
                | "isCharacterDevice"
                | "isSymbolicLink"
                | "isFIFO"
                | "isSocket";
              /**
               * Remove all path parts from generated 'dest' paths
               */
              flatten?: boolean;
              /**
               * If set, patterns without slashes will be matched against the basename of the path if it contains slashes. For example, 'a?b' would match the path '/xyz/123/acb', but not '/xyz/acb/123'.
               */
              matchBase?: boolean;
              /**
               * If set to 'true' then the operation will include non-matching patterns. Combined with grunt's '--verbose' flag, this option can help debug file path issues.
               */
              nonull?: boolean;
              /**
               * This function is called for each matched 'src' file, (after extension renaming and flattening).
               */
              rename?: string;
              /**
               * Pattern(s) to match, relative to the 'cwd'.
               */
              src: string[];
              [k: string]: any;
            }[];
        [k: string]: any;
      }
    | {
        /**
         * Must be set to true to use properties other than 'src' and 'dest'
         */
        expand?: boolean;
        /**
         * All 'src' matches are relative to (but don't include) this path
         */
        cwd?: string;
        /**
         * Destination path prefix.
         */
        dest?: string;
        /**
         * Replace any existing extension with this value in generated 'dest' paths.
         */
        ext?: string;
        /**
         * Used to indicate where the period indicating the extension is located.
         */
        extDot?: "first" | "last";
        /**
         * The 'filter' property can help you target files with a greater level of detail
         */
        filter?:
          | "isFile"
          | "isDirectory"
          | "isBlockDevice"
          | "isCharacterDevice"
          | "isSymbolicLink"
          | "isFIFO"
          | "isSocket";
        /**
         * Remove all path parts from generated 'dest' paths
         */
        flatten?: boolean;
        /**
         * If set, patterns without slashes will be matched against the basename of the path if it contains slashes. For example, 'a?b' would match the path '/xyz/123/acb', but not '/xyz/acb/123'.
         */
        matchBase?: boolean;
        /**
         * If set to 'true' then the operation will include non-matching patterns. Combined with grunt's '--verbose' flag, this option can help debug file path issues.
         */
        nonull?: boolean;
        /**
         * This function is called for each matched 'src' file, (after extension renaming and flattening).
         */
        rename?: string;
        /**
         * Pattern(s) to match, relative to the 'cwd'.
         */
        src: string[];
        [k: string]: any;
      }) & {
    options?: Options;
    [k: string]: any;
  };
}
/**
 * Set the options for cssmin
 */
export interface Options {
  /**
   * Prefix the compressed source with the given banner, with a linebreak inbetween.
   */
  banner?: null | string;
  /**
   * To keep or remove special comments, exposing the underlying option from 'clean-css'.
   */
  keepSpecialComments?: "*" | 1 | 2;
  /**
   * Either report only minification result or report minification and gzip results. This is useful to see exactly how well clean-css is performing but using  'gzip'  will make the task take 5-10x longer to complete.
   */
  report?: "min" | "gzip";
  [k: string]: any;
}

/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Auto-Generated JSON Schema for Ansible-stable 2.2 (https://github.com/shaded-enmity/ansible-schema-generator)
 */
export type Ansible22 = (
  | {
      shell: string;
      args?: {
        /**
         * Default: True
         *
         * if command warnings are on in ansible.cfg, do not warn about this particular line if set to no/false.
         */
        warn?: string;
        /**
         * a filename, when it already exists, this step will B(not) be run.
         */
        creates?: string;
        /**
         * change the shell used to execute the command. Should be an absolute path to the executable.
         */
        executable?: string;
        /**
         * cd into this directory before running the command
         */
        chdir?: string;
        /**
         * a filename, when it does not exist, this step will B(not) be run.
         */
        removes?: string;
        [k: string]: unknown;
      };
      name?: string;
      [k: string]: unknown;
    }
  | {
      raw: string;
      args?: {
        /**
         * change the shell used to execute the command. Should be an absolute path to the executable.
         * when using privilege escalation (C(become)), a default shell will be assigned if one is not provided as privilege escalation requires a shell.
         */
        executable?: string;
        [k: string]: unknown;
      };
      name?: string;
      [k: string]: unknown;
    }
  | {
      args?: {
        /**
         * Default: True
         *
         * if command warnings are on in ansible.cfg, do not warn about this particular line if set to no/false.
         */
        warn?: string;
        /**
         * a filename or (since 2.0) glob pattern, when it already exists, this step will B(not) be run.
         */
        creates?: string;
        /**
         * change the shell used to execute the command. Should be an absolute path to the executable.
         */
        executable?: string;
        /**
         * cd into this directory before running the command
         */
        chdir?: string;
        /**
         * a filename or (since 2.0) glob pattern, when it does not exist, this step will B(not) be run.
         */
        removes?: string;
        [k: string]: unknown;
      };
      command: string;
      name?: string;
      [k: string]: unknown;
    }
  | {
      args?: {
        /**
         * a filename, when it already exists, this step will B(not) be run.
         */
        creates?: string;
        /**
         * a filename, when it does not exist, this step will B(not) be run.
         */
        removes?: string;
        [k: string]: unknown;
      };
      name?: string;
      script: string;
      [k: string]: unknown;
    }
  | {
      [k: string]: unknown;
    }
  | {
      /**
       * List of file names to ignore. The defaults can not be overridden, but can be extended.
       */
      ignore_files?: unknown[];
      /**
       * Limit the variables that are loaded within any directory to this regular expression.
       */
      files_matching?: string;
      /**
       * By default, this module will recursively go through each sub directory and load up the variables. By explicitly setting the depth, this module will only go as deep as the depth.
       */
      depth?: string;
      /**
       * The file name from which variables should be loaded.
       * If the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook.
       */
      file?: string;
      /**
       * The directory name from which the variables should be loaded.
       * If the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook.
       */
      dir?: string;
      /**
       * The name of a variable into which assign the included vars, if omitted (null) they will be made top level vars.
       */
      name?: string;
      [k: string]: unknown;
    }
  | {
      /**
       * Creates or terminates task definitions
       */
      ecs_taskdefinition?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Configures the SELinux mode and policy. A reboot may be required after usage. Ansible will not issue this reboot but will let you know when it is required.
       */
      selinux?: {
        [k: string]: unknown;
      };
      /**
       * Registers services and checks for an agent with a consul cluster. A service is some process running on the agent node that should be advertised by consul's discovery mechanism. It may optionally supply a check definition, a periodic service test to notify the consul cluster of service's health.
       * Checks may also be registered per node e.g. disk usage, or cpu usage and notify the health of the entire node to the cluster. Service level checks do not require a check name or id as these are derived by Consul from the Service name and id respectively by appending 'service:' Node level checks require a check_name and optionally a check_id.
       * Currently, there is no complete way to retrieve the script, interval or ttl metadata for a registered check. Without this metadata it is  not possible to tell if the data supplied with ansible represents a change to a check. As a result this does not attempt to determine changes and will always report a changed occurred. An api method is planned to supply this metadata so at that stage change management will be added.
       * See http://consul.io for more details.
       */
      consul?: {
        /**
         * Default: None
         *
         * the address to advertise that the service will be listening on. This value will be passed as the I(Address) parameter to Consul's U(/v1/agent/service/register) API method, so refer to the Consul API documentation for further details.
         */
        service_address?: string;
        /**
         * Default: None
         *
         * checks can be registered with an http endpoint. This means that consul will check that the http endpoint returns a successful http status. Interval must also be provided with this option.
         */
        http?: string;
        check_node?: string;
        /**
         * Default: None
         *
         * a list of tags that will be attached to the service registration.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: None
         *
         * a name for the service check, defaults to the check id. required if standalone, ignored if part of service definition.
         */
        check_name?: string;
        /**
         * Unique name for the service on a node, must be unique per node, required if registering a service. May be ommitted if registering a node level check
         */
        service_name?: string;
        /**
         * Default: None
         *
         * Notes to attach to check when registering it.
         */
        notes?: string;
        /**
         * Default: None
         *
         * the script/command that will be run periodically to check the health of the service. Scripts require an interval and vise versa
         */
        script?: string;
        /**
         * Default: None
         *
         * the token key indentifying an ACL rule set. May be required to register services.
         */
        token?: string;
        /**
         * Default: None
         *
         * the interval at which the service check will be run. This is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m. Required if the script param is specified.
         */
        interval?: string;
        /**
         * Default: None
         *
         * an ID for the service check, defaults to the check name, ignored if part of a service definition.
         */
        check_id?: string;
        /**
         * Default: localhost
         *
         * host of the consul agent defaults to localhost
         */
        host?: string;
        /**
         * register or deregister the consul service, defaults to present
         */
        state?: "present" | "absent";
        /**
         * the port on which the service is listening required for registration of a service, i.e. if service_name or service_id is set
         */
        service_port?: number | string;
        /**
         * Default: None
         *
         * A custom HTTP check timeout. The consul default is 10 seconds. Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes, e.g. 15s or 1m.
         */
        timeout?: string;
        /**
         * Default: None
         *
         * checks can be registered with a ttl instead of a script and interval this means that the service will check in with the agent before the ttl expires. If it doesn't the check will be considered failed. Required if registering a check and the script an interval are missing Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m
         */
        ttl?: string;
        /**
         * Default: service_name if supplied
         *
         * the ID for the service, must be unique per node, defaults to the service name if the service name is supplied
         */
        service_id?: string;
        /**
         * Default: http
         *
         * the protocol scheme on which the consul agent is running
         */
        scheme?: string;
        /**
         * Default: True
         *
         * whether to verify the tls certificate of the consul agent
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 8500
         *
         * the port on which the consul agent is running
         */
        port?: number | string;
        check_host?: string;
        [k: string]: unknown;
      };
      /**
       * Manages symbolic links using the 'update-alternatives' tool
       * Useful when multiple programs are installed but provide similar functionality (e.g. different editors).
       */
      alternatives?: {
        /**
         * Default: 50
         *
         * The priority of the alternative
         */
        priority?: number | string;
        /**
         * The path to the real executable that the link should point to.
         */
        path: string;
        /**
         * The path to the symbolic link that should point to the real executable.
         * This option is required on RHEL-based distributions
         */
        link?: string;
        /**
         * The generic name of the link.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module allows setting/accumulating stats on the current ansible run, either per host of for all hosts in the run.
       */
      set_stats?: {
        /**
         * Default: True
         *
         * boolean that indicates if the provided value is aggregated to the existing stat C(yes) or will replace it C(no)
         */
        aggregate?: string;
        /**
         * A dictionary of which each key represents a stat (or variable) you want to keep track of
         */
        data?: string;
        /**
         * boolean that indicates if the stats is per host or for all hosts in the run.
         */
        per_host?: string;
        [k: string]: unknown;
      };
      /**
       * This module can create and destroy Google Compute Engine C(loadbalancer) and C(httphealthcheck) resources.  The primary LB resource is the C(load_balancer) resource and the health check parameters are all prefixed with I(httphealthcheck). The full documentation for Google Compute Engine load balancing is at U(https://developers.google.com/compute/docs/load-balancing/).  However, the ansible module simplifies the configuration by following the libcloud model. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.
       */
      gce_lb?: {
        /**
         * host header to pass through on HTTP check requests
         */
        httphealthcheck_host?: string;
        /**
         * the name identifier for the HTTP health check
         */
        httphealthcheck_name?: string;
        /**
         * name of the load-balancer resource
         */
        name?: string;
        /**
         * the external static IPv4 (or auto-assigned) address for the LB
         */
        external_ip?: string;
        /**
         * service account email
         */
        service_account_email?: string;
        /**
         * the GCE region where the load-balancer is defined
         */
        region?: string;
        /**
         * Default: 2
         *
         * number of consecutive failed checks before marking a node unhealthy
         */
        httphealthcheck_unhealthy_count?: string;
        /**
         * Default: 2
         *
         * number of consecutive successful checks before marking a node healthy
         */
        httphealthcheck_healthy_count?: string;
        /**
         * path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
         */
        pem_file?: string;
        /**
         * Default: /
         *
         * the url path to use for HTTP health checking
         */
        httphealthcheck_path?: string;
        /**
         * the port (range) to forward, e.g. 80 or 8000-8888 defaults to all ports
         */
        port_range?: string;
        /**
         * Default: present
         *
         * desired state of the LB
         */
        state?: string;
        /**
         * Default: 5
         *
         * the timeout in seconds before a request is considered a failed check
         */
        httphealthcheck_timeout?: string;
        /**
         * a list of zone/nodename pairs, e.g ['us-central1-a/www-a', ...]
         */
        members?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * path to the JSON file associated with the service account email
         */
        credentials_file?: string;
        /**
         * Default: 80
         *
         * the TCP port to use for HTTP health checking
         */
        httphealthcheck_port?: string;
        /**
         * Default: tcp
         *
         * the protocol used for the load-balancer packet forwarding, tcp or udp
         */
        protocol?: string;
        /**
         * your GCE project ID
         */
        project_id?: string;
        /**
         * Default: 5
         *
         * the duration in seconds between each health check request
         */
        httphealthcheck_interval?: string;
        [k: string]: unknown;
      };
      /**
       * Creates or terminates ecs clusters.
       */
      ecs_cluster?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about a one or more OpenStack domains
       */
      os_keystone_domain_facts?: {
        /**
         * Name or ID of the domain
         */
        name?: string;
        /**
         * Default: None
         *
         * A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
         */
        filters?: string;
        [k: string]: unknown;
      };
      /**
       * Manage OpenStack DNS recordsets. Recordsets can be created, deleted or updated. Only the I(records), I(description), and I(ttl) values can be updated.
       */
      os_recordset?: {
        /**
         * Name of the recordset
         */
        name?: string;
        /**
         * Zone managing the recordset
         */
        zone?: string;
        /**
         * List of recordset definitions
         */
        records?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: None
         *
         * TTL (Time To Live) value in seconds
         */
        ttl?: string;
        /**
         * Recordset type
         */
        recordset_type?: string;
        /**
         * Default: None
         *
         * Description of the recordset
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Execute vrouter-ospf-add, vrouter-ospf-remove command.
       * This command adds/removes Open Shortest Path First(OSPF) routing protocol to a virtual router(vRouter) service.
       */
      pn_ospf?: {
        /**
         * Stub area number for the configuration. Required for vrouter-ospf-add.
         */
        pn_ospf_area?: string;
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Specify the name of the vRouter.
         */
        pn_vrouter_name: string;
        /**
         * Specify the network IP (IPv4 or IPv6) address.
         */
        pn_network_ip: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Default: present
         *
         * Assert the state of the ospf. Use 'present' to add ospf and 'absent' to remove ospf.
         */
        state?: "present" | "absent";
        /**
         * Target switch to run the CLI on.
         */
        pn_cliswitch?: string;
        [k: string]: unknown;
      };
      /**
       * Add and remove username/password entries in a password file using htpasswd.
       * This is used by web servers such as Apache and Nginx for basic authentication.
       */
      htpasswd?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module can add or remove tags U(https://cloud.google.com/compute/docs/instances/#tags) to/from GCE instance.
       */
      gce_tag?: {
        /**
         * Default: us-central1-a
         *
         * the zone of the disk specified by source
         */
        zone?: string;
        /**
         * comma-separated list of tags to add or remove
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * service account email
         */
        service_account_email?: string;
        /**
         * path to the pem file associated with the service account email
         */
        pem_file?: string;
        /**
         * the name of the GCE instance to add/remove tags
         */
        instance_name: string;
        /**
         * Default: present
         *
         * desired state of the tags
         */
        state?: "present" | "absent";
        /**
         * your GCE project ID
         */
        project_id?: string;
        [k: string]: unknown;
      };
      /**
       * This module will let you create Zabbix maintenance windows.
       */
      zabbix_maintenance?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        };
      /**
       * install a different version of Cumulus Linux in the inactive slot. For more details go the Image Management User Guide at U(http://docs.cumulusnetworks.com/).
       */
      cl_img_install?: {
        /**
         * The full path to the Cumulus Linux binary image. Can be a local path, http or https URL. If the code version is in the name of the file, the module will assume this is the version of code you wish to install.
         */
        src: string;
        /**
         * Default: None
         *
         * Inform the module of the exact version one is installing. This overrides the automatic check of version in the file name. For example, if the binary file name is called CumulusLinux-2.2.3.bin, and version is set to '2.5.0', then the module will assume it is installing '2.5.0' not '2.2.3'. If version is not included, then the module will assume '2.2.3' is the version to install.
         */
        version?: string;
        /**
         * Default: no
         *
         * Switch slots after installing the image. To run the installed code, reboot the switch.
         */
        switch_slot?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage a maintenance-mode or normal-mode profile with configuration commands that can be applied during graceful removal or graceful insertion.
       */
      nxos_gir_profile_management?: {
        /**
         * Specify to retrieve or not the complete running configuration for module operations.
         */
        include_defaults?: string;
        /**
         * List of commands to be included into the profile.
         */
        commands?: string;
        /**
         * Specify the configuration string to be used for module operations.
         */
        config?: string;
        /**
         * Configure the profile as Maintenance or Normal mode.
         */
        mode?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove kernel modules from blacklist.
       */
      kernel_blacklist?: {
        /**
         * If specified, use this blacklist file instead of C(/etc/modprobe.d/blacklist-ansible.conf).
         */
        blacklist_file?: string;
        /**
         * Default: present
         *
         * Whether the module should be present in the blacklist or absent.
         */
        state?: "present" | "absent";
        /**
         * Name of kernel module to black- or whitelist.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete volume snapshot policies.
       */
      cs_snapshot_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Sends an arbitrary command to an NXOS node and returns the results read from the device.  This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      nxos_command?: {
        [k: string]: unknown;
      };
      /**
       * Manage I(libvirt) storage pools.
       */
      virt_pool?: {
        [k: string]: unknown;
      };
      /**
       * Allows for the initialization, suspension and resumption of an asynchronous mirror group's synchronization for NetApp E-series storage arrays.
       */
      netapp_e_amg_sync?: {
        /**
         * The ID of the storage array containing the AMG you wish to target
         */
        ssid: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * The synchronization action you'd like to take.
         * If C(running) then it will begin syncing if there is no active sync or will resume a suspended sync. If there is already a sync in progress, it will return with an OK status.
         * If C(suspended) it will suspend any ongoing sync action, but return OK if there is no active sync or if the sync is already suspended
         */
        state: "running" | "suspended";
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * Indicates whether the failures point can be deleted on the secondary if necessary to achieve the synchronization.
         * If true, and if the amount of unsynchronized data exceeds the CoW repository capacity on the secondary for any member volume, the last failures point will be deleted and synchronization will continue.
         * If false, the synchronization will be suspended if the amount of unsynchronized data exceeds the CoW Repository capacity on the secondary and the failures point will be preserved.
         * NOTE: This only has impact for newly launched syncs.
         */
        delete_recovery_point?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the async mirror group you wish to target
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manage dynamic, cluster-wide parameters for RabbitMQ
       */
      rabbitmq_parameter?: {
        /**
         * Default: rabbit
         *
         * erlang node name of the rabbit we wish to configure
         */
        node?: string;
        /**
         * Name of the parameter being set
         */
        name: string;
        /**
         * Name of the component of which the parameter is being set
         */
        component: string;
        /**
         * Value of the parameter, as a JSON term
         */
        value?: string;
        /**
         * Default: /
         *
         * vhost to apply access privileges.
         */
        vhost?: string;
        /**
         * Default: present
         *
         * Specify if user is to be added or removed
         */
        state?: "present" | "absent";
        [k: string]: unknown;
      };
      /**
       * Sends logs to LogEntries in realtime
       */
      logentries?: {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about all installed images on SmartOS. Facts will be inserted to the ansible_facts key.
       */
      smartos_image_facts?: {
        /**
         * Default: None
         *
         * Criteria for selecting image. Can be any value from image manifest and 'published_date', 'published', 'source', 'clones', and 'size'. More informaton can be found at U(https://smartos.org/man/1m/imgadm) under 'imgadm list'.
         */
        filters?: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM pool members via iControl SOAP API
       */
      bigip_pool_member?: {
        /**
         * Set new session availability status for pool member
         */
        session_state?: string;
        /**
         * Pool member ratio weight. Valid values range from 1 through 100. New pool members -- unless overriden with this value -- default to 1.
         */
        ratio?: string;
        /**
         * Pool member description
         */
        description?: string;
        /**
         * Set monitor availability status for pool member
         */
        monitor_state?: string;
        /**
         * Default: Common
         *
         * Partition
         */
        partition?: string;
        /**
         * Pool member connection limit. Setting this to 0 disables the limit.
         */
        connection_limit?: string;
        /**
         * Pool member IP
         */
        host?: string;
        /**
         * Default: present
         *
         * Pool member state
         */
        state?: string;
        /**
         * Default: no
         *
         * When state is absent and the pool member is no longer referenced in other pools, the default behavior removes the unused node o bject. Setting this to 'yes' disables this behavior.
         */
        preserve_node?: string;
        /**
         * Pool member rate limit (connections-per-second). Setting this to 0 disables the limit.
         */
        rate_limit?: string;
        /**
         * Pool member port
         */
        port?: string;
        /**
         * Pool name. This pool must exist.
         */
        pool?: string;
        [k: string]: unknown;
      };
      /**
       * Checks management connectivity of a windows host
       */
      win_ping?: {
        /**
         * Default: pong
         *
         * Alternate data to return instead of 'pong'
         */
        data?: string;
        [k: string]: unknown;
      };
      /**
       * Add or Remove a floating IP to an instance
       */
      os_floating_ip?: {
        /**
         * To which fixed IP of server the floating IP address should be attached to.
         */
        fixed_address?: string;
        /**
         * The name or ID of a neutron external network or a nova pool name.
         */
        network?: string;
        /**
         * When I(state) is present, and I(floating_ip_address) is not present, this parameter can be used to specify whether we should try to reuse a floating IP address already allocated to the project.
         */
        reuse?: string;
        /**
         * The name or ID of the instance to which the IP address should be assigned.
         */
        server?: string;
        /**
         * When I(state) is absent, indicates whether or not to delete the floating IP completely, or only detach it from the server. Default is to detach only.
         */
        purge?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * A floating IP address to attach or to detach. Required only if I(state) is absent. When I(state) is present can be used to specify a IP address to attach.
         */
        floating_ip_address?: string;
        /**
         * Default: 60
         *
         * Time to wait for an IP address to appear as attached. See wait.
         */
        timeout?: string;
        /**
         * When attaching a floating IP address, specify whether we should wait for it to appear as attached.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * Installs or uninstalls Windows Roles or Features on Windows Server. This module uses the Add/Remove-WindowsFeature Cmdlets, which is not available on client os machines.
       */
      win_feature?: {
        /**
         * Names of roles or features to install as a single feature or a comma-separated list of features
         */
        name?: string;
        /**
         * Adds the corresponding management tools to the specified feature
         */
        include_management_tools?: string;
        /**
         * Adds all subfeatures of the specified feature
         */
        include_sub_features?: string;
        /**
         * Specify a source to install the feature from
         */
        source?: string;
        /**
         * Default: present
         *
         * State of the features or roles on the system
         */
        state?: string;
        /**
         * Restarts the computer automatically when installation is complete, if restarting is required by the roles or features installed.
         */
        restart?: string;
        [k: string]: unknown;
      };
      /**
       * Manages Windows services
       */
      win_service?: {
        /**
         * Set the startup type for the service
         */
        start_mode?: string;
        /**
         * C(started)/C(stopped) are idempotent actions that will not run commands unless necessary.  C(restarted) will always bounce the service.
         */
        state?: string;
        /**
         * Name of the service
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module de-registers or registers an AWS EC2 instance from the ELBs that it belongs to.
       * Returns fact "ec2_elbs" which is a list of elbs attached to the instance if state=absent is passed as an argument.
       * Will be marked changed when called only if there are ELBs found to operate on.
       */
      ec2_elb?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * The M(git_config) module changes git configuration by invoking 'git config'. This is needed if you don't want to use M(template) for the entire git config file (e.g. because you need to change just C(user.email) in /etc/.git/config).  Solutions involving M(command) are cumbersone or don't work correctly in check mode.
       */
      git_config?: {
        /**
         * Path to a git repository for reading and writing values from a specific repo.
         */
        repo?: string;
        /**
         * Specify which scope to read/set values from. This is required when setting config values. If this is set to local, you must also specify the repo parameter. It defaults to system only when not using I(list_all)=yes.
         */
        scope?: "local" | "global" | "system";
        /**
         * List all settings (optionally limited to a given I(scope))
         */
        list_all?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the setting. If no value is supplied, the value will be read from the config if it has been set.
         */
        name?: string;
        /**
         * When specifying the name of a single setting, supply a value to set that setting to the given value.
         */
        value?: string;
        [k: string]: unknown;
      };
      /**
       * Verifies Rackspace Cloud credentials and returns identity information
       */
      rax_identity?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages VXLAN Network Virtualization Endpoint (NVE) overlay interface that terminates VXLAN tunnels.
       */
      nxos_vxlan_vtep?: {
        /**
         * Description of the NVE interface.
         */
        description?: string;
        /**
         * Specify mechanism for host reachability advertisement.
         */
        host_reachability?: string;
        /**
         * Suppresses advertisement of the NVE loopback address until the overlay has converged.
         */
        source_interface_hold_down_time?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: string;
        /**
         * Administratively shutdown the NVE interface.
         */
        shutdown?: string;
        /**
         * Specify the loopback interface whose IP address should be used for the NVE interface.
         */
        source_interface?: string;
        /**
         * Interface name for the VXLAN Network Virtualization Endpoint.
         */
        interface?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and remove port forwarding rules.
       */
      cs_portforward?: {
        /**
         * Whether the firewall rule for public port should be created, while creating the new rule.
         * Use M(cs_firewall) for managing firewall rules.
         */
        open_firewall?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * VM guest NIC secondary IP address for the port forwarding rule.
         */
        vm_guest_ip?: string;
        /**
         * Domain the C(vm) is related to.
         */
        domain?: string;
        api_key?: string;
        /**
         * Default: tcp
         *
         * Protocol of the port forwarding rule.
         */
        protocol?: "tcp" | "udp";
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Start public port for this rule.
         */
        public_port: number | string;
        /**
         * Name of virtual machine which we make the port forwarding rule for.
         * Required if C(state=present).
         */
        vm?: string;
        /**
         * End public port for this rule.
         * If not specified equal C(public_port).
         */
        public_end_port?: number | string;
        api_region?: string;
        /**
         * Name of the project the C(vm) is located in.
         */
        project?: string;
        /**
         * Start private port for this rule.
         */
        private_port: number | string;
        /**
         * Default: present
         *
         * State of the port forwarding rule.
         */
        state?: "present" | "absent";
        /**
         * End private port for this rule.
         * If not specified equal C(private_port).
         */
        private_end_port?: number | string;
        /**
         * Account the C(vm) is related to.
         */
        account?: string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the zone in which the virtual machine is in.
         * If not set, default zone is used.
         */
        zone?: string;
        /**
         * Public IP address the rule is assigned to.
         */
        ip_address: string;
        [k: string]: unknown;
      };
      /**
       * Allows uploading or removing IAM policies for IAM users, groups or roles.
       */
      iam_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Reboot a Windows machine, wait for it to go down, come back up, and respond to commands.
       */
      win_reboot?: {
        /**
         * Default: 600
         *
         * Maximum seconds to wait for machine to re-appear on the network and respond to a test command
         * This timeout is evaluated separately for both network appearance and test command success (so maximum clock time is actually twice this value)
         */
        reboot_timeout_sec?: string;
        /**
         * Default: 2
         *
         * Seconds for shutdown to wait before requesting reboot
         */
        pre_reboot_delay_sec?: string;
        /**
         * Default: 600
         *
         * Maximum seconds to wait for shutdown to occur
         * Increase this timeout for very slow hardware, large update applications, etc
         */
        shutdown_timeout_sec?: string;
        /**
         * Default: whoami
         *
         * Command to expect success for to determine the machine is ready for management
         */
        test_command?: string;
        /**
         * Default: 5
         *
         * Maximum seconds to wait for a single successful TCP connection to the WinRM endpoint before trying again
         */
        connect_timeout_sec?: string;
        [k: string]: unknown;
      };
      /**
       * Upload, download, and delete objects in Rackspace Cloud Files
       */
      rax_files_objects?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Attach/Detach a subnet interface to a router, to provide a gateway for the subnet.
       */
      quantum_router_interface?: {
        /**
         * Default: None
         *
         * Name of the region
         */
        region_name?: string;
        availability_zone?: string;
        /**
         * Default: None
         *
         * Name of the tenant whose subnet has to be attached.
         */
        tenant_name?: string;
        /**
         * Default: yes
         *
         * The tenant name of the login user
         */
        login_tenant_name?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: "present" | "absent";
        /**
         * Default: http://127.0.0.1:35357/v2.0/
         *
         * The keystone URL for authentication
         */
        auth_url?: string;
        /**
         * Default: yes
         *
         * Password of login user
         */
        login_password: string;
        /**
         * Default: admin
         *
         * login username to authenticate to keystone
         */
        login_username?: string;
        /**
         * Default: None
         *
         * Name of the subnet to whose interface should be attached to the router.
         */
        subnet_name: string;
        /**
         * Default: None
         *
         * Name of the router to which the subnet's interface should be attached.
         */
        router_name: string;
        [k: string]: unknown;
      };
      /**
       * Ansible module which helps to manage Jenkins plugins.
       */
      jenkins_plugin?: {
        [k: string]: unknown;
      };
      /**
       * Add or remove rights/permissions for a given user or group for the specified src file or folder.
       */
      win_acl?: {
        /**
         * Default: none
         *
         * The rights/permissions that are to be allowed/denyed for the specified user or group for the given src file or directory.  Can be entered as a comma separated list (Ex. "Modify, Delete, ExecuteFile").  For more information on the choices see MSDN FileSystemRights Enumeration.
         */
        rights?: string;
        /**
         * Default: For Leaf File, None; For Directory, ContainerInherit, ObjectInherit;
         *
         * Inherit flags on the ACL rules.  Can be specified as a comma separated list (Ex. "ContainerInherit, ObjectInherit").  For more information on the choices see MSDN InheritanceFlags Enumeration.
         */
        inherit?: string;
        /**
         * Default: None
         *
         * Propagation flag on the ACL rules.  For more information on the choices see MSDN PropagationFlags Enumeration.
         */
        propagation?: string;
        /**
         * Default: present
         *
         * Specify whether to add C(present) or remove C(absent) the specified access rule
         */
        state?: string;
        /**
         * Default: none
         *
         * User or Group to add specified rights to act on src file/folder
         */
        user?: string;
        /**
         * File or Directory
         */
        path?: string;
        /**
         * Default: none
         *
         * Specify whether to allow or deny the rights specified
         */
        type?: string;
        [k: string]: unknown;
      };
      /**
       * Manage the state of a program or group of programs running via supervisord
       */
      supervisorctl?: {
        /**
         * username to use for authentication
         */
        username?: string;
        /**
         * path to supervisorctl executable
         */
        supervisorctl_path?: string;
        /**
         * The name of the supervisord program or group to manage.
         * The name will be taken as group name when it ends with a colon I(:)
         * Group support is only available in Ansible version 1.6 or later.
         */
        name: string;
        /**
         * URL on which supervisord server is listening
         */
        server_url?: string;
        /**
         * The desired state of program/group.
         */
        state: "present" | "started" | "stopped" | "restarted" | "absent";
        /**
         * password to use for authentication
         */
        password?: string;
        /**
         * The supervisor configuration file path
         */
        config?: string;
        [k: string]: unknown;
      };
      /**
       * Manipulate Rackspace Cloud Block Storage Volume Attachments
       */
      rax_cbs_attachments?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Adds or removes a user from a MySQL database.
       */
      mysql_user?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * maintains ec2 security groups. This module has a dependency on python-boto >= 2.5
       */
      ec2_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is automatically called by playbooks to gather useful variables about remote hosts that can be used in playbooks. It can also be executed directly by C(/usr/bin/ansible) to check what variables are available to a host. Ansible provides many I(facts) about the system, automatically.
       */
      setup?: {
        /**
         * Default: *
         *
         * if supplied, only return facts that match this shell-style (fnmatch) wildcard.
         */
        filter?: string;
        /**
         * Default: all
         *
         * if supplied, restrict the additional facts collected to the given subset. Possible values: all, hardware, network, virtual, ohai, and facter Can specify a list of values to specify a larger subset. Values can also be used with an initial C(!) to specify that that specific subset should not be collected.  For instance: !hardware, !network, !virtual, !ohai, !facter.  Note that a few facts are always collected.  Use the filter parameter if you do not want to display those.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: /etc/ansible/facts.d
         *
         * path used for local ansible facts (*.fact) - files in this dir will be run (if executable) and their results be added to ansible_local facts if a file is not executable it is read. Check notes for Windows options. (from 2.1 on) File/results format can be json or ini-format
         */
        fact_path?: string;
        /**
         * Default: 10
         *
         * Set the default timeout in seconds for individual fact gathering
         */
        gather_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Add or Remove images from the glance repository.
       */
      glance_image?: {
        /**
         * Default: yes
         *
         * The tenant name of the login user
         */
        login_tenant_name?: string;
        /**
         * Default: None
         *
         * Name of the region
         */
        region_name?: string;
        availability_zone?: string;
        /**
         * Default: bare
         *
         * The format of the container
         */
        container_format?: "aki" | "ari" | "bare" | "ovf";
        /**
         * Default: None
         *
         * The minimum ram required to deploy this image
         */
        min_ram?: string;
        /**
         * Default: qcow2
         *
         * The format of the disk that is getting uploaded
         */
        disk_format?: "aki" | "vhd" | "vmdk" | "raw" | "qcow2" | "vdi" | "iso";
        /**
         * Default: 180
         *
         * The time to wait for the image process to complete in seconds
         */
        timeout?: string;
        /**
         * Default: None
         *
         * A url from where the image can be downloaded, mutually exclusive with file parameter
         */
        copy_from?: string;
        /**
         * Default: None
         *
         * The owner of the image
         */
        owner?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: "present" | "absent";
        /**
         * Default: publicURL
         *
         * The name of the glance service's endpoint URL type
         */
        endpoint_type?: "publicURL" | "internalURL";
        /**
         * Default: http://127.0.0.1:35357/v2.0/
         *
         * The keystone url for authentication
         */
        auth_url?: string;
        /**
         * Default: None
         *
         * The path to the file which has to be uploaded, mutually exclusive with copy_from
         */
        file?: string;
        /**
         * Default: yes
         *
         * Password of login user
         */
        login_password: string;
        /**
         * Default: None
         *
         * The minimum disk space required to deploy this image
         */
        min_disk?: string;
        /**
         * Default: yes
         *
         * Whether the image can be accessed publicly
         */
        is_public?: string;
        /**
         * Default: admin
         *
         * login username to authenticate to keystone
         */
        login_username?: string;
        /**
         * Default: None
         *
         * Name that has to be given to the image
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * allows the addition, modification and deletion of sessions in a consul cluster. These sessions can then be used in conjunction with key value pairs to implement distributed locks. In depth documentation for working with sessions can be found here http://www.consul.io/docs/internals/sessions.html
       */
      consul_session?: {
        /**
         * Default: None
         *
         * the name of the node that with which the session will be associated. by default this is the name of the agent.
         */
        node?: string;
        /**
         * Default: None
         *
         * name of the datacenter in which the session exists or should be created.
         */
        datacenter?: string;
        /**
         * Default: None
         *
         * the name that should be associated with the session. This is opaque to Consul and not required.
         */
        name?: string;
        /**
         * Default: localhost
         *
         * host of the consul agent defaults to localhost
         */
        host?: string;
        /**
         * Default: 8500
         *
         * the port on which the consul agent is running
         */
        port?: string;
        /**
         * Default: 15
         *
         * the optional lock delay that can be attached to the session when it is created. Locks for invalidated sessions ar blocked from being acquired until this delay has expired. Durations are in seconds
         */
        delay?: string;
        /**
         * Default: present
         *
         * whether the session should be present i.e. created if it doesn't exist, or absent, removed if present. If created, the ID for the session is returned in the output. If absent, the name or ID is required to remove the session. Info for a single session, all the sessions for a node or all available sessions can be retrieved by specifying info, node or list for the state; for node or info, the node name or session id is required as parameter.
         */
        state?: string;
        /**
         * Default: release
         *
         * the optional behavior that can be attached to the session when it is created. This can be set to either release or delete. This controls the behavior when a session is invalidated.
         */
        behavior?: string;
        /**
         * Default: http
         *
         * the protocol scheme on which the consul agent is running
         */
        scheme?: string;
        /**
         * Default: True
         *
         * whether to verify the tls certificate of the consul agent
         */
        validate_certs?: string;
        /**
         * Default: None
         *
         * a list of checks that will be used to verify the session health. If all the checks fail, the session will be invalidated and any locks associated with the session will be release and can be acquired once the associated lock delay has expired.
         */
        checks?: string;
        [k: string]: unknown;
      };
      /**
       * Gets the default administrator password from any EC2 Windows instance.  The instance is referenced by its id (e.g. i-XXXXXXX). This module has a dependency on python-boto.
       */
      ec2_win_password?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates AWS VPN Virtual Gateways
       * Deletes AWS VPN Virtual Gateways
       * Attaches Virtual Gateways to VPCs
       * Detaches Virtual Gateways from VPCs
       */
      ec2_vpc_vgw?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Nokia SR OS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with SR OS configuration sections in a deterministic way.
       */
      sros_config?: {
        /**
         * Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).
         */
        src?: string;
        /**
         * The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.
         * Note this argument should be considered deprecated.  To achieve the equivalent, set the C(match=none) which is idempotent.  This argument will be removed in a future release.
         */
        force?: string;
        /**
         * The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.
         */
        config?: string;
        /**
         * The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
         */
        after?: string;
        /**
         * The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
         */
        lines?: string;
        /**
         * Default: line
         *
         * Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct.
         */
        replace?: string;
        /**
         * The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
         */
        parents?: string;
        /**
         * This argument specifies whether or not to collect all defaults when getting the remote device running config.  When enabled, the module will get the current config by issuing the command C(show running-config all).
         */
        defaults?: string;
        /**
         * The C(save) argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.
         */
        save?: string;
        /**
         * This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.
         */
        backup?: string;
        /**
         * Default: line
         *
         * Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device.
         */
        match?: string;
        /**
         * The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
         */
        before?: string;
        [k: string]: unknown;
      };
      /**
       * Place an ESXI host into maintenance mode
       * Support for VSAN compliant maintenance mode when selected
       */
      vmware_maintenancemode?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage Jenkins jobs by using Jenkins REST API.
       */
      jenkins_job?: {
        /**
         * Name of the Jenkins job.
         */
        name: string;
        /**
         * Default: http://localhost:8080
         *
         * Url where the Jenkins server is accessible.
         */
        url?: string;
        /**
         * Whether the job should be enabled or disabled.
         * Mututally exclusive with C(config).
         * Considered if C(state=present).
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Attribute that specifies if the job has to be created or deleted.
         */
        state?: "present" | "absent";
        /**
         * API token used to authenticate alternatively to password.
         */
        token?: string;
        /**
         * User to authenticate with the Jenkins server.
         */
        user?: string;
        /**
         * Password to authenticate with the Jenkins server.
         */
        password?: string;
        /**
         * config in XML format.
         * Required if job does not yet exist.
         * Mututally exclusive with C(enabled).
         * Considered if C(state=present).
         */
        config?: string;
        [k: string]: unknown;
      };
      /**
       * Manage the arrays accessible via a NetApp Web Services Proxy for NetApp E-series storage arrays.
       */
      netapp_e_storage_system?: {
        /**
         * The ID of the array to manage. This value must be unique for each array.
         */
        ssid: string;
        /**
         * Default: None
         *
         * Optional meta tags to associate to this storage system
         */
        meta_tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url?: string;
        /**
         * The WWN of the array to manage. Only necessary if in-band managing multiple arrays on the same agent host.  Mutually exclusive of controller_addresses parameter.
         */
        array_wwn?: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password?: string;
        array_status_timeout_sec?: number | string;
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username?: string;
        /**
         * Whether the specified array should be configured on the Web Services Proxy or not.
         */
        state: "present" | "absent";
        /**
         * The management password of the array to manage, if set.
         */
        array_password?: string;
        /**
         * Enable trace logging for SYMbol calls to the storage system.
         */
        enable_trace?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The list addresses for the out-of-band management adapter or the agent host. Mutually exclusive of array_wwn parameter.
         */
        controller_addresses?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Use this module to manage crontab and environment variables entries. This module allows you to create environment variables and named crontab entries, update, or delete them.
       * When crontab jobs are managed: the module includes one line with the description of the crontab entry C("#Ansible: <name>") corresponding to the "name" passed to the module, which is used by future ansible/module calls to find/check the state. The "name" parameter should be unique, and changing the "name" value will result in a new cron task being created (or a different one being removed).
       * When environment variables are managed: no comment line is added, but, when the module needs to find/check the state, it uses the "name" parameter to find the environment variable definition line.
       * When using symbols such as %, they must be properly escaped.
       */
      cron?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or Remove a Stack to an OpenStack Heat
       */
      os_stack?: {
        /**
         * Rollback stack creation
         */
        rollback?: string;
        /**
         * Name of the stack that should be created, name could be char and digit, no space
         */
        name?: string;
        /**
         * Default: None
         *
         * Dictionary of parameters for the stack creation
         */
        parameters?: string;
        /**
         * Default: None
         *
         * List of environment files that should be used for the stack creation
         */
        environment?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: string;
        /**
         * Default: 3600
         *
         * Maximum number of seconds to wait for the stack creation
         */
        timeout?: string;
        /**
         * Default: None
         *
         * Path of the template file to use for the stack creation
         */
        template?: string;
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running IOS.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      ios_facts?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Configure an s3 bucket as a website
       */
      s3_website?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Read the AWS documentation for VPC Peering Connections U(http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-peering.html)
       */
      ec2_vpc_peer?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 VPC subnets in AWS
       */
      ec2_vpc_subnet_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Notify airbrake about app deployments (see http://help.airbrake.io/kb/api-2/deploy-tracking)
       */
      airbrake_deployment?: {
        /**
         * URL of the project repository
         */
        repo?: string;
        /**
         * Default: https://airbrake.io/deploys.txt
         *
         * Optional URL to submit the notification to. Use to send notifications to Airbrake-compliant tools like Errbit.
         */
        url?: string;
        /**
         * The airbrake environment name, typically 'production', 'staging', etc.
         */
        environment: string;
        /**
         * API token.
         */
        token: string;
        /**
         * The username of the person doing the deployment
         */
        user?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A hash, number, tag, or other identifier showing what revision was deployed
         */
        revision?: string;
        [k: string]: unknown;
      };
      /**
       * Create/destroy Block Storage volume in DigitalOcean, or attach/detach Block Storage volume to a droplet.
       */
      digital_ocean_block_storage?: {
        [k: string]: unknown;
      };
      /**
       * Manages Layer 2 interfaces
       */
      nxos_switchport?: {
        /**
         * If C(mode=trunk), used as the trunk native VLAN ID.
         */
        native_vlan?: string;
        /**
         * If C(mode=access), used as the access VLAN ID.
         */
        access_vlan?: string;
        /**
         * If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk.
         */
        trunk_vlans?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * if C(mode=trunk), these are the only VLANs that will be configured on the trunk, i.e. "2-10,15".
         */
        trunk_allowed_vlans?: string;
        /**
         * Mode for the Layer 2 port.
         */
        mode?: string;
        /**
         * Full name of the interface, i.e. Ethernet1/1.
         */
        interface?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about server instances from OpenStack.
       */
      os_server_facts?: {
        /**
         * when true, return additional detail about servers at the expense of additional API calls.
         */
        detailed?: string;
        /**
         * Default: None
         *
         * restrict results to servers with names matching this glob expression (e.g., C<web*>).
         */
        server?: string;
        [k: string]: unknown;
      };
      /**
       * Return a list files based on specific criteria. Multiple criteria are AND'd together.
       */
      find?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Deploy applications to JBoss standalone using the filesystem
       */
      jboss?: {
        /**
         * The remote path of the application ear or war to deploy
         */
        src?: string;
        /**
         * Default: present
         *
         * Whether the application should be deployed or undeployed
         */
        state?: "present" | "absent";
        /**
         * Default: /var/lib/jbossas/standalone/deployments
         *
         * The location in the filesystem where the deployment scanner listens
         */
        deploy_path?: string;
        /**
         * The name of the deployment
         */
        deployment: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove YUM repositories in RPM-based Linux distributions.
       */
      yum_repository?: {
        /**
         * Default: whatever
         *
         * Determines how yum resolves host names.
         * C(4) or C(IPv4) - resolve to IPv4 addresses only.
         * C(6) or C(IPv6) - resolve to IPv6 addresses only.
         */
        ip_resolve?: "4" | "6" | "IPv4" | "IPv6" | "whatever";
        /**
         * Default: yes
         *
         * This tells yum whether or not use this repository.
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Username to use for proxy.
         */
        proxy_password?: string;
        /**
         * Maximum available network bandwidth in bytes/second. Used with the I(throttle) option.
         * If I(throttle) is a percentage and bandwidth is C(0) then bandwidth throttling will be disabled. If I(throttle) is expressed as a data rate (bytes/sec) then this option is ignored. Default is C(0) (no bandwidth throttling).
         */
        bandwidth?: string;
        /**
         * Default: 1000
         *
         * Relative cost of accessing this repository. Useful for weighing one repo's packages as greater/less than any other.
         */
        cost?: string;
        /**
         * File to use to save the repo in. Defaults to the value of I(name).
         */
        file?: string;
        /**
         * Default: 21600
         *
         * Time (in seconds) after which the mirrorlist locally cached will expire.
         * Default value is 6 hours.
         */
        mirrorlist_expire?: string;
        /**
         * List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed.
         * The list can also be a regular YAML array.
         */
        exclude?: string;
        /**
         * Default: no
         *
         * This tells yum whether or not HTTP/1.1 keepalive should be used with this repository. This can improve transfer speeds by using one connection when downloading multiple files from a repository.
         */
        keepalive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * This tells yum whether or not it should perform a GPG signature check on the repodata from this repository.
         */
        repo_gpgcheck?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Defines whether yum should verify SSL certificates/hosts at all.
         */
        sslverify?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: roundrobin
         *
         * C(roundrobin) randomly selects a URL out of the list of URLs to start with and proceeds through each of them as it encounters a failure contacting the host.
         * C(priority) starts from the first I(baseurl) listed and reads through them sequentially.
         */
        failovermethod?: "roundrobin" | "priority";
        /**
         * Default: 100
         *
         * When the relative size of deltarpm metadata vs pkgs is larger than this, deltarpm metadata is not downloaded from the repo. Note that you can give values over C(100), so C(200) means that the metadata is required to be half the size of the packages. Use C(0) to turn off this check, and always download metadata.
         */
        deltarpm_metadata_percentage?: string;
        /**
         * A URL pointing to the ASCII-armored GPG key file for the repository.
         */
        gpgkey?: string;
        /**
         * Default: all
         *
         * Determines how upstream HTTP caches are instructed to handle any HTTP downloads that Yum does.
         * C(all) means that all HTTP downloads should be cached.
         * C(packages) means that only RPM package downloads should be cached (but not repository metadata downloads).
         * C(none) means that no HTTP downloads should be cached.
         */
        http_caching?: "all" | "packages" | "none";
        /**
         * Default: 99
         *
         * Enforce ordered protection of repositories. The value is an integer from 1 to 99.
         * This option only works if the YUM Priorities plugin is installed.
         */
        priority?: string;
        /**
         * Default: present
         *
         * State of the repo file.
         */
        state?: "absent" | "present";
        /**
         * Specifies a URL to a file containing a list of baseurls.
         * This or the I(baseurl) parameter is required if I(state) is set to C(present).
         */
        mirrorlist?: string;
        /**
         * Option used to allow the user to overwrite any of the other options. To remove an option, set the value of the option to C(null).
         */
        params?: {
          [k: string]: unknown;
        };
        /**
         * Default: no
         *
         * Tells yum whether or not it should perform a GPG signature check on packages.
         */
        gpgcheck?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the I(include=) line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected.
         */
        include?: string;
        /**
         * Password for this proxy.
         */
        proxy_username?: string;
        /**
         * Username to use for basic authentication to a repo or really any url.
         */
        username?: string;
        /**
         * Default: 21600
         *
         * Time (in seconds) after which the metadata will expire.
         * Default value is 6 hours.
         */
        metadata_expire?: string;
        /**
         * A human readable string describing the repository.
         * This parameter is only required if I(state) is set to C(present).
         */
        description?: string;
        /**
         * Default: 10
         *
         * Set the number of times any attempt to retrieve a file should retry before returning an error. Setting this to C(0) makes yum try forever.
         */
        retries?: string;
        /**
         * Path to the SSL client certificate yum should use to connect to repos/remote sites.
         */
        sslclientcert?: string;
        /**
         * A URL pointing to the ASCII-armored CA key file for the repository.
         */
        gpgcakey?: string;
        /**
         * URL to the directory where the yum repository's 'repodata' directory lives.
         * This or the I(mirrorlist) parameter is required if I(state) is set to C(present).
         */
        baseurl?: string;
        /**
         * Default: no
         *
         * Enables support for S3 repositories.
         * This option only works if the YUM S3 plugin is installed.
         */
        s3_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed. Substitution variables (e.g. C($releasever)) are honored here.
         * The list can also be a regular YAML array.
         */
        includepkgs?: string;
        /**
         * Default: yes
         *
         * If set to C(yes) Yum will download packages and metadata from this repo in parallel, if possible.
         */
        async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Password to use with the username for basic authentication.
         */
        password?: string;
        /**
         * Default: releasever basearch
         *
         * When a repository id is displayed, append these yum variables to the string if they are used in the I(baseurl)/etc. Variables are appended in the order listed (and found).
         */
        ui_repoid_vars?: string;
        /**
         * Default: no
         *
         * Protect packages from updates from other repositories.
         */
        protect?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Whether yum should check the permissions on the paths for the certificates on the repository (both remote and local).
         * If we can't read any of the files then yum will force I(skip_if_unavailable) to be C(yes). This is most useful for non-root processes which use yum on repos that have client cert files which are readable only by root.
         */
        ssl_check_cert_permissions?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable bandwidth throttling for downloads.
         * This option can be expressed as a absolute data rate in bytes/sec. An SI prefix (k, M or G) may be appended to the bandwidth value.
         */
        throttle?: string;
        /**
         * Unique repository ID.
         * This parameter is only required if I(state) is set to C(present) or C(absent).
         */
        name: string;
        /**
         * Default: 75
         *
         * When the relative size of delta vs pkg is larger than this, delta is not used. Use C(0) to turn off delta rpm processing. Local repositories (with file:// I(baseurl)) have delta rpms turned off by default.
         */
        deltarpm_percentage?: string;
        /**
         * Path to the SSL client key yum should use to connect to repos/remote sites.
         */
        sslclientkey?: string;
        /**
         * Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a I(baseurl).
         */
        metalink?: string;
        /**
         * Default: /etc/yum.repos.d
         *
         * Directory where the C(.repo) files will be stored.
         */
        reposdir?: string;
        /**
         * Default: no
         *
         * If set to C(yes) yum will continue running if this repository cannot be contacted for any reason. This should be set carefully as all repos are consulted for any given command.
         */
        skip_if_unavailable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * Either C(1) or C(0). Determines whether or not yum keeps the cache of headers and packages after successful installation.
         */
        keepcache?: "0" | "1";
        /**
         * Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates.
         */
        sslcacert?: string;
        /**
         * Default: 30
         *
         * Number of seconds to wait for a connection before timing out.
         */
        timeout?: string;
        /**
         * Default: yes
         *
         * Determines whether yum will allow the use of package groups for this repository.
         */
        enablegroups?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: read-only:present
         *
         * Filter the I(metadata_expire) time, allowing a trade of speed for accuracy if a command doesn't require it. Each yum command can specify that it requires a certain level of timeliness quality from the remote repos. from "I'm about to install/upgrade, so this better be current" to "Anything that's available is good enough".
         * C(never) - Nothing is filtered, always obey I(metadata_expire).
         * C(read-only:past) - Commands that only care about past information are filtered from metadata expiring. Eg. I(yum history) info (if history needs to lookup anything about a previous transaction, then by definition the remote package was available in the past).
         * C(read-only:present) - Commands that are balanced between past and future. Eg. I(yum list yum).
         * C(read-only:future) - Commands that are likely to result in running other commands which will require the latest metadata. Eg. I(yum check-update).
         * Note that this option does not override "yum clean expire-cache".
         */
        metadata_expire_filter?: "never" | "read-only:past" | "read-only:present" | "read-only:future";
        /**
         * URL to the proxy server that yum should use. Set to C(_none_) to disable the global proxy setting.
         */
        proxy?: string;
        [k: string]: unknown;
      };
      /**
       * Templates are processed by the Jinja2 templating language (U(http://jinja.pocoo.org/docs/)) - documentation on the template formatting can be found in the Template Designer Documentation (U(http://jinja.pocoo.org/docs/templates/)).
       * Six additional variables can be used in templates: C(ansible_managed) (configurable via the C(defaults) section of C(ansible.cfg)) contains a string which can be used to describe the template name, host, modification time of the template file and the owner uid, C(template_host) contains the node name of the template's machine, C(template_uid) the owner, C(template_path) the absolute path of the template, C(template_fullpath) is the absolute path of the template, and C(template_run_date) is the date that the template was rendered. Note that including a string that uses a date in the template will result in the template being marked 'changed' each time.
       */
      template?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Installs a Cumulus Linux license. The module reports no change of status when a license is installed. For more details go the Cumulus Linux License Documentation at U(http://docs.cumulusnetwork.com) and the Licensing KB Site at U(https://support.cumulusnetworks.com/hc/en-us/sections/200507688)
       */
      cl_license?: {
        /**
         * The full path to the license. Can be local path or HTTP URL.
         */
        src: string;
        /**
         * Force installation of a license. Typically not needed. It is recommended to manually run this command via the ansible command. A reload of switchd is not required. Running the force option in a playbook will break the idempotent state machine of the module and cause the switchd notification to kick in all the time, causing a disruption.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Returns list of matching AMIs with AMI ID, along with other useful information
       * Can search AMIs with different owners
       * Can search by matching tag(s), by AMI name and/or other criteria
       * Results can be sorted and sliced
       */
      ec2_ami_find?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and remove clusters.
       */
      cs_cluster?: {
        /**
         * Username for the cluster.
         */
        username?: string;
        /**
         * Ovm3 native OCFS2 clustering enabled for cluster.
         */
        ovm3_cluster?: string;
        /**
         * Ovm3 native pooling enabled for cluster.
         */
        ovm3_pool?: string;
        api_http_method?: "get" | "post";
        /**
         * Name of the pod in which the cluster belongs to.
         */
        pod?: string;
        /**
         * Type of virtual switch used for public traffic in the cluster.
         * Allowed values are, vmwaresvs (for VMware standard vSwitch) and vmwaredvs (for VMware distributed vSwitch)
         */
        public_vswitch_type?: "vmwaresvs" | "vmwaredvs";
        api_url?: string;
        /**
         * Name of the zone in which the cluster belongs to.
         * If not set, default zone is used.
         */
        zone?: string;
        /**
         * Type of the cluster.
         * Required if C(state=present)
         */
        cluster_type?: "CloudManaged" | "ExternalManaged";
        /**
         * Ovm3 vip to use for pool (and cluster).
         */
        ovm3_vip?: string;
        /**
         * IP address of the VSM associated with this cluster.
         */
        vms_ip_address?: string;
        /**
         * Default: present
         *
         * State of the cluster.
         */
        state?: "present" | "absent" | "disabled" | "enabled";
        api_key?: string;
        /**
         * Type of virtual switch used for guest traffic in the cluster.
         * Allowed values are, vmwaresvs (for VMware standard vSwitch) and vmwaredvs (for VMware distributed vSwitch)
         */
        guest_vswitch_type?: "vmwaresvs" | "vmwaredvs";
        /**
         * Name of virtual switch used for guest traffic in the cluster.
         * This would override zone wide traffic label setting.
         */
        guest_vswitch_name?: string;
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Password for the cluster.
         */
        password?: string;
        /**
         * Username for the VSM associated with this cluster.
         */
        vms_username?: string;
        /**
         * name of the cluster.
         */
        name: string;
        /**
         * URL for the cluster
         */
        url?: string;
        /**
         * Default: none
         *
         * Name the hypervisor to be used.
         * Required if C(state=present).
         */
        hypervisor?:
          | "KVM"
          | "kvm"
          | "VMware"
          | "vmware"
          | "BareMetal"
          | "baremetal"
          | "XenServer"
          | "xenserver"
          | "LXC"
          | "lxc"
          | "HyperV"
          | "hyperv"
          | "UCS"
          | "ucs"
          | "OVM"
          | "ovm"
          | "Simulator"
          | "simulator";
        api_region?: string;
        /**
         * Name of virtual switch used for public traffic in the cluster.
         * This would override zone wide traffic label setting.
         */
        public_vswitch_name?: string;
        /**
         * Password for the VSM associated with this cluster.
         */
        vms_password?: string;
        [k: string]: unknown;
      };
      /**
       * Manages SNMP community configuration.
       */
      nxos_snmp_community?: {
        /**
         * Group to which the community belongs.
         */
        group?: string;
        /**
         * Case-sensitive community string.
         */
        community?: string;
        /**
         * Default: 1
         *
         * ACL name to filter snmp requests.
         */
        acl?: string;
        /**
         * Access type for community.
         */
        access?: string;
        /**
         * Specify to use or not the complete running configuration for module operations.
         */
        include_defaults?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Specify to save the running configuration after module operations.
         */
        save?: string;
        /**
         * Configuration string to be used for module operations. If not specified, the module will use the current running configuration.
         */
        config?: string;
        [k: string]: unknown;
      };
      /**
       * Look up the most recent AMI on AWS for a given operating system.
       * Returns C(ami), C(aki), C(ari), C(serial), C(tag)
       * If there is no AKI or ARI associated with an image, these will be C(null).
       * Only supports images from cloud-images.ubuntu.com
       * Example output: C({"ami": "ami-69f5a900", "changed": false, "aki": "aki-88aa75e1", "tag": "release", "ari": null, "serial": "20131024"})
       */
      ec2_ami_search?: {
        /**
         * Default: server
         *
         * Type of release.
         */
        stream?: "server" | "desktop";
        /**
         * Default: paravirtual
         *
         * virutalization type
         */
        virt?: "paravirtual" | "hvm";
        /**
         * Default: us-east-1
         *
         * EC2 region
         */
        region?:
          | "ap-northeast-1"
          | "ap-southeast-1"
          | "ap-northeast-2"
          | "ap-southeast-2"
          | "ap-south-1"
          | "eu-central-1"
          | "eu-west-1"
          | "sa-east-1"
          | "us-east-1"
          | "us-west-1"
          | "us-west-2"
          | "us-gov-west-1";
        /**
         * short name of the release (e.g., C(precise))
         */
        release: string;
        /**
         * Default: amd64
         *
         * CPU architecture
         */
        arch?: "i386" | "amd64";
        /**
         * Default: ebs
         *
         * Back-end store for instance
         */
        store?: "ebs" | "ebs-io1" | "ebs-ssd" | "instance-store";
        /**
         * Linux distribution (e.g., C(ubuntu))
         */
        distro: "ubuntu";
        [k: string]: unknown;
      };
      /**
       * Creates or cancels SoftLayer instances. When created, optionally waits for it to be 'running'.
       */
      sl_vm?: {
        /**
         * Falg to determine if the instance should be deployed in dedicated space
         */
        dedicated?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Count of cpus to be assigned to new virtual instance
         */
        cpus?: number | string;
        /**
         * Flag to determine if the instance should be private only
         */
        private?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Domain name to be provided to a virtual instance
         */
        domain?: string;
        /**
         * VLAN by its Id to be assigned to the private NIC
         */
        private_vlan?: string;
        /**
         * Default: True
         *
         * Flag to determine if the instance should be hourly billed
         */
        hourly?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of ssh keys by their Id to be assigned to a virtual instance
         */
        ssh_keys?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Hostname to be provided to a virtual instance
         */
        hostname?: string;
        /**
         * OS Code to be used for new virtual instance
         */
        os_code?: string;
        wait_time?: number | string;
        /**
         * Default: present
         *
         * Create, or cancel a virtual instance. Specify "present" for create, "absent" to cancel.
         */
        state?: "present" | "absent";
        /**
         * URL of a post provisioning script ot be loaded and exectued on virtual instance
         */
        post_uri?: string;
        /**
         * Amount of memory to be assigned to new virtual instance
         */
        memory?: number | string;
        /**
         * Tag or list of tags to be provided to a virtual instance
         */
        tags?: string;
        /**
         * Image Template to be used for new virtual instance
         */
        image_id?: string;
        /**
         * Default: 10
         *
         * NIC Speed to be assigned to new virtual instance
         */
        nic_speed?: number | string;
        /**
         * VLAN by its Id to be assigned to the public NIC
         */
        public_vlan?: string;
        /**
         * Default: True
         *
         * Flag used to wait for active status before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Datacenter for the virtual instance to be deployed
         */
        datacenter?:
          | "ams01"
          | "ams03"
          | "che01"
          | "dal01"
          | "dal05"
          | "dal06"
          | "dal09"
          | "dal10"
          | "fra02"
          | "hkg02"
          | "hou02"
          | "lon02"
          | "mel01"
          | "mex01"
          | "mil01"
          | "mon01"
          | "osl01"
          | "par01"
          | "sjc01"
          | "sjc03"
          | "sao01"
          | "sea01"
          | "sng01"
          | "syd01"
          | "tok02"
          | "tor01"
          | "wdc01"
          | "wdc04";
        /**
         * Default: [25]
         *
         * List of disk sizes to be assigned to new virtual instance
         */
        disks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Instance Id of the virtual instance to perform action option
         */
        instance_id?: string;
        /**
         * Default: True
         *
         * Flag to determine if local disk should be used for the new instance
         */
        local_disk?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * You can wait for a set amount of time C(timeout), this is the default if nothing is specified.
       * Waiting for a port to become available is useful for when services are not immediately available after their init scripts return which is true of certain Java application servers. It is also useful when starting guests with the M(virt) module and needing to pause until they are ready.
       * This module can also be used to wait for a regex match a string to be present in a file.
       * In 1.6 and later, this module can also be used to wait for a file to be available or absent on the filesystem.
       * In 1.8 and later, this module can also be used to wait for active connections to be closed before continuing, useful if a node is being rotated out of a load balancer pool.
       */
      wait_for?: {
        /**
         * Default: 127.0.0.1
         *
         * A resolvable hostname or IP address to wait for
         */
        host?: string;
        /**
         * Default: 5
         *
         * maximum number of seconds to wait for a connection to happen before closing and retrying
         */
        connect_timeout?: number | string;
        /**
         * number of seconds to wait before starting to poll
         */
        delay?: number | string;
        /**
         * Default: started
         *
         * either C(present), C(started), or C(stopped), C(absent), or C(drained)
         * When checking a port C(started) will ensure the port is open, C(stopped) will check that it is closed, C(drained) will check for active connections
         * When checking for a file or a search string C(present) or C(started) will ensure that the file or string is present before continuing, C(absent) will check that file is absent or removed
         */
        state?: "present" | "started" | "stopped" | "absent" | "drained";
        /**
         * Default: 300
         *
         * maximum number of seconds to wait for
         */
        timeout?: number | string;
        /**
         * list of hosts or IPs to ignore when looking for active TCP connections for C(drained) state
         */
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Can be used to match a string in either a file or a socket connection. Defaults to a multiline regex.
         */
        search_regex?: string;
        /**
         * path to a file on the filesytem that must exist before continuing
         */
        path?: string;
        /**
         * port number to poll
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Creates, modifies, and deletes RDS parameter groups. This module has a dependency on python-boto >= 2.5.
       */
      rds_param_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Reads data out of XenAPI, can be used instead of multiple xe commands.
       */
      xenserver_facts?: {
        [k: string]: unknown;
      };
      /**
       * Creates, modifies, and deletes Elasticache subnet groups. This module has a dependency on python-boto >= 2.5.
       */
      elasticache_subnet_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Updates Vertica configuration parameters.
       */
      vertica_configuration?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module can be used to add/remove an ESXi host to/from vCenter
       */
      vmware_host?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Set column values in record in database table.
       */
      openvswitch_db?: {
        /**
         * Identifies the key in the record column
         */
        key: string;
        /**
         * Expected value for the table, record, column and key.
         */
        value: string;
        /**
         * Identifies the recoard in the table.
         */
        record: string;
        /**
         * Default: 5
         *
         * How long to wait for ovs-vswitchd to respond
         */
        timeout?: number | string;
        /**
         * Identifies the table in the database.
         */
        table: string;
        col: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove domains or subdomains on a Webfaction host. Further documentation at http://github.com/quentinsf/ansible-webfaction.
       */
      webfaction_domain?: {
        /**
         * Default: present
         *
         * Whether the domain should exist
         */
        state?: "present" | "absent";
        /**
         * Any subdomains to create.
         */
        subdomains?: string;
        /**
         * The webfaction account to use
         */
        login_name: string;
        /**
         * The name of the domain
         */
        name: string;
        /**
         * The webfaction password to use
         */
        login_password: string;
        [k: string]: unknown;
      };
      /**
       * Creates, deletes, or modifies rds instances.  When creating an instance it can be either a new instance or a read-only replica of an existing instance. This module has a dependency on python-boto >= 2.5. The 'promote' command requires boto >= 2.18.0. Certain features such as tags rely on boto.rds2 (boto >= 2.26.0)
       */
      rds?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages core NTP configuration.
       */
      nxos_ntp?: {
        /**
         * Local source address from which NTP messages are sent.
         */
        source_addr?: string;
        /**
         * Makes given NTP server or peer the preferred NTP server or peer for the device.
         */
        prefer?: string;
        /**
         * Network address of NTP server.
         */
        server?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Makes the device communicate with the given NTP server or peer over a specific VRF.
         */
        vrf_name?: string;
        /**
         * Network address of NTP peer.
         */
        peer?: string;
        /**
         * Authentication key identifier to use with given NTP server or peer.
         */
        key_id?: string;
        /**
         * Local source interface from which NTP messages are sent. Must be fully qualified interface name.
         */
        source_int?: string;
        [k: string]: unknown;
      };
      /**
       * Allows the addition, modification and deletion of key/value entries in a consul cluster via the agent. The entire contents of the record, including the indices, flags and session are returned as 'value'.
       * If the key represents a prefix then Note that when a value is removed, the existing value if any is returned as part of the results.
       * See http://www.consul.io/docs/agent/http.html#kv for more details.
       */
      consul_kv?: {
        /**
         * Default: None
         *
         * used when acquiring a lock with a session. If the cas is 0, then Consul will only put the key if it does not already exist. If the cas value is non-zero, then the key is only set if the index matches the ModifyIndex of that key.
         */
        cas?: string;
        /**
         * if the key represents a prefix, each entry with the prefix can be retrieved by setting this to true.
         */
        recurse?: string;
        /**
         * Default: present
         *
         * the action to take with the supplied key and value. If the state is 'present', the key contents will be set to the value supplied, 'changed' will be set to true only if the value was different to the current contents. The state 'absent' will remove the key/value pair, again 'changed' will be set to true only if the key actually existed prior to the removal. An attempt can be made to obtain or free the lock associated with a key/value pair with the states 'acquire' or 'release' respectively. a valid session must be supplied to make the attempt changed will be true if the attempt is successful, false otherwise.
         */
        state?: string;
        /**
         * the value should be associated with the given key, required if state is present
         */
        value?: string;
        /**
         * Default: None
         *
         * the token key indentifying an ACL rule set that controls access to the key value pair
         */
        token?: string;
        /**
         * Default: None
         *
         * the session that should be used to acquire or release a lock associated with a key/value pair
         */
        session?: string;
        /**
         * Default: None
         *
         * opaque integer value that can be passed when setting a value.
         */
        flags?: string;
        /**
         * the key at which the value should be stored.
         */
        key?: string;
        /**
         * Default: localhost
         *
         * host of the consul agent defaults to localhost
         */
        host?: string;
        /**
         * Default: http
         *
         * the protocol scheme on which the consul agent is running
         */
        scheme?: string;
        /**
         * Default: True
         *
         * whether to verify the tls certificate of the consul agent
         */
        validate_certs?: string;
        /**
         * Default: 8500
         *
         * the port on which the consul agent is running
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides user management for ejabberd servers
       */
      ejabberd_user?: {
        /**
         * the name of the user to manage
         */
        username?: string;
        /**
         * Default: present
         *
         * describe the desired state of the user to be managed
         */
        state?: "present" | "absent";
        /**
         * the password to assign to the username
         */
        password?: string;
        /**
         * enables or disables the local syslog facility for this module
         */
        logging?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * the ejabberd host associated with this username
         */
        host?: string;
        [k: string]: unknown;
      };
      /**
       * Configure the rollback feature on remote Nokia devices running the SR OS operating system.  this module provides a stateful implementation for managing the configuration of the rollback feature
       */
      sros_rollback?: {
        /**
         * Default: present
         *
         * The I(state) argument specifies the state of the configuration entries in the devices active configuration.  When the state value is set to C(true) the configuration is present in the devices active configuration.  When the state value is set to C(false) the configuration values are removed from the devices active configuration.
         */
        state?: string;
        /**
         * The I(local_max_checkpoints) argument configures the maximum number of rollback files that can be saved on the devices local compact flash.  Valid values for this argument are in the range of 1 to 50
         */
        local_max_checkpoints?: string;
        /**
         * The I(rescue_location) specifies the location of the rescue file.  This argument supports any valid local or remote URL as specified in SR OS
         */
        rescue_location?: string;
        /**
         * The I(remote_max_checkpoints) argument configures the maximum number of rollback files that can be transfered and saved to a remote location.  Valid values for this argument are in the range of 1 to 50
         */
        remote_max_checkpoints?: string;
        /**
         * The I(rollback_location) specifies the location and filename of the rollback checkpoint files.   This argument supports any valid local or remote URL as specified in SR OS
         */
        rollback_location?: string;
        [k: string]: unknown;
      };
      /**
       * Lists or describes services in ecs.
       */
      ecs_service_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or remove mailboxes on a Webfaction account. Further documentation at http://github.com/quentinsf/ansible-webfaction.
       */
      webfaction_mailbox?: {
        /**
         * The password for the mailbox
         */
        mailbox_password: string;
        /**
         * Default: present
         *
         * Whether the mailbox should exist
         */
        state?: "present" | "absent";
        /**
         * The webfaction account to use
         */
        login_name: string;
        /**
         * The name of the mailbox
         */
        mailbox_name: string;
        /**
         * The webfaction password to use
         */
        login_password: string;
        [k: string]: unknown;
      };
      /**
       * Install an operating system by setting the boot options like boot image and kickstart image.
       */
      nxos_install_os?: {
        /**
         * Name of the system (or combined) image file on flash.
         */
        system_image_file?: string;
        /**
         * Name of the kickstart image file on flash.
         */
        kickstart_image_file?: string;
        [k: string]: unknown;
      };
      /**
       * Manages SNMP location configuration.
       */
      nxos_snmp_location?: {
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Location information.
         */
        location?: string;
        [k: string]: unknown;
      };
      /**
       * The M(sns_topic) module allows you to create, delete, and manage subscriptions for AWS SNS topics.
       */
      sns_topic?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage BIG-IP data center configuration. A data center defines the location where the physical network components reside, such as the server and link objects that share the same subnet on the network. This module is able to manipulate the data center definitions in a BIG-IP
       */
      bigip_gtm_datacenter?: {
        /**
         * The description of the data center.
         */
        description?: string;
        /**
         * Whether the data center should be enabled. At least one of C(state) and C(enabled) are required.
         */
        enabled?: string;
        /**
         * The state of the datacenter on the BIG-IP. When C(present), guarantees that the data center exists. When C(absent) removes the data center from the BIG-IP. C(enabled) will enable the data center and C(disabled) will ensure the data center is disabled. At least one of state and enabled are required.
         */
        state?: string;
        /**
         * The name of the contact for the data center.
         */
        contact?: string;
        /**
         * The location of the data center.
         */
        location?: string;
        /**
         * The name of the data center.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Creates, Removes and configures a IIS Web site
       */
      win_iis_website?: {
        /**
         * The host header to bind to / use for the new site.
         */
        hostname?: string;
        /**
         * Names of web site
         */
        name?: string;
        /**
         * Custom site Parameters from string where properties are seperated by a pipe and property name/values by colon Ex. "foo:1|bar:2"
         */
        parameters?: string;
        /**
         * The IP address to bind to / use for the new site.
         */
        ip?: string;
        /**
         * The physical path on the remote host to use for the new site. The specified folder must already exist.
         */
        physical_path?: string;
        /**
         * The application pool in which the new site executes.
         */
        application_pool?: string;
        /**
         * Explicitly set the IIS numeric ID for a site. Note that this value cannot be changed after the website has been created.
         */
        site_id?: string;
        /**
         * Enables HTTPS binding on the site..
         */
        ssl?: string;
        /**
         * State of the web site
         */
        state?: string;
        /**
         * The port to bind to / use for the new site.
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * After .NET framework is installed/updated, Windows will probably want to recompile things to optimise for the host.
       * This happens via scheduled task, usually at some inopportune time.
       * This module allows you to run this task on your own schedule, so you incur the CPU hit at some more convenient and controlled time.
       * http://blogs.msdn.com/b/dotnet/archive/2013/08/06/wondering-why-mscorsvw-exe-has-high-cpu-usage-you-can-speed-it-up.aspx
       */
      win_dotnet_ngen?: {
        [k: string]: unknown;
      };
      /**
       * Launches an AWS CloudFormation stack and waits for it complete.
       */
      cloudformation?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about a one or more OpenStack users
       */
      os_user_facts?: {
        /**
         * Default: None
         *
         * Name or ID of the domain containing the user if the cloud supports domains
         */
        domain?: string;
        /**
         * Name or ID of the user
         */
        name?: string;
        /**
         * Default: None
         *
         * A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
         */
        filters?: string;
        [k: string]: unknown;
      };
      /**
       * Manages I(apk) packages for Alpine Linux.
       */
      apk?: {
        /**
         * Default: present
         *
         * Indicates the desired package(s) state.
         * C(present) ensures the package(s) is/are present.
         * C(absent) ensures the package(s) is/are absent.
         * C(latest) ensures the package(s) is/are present and the latest version(s).
         */
        state?: "present" | "installed" | "absent" | "removed" | "latest";
        /**
         * Upgrade all installed packages to their latest version.
         */
        upgrade?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Update repository indexes. Can be run with other steps or on it's own.
         */
        update_cache?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A package name, like C(foo), or mutliple packages, like C(foo, bar).
         */
        name?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Notify BigPanda when deployments start and end (successfully or not). Returns a deployment object containing all the parameters for future module calls.
       */
      bigpanda?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Creates, Removes and configures a IIS Web applications
       */
      win_iis_webapplication?: {
        /**
         * State of the web application
         */
        state?: string;
        /**
         * The application pool in which the new site executes.
         */
        application_pool?: string;
        /**
         * Name of the Web applicatio
         */
        name?: string;
        /**
         * The physical path on the remote host to use for the new applicatiojn. The specified folder must already exist.
         */
        physical_path?: string;
        /**
         * Name of the site on which the application is created.
         */
        site?: string;
        [k: string]: unknown;
      };
      /**
       * Composer is a tool for dependency management in PHP. It allows you to declare the dependent libraries your project needs and it will install them in your project for you
       */
      composer?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * The Deploy Helper manages some of the steps common in deploying software. It creates a folder structure, manages a symlink for the current release and cleans up old releases.
       * Running it with the C(state=query) or C(state=present) will return the C(deploy_helper) fact. C(project_path), whatever you set in the path parameter, C(current_path), the path to the symlink that points to the active release, C(releases_path), the path to the folder to keep releases in, C(shared_path), the path to the folder to keep shared resources in, C(unfinished_filename), the file to check for to recognize unfinished builds, C(previous_release), the release the 'current' symlink is pointing to, C(previous_release_path), the full path to the 'current' symlink target, C(new_release), either the 'release' parameter or a generated timestamp, C(new_release_path), the path to the new release folder (not created by the module).
       */
      deploy_helper?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Adds or removes (rpm --import) a gpg key to your rpm database.
       */
      rpm_key?: {
        /**
         * Default: present
         *
         * If the key will be imported or removed from the rpm db.
         */
        state?: "present" | "absent";
        /**
         * Default: yes
         *
         * If C(no) and the C(key) is a url starting with https, SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Key that will be modified. Can be a url, a file, or a keyid if the key already exists in the database.
         */
        key: string;
        [k: string]: unknown;
      };
      /**
       * Send a message to hipchat
       */
      hipchat?: {
        [k: string]: unknown;
      };
      /**
       * Synchronizes the contents of two directories on the remote machine. Under the hood this just calls out to RoboCopy, since that should be available on most modern Windows Systems.
       */
      win_robocopy?: {
        /**
         * Destination file/directory to sync (Will receive contents of src).
         */
        dest?: string;
        /**
         * Source file/directory to sync.
         */
        src?: string;
        /**
         * Includes all subdirectories (Toggles the `/e` flag to RoboCopy). If "flags" is set, this will be ignored.
         */
        recurse?: string;
        /**
         * Deletes any files/directories found in the destination that do not exist in the source (Toggles the `/purge` flag to RoboCopy). If "flags" is set, this will be ignored.
         */
        purge?: string;
        /**
         * Default: None
         *
         * Directly supply Robocopy flags. If set, purge and recurse will be ignored.
         */
        flags?: string;
        [k: string]: unknown;
      };
      /**
       * Installs, upgrade, removes, and lists packages and groups with the I(dnf) package manager.
       */
      dnf?: {
        [k: string]: unknown;
      };
      /**
       * nssm is a service helper which doesn't suck. See https://nssm.cc/ for more information.
       */
      win_nssm?: {
        /**
         * Name of the service to operate on
         */
        name?: string;
        /**
         * Default: auto
         *
         * If C(auto) is selected, the service will start at bootup. C(manual) means that the service will start only when another service needs it. C(disabled) means that the service will stay off, regardless if it is needed or not.
         */
        start_mode?: string;
        /**
         * Path to receive error output
         */
        stderr_file?: string;
        /**
         * The application binary to run as a service
         * Specify this whenever the service may need to be installed (state: present, started, stopped, restarted)
         * Note that the application name must look like the following, if the directory includes spaces:
         * nssm install service "c:\Program Files\app.exe\" "C:\Path with spaces\"
         * See commit 0b386fc1984ab74ee59b7bed14b7e8f57212c22b in the nssm.git project for more info (https://git.nssm.cc/?p=nssm.git;a=commit;h=0b386fc1984ab74ee59b7bed14b7e8f57212c22b)
         */
        application?: string;
        /**
         * Default: started
         *
         * State of the service on the system
         * Note that NSSM actions like "pause", "continue", "rotate" do not fit the declarative style of ansible, so these should be implemented via the ansible command module
         */
        state?: string;
        /**
         * Service dependencies that has to be started to trigger startup, separated by comma.
         */
        dependencies?: string;
        /**
         * User to be used for service startup
         */
        user?: string;
        /**
         * Password to be used for service startup
         */
        password?: string;
        /**
         * Path to receive output
         */
        stdout_file?: string;
        /**
         * Parameters to be passed to the application when it starts
         */
        app_parameters?: string;
        [k: string]: unknown;
      };
      /**
       * Manage installation and Gem version dependencies for Ruby using the Bundler gem
       */
      bundler?: {
        /**
         * The path to the bundler executable
         */
        executable?: string;
        /**
         * Default: temporary working directory
         *
         * The directory to execute the bundler commands from. This directoy needs to contain a valid Gemfile or .bundle/ directory
         */
        chdir?: string;
        /**
         * Default: Gemfile in current directory
         *
         * Only applies if state is C(present). The path to the gemfile to use to install gems.
         */
        gemfile?: string;
        /**
         * Default: no
         *
         * Only applies if state is C(present). If set removes any gems on the target host that are not in the gemfile
         */
        clean?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Only applies if state is C(present). Installs gems in the local user's cache or for all users
         */
        user_install?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A space separated string of additional commands that can be applied to the Bundler command. Refer to the Bundler documentation for more information
         */
        extra_args?: string;
        /**
         * Default: present
         *
         * The desired state of the Gem bundle. C(latest) updates gems to the most recent, acceptable version
         */
        state?: "present" | "latest";
        /**
         * Default: no
         *
         * Only applies if state is C(present). If set it will only install gems that are in the default or production groups. Requires a Gemfile.lock file to have been created prior
         */
        deployment_mode?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Only applies if state is C(present). Specifies the directory to install any gem bins files to. When executed the bin files will run within the context of the Gemfile and fail if any required gem dependencies are not installed. If C(chdir) is set then this path is relative to C(chdir)
         */
        binstub_directory?: string;
        /**
         * A list of Gemfile groups to exclude during operations. This only applies when state is C(present). Bundler considers this a 'remembered' property for the Gemfile and will automatically exclude groups in future operations even if C(exclude_groups) is not set
         */
        exclude_groups?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: no
         *
         * If set only installs gems from the cache on the target host
         */
        local?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: RubyGems gem paths
         *
         * Only applies if state is C(present). Specifies the directory to install the gems into. If C(chdir) is set then this path is relative to C(chdir)
         */
        gem_path?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows to manage user groups on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
       */
      udm_group?: {
        /**
         * Group description.
         */
        description?: string;
        /**
         * Subpath inside the OU, e.g. C(cn=classes,cn=students,cn=groups).
         */
        subpath?: string;
        /**
         * Default: present
         *
         * Whether the group is present or not.
         */
        state?: "present" | "absent";
        /**
         * define the whole ldap position of the group, e.g. C(cn=g123m-1A,cn=classes,cn=schueler,cn=groups,ou=schule,dc=example,dc=com).
         */
        position?: string;
        /**
         * LDAP OU, e.g. school for LDAP OU C(ou=school,dc=example,dc=com).
         */
        ou?: string;
        /**
         * Name of the posix group.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages global VRF configuration.
       */
      nxos_vrf?: {
        /**
         * Description of the VRF.
         */
        description?: string;
        /**
         * Specify virtual network identifier. Valid values are Integer or keyword 'default'.
         */
        vni?: string;
        /**
         * Default: present
         *
         * Manages desired state of the resource.
         */
        state?: string;
        /**
         * VPN Route Distinguisher (RD). Valid values are a string in one of the route-distinguisher formats (ASN2:NN, ASN4:NN, or IPV4:NN); the keyword 'auto', or the keyword 'default'.
         */
        route_distinguisher?: string;
        /**
         * Default: up
         *
         * Administrative state of the VRF.
         */
        admin_state?: string;
        /**
         * Name of VRF to be managed.
         */
        vrf?: string;
        [k: string]: unknown;
      };
      /**
       * LogicMonitor is a hosted, full-stack, infrastructure monitoring platform.
       * This module manages hosts, host groups, and collectors within your LogicMonitor account.
       */
      logicmonitor?: {
        /**
         * Default: hostname -f
         *
         * The display name of a host in your LogicMonitor account or the desired display name of a device to manage.
         * Optional for managing hosts (target=host).
         */
        displayname?: string;
        /**
         * The long text description of the object in your LogicMonitor account.
         * Optional for managing hosts and host groups (target=host or target=hostgroup; action=add or action=update).
         */
        description?: string;
        /**
         * The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes."
         */
        company: string;
        /**
         * Default: hostname -f
         *
         * The hostname of a host in your LogicMonitor account, or the desired hostname of a device to manage.
         * Optional for managing hosts (target=host).
         */
        hostname?: string;
        /**
         * The fullpath of the host group object you would like to manage.
         * Recommend running on a single Ansible host.
         * Required for management of LogicMonitor host groups (target=hostgroup).
         */
        fullpath?: string;
        /**
         * A dictionary of properties to set on the LogicMonitor host or host group.
         * Optional for managing hosts and host groups (target=host or target=hostgroup; action=add or action=update).
         * This parameter will add or update existing properties in your LogicMonitor account.
         */
        properties?: {
          [k: string]: unknown;
        };
        /**
         * The action you wish to perform on target.
         * Add: Add an object to your LogicMonitor account.
         * Remove: Remove an object from your LogicMonitor account.
         * Update: Update properties, description, or groups (target=host) for an object in your LogicMonitor account.
         * SDT: Schedule downtime for an object in your LogicMonitor account.
         */
        action: "add" | "remove" | "update" | "sdt";
        /**
         * A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.
         */
        user: string;
        /**
         * A list of groups that the host should be a member of.
         * Optional for managing hosts (target=host; action=add or action=update).
         */
        groups?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 30
         *
         * The duration (minutes) of the Scheduled Down Time (SDT).
         * Optional for putting an object into SDT (action=sdt).
         */
        duration?: string;
        /**
         * Default: True
         *
         * A boolean flag to turn alerting on or off for an object.
         * Optional for managing all hosts (action=add or action=update).
         */
        alertenable?: 0 | "on" | "f" | "false" | 1 | "no" | "n" | "1" | "0" | "t" | "y" | "off" | "yes" | "true";
        /**
         * Default: Now
         *
         * The time that the Scheduled Down Time (SDT) should begin.
         * Optional for managing SDT (action=sdt).
         * Y-m-d H:M
         */
        starttime?: string;
        /**
         * The password of the specified LogicMonitor user
         */
        password: string;
        /**
         * The fully qualified domain name of a collector in your LogicMonitor account.
         * This is required for the creation of a LogicMonitor host (target=host action=add).
         * This is required for updating, removing or scheduling downtime for hosts if 'displayname' isn't specified (target=host action=update action=remove action=sdt).
         */
        collector?: string;
        /**
         * ID of the datasource to target.
         * Required for management of LogicMonitor datasources (target=datasource).
         */
        id?: string;
        /**
         * The type of LogicMonitor object you wish to manage.
         * Collector: Perform actions on a LogicMonitor collector.
         * NOTE You should use Ansible service modules such as M(service) or M(supervisorctl) for managing the Collector 'logicmonitor-agent' and 'logicmonitor-watchdog' services. Specifically, you'll probably want to start these services after a Collector add and stop these services before a Collector remove.
         * Host: Perform actions on a host device.
         * Hostgroup: Perform actions on a LogicMonitor host group.
         * NOTE Host and Hostgroup tasks should always be performed via local_action. There are no benefits to running these tasks on the remote host and doing so will typically cause problems.
         */
        target: "collector" | "host" | "datasource" | "hostgroup";
        [k: string]: unknown;
      };
      /**
       * Add or Remove rule from an existing security group
       */
      os_security_group_rule?: {
        /**
         * Default: ingress
         *
         * The direction in which the security group rule is applied. Not all providers support egress.
         */
        direction?: string;
        /**
         * Default: None
         *
         * IP protocols TCP UDP ICMP 112 (VRRP)
         */
        protocol?: string;
        /**
         * Source IP address(es) in CIDR notation (exclusive with remote_group)
         */
        remote_ip_prefix?: string;
        /**
         * Default: None
         *
         * Ending port
         */
        port_range_max?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: None
         *
         * Starting port
         */
        port_range_min?: string;
        /**
         * Default: IPv4
         *
         * Must be IPv4 or IPv6, and addresses represented in CIDR must match the ingress or egress rules. Not all providers support IPv6.
         */
        ethertype?: string;
        /**
         * Name or ID of the security group
         */
        security_group?: string;
        /**
         * Name or ID of the Security group to link (exclusive with remote_ip_prefix)
         */
        remote_group?: string;
        [k: string]: unknown;
      };
      /**
       * Get facts for one storage account or all storage accounts within a resource group.
       */
      azure_rm_storageaccount_facts?: {
        profile?: string;
        cli_default_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Only show results for a specific account.
         */
        name?: string;
        /**
         * Limit results to a resource group. Required when filtering by name.
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        secret?: string;
        client_id?: string;
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Provides functionality similar to the "docker login" command.
       * Authenticate with a docker registry and add the credentials to your local Docker config file. Adding the credentials to the config files allows future connections to the registry using tools such as Ansible's Docker modules, the Docker CLI and docker-py without needing to provide credentials.
       * Running in check mode will perform the authentication without updating the config file.
       */
      docker_login?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Return basic facts pertaining to a vSphere virtual machine guest
       */
      vmware_vm_facts?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * When the user does not exists in Gitlab, it will be created.
       * When the user does exists and state=absent, the user will be deleted.
       * When changes are made to user, the user will be updated.
       */
      gitlab_user?: {
        [k: string]: unknown;
      };
      /**
       * Manages Cisco Ethernet Virtual Private Network (EVPN) VXLAN Network Identifier (VNI) configurations of a Nexus device.
       */
      nxos_evpn_vni?: {
        /**
         * Enables/Disables route-target settings for both import and export target communities using a single property.
         */
        route_target_both?: string;
        /**
         * The EVPN VXLAN Network Identifier.
         */
        vni?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: string;
        /**
         * The VPN Route Distinguisher (RD). The RD is combined with the IPv4 or IPv6 prefix learned by the PE router to create a globally unique address.
         */
        route_distinguisher?: string;
        /**
         * Sets the route-target 'import' extended communities.
         */
        route_target_import?: string;
        /**
         * Sets the route-target 'import' extended communities.
         */
        route_target_export?: string;
        [k: string]: unknown;
      };
      /**
       * Start, restart, stop and destroy routers.
       * C(state=present) is not able to create routers, use M(cs_network) instead.
       */
      cs_router?: {
        /**
         * Account the router is related to.
         */
        account?: string;
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Name of the project the router is related to.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the router.
         */
        state?: "present" | "absent" | "started" | "stopped" | "restarted";
        /**
         * Domain the router is related to.
         */
        domain?: string;
        /**
         * Name or id of the service offering of the router.
         */
        service_offering?: string;
        api_key?: string;
        /**
         * Name of the router.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manage OpenStack Identity Roles.
       */
      os_keystone_role?: {
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Role Name
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Create VMware vSphere Cluster
       */
      vmware_cluster?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Gather facts about ec2 instances in AWS
       */
      ec2_remote_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or Remove key pair from OpenStack
       */
      os_keypair?: {
        /**
         * Default: None
         *
         * The public key that would be uploaded to nova and injected into VMs upon creation.
         */
        public_key?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: None
         *
         * Path to local file containing ssh public key. Mutually exclusive with public_key.
         */
        public_key_file?: string;
        /**
         * Default: None
         *
         * Name that has to be given to the key pair
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Add/remove subnet from a network
       */
      quantum_subnet?: {
        /**
         * Default: None
         *
         * Name of the region
         */
        region_name?: string;
        /**
         * Default: True
         *
         * Whether DHCP should be enabled for this subnet.
         */
        enable_dhcp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        availability_zone?: string;
        /**
         * Default: None
         *
         * The name of the tenant for whom the subnet should be created
         */
        tenant_name?: string;
        /**
         * Default: None
         *
         * DNS nameservers for this subnet, comma-separated
         */
        dns_nameservers?: string;
        /**
         * Default: True
         *
         * The tenant name of the login user
         */
        login_tenant_name?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: "present" | "absent";
        /**
         * Default: None
         *
         * From the subnet pool the starting address from which the IP should be allocated
         */
        allocation_pool_start?: string;
        /**
         * Default: http://127.0.0.1:35357/v2.0/
         *
         * The keystone URL for authentication
         */
        auth_url?: string;
        /**
         * Default: True
         *
         * Password of login user
         */
        login_password: string;
        /**
         * Default: admin
         *
         * login username to authenticate to keystone
         */
        login_username?: string;
        /**
         * Default: None
         *
         * The ip that would be assigned to the gateway for this subnet
         */
        gateway_ip?: string;
        /**
         * Default: None
         *
         * The CIDR representation of the subnet that should be assigned to the subnet
         */
        cidr: string;
        /**
         * Default: None
         *
         * Name of the network to which the subnet should be attached
         */
        network_name: string;
        /**
         * Default: 4
         *
         * The IP version of the subnet 4 or 6
         */
        ip_version?: "4" | "6";
        /**
         * Default: None
         *
         * From the subnet pool the last IP that should be assigned to the virtual machines
         */
        allocation_pool_end?: string;
        /**
         * Default: None
         *
         * The name of the subnet that should be created
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 VPC route tables in AWS
       */
      ec2_vpc_route_table_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Arista EOS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with eos configuration sections in a deterministic way.  This module works with either CLI or eAPI transports.
       */
      eos_config?: {
        /**
         * The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.
         */
        src?: string;
        /**
         * The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.
         * Note this argument should be considered deprecated.  To achieve the equivalent, set the C(match=none) which is idempotent.  This argument will be removed in a future release.
         */
        force?: string;
        /**
         * The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
         */
        config?: string;
        /**
         * The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
         */
        after?: string;
        /**
         * The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
         */
        lines?: string;
        /**
         * Default: line
         *
         * Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct.
         */
        replace?: string;
        /**
         * The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
         */
        parents?: string;
        /**
         * The I(defaults) argument will influence how the running-config is collected from the device.  When the value is set to true, the command used to collect the running-config is append with the all keyword.  When the value is set to false, the command is issued without the all keyword
         */
        defaults?: string;
        /**
         * The C(save) argument instructs the module to save the running-config to startup-config.  This operation is performed after any changes are made to the current running config.  If no changes are made, the configuration is still saved to the startup config.  This option will always cause the module to return changed.
         */
        save?: string;
        /**
         * This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.
         */
        backup?: string;
        /**
         * Default: line
         *
         * Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device.
         */
        match?: string;
        /**
         * The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
         */
        before?: string;
        [k: string]: unknown;
      };
      /**
       * Manages network device configurations over SSH or eAPI.  This module allows implementers to work with the device running-config.  It provides a way to push a set of commands onto a network device by evaluating the current running-config and only pushing configuration commands that are not already configured.  The config source can be a set of commands or a template.
       */
      eos_template?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        /**
         * The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The path to the config source.  The source can be either a file with config or a template that will be merged during runtime.  By default the task will search for the source file in role or playbook root folder in templates directory.
         */
        src: string;
        /**
         * When this argument is configured true, the module will backup the running-config from the node prior to making any changes. The backup file will be written to backup_{{ hostname }} in the root of the playbook directory.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        auth_pass?: string;
        /**
         * This argument will cause the provided configuration to be replaced on the destination node.   The use of the replace argument will always cause the task to set changed to true and will implies C(force=true).  This argument is only valid with C(transport=eapi).
         */
        replace?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * By default when the M(eos_template) connects to the remote device to retrieve the configuration it will issue the C(show running-config) command.  If this option is set to True then the issued command will be C(show running-config all).
         */
        include_defaults?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
         */
        config?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * The M(known_hosts) module lets you add or remove a host keys from the C(known_hosts) file.
       * Starting at Ansible 2.2, multiple entries per host are allowed, but only one for each key type supported by ssh. This is useful if you're going to want to use the M(git) module over ssh, for example.
       * If you have a very large number of host keys to manage, you will find the M(template) module more useful.
       */
      known_hosts?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Creates a Virtual Network Identifier member (VNI) for an NVE overlay interface.
       */
      nxos_vxlan_vtep_vni?: {
        /**
         * Specify to save the running configuration after module operations.
         */
        save?: string;
        /**
         * This attribute is used to identify and separate processing VNIs that are associated with a VRF and used for routing. The VRF and VNI specified with this command must match the configuration of the VNI under the VRF.
         */
        assoc_vrf?: string;
        /**
         * Default: True
         *
         * Specify to use or not the complete running configuration for module operations.
         */
        include_defaults?: string;
        /**
         * ID of the Virtual Network Identifier.
         */
        vni?: string;
        /**
         * The multicast group (range) of the VNI. Valid values are string and keyword 'default'.
         */
        multicast_group?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: string;
        /**
         * Set the ingress-replication static peer list. Valid values are an array, a space-separated string of ip addresses, or the keyword 'default'.
         */
        peer_list?: string;
        /**
         * Interface name for the VXLAN Network Virtualization Endpoint.
         */
        interface?: string;
        /**
         * Specifies mechanism for host reachability advertisement.
         */
        ingress_replication?: string;
        /**
         * Suppress arp under layer 2 VNI.
         */
        suppress_arp?: string;
        /**
         * Configuration string to be used for module operations. If not specified, the module will use the current running configuration.
         */
        config?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts for a device using SNMP, the facts will be inserted to the ansible_facts key.
       */
      snmp_facts?: {
        /**
         * Username for SNMPv3, required if version is v3
         */
        username?: string;
        /**
         * Encryption algoritm, required if level is authPriv
         */
        privacy?: "des" | "aes";
        /**
         * Authentication level, required if version is v3
         */
        level?: "authPriv" | "authNoPriv";
        /**
         * The SNMP community string, required if version is v2/v2c
         */
        community?: string;
        /**
         * Authentication key, required if version is v3
         */
        authkey?: string;
        /**
         * Set to target snmp server (normally {{inventory_hostname}})
         */
        host: string;
        /**
         * SNMP Version to use, v2/v2c or v3
         */
        version: "v2" | "v2c" | "v3";
        /**
         * Hashing algoritm, required if version is v3
         */
        integrity?: "md5" | "sha";
        removeplaceholder?: string;
        /**
         * Encryption key, required if version is authPriv
         */
        privkey?: string;
        [k: string]: unknown;
      };
      /**
       * Manage OpenStack Identity Groups. Groups can be created, deleted or updated. Only the I(description) value can be updated.
       */
      os_group?: {
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Group name
         */
        name?: string;
        /**
         * Default: None
         *
         * Group description
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Deploy, start, update, scale, restart, restore, stop and destroy instances.
       */
      cs_instance?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Get DLL or EXE file build version
       * change state alway be false
       */
      win_file_version?: {
        /**
         * File to get version(provide absolute path)
         */
        path?: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to a Dell OS6 node and returns the results read from the device. The M(dellos6_command) module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(dellos6_config) to configure Dell OS6 devices.
       */
      dellos6_command?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        /**
         * List of commands to send to the remote dellos6 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) as expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ssh_keyfile?: string;
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should be tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        password?: string;
        auth_pass?: string;
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        host: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Downloads files from HTTP, HTTPS, or FTP to the remote server. The remote server I(must) have direct access to the remote resource.
       * By default, if an environment variable C(<protocol>_proxy) is set on the target host, requests will be sent through that proxy. This behaviour can be overridden by setting a variable for this task (see `setting the environment <http://docs.ansible.com/playbooks_environment.html>`_), or by using the use_proxy option.
       * HTTP redirects can redirect from HTTP to HTTPS so you should be sure that your proxy environment for both protocols is correct.
       */
      get_url?: {
        [k: string]: unknown;
      };
      /**
       * Creates, removes and lists tags from any EC2 resource.  The resource is referenced by its resource id (e.g. an instance being i-XXXXXXX). It is designed to be used with complex args (tags), see the examples.  This module has a dependency on python-boto.
       */
      ec2_tag?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates, modifies, and deletes RDS database subnet groups. This module has a dependency on python-boto >= 2.5.
       */
      rds_subnet_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module works like M(copy), but in reverse. It is used for fetching files from remote machines and storing them locally in a file tree, organized by hostname. Note that this module is written to transfer log files that might not be present, so a missing remote file won't be an error unless fail_on_missing is set to 'yes'.
       */
      fetch?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module sends push notifications via Pushbullet to channels or devices.
       */
      pushbullet?: {
        /**
         * Body of the notification, e.g. Details of the fault you're alerting.
         */
        body?: string;
        /**
         * Title of the notification.
         */
        title: string;
        url?: string;
        /**
         * Default: note
         *
         * Thing you wish to push.
         */
        push_type?: "note" | "link";
        /**
         * The device NAME you wish to send a push notification, as seen on the Pushbullet main page.
         */
        device?: string;
        /**
         * Push bullet API token
         */
        api_key: string;
        /**
         * The channel TAG you wish to broadcast a push notification, as seen on the "My Channels" > "Edit your channel" at Pushbullet page.
         */
        channel?: string;
        [k: string]: unknown;
      };
      /**
       * Fetch metadata about Github Releases
       */
      github_release?: {
        /**
         * Action to perform
         */
        action: "latest_release";
        /**
         * Repository name
         */
        repo: string;
        /**
         * Github Personal Access Token for authenticating
         */
        token: string;
        /**
         * The GitHub account that owns the repository
         */
        user: string;
        [k: string]: unknown;
      };
      /**
       * Creates or deletes ec2 images.
       */
      ec2_ami?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates or deletes CloudTrail configuration. Ensures logging is also enabled.
       */
      cloudtrail?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create and delete snapshots images on volume groups for NetApp E-series storage arrays.
       */
      netapp_e_volume_copy?: {
        status: "present" | "absent";
        /**
         * Default: True
         *
         * Defines if a copy pair will be created if it does not exist.
         * If set to True destination_volume_id and source_volume_id are required.
         */
        create_copy_pair_if_does_not_exist?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Searches for all valid potential target and source volumes that could be used in a copy_pair
         * Mutually exclusive with volume_copy_pair_id, destination_volume_id and source_volume_id
         */
        search_volume_id?: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * The the id of a given volume copy pair
         * Mutually exclusive with destination_volume_id, source_volume_id, and search_volume_id
         * Can use to delete or check presence of volume pairs
         * Must specify this or (destination_volume_id and source_volume_id)
         */
        volume_copy_pair_id?: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password?: string;
        /**
         * The the id of the volume copy source.
         * If used, must be paired with destination_volume_id
         * Mutually exclusive with volume_copy_pair_id, and search_volume_id
         */
        source_volume_id?: string;
        /**
         * The the id of the volume copy destination.
         * If used, must be paired with source_volume_id
         * Mutually exclusive with volume_copy_pair_id, and search_volume_id
         */
        destination_volume_id?: string;
        copy_priority?: number | string;
        onlineCopy?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username?: string;
        /**
         * starts a re-copy or stops a copy in progress
         * Note: If you stop the initial file copy before it it done the copy pair will be destroyed
         * Requires volume_copy_pair_id
         */
        start_stop_copy?: "start" | "stop";
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?: string;
        targetWriteProtected?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ssid: string;
        [k: string]: unknown;
      };
      /**
       * Create or Remove Ironic nodes from OpenStack.
       */
      os_ironic?: {
        /**
         * Default: None
         *
         * globally unique identifier (UUID) to be given to the resource. Will be auto-generated if not specified, and name is specified.
         * Definition of a UUID will always take precedence to a name value.
         */
        uuid?: string;
        /**
         * Information for this server's driver. Will vary based on which driver is in use. Any sub-field which is populated will be validated during creation.
         */
        driver_info?: string;
        /**
         * A list of network interface cards, eg, " - mac: aa:bb:cc:aa:bb:cc"
         */
        nics?: string;
        /**
         * Default: None
         *
         * The name of the Ironic Driver to use with this node.
         */
        driver?: string;
        /**
         * Default: None
         *
         * If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.
         */
        ironic_url?: string;
        /**
         * Default: present
         *
         * Indicates desired state of the resource
         */
        state?: string;
        /**
         * Default: None
         *
         * Associate the node with a pre-defined chassis.
         */
        chassis_uuid?: string;
        /**
         * Allows the code that would assert changes to nodes to skip the update if the change is a single line consisting of the password field.  As of Kilo, by default, passwords are always masked to API requests, which means the logic as a result always attempts to re-assert the password field.
         */
        skip_update_of_driver_password?: string;
        /**
         * Definition of the physical characteristics of this server, used for scheduling purposes
         */
        properties?: string;
        /**
         * Default: None
         *
         * unique name identifier to be given to the resource.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module will search a file for a line, and ensure that it is present or absent.
       * This is primarily useful when you want to change a single line in a file only. See the M(replace) module if you want to change multiple, similar lines or check M(blockinfile) if you want to insert/update/remove a block of lines in a file. For other cases, see the M(copy) or M(template) modules.
       */
      lineinfile?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * This module can create and destroy Google Compute Engine networks and firewall rules U(https://developers.google.com/compute/docs/networking). The I(name) parameter is reserved for referencing a network while the I(fwname) parameter is used to reference firewall rules. IPv4 Address ranges must be specified using the CIDR U(http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) format. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.
       */
      gce_net?: {
        /**
         * the source instance tags for creating a firewall rule
         */
        src_tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * region of subnet to create
         */
        subnet_region?: string;
        /**
         * name of the network
         */
        name?: string;
        /**
         * Default: present
         *
         * desired state of the network or firewall
         */
        state?: string;
        /**
         * the source IPv4 address range in CIDR notation
         */
        src_range?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * path to the JSON file associated with the service account email
         */
        credentials_file?: string;
        /**
         * the IPv4 address range in CIDR notation for the network this parameter is not mandatory when you specified existing network in name parameter, but when you create new network, this parameter is mandatory
         */
        ipv4_range?: string;
        /**
         * name of the firewall rule
         */
        fwname?: string;
        /**
         * path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
         */
        pem_file?: string;
        /**
         * the target instance tags for creating a firewall rule
         */
        target_tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * name of subnet to create
         */
        subnet_name?: string;
        /**
         * Default: legacy
         *
         * network mode for Google Cloud "legacy" indicates a network with an IP address range "auto" automatically generates subnetworks in different regions "custom" uses networks to group subnets of user specified IP address ranges https://cloud.google.com/compute/docs/networking#network_types
         */
        mode?: "legacy" | "auto" | "custom";
        /**
         * the protocol:ports to allow ('tcp:80' or 'tcp:80,443' or 'tcp:80-800;udp:1-25') this parameter is mandatory when creating or updating a firewall rule
         */
        allowed?: string;
        /**
         * service account email
         */
        service_account_email?: string;
        /**
         * your GCE project ID
         */
        project_id?: string;
        /**
         * description of subnet to create
         */
        subnet_desc?: string;
        [k: string]: unknown;
      };
      /**
       * Management of LXD containers
       */
      lxd_container?: {
        description?: string;
        /**
         * The source for the container (e.g. { "type": "image", "mode": "pull", "server": "https://images.linuxcontainers.org", "protocol": "lxd", "alias": "ubuntu/xenial/amd64" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
         */
        source?: {
          [k: string]: unknown;
        };
        /**
         * Default: unix:/var/lib/lxd/unix.socket
         *
         * The unix domain socket path or the https URL for the LXD server.
         */
        url?: string;
        /**
         * The config for the container (e.g. {"limits.cpu": "2"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
         * If the container already exists and its "config" value in metadata obtained from GET /1.0/containers/<name> U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#10containersname) are different, they this module tries to apply the configurations.
         * The key starts with 'volatile.' are ignored for this comparison.
         * Not all config values are supported to apply the existing container. Maybe you need to delete and recreate a container.
         */
        config?: {
          [k: string]: unknown;
        };
        /**
         * Default: "{}/.config/lxc/client.crt" .format(os.environ["HOME"])
         *
         * The client certificate file path.
         */
        cert_file?: string;
        /**
         * Whether or not the container is ephemeral (e.g. true or false). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
         */
        ephemeral?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The archiecture for the container (e.g. "x86_64" or "i686"). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
         */
        architecture?: string;
        /**
         * The devices for the container (e.g. { "rootfs": { "path": "/dev/kvm", "type": "unix-char" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)
         */
        devices?: {
          [k: string]: unknown;
        };
        /**
         * If this is true, the M(lxd_container) waits until IPv4 addresses are set to the all network interfaces in the container after starting or restarting.
         */
        wait_for_ipv4_addresses?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: started
         *
         * Define the state of a container.
         */
        state?: "started" | "stopped" | "restarted" | "absent" | "frozen";
        profiles?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 30
         *
         * A timeout for changing the state of the container.
         * This is also used as a timeout for waiting until IPv4 addresses are set to the all network interfaces in the container after starting or restarting.
         */
        timeout?: number | string;
        /**
         * Default: "{}/.config/lxc/client.key" .format(os.environ["HOME"])
         *
         * The client certificate key file path.
         */
        key_file?: string;
        /**
         * The client trusted password.
         * You need to set this password on the LXD server before running this module using the following command. lxc config set core.trust_password <some random password> See U(https://www.stgraber.org/2016/04/18/lxd-api-direct-interaction/)
         * If trust_password is set, this module send a request for authentication before sending any requests.
         */
        trust_password?: string;
        /**
         * If this is true, the M(lxd_container) forces to stop the container when it stops or restarts the container.
         */
        force_stop?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of a container.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module allows you to work with access-lists on a Cisco ASA device.
       */
      asa_acl?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manages packages with I(apt-rpm). Both low-level (I(rpm)) and high-level (I(apt-get)) package manager binaries required.
       */
      apt_rpm?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Manage logging facility of an s3 bucket in AWS
       */
      s3_logging?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create and remove tag(s) to DigitalOcean resource.
       */
      digital_ocean_tag?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages VRRP configuration on NX-OS switches.
       */
      nxos_vrrp?: {
        /**
         * VRRP group number.
         */
        group?: string;
        /**
         * VRRP virtual IP address.
         */
        vip?: string;
        /**
         * Clear text authentication string.
         */
        authentication?: string;
        /**
         * VRRP priority.
         */
        priority?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: string;
        /**
         * Default: no shutdown
         *
         * Used to enable or disable the VRRP process.
         */
        admin_state?: string;
        /**
         * Full name of interface that is being managed for VRRP.
         */
        interface?: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to a Dell OS10 node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(dellos10_config) to configure Dell OS10 devices.
       */
      dellos10_command?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        /**
         * List of commands to send to the remote dellos10 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ssh_keyfile?: string;
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        password?: string;
        auth_pass?: string;
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        host: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Creates or terminates Google Compute Engine (GCE) instances.  See U(https://cloud.google.com/products/compute-engine) for an overview. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.
       */
      gce?: {
        /**
         * a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).
         */
        disks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * identifier when working with a single instance
         */
        name?: string;
        /**
         * Default: us-central1-a
         *
         * the GCE zone to use
         */
        zone?: string;
        /**
         * Default: false
         *
         * set to true if the instance can forward ip packets (useful for gateways)
         */
        ip_forward?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: ephemeral
         *
         * type of external ip, ephemeral by default; alternatively, a list of fixed gce ips or ip names can be given (if there is not enough specified ip, 'ephemeral' will be used). Specify 'none' if no external ip is desired.
         */
        external_ip?: string;
        /**
         * service account email
         */
        service_account_email?: string;
        /**
         * Default: false
         *
         * if set to true, instances will be preemptible and time-limited. (requires libcloud >= 0.20.0)
         */
        preemptible?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * service account permissions (see U(https://cloud.google.com/sdk/gcloud/reference/compute/instances/create), --scopes section for detailed information)
         */
        service_account_permissions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * a hash/dictionary of custom data for the instance; '{"key":"value", ...}'
         */
        metadata?: string;
        /**
         * Default: false
         *
         * if set, create the instance with a persistent boot disk
         */
        persistent_boot_disk?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
         */
        pem_file?: string;
        /**
         * your GCE project ID
         */
        project_id?: string;
        /**
         * Default: present
         *
         * desired state of the resource
         */
        state?: "active" | "present" | "absent" | "deleted" | "started" | "stopped" | "terminated";
        /**
         * Default: n1-standard-1
         *
         * machine type to use for the instance, use 'n1-standard-1' by default
         */
        machine_type?: string;
        /**
         * path to the JSON file associated with the service account email
         */
        credentials_file?: string;
        /**
         * name of the subnetwork in which the instance should be created
         */
        subnetwork?: string;
        /**
         * Default: true
         *
         * if set boot disk will be removed after instance destruction
         */
        disk_auto_delete?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: debian-7
         *
         * image string to use for the instance
         */
        image?: string;
        /**
         * a comma-separated list of instance names to create or destroy
         */
        instance_names?: string;
        /**
         * a comma-separated list of tags to associate with the instance
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: default
         *
         * name of the network, 'default' will be used if not specified
         */
        network?: string;
        [k: string]: unknown;
      };
      /**
       * Manages configuration of an Protocol Independent Multicast (PIM) static rendezvous point (RP) address instance.
       */
      nxos_pim_rp_address?: {
        /**
         * Route map policy for static RP. Valid values are route-map policy names.
         */
        route_map?: string;
        /**
         * Prefix list policy for static RP. Valid values are prefix-list policy names.
         */
        prefix_list?: string;
        /**
         * Configures a Protocol Independent Multicast (PIM) static rendezvous point (RP) address. Valid values are unicast addresses.
         */
        rp_address?: string;
        /**
         * Group range for static RP. Valid values are multicast addresses.
         */
        group_list?: string;
        /**
         * Group range is treated in PIM bidirectional mode.
         */
        bidir?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows the user to manage S3 buckets and the objects within them. Includes support for creating and deleting both objects and buckets, retrieving objects as files or strings and generating download links. This module has a dependency on python-boto.
       */
      s3?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages Gentoo packages
       */
      portage?: {
        [k: string]: unknown;
      };
      /**
       * The standard package manager for SmartOS, but also usable on NetBSD or any OS that uses C(pkgsrc).  (Home: U(http://pkgin.net/))
       */
      pkgin?: {
        [k: string]: unknown;
      };
      /**
       * A trivial test module, this module always returns C(pong) on successful contact. It does not make sense in playbooks, but it is useful from C(/usr/bin/ansible) to verify the ability to login and that a usable python is configured.
       * This is NOT ICMP ping, this is just a trivial test module.
       */
      ping?: {
        data?: string;
        [k: string]: unknown;
      };
      /**
       * Execute cluster-create or cluster-delete command.
       * A cluster allows two switches to cooperate in high-availability (HA) deployments. The nodes that form the cluster must be members of the same fabric. Clusters are typically used in conjunction with a virtual link aggregation group (VLAG) that allows links physically connected to two separate switches appear as a single trunk to a third device. The third device can be a switch,server, or any Ethernet device.
       */
      pn_cluster?: {
        /**
         * Specify the name of the cluster.
         */
        pn_name: string;
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Validate the inter-switch links and state of switches in the cluster.
         */
        pn_validate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify action to perform. Use 'present' to create cluster and 'absent' to delete cluster.
         */
        state: "present" | "absent";
        /**
         * Target switch to run the cli on.
         */
        pn_cliswitch?: string;
        /**
         * Specify the name of the first switch in the cluster.
         * Required for 'cluster-create'.
         */
        pn_cluster_node1?: string;
        /**
         * Specify the name of the second switch in the cluster.
         * Required for 'cluster-create'.
         */
        pn_cluster_node2?: string;
        [k: string]: unknown;
      };
      /**
       * Creates and deletes Route53 private and public zones
       */
      route53_zone?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or remove disk groups and disk pools for NetApp E-series storage arrays.
       */
      netapp_e_storagepool?: {
        /**
         * Default: gb
         *
         * The unit used to interpret size parameters
         */
        criteria_size_unit?: string;
        /**
         * Whether full disk encryption ability is required for drives to be added to the storage pool
         */
        criteria_drive_require_fde?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The minimum size of the storage pool (in size_unit). The pool will be expanded if this value exceeds itscurrent size.
         */
        criteria_min_usable_capacity?: number | string;
        /**
         * The ID of the array to manage (as configured on the web services proxy).
         */
        ssid: string;
        log_path?: string;
        remove_drives?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Whether to convert to a secure storage pool. Will only work if all drives in the pool are security capable.
         */
        secure_pool?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * Only required when the requested state is 'present'.  The RAID level of the storage pool to be created.
         */
        raid_level?: "raidUnsupported" | "raidAll" | "raid0" | "raid1" | "raid3" | "raid5" | "raid6" | "raidDiskPool";
        /**
         * The minimum individual drive size (in size_unit) to consider when choosing drives for the storage pool.
         */
        criteria_drive_min_size?: number | string;
        /**
         * The name of the storage pool to manage
         */
        name: string;
        /**
         * Whether the specified storage pool should exist or not.
         * Note that removing a storage pool currently requires the removal of all defined volumes first.
         */
        state: "present" | "absent";
        /**
         * Prior to removing a storage pool, delete all volumes in the pool.
         */
        remove_volumes?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The type of disk (hdd or ssd) to use when searching for candidates to use.
         */
        criteria_drive_type?: "hdd" | "ssd";
        /**
         * The number of disks to use for building the storage pool. The pool will be expanded if this number exceeds the number of disks already in place
         */
        criteria_drive_count?: number | string;
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * Whether to erase secured disks before adding to storage pool
         */
        erase_secured_drives?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The interface type to use when selecting drives for the storage pool (no value means all interface types will be considered)
         */
        criteria_drive_interface_type?: "sas" | "sas4k" | "fibre" | "fibre520b" | "scsi" | "sata" | "pata";
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set the number of drives reserved by the storage pool for reconstruction operations. Only valide on raid disk pools.
         */
        reserve_drive_count?: number | string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        [k: string]: unknown;
      };
      /**
       * Create and remove security groups.
       */
      cs_securitygroup?: {
        /**
         * Domain the security group is related to.
         */
        domain?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        /**
         * Description of the security group.
         */
        description?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Name of the project the security group to be created in.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the security group.
         */
        state?: "present" | "absent";
        /**
         * Account the security group is related to.
         */
        account?: string;
        api_key?: string;
        /**
         * Name of the security group.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Collect facts from F5 BIG-IP devices via iControl SOAP API
       */
      bigip_facts?: {
        /**
         * Shell-style glob matching string used to filter fact keys. Not applicable for software, provision, and system_info fact categories.
         */
        filter?: string;
        /**
         * Fact category or list of categories to collect
         */
        include?: string;
        /**
         * Default: True
         *
         * BIG-IP session support; may be useful to avoid concurrency issues in certain circumstances.
         */
        session?: string;
        [k: string]: unknown;
      };
      /**
       * Manage an AWS customer gateway
       */
      ec2_customer_gateway?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module gets the status of an asynchronous task.
       */
      async_status?: {
        /**
         * Job or task identifier
         */
        jid: string;
        /**
         * Default: status
         *
         * if C(status), obtain the status; if C(cleanup), clean up the async job cache located in C(~/.ansible_async/) for the specified job I(jid).
         */
        mode?: "status" | "cleanup";
        [k: string]: unknown;
      };
      /**
       * Manage node.js packages with Node Package Manager (npm)
       */
      npm?: {
        /**
         * The executable location for npm.
         * This is useful if you are using a version manager, such as nvm
         */
        executable?: string;
        /**
         * The name of a node.js library to install
         */
        name?: string;
        /**
         * Install the node.js library globally
         */
        global?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Use the --ignore-scripts flag when installing.
         */
        ignore_scripts?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * The state of the node.js library
         */
        state?: "present" | "absent" | "latest";
        /**
         * Install dependencies in production mode, excluding devDependencies
         */
        production?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The registry to install modules from.
         */
        registry?: string;
        /**
         * The version to be installed
         */
        version?: string;
        /**
         * The base path where to install the node.js libraries
         */
        path?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows setting new variables.  Variables are set on a host-by-host basis just like facts discovered by the setup module.
       * These variables will be available to subsequent plays during an ansible-playbook run, but will not be saved across executions even if you use a fact cache.
       */
      set_fact?: {
        /**
         * The C(set_fact) module takes key=value pairs as variables to set in the playbook scope. Or alternatively, accepts complex arguments using the C(args:) statement.
         */
        key_value?: string;
        [k: string]: unknown;
      };
      /**
       * Configure the VMkernel IP Address
       */
      vmware_vmkernel_ip_config?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Notify newrelic about app deployments (see https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/deployment-notifications#api)
       */
      newrelic_deployment?: {
        /**
         * (one of app_name or application_id are required) The application id, found in the URL when viewing the application in RPM
         */
        application_id?: string;
        /**
         * Text annotation for the deployment - notes for you
         */
        description?: string;
        /**
         * A list of changes for this deployment
         */
        changelog?: string;
        /**
         * Name of the application
         */
        appname?: string;
        /**
         * The environment for this deployment
         */
        environment?: string;
        /**
         * API token, to place in the x-api-key header.
         */
        token: string;
        /**
         * The name of the user/process that triggered this deployment
         */
        user?: string;
        /**
         * (one of app_name or application_id are required) The value of app_name in the newrelic.yml file used by the application
         */
        app_name?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A revision number (e.g., git commit SHA)
         */
        revision?: string;
        [k: string]: unknown;
      };
      /**
       * This module provides an abstraction that enables and configures the netconf system service running on Junos devices.  This module can be used to easily enable the Netconf API. Netconf provides a programmatic interface for working with configuration and state resources as defined in RFC 6242.
       */
      junos_netconf?: {
        [k: string]: unknown;
      };
      /**
       * Manages IGMP snooping global configuration.
       */
      nxos_igmp_snooping?: {
        /**
         * Global link-local groups suppression.
         */
        link_local_grp_supp?: string;
        /**
         * Global IGMPv1/IGMPv2 Report Suppression.
         */
        report_supp?: string;
        /**
         * Enables/disables IGMP snooping on the switch.
         */
        snooping?: string;
        /**
         * Group membership timeout value for all VLANs on the device. Accepted values are integer in range 1-10080, I(never) and I(default).
         */
        group_timeout?: string;
        /**
         * Global IGMPv3 Report Suppression and Proxy Reporting.
         */
        v3_report_supp?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * The M(sns) module sends notifications to a topic on your Amazon SNS account
       */
      sns?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Attach or Detach volumes from OpenStack VM's
       */
      os_server_volume?: {
        /**
         * Name or id of volume you want to attach to a server
         */
        volume?: string;
        /**
         * Default: None
         *
         * Device you want to attach. Defaults to auto finding a device name.
         */
        device?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Name or ID of server you want to attach a volume to
         */
        server?: string;
        [k: string]: unknown;
      };
      /**
       * This module will import/delete SSL certificates on BIG-IP LTM. Certificates can be imported from certificate and key files on the local disk, in PEM format.
       */
      bigip_ssl_certificate?: {
        /**
         * SSL Certificate Name.  This is the cert/key pair name used when importing a certificate/key into the F5. It also determines the filenames of the objects on the LTM (:Partition:name.cer_11111_1 and :Partition_name.key_11111_1).
         */
        name?: string;
        /**
         * When used instead of 'cert_src', sets the contents of a certificate directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).
         */
        cert_content?: string;
        /**
         * Default: Common
         *
         * BIG-IP partition to use when adding/deleting certificate.
         */
        partition?: string;
        /**
         * This is the local filename of the certificate. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).
         */
        cert_src?: string;
        /**
         * Default: present
         *
         * Certificate and key state. This determines if the provided certificate and key is to be made C(present) on the device or C(absent).
         */
        state?: string;
        /**
         * Passphrase on certificate private key
         */
        passphrase?: string;
        /**
         * When used instead of 'key_src', sets the contents of a certificate key directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).
         */
        key_content?: string;
        /**
         * This is the local filename of the private key. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).
         */
        key_src?: string;
        [k: string]: unknown;
      };
      /**
       * Create or Delete objects and containers from OpenStack
       */
      os_object?: {
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * The name of the container in which to create the object
         */
        container?: string;
        /**
         * Name to be give to the object. If omitted, operations will be on the entire container
         */
        name?: string;
        /**
         * Default: private
         *
         * desired container access level.
         */
        container_access?: string;
        /**
         * Path to local file to be uploaded.
         */
        filename?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows to manage posix users on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
       */
      udm_user?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manage cache clusters in Amazon Elasticache.
       * Returns information about the specified cache cluster.
       */
      elasticache?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Module searches Amazon EFS file systems
       */
      efs_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Build, load or pull an image, making the image available for creating containers. Also supports tagging an image into a repository and archiving an image to a .tar file.
       */
      docker_image?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and delete a resource group.
       */
      azure_rm_resourcegroup?: {
        profile?: string;
        cli_default_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Remove a resource group and all associated resources. Use with state 'absent' to delete a resource group that contains resources.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the resource group.
         */
        name: string;
        tags?: {
          [k: string]: unknown;
        };
        ad_user?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        cloud_environment?: string;
        secret?: string;
        /**
         * Default: present
         *
         * Assert the state of the resource group. Use 'present' to create or update and 'absent' to delete. When 'absent' a resource group containing resources will not be removed unless the force option is used.
         */
        state?: "absent" | "present";
        /**
         * Azure location for the resource group. Required when creating a new resource group. Cannot be changed once resource group is created.
         */
        location?: string;
        client_id?: string;
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Manages port-channel specific configuration parameters.
       */
      nxos_portchannel?: {
        /**
         * Channel-group number for the port-channel.
         */
        group?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Default: True
         *
         * Mode for the port-channel, i.e. on, active, passive.
         */
        mode?: string;
        /**
         * List of interfaces that will be managed in a given portchannel.
         */
        members?: string;
        /**
         * Min links required to keep portchannel up.
         */
        min_links?: string;
        /**
         * When true it forces port-channel members to match what is declared in the members param. This can be used to remove members.
         */
        force?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about dhcp options sets in AWS
       */
      ec2_vpc_dhcp_options_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates or removes resource records in Google Cloud DNS.
       */
      gcdns_record?: {
        /**
         * The Google Cloud ID of the zone (e.g., example-com).
         * One of either I(zone) or I(zone_id) must be specified as an option, or the module will fail.
         * These usually take the form of domain names with the dots replaced with dashes. A zone ID will never have any dots in it.
         * I(zone_id) can be faster than I(zone) in projects with a large number of zones.
         * If both I(zone) and I(zone_id) are specifed, I(zone_id) will be used.
         */
        zone_id?: string;
        /**
         * The DNS domain name of the zone (e.g., example.com).
         * One of either I(zone) or I(zone_id) must be specified as an option, or the module will fail.
         * If both I(zone) and I(zone_id) are specifed, I(zone_id) will be used.
         */
        zone?: string;
        /**
         * The record_data to use for the resource record.
         * I(record_data) must be specified if I(state) is C(present) or I(overwrite) is C(True), or the module will fail.
         * Valid record_data vary based on the record's I(type). In addition, resource records that contain a DNS domain name in the value field (e.g., CNAME, PTR, SRV, .etc) MUST include a trailing dot in the value.
         * Individual string record_data for TXT records must be enclosed in double quotes.
         * For resource records that have the same name but different record_data (e.g., multiple A records), they must be defined as multiple list entries in a single record.
         */
        record_data?: string;
        /**
         * The e-mail address for a service account with access to Google Cloud DNS.
         */
        service_account_email?: string;
        /**
         * The path to the JSON file associated with the service account email.
         */
        credentials_file?: string;
        /**
         * The path to the PEM file associated with the service account email.
         * This option is deprecated and may be removed in a future release. Use I(credentials_file) instead.
         */
        pem_file?: string;
        /**
         * The fully-qualified domain name of the resource record.
         */
        record?: string;
        /**
         * Default: present
         *
         * Whether the given resource record should or should not be present.
         */
        state?: string;
        /**
         * Default: 300
         *
         * The amount of time in seconds that a resource record will remain cached by a caching resolver.
         */
        ttl?: string;
        /**
         * The Google Cloud Platform project ID to use.
         */
        project_id?: string;
        /**
         * The type of resource record to add.
         */
        type?: string;
        /**
         * Whether an attempt to overwrite an existing record should succeed or fail. The behavior of this option depends on I(state).
         * If I(state) is C(present) and I(overwrite) is C(True), this module will replace an existing resource record of the same name with the provided I(record_data). If I(state) is C(present) and I(overwrite) is C(False), this module will fail if there is an existing resource record with the same name and type, but different resource data.
         * If I(state) is C(absent) and I(overwrite) is C(True), this module will remove the given resource record unconditionally. If I(state) is C(absent) and I(overwrite) is C(False), this module will fail if the provided record_data do not match exactly with the existing resource record's record_data.
         */
        overwrite?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, or delete OpenStack Identity service. If a service with the supplied name already exists, it will be updated with the new description and enabled attributes.
       */
      os_keystone_service?: {
        /**
         * The type of service
         */
        service_type?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: True
         *
         * Is the service enabled
         */
        enabled?: string;
        /**
         * Name of the service
         */
        name?: string;
        /**
         * Default: None
         *
         * Description of the service
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manages dns records via the Cloudflare API, see the docs: U(https://api.cloudflare.com/)
       */
      cloudflare_dns?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * An Ansible module to deploy blue print package on a set of servers in CenturyLink Cloud.
       */
      clc_blueprint_package?: {
        /**
         * A list of server Ids to deploy the blue print package.
         */
        server_ids:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Whether to install or un-install the package. Currently it supports only "present" for install action.
         */
        state?: "present";
        /**
         * The dictionary of arguments required to deploy the blue print.
         */
        package_params?: {
          [k: string]: unknown;
        };
        /**
         * The package id of the blue print.
         */
        package_id: string;
        /**
         * Default: True
         *
         * Whether to wait for the tasks to finish before returning.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * Adds or removes nat rules from a gateway in a vca environment
       */
      vca_nat?: {
        /**
         * A list of rules to be added to the gateway, Please see examples on valid entries
         */
        nat_rules?: string;
        /**
         * If set to true, it will delete all rules in the gateway that are not given as paramter to this module.
         */
        purge_rules?: string;
        [k: string]: unknown;
      };
      /**
       * Modern SSH clients support ControlPersist which is just as fast as fireball was.  Please enable that in ansible.cfg as a replacement for fireball.
       * Removed in ansible 2.0.
       */
      fireball?: {
        [k: string]: unknown;
      };
      /**
       * Sends an email with a SendGrid account through their API, not through the SMTP service.
       */
      sendgrid?: {
        body: string;
        /**
         * username for logging into the SendGrid account.
         * Since 2.2 it is only required if api_key is not supplied.
         */
        username?: string;
        /**
         * password that corresponds to the username
         * Since 2.2 it is only required if api_key is not supplied.
         */
        password?: string;
        /**
         * the name you want to appear in the from field, i.e 'John Doe'
         */
        from_name?: string;
        /**
         * a list of relative or explicit paths of files you want to attach (7MB limit as per SendGrid docs)
         */
        attachments?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * a list of email addresses to cc
         */
        cc?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * a list of email addresses to bcc
         */
        bcc?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * a dict to pass on as headers
         */
        headers?: {
          [k: string]: unknown;
        };
        /**
         * a list with one or more recipient email addresses
         */
        to_addresses:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * whether the body is html content that should be rendered
         */
        html_body?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * sendgrid API key to use instead of username/password
         */
        api_key?: string;
        /**
         * the address in the "from" field for the email
         */
        from_address: string;
        /**
         * the desired subject for the email
         */
        subject: string;
        [k: string]: unknown;
      };
      /**
       * Create and modify issues in a JIRA instance.
       */
      jira?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Set system's hostname.
       * Currently implemented on Debian, Ubuntu, Fedora, RedHat, openSUSE, Linaro, ScientificLinux, Arch, CentOS, AMI.
       * Any distribution that uses systemd as their init system.
       * Note, this module does *NOT* modify /etc/hosts. You need to modify it yourself using other modules like template or replace.
       */
      hostname?: {
        /**
         * Name of the host
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module manipulates sysctl entries and optionally performs a C(/sbin/sysctl -p) after changing them.
       */
      sysctl?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Cisco NXOS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with NXOS configuration sections in a deterministic way.  This module works with either CLI or NXAPI transports.
       */
      nxos_config?: {
        [k: string]: unknown;
      };
      /**
       * Manages access list entries for ACLs.
       */
      nxos_acl?: {
        /**
         * Sequence number of the entry (ACE).
         */
        seq?: string;
        /**
         * Name of time-range to apply.
         */
        "time-range"?: string;
        /**
         * Destination port operands such as eq, neq, gt, lt, range.
         */
        dest_port_op?: string;
        /**
         * Match established connections.
         */
        established?: string;
        /**
         * Match packets with given precedence.
         */
        precedence?: string;
        /**
         * Port number or protocol (as supported by the switch).
         */
        proto?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: string;
        /**
         * Check non-initial fragments.
         */
        fragments?: string;
        /**
         * Port/protocol and also first (lower) port when using range operand.
         */
        src_port1?: string;
        /**
         * Second (end) port when using range operand.
         */
        src_port2?: string;
        /**
         * Source port operands such as eq, neq, gt, lt, range.
         */
        src_port_op?: string;
        /**
         * Match on the PSH bit.
         */
        psh?: string;
        /**
         * Destination ip and mask using IP/MASK notation and supports the keyword 'any'.
         */
        dest?: string;
        /**
         * Match on the SYN bit.
         */
        syn?: string;
        /**
         * Match packets with given dscp value.
         */
        dscp?: string;
        /**
         * Match on the RST bit.
         */
        rst?: string;
        /**
         * Log matches against this entry.
         */
        log?: string;
        /**
         * Source ip and mask using IP/MASK notation and supports keyword 'any'.
         */
        src?: string;
        /**
         * If action is set to remark, this is the description.
         */
        remark?: string;
        /**
         * Match on the URG bit.
         */
        urg?: string;
        /**
         * Case sensitive name of the access list (ACL).
         */
        name?: string;
        /**
         * Match on the ACK bit.
         */
        ack?: string;
        /**
         * Match on the FIN bit.
         */
        fin?: string;
        /**
         * Action of the ACE.
         */
        action?: string;
        /**
         * Port/protocol and also first (lower) port when using range operand.
         */
        dest_port1?: string;
        /**
         * Second (end) port when using range operand.
         */
        dest_port2?: string;
        [k: string]: unknown;
      };
      /**
       * Create or Remove virtual machines from Openstack.
       */
      nova_compute?: {
        /**
         * Default: None
         *
         * Name of the availability zone
         */
        availability_zone?: string;
        /**
         * Text to use to filter image names, for the case, such as HP, where there are multiple image names matching the common identifying portions. image_exclude is a negative match filter - it is text that may not exist in the image name. Defaults to "(deprecated)"
         */
        image_exclude?: string;
        /**
         * Text to use to filter flavor names, for the case, such as Rackspace, where there are multiple flavors that have the same ram count. flavor_include is a positive match filter - it must exist in the flavor name.
         */
        flavor_include?: string;
        /**
         * Default: None
         *
         * A list of key value pairs that should be provided as a metadata to the new VM
         */
        meta?: {
          [k: string]: unknown;
        };
        /**
         * Default: http://127.0.0.1:35357/v2.0/
         *
         * The keystone url for authentication
         */
        auth_url?: string;
        /**
         * Default: admin
         *
         * login username to authenticate to keystone
         */
        login_username?: string;
        /**
         * Default: 180
         *
         * The amount of time the module should wait for the VM to get into active state
         */
        wait_for?: string;
        /**
         * Default: no
         *
         * Should a floating ip be auto created and assigned
         */
        auto_floating_ip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * Arbitrary key/value pairs to the scheduler for custom use
         */
        scheduler_hints?: {
          [k: string]: unknown;
        };
        /**
         * Default: None
         *
         * A list of network id's to which the VM's interface should be attached
         */
        nics?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: None
         *
         * list of valid floating IPs that pre-exist to assign to this node
         */
        floating_ips?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 1
         *
         * The minimum amount of ram in MB that the flavor in which the new VM has to be created must have. Mutually exclusive with flavor_id
         */
        flavor_ram?: number | string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: "present" | "absent";
        /**
         * Default: None
         *
         * The name of the security group to which the VM should be added
         */
        security_groups?: string;
        /**
         * Default: no
         *
         * Whether to boot the server with config drive enabled
         */
        config_drive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * Name of the region
         */
        region_name?: string;
        /**
         * Default: None
         *
         * The key pair name to be used when creating a VM
         */
        key_name?: string;
        /**
         * Default: None
         *
         * The name of the base image to boot. Mutually exclusive with image_id
         */
        image_name?: string;
        /**
         * Default: None
         *
         * Opaque blob of data which is made available to the instance
         */
        user_data?: string;
        /**
         * Default: None
         *
         * The id of the base image to boot. Mutually exclusive with image_name
         */
        image_id?: string;
        /**
         * Default: yes
         *
         * Password of login user
         */
        login_password: string;
        /**
         * Default: yes
         *
         * If the module should wait for the VM to be created.
         */
        wait?: "yes" | "no";
        /**
         * Default: None
         *
         * Name that has to be given to the instance
         */
        name: string;
        /**
         * Default: yes
         *
         * The tenant name of the login user
         */
        login_tenant_name?: string;
        /**
         * Default: 1
         *
         * The id of the flavor in which the new VM has to be created. Mutually exclusive with flavor_ram
         */
        flavor_id?: string;
        /**
         * Default: None
         *
         * list of floating IP pools from which to choose a floating IP
         */
        floating_ip_pools?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Create and remove domain records.
       */
      exo_dns_domain?: {
        /**
         * Name of the record.
         */
        name: string;
        /**
         * Secret key of the Exoscale DNS API.
         */
        api_secret?: string;
        /**
         * Default: 10
         *
         * HTTP timeout to Exoscale DNS API.
         */
        api_timeout?: number | string;
        /**
         * Default: cloudstack
         *
         * Name of the ini section in the C(cloustack.ini) file.
         */
        api_region?: string;
        /**
         * Default: present
         *
         * State of the resource.
         */
        state?: "present" | "absent";
        /**
         * API key of the Exoscale DNS API.
         */
        api_key?: string;
        /**
         * Default: True
         *
         * Validate SSL certs of the Exoscale DNS API.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Installs packages using Web Platform Installer command-line (http://www.iis.net/learn/install/web-platform-installer/web-platform-installer-v4-command-line-webpicmdexe-rtw-release).
       * Must be installed and present in PATH (see win_chocolatey module; 'webpicmd' is the package name, and you must install 'lessmsi' first too)
       * Install IIS first (see win_feature module)
       */
      win_webpicmd?: {
        /**
         * Name of the package to be installed
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Grant or revoke privileges on PostgreSQL database objects.
       * This module is basically a wrapper around most of the functionality of PostgreSQL's GRANT and REVOKE statements with detection of changes (GRANT/REVOKE I(privs) ON I(type) I(objs) TO/FROM I(roles))
       */
      postgresql_privs?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manages SVR4 packages on Solaris 10 and 11.
       * These were the native packages on Solaris <= 10 and are available as a legacy feature in Solaris 11.
       * Note that this is a very basic packaging system. It will not enforce dependencies on install or remove.
       */
      svr4pkg?: {
        /**
         * Install/Remove category instead of a single package.
         */
        category?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies the location to install the package from. Required when C(state=present).
         * Can be any path acceptable to the C(pkgadd) command's C(-d) option. e.g.: C(somefile.pkg), C(/dir/with/pkgs), C(http:/server/mypkgs.pkg).
         * If using a file or directory, they must already be accessible by the host. See the M(copy) module for a way to get them there.
         */
        src?: string;
        /**
         * Package name, e.g. C(SUNWcsr)
         */
        name: string;
        /**
         * Default: all
         *
         * Whether to install the package only in the current zone, or install it into all zones.
         * The installation into all zones works only if you are working with the global zone.
         */
        zone?: "current" | "all";
        /**
         * Whether to install (C(present)), or remove (C(absent)) a package.
         * If the package is to be installed, then I(src) is required.
         * The SVR4 package system doesn't provide an upgrade operation. You need to uninstall the old, then install the new package.
         */
        state: "present" | "absent";
        /**
         * HTTP[s] proxy to be used if C(src) is a URL.
         */
        proxy?: string;
        /**
         * Specifies the location of a response file to be used if package expects input on install. (added in Ansible 1.4)
         */
        response_file?: string;
        [k: string]: unknown;
      };
      /**
       * Create or Remove cinder block storage volumes
       */
      os_volume?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, remove, start, stop and tune GlusterFS volumes
       */
      gluster_volume?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Controls systemd services on remote hosts.
       */
      systemd?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Create, register and remove SSH keys.
       * If no key was found and no public key was provided and a new SSH private/public key pair will be created and the private key will be returned.
       */
      cs_sshkeypair?: {
        /**
         * String of the public key.
         */
        public_key?: string;
        /**
         * Account the public key is related to.
         */
        account?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Name of the project the public key to be registered in.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the public key.
         */
        state?: "present" | "absent";
        /**
         * Domain the public key is related to.
         */
        domain?: string;
        api_key?: string;
        /**
         * Name of public key.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manage presence of groups on a host.
       */
      group?: {
        /**
         * Default: present
         *
         * Whether the group should be present or not on the remote host.
         */
        state?: "present" | "absent";
        /**
         * Optional I(GID) to set for the group.
         */
        gid?: string;
        /**
         * Default: no
         *
         * If I(yes), indicates that the group created is a system group.
         */
        system?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the group to manage.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create or remove SSD caches on a NetApp E-Series storage array.
       */
      netapp_e_flashcache?: {
        /**
         * The minimum size (in size_units) of the ssd cache. The cache will be expanded if this exceeds the current size of the cache.
         */
        cache_size_min?: number | string;
        /**
         * The name of the SSD cache to manage
         */
        name: string;
        log_path?: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * Default: filesystem
         *
         * The type of workload to optimize the cache for.
         */
        io_type?: "filesystem" | "database" | "media";
        /**
         * The minimum number of disks to use for building the cache. The cache will be expanded if this number exceeds the number of disks already in place
         */
        disk_count?: number | string;
        /**
         * Default: gb
         *
         * The unit to be applied to size arguments
         */
        size_unit?: "bytes" | "b" | "kb" | "mb" | "gb" | "tb" | "pb" | "eb" | "zb" | "yb";
        log_mode?: string;
        /**
         * Default: present
         *
         * Whether the specified SSD cache should exist or not.
         */
        state?: "present" | "absent";
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        disk_refs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        criteria_disk_phy_type?: "sas" | "sas4k" | "fibre" | "fibre520b" | "scsi" | "sata" | "pata";
        /**
         * The ID of the array to manage (as configured on the web services proxy).
         */
        ssid: string;
        [k: string]: unknown;
      };
      /**
       * Manage users,tenants, roles from OpenStack.
       */
      keystone_user?: {
        /**
         * Default: None
         *
         * A description for the tenant
         */
        tenant_description?: string;
        /**
         * Default: http://127.0.0.1:35357/v2.0/
         *
         * The keystone url for authentication
         */
        endpoint?: string;
        region_name?: string;
        availability_zone?: string;
        /**
         * Default: admin
         *
         * login username to authenticate to keystone
         */
        login_user?: string;
        /**
         * Default: None
         *
         * The token to be uses in case the password is not specified
         */
        token?: string;
        /**
         * Default: None
         *
         * The tenant login_user belongs to
         */
        login_tenant_name?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: "present" | "absent";
        /**
         * Default: None
         *
         * The name of the role to be assigned or created
         */
        role?: string;
        /**
         * Default: None
         *
         * The name of the user that has to added/removed from OpenStack
         */
        user?: string;
        /**
         * Default: yes
         *
         * Password of login user
         */
        login_password?: string;
        login_username?: string;
        /**
         * Default: None
         *
         * The password to be assigned to the user
         */
        password?: string;
        /**
         * Default: None
         *
         * An email address for the user
         */
        email?: string;
        /**
         * Default: None
         *
         * The tenant name that has be added/removed
         */
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Manage slb server objects on A10 Networks devices via aXAPI
       */
      a10_server?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Add or remove applications on a Webfaction host.  Further documentation at http://github.com/quentinsf/ansible-webfaction.
       */
      webfaction_app?: {
        /**
         * The name of the application
         */
        name: string;
        /**
         * IF the port should be opened
         */
        port_open?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The machine name to use (optional for accounts with only one machine)
         */
        machine?: string;
        /**
         * Default: present
         *
         * Whether the application should exist
         */
        state?: "present" | "absent";
        /**
         * Default: no
         *
         * Whether the app should restart with an autostart.cgi script
         */
        autostart?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The webfaction password to use
         */
        login_password: string;
        /**
         * The type of application to create. See the Webfaction docs at http://docs.webfaction.com/xmlrpc-api/apps.html for a list.
         */
        type: string;
        /**
         * The webfaction account to use
         */
        login_name: string;
        /**
         * Any extra parameters required by the app
         */
        extra_info?: string;
        [k: string]: unknown;
      };
      /**
       * Publish a message on an MQTT topic.
       */
      mqtt?: {
        /**
         * Username to authenticate against the broker.
         */
        username?: string;
        /**
         * QoS (Quality of Service)
         */
        qos?: "0" | "1" | "2";
        /**
         * Default: 1883
         *
         * MQTT broker port number
         */
        port?: number | string;
        /**
         * Default: localhost
         *
         * MQTT broker address/name
         */
        server?: string;
        /**
         * MQTT topic name
         */
        topic: string;
        /**
         * Default: hostname + pid
         *
         * MQTT client identifier
         */
        client_id?: string;
        /**
         * Setting this flag causes the broker to retain (i.e. keep) the message so that applications that subsequently subscribe to the topic can received the last retained message immediately.
         */
        retain?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Password for C(username) to authenticate against the broker.
         */
        password?: string;
        /**
         * Payload. The special string C("None") may be used to send a NULL (i.e. empty) payload which is useful to simply notify with the I(topic) or to clear previously retained messages.
         */
        payload: string;
        [k: string]: unknown;
      };
      /**
       * Manage installation and uninstallation of Ruby gems.
       */
      gem?: {
        [k: string]: unknown;
      };
      /**
       * Retrieve the attributes of a server certificate
       */
      iam_server_certificate_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module is useful for sending emails from playbooks.
       * One may wonder why automate sending emails?  In complex environments there are from time to time processes that cannot be automated, either because you lack the authority to make it so, or because not everyone agrees to a common approach.
       * If you cannot automate a specific step, but the step is non-blocking, sending out an email to the responsible party to make him perform his part of the bargain is an elegant way to put the responsibility in someone else's lap.
       * Of course sending out a mail can be equally useful as a way to notify one or more people in a team that a specific action has been (successfully) taken.
       */
      mail?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
          [k: string]: unknown;
        };
      /**
       * Creates, Removes and configures a binding to an existing IIS Web site
       */
      win_iis_webbinding?: {
        /**
         * The protocol to be used for the Web binding (usually HTTP, HTTPS, or FTP).
         */
        protocol?: string;
        /**
         * Names of web site
         */
        name?: string;
        /**
         * Certificate hash for the SSL binding. The certificate hash is the unique identifier for the certificate.
         */
        certificate_hash?: string;
        /**
         * The IP address to bind to / use for the new site.
         */
        ip?: string;
        /**
         * The host header to bind to / use for the new site.
         */
        host_header?: string;
        /**
         * State of the binding
         */
        state?: string;
        /**
         * The port to bind to / use for the new site.
         */
        port?: string;
        /**
         * Default: My
         *
         * Name of the certificate store where the certificate for the binding is located.
         */
        certificate_store_name?: string;
        [k: string]: unknown;
      };
      /**
       * Adds or removes Red Hat software channels
       */
      rhn_channel?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Add or remove an APT repositories in Ubuntu and Debian.
       */
      apt_repository?: {
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific public IP or all public IPs within a resource group.
       */
      azure_rm_publicip_facts?: {
        profile?: string;
        cli_default_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Only show results for a specific Public IP.
         */
        name?: string;
        /**
         * Limit results by resource group. Required when using name parameter.
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        secret?: string;
        client_id?: string;
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Copies AMI from a source region to a destination region. This module has a dependency on python-boto >= 2.5
       */
      ec2_ami_copy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Send notifications via pushover, to subscriber list of devices, and email addresses. Requires pushover app on devices.
       */
      pushover?: {
        /**
         * What message you wish to send.
         */
        msg: string;
        /**
         * Pushover issued authentication key for your user.
         */
        user_key: string;
        /**
         * Pushover issued token identifying your pushover app.
         */
        app_token: string;
        /**
         * Message priority (see U(https://pushover.net) for details.)
         */
        pri?: "-2" | "-1" | "0" | "1" | "2";
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to a Dell OS9 node and returns the results read from the device. This  module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(dellos9_config) to configure Dell OS9 devices.
       */
      dellos9_command?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        /**
         * List of commands to send to the remote dellos9 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.
         */
        commands:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ssh_keyfile?: string;
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should be tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: number | string;
        password?: string;
        auth_pass?: string;
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: number | string;
        host: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.
         */
        wait_for?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Assume a role using AWS Security Token Service and obtain temporary credentials
       */
      sts_assume_role?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * create / delete a database in the Cloud Databases.
       */
      rax_cdb_user?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * allows you to create/delete/stop instances in Proxmox VE cluster
       * Starting in Ansible 2.1, it automatically detects containerization type (lxc for PVE 4, openvz for older)
       */
      proxmox?: {
        /**
         * forcing operations
         * can be used only with states C(present), C(stopped), C(restarted)
         * with C(state=present) force option allow to overwrite existing container
         * with states C(stopped) , C(restarted) allow to force stop instance
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * numbers of allocated cpus for instance
         */
        cpus?: number | string;
        /**
         * the template for VM creating
         * required only for C(state=present)
         */
        ostemplate?: string;
        /**
         * Default: 3
         *
         * hard disk size in GB for instance
         */
        disk?: string;
        /**
         * sets DNS search domain for a container
         */
        searchdomain?: string;
        /**
         * the user to authenticate with
         */
        api_user: string;
        /**
         * the instance hostname
         * required only for C(state=present)
         */
        hostname?: string;
        /**
         * Default: local
         *
         * target storage
         */
        storage?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the instance
         */
        state?: "present" | "started" | "absent" | "stopped" | "restarted";
        /**
         * swap memory size in MB for instance
         */
        swap?: number | string;
        /**
         * Default: 512
         *
         * memory size in MB for instance
         */
        memory?: number | string;
        /**
         * Proxmox VE node, when new VM will be created
         * required only for C(state=present)
         * for another states will be autodiscovered
         */
        node?: string;
        /**
         * Default: 1000
         *
         * CPU weight for a VM
         */
        cpuunits?: number | string;
        /**
         * the password to authenticate with
         * you can use PROXMOX_PASSWORD environment variable
         */
        api_password?: string;
        /**
         * the instance root password
         * required only for C(state=present)
         */
        password?: string;
        /**
         * specifies the address the container will be assigned
         */
        ip_address?: string;
        /**
         * the host of the Proxmox VE cluster
         */
        api_host: string;
        /**
         * specifies network interfaces for the container
         */
        netif?: {
          [k: string]: unknown;
        };
        /**
         * the instance id
         */
        vmid: string;
        /**
         * Default: 30
         *
         * timeout for operations
         */
        timeout?: number | string;
        /**
         * specifies additional mounts (separate disks) for the container
         */
        mounts?: {
          [k: string]: unknown;
        };
        /**
         * sets DNS server IP address for a container
         */
        nameserver?: string;
        /**
         * enable / disable https certificate verification
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * specifies whether a VM will be started during system bootup
         */
        onboot?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * IPS packages are the native packages in Solaris 11 and higher.
       * This modules will configure which publishers a client will download IPS packages from.
       */
      pkg5_publisher?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage packages on OpenBSD using the pkg tools.
       */
      openbsd_pkg?: {
        /**
         * C(present) will make sure the package is installed. C(latest) will make sure the latest version of the package is installed. C(absent) will make sure the specified package is not installed.
         */
        state: "absent" | "installed" | "latest" | "present" | "removed";
        /**
         * Build the package from source instead of downloading and installing a binary. Requires that the port source tree is already installed. Automatically builds and installs the 'sqlports' package, if it is not already installed.
         */
        build?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the package.
         */
        name: string;
        /**
         * Default: /usr/ports
         *
         * When used in combination with the 'build' option, allows overriding the default ports source directory.
         */
        ports_dir?: string;
        [k: string]: unknown;
      };
      /**
       * Execute vlag-create/vlag-delete/vlag-modify command.
       * A virtual link aggregation group (VLAG) allows links that are physically connected to two different Pluribus Networks devices to appear as a single trunk to a third device. The third device can be a switch, server, or any Ethernet device. A VLAG can provide Layer 2 multipathing, which allows you to create redundancy by increasing bandwidth, enabling multiple parallel paths between nodes and loadbalancing traffic where alternative paths exist.
       */
      pn_vlag?: {
        /**
         * The C(pn_name) takes a valid name for vlag configuration.
         */
        pn_name: string;
        /**
         * Specify the LACP fallback mode as bundles or individual.
         */
        pn_lacp_fallback?: "individual" | "bundled";
        /**
         * Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.
         */
        pn_lacp_fallback_timeout?: string;
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Specify the LACP timeout as slow(30 seconds) or fast(4 seconds).
         */
        pn_lacp_timeout?: "slow" | "fast";
        /**
         * State the action to perform. Use 'present' to create vlag, 'absent' to delete vlag and 'update' to modify vlag.
         */
        state: "present" | "absent" | "update";
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Specify the LACP mode.
         */
        pn_lacp_mode?: "off" | "passive" | "active";
        /**
         * Specify the failover action as move or ignore.
         */
        pn_failover_action?: "move" | "ignore";
        /**
         * Specify the peer VLAG port.
         * Required for vlag-create.
         */
        pn_peer_port?: string;
        /**
         * Specify the fabric-name of the peer switch.
         */
        pn_peer_switch?: string;
        /**
         * Specify the local VLAG port.
         * Required for vlag-create.
         */
        pn_port?: string;
        /**
         * Target switch(es) to run this command on.
         */
        pn_cliswitch?: string;
        /**
         * Specify the mode for the VLAG. Active-standby indicates one side is active and the other side is in standby mode. Active-active indicates that both sides of the vlag are up by default.
         */
        pn_mode?: "active-active" | "active-standby";
        [k: string]: unknown;
      };
      /**
       * The M(hall) module connects to the U(https://hall.com) messaging API and allows you to deliver notication messages to rooms.
       */
      hall?: {
        /**
         * The message you wish to deliver as a notifcation
         */
        msg: string;
        /**
         * The full URL to the image you wish to use for the Icon of the message. Defaults to U(http://cdn2.hubspot.net/hub/330046/file-769078210-png/Official_Logos/ansible_logo_black_square_small.png?t=1421076128627)
         */
        picture?: string;
        /**
         * Room token provided to you by setting up the Ansible room integation on U(https://hall.com)
         */
        room_token: string;
        /**
         * The title of the message
         */
        title: string;
        [k: string]: unknown;
      };
      /**
       * Manages domains and records via the DNSimple API, see the docs: U(http://developer.dnsimple.com/)
       */
      dnsimple?: {
        /**
         * Whether the record should be the only one for that record type and record name. Only use with state=present on a record
         */
        solo?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNSimple. If omitted, a list of domains will be returned.
         * If domain is present but the domain doesn't exist, it will be created.
         */
        domain?: string;
        /**
         * Account email. If omitted, the env variables DNSIMPLE_EMAIL and DNSIMPLE_API_TOKEN will be looked for. If those aren't found, a C(.dnsimple) file will be looked for, see: U(https://github.com/mikemaccana/dnsimple-python#getting-started)
         */
        account_email?: string;
        /**
         * List of records to ensure they either exist or don't exist
         */
        record_ids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Record value
         * Must be specified when trying to ensure a record exists
         */
        value?: string;
        /**
         * Record priority
         */
        priority?: number | string;
        /**
         * Record to add, if blank a record for the domain will be created, supports the wildcard (*)
         */
        record?: string;
        /**
         * whether the record should exist or not
         */
        state?: "present" | "absent";
        /**
         * Default: 3600 (one hour)
         *
         * The TTL to give the new record
         */
        ttl?: number | string;
        /**
         * The type of DNS record to create
         */
        type?:
          | "A"
          | "ALIAS"
          | "CNAME"
          | "MX"
          | "SPF"
          | "URL"
          | "TXT"
          | "NS"
          | "SRV"
          | "NAPTR"
          | "PTR"
          | "AAAA"
          | "SSHFP"
          | "HINFO"
          | "POOL";
        /**
         * Account API token. See I(account_email) for info.
         */
        account_api_token?: string;
        [k: string]: unknown;
      };
      /**
       * Migrate a VMK interface from VSS to VDS
       */
      vmware_migrate_vmk?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage scheduled tasks
       */
      win_scheduled_task?: {
        /**
         * Command the scheduled task should execute
         */
        execute?: string;
        /**
         * Name of the scheduled task
         */
        name?: string;
        /**
         * Days of the week to run a weekly task, not idempotent
         */
        days_of_week?: string;
        /**
         * Default: True
         *
         * Enable/disable the task
         */
        enabled?: string;
        /**
         * Arguments to provide scheduled task action
         */
        argument?: string;
        /**
         * State that the task should become
         */
        state?: string;
        /**
         * The frequency of the command, not idempotent
         */
        frequency?: string;
        /**
         * User to run scheduled task as
         */
        user?: string;
        /**
         * Time to execute scheduled task, not idempotent
         */
        time?: string;
        /**
         * Folder path of scheduled task
         */
        path?: string;
        /**
         * The description for the scheduled task
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Create or delete a Rackspace Cloud Monitoring alarm that associates an existing rax_mon_entity, rax_mon_check, and rax_mon_notification_plan with criteria that specify what conditions will trigger which levels of notifications. Rackspace monitoring module flow | rax_mon_entity -> rax_mon_check -> rax_mon_notification -> rax_mon_notification_plan -> *rax_mon_alarm*
       */
      rax_mon_alarm?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages Cisco IOS network device configurations over SSH.  This module allows implementers to work with the device running-config.  It provides a way to push a set of commands onto a network device by evaluating the current running-config and only pushing configuration commands that are not already configured.  The config source can be a set of commands or a template.
       */
      ios_template?: {
        /**
         * The path to the config source.  The source can be either a file with config or a template that will be merged during runtime.  By default the task will first search for the source file in role or playbook root folder in templates unless a full path to the file is given.
         */
        src?: string;
        /**
         * The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
         */
        config?: string;
        /**
         * The force argument instructs the module not to consider the current device running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.
         */
        force?: string;
        /**
         * When this argument is configured true, the module will backup the running-config from the node prior to making any changes. The backup file will be written to backup_{{ hostname }} in the root of the playbook directory.
         */
        backup?: string;
        /**
         * The module, by default, will collect the current device running-config to use as a base for comparison to the commands in I(src).  Setting this value to true will cause the command issued to add any necessary flags to collect all defaults as well as the device configuration.  If the destination device does not support such a flag, this argument is silently ignored.
         */
        include_defaults?: string;
        [k: string]: unknown;
      };
      name: string;
      /**
       * This module removes, or creates DHCP option sets, and can associate them to a VPC. Optionally, a new DHCP Options set can be created that converges a VPC's existing DHCP option set with values provided. When dhcp_options_id is provided, the module will 1. remove (with state='absent') 2. ensure tags are applied (if state='present' and tags are provided 3. attach it to a VPC (if state='present' and a vpc_id is provided. If any of the optional values are missing, they will either be treated as a no-op (i.e., inherit what already exists for the VPC) To remove existing options while inheriting, supply an empty value (e.g. set ntp_servers to [] if you want to remove them from the VPC's options) Most of the options should be self-explanatory.
       */
      ec2_vpc_dhcp_options?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * An Ansible module to Create, Delete, Start and Stop servers in CenturyLink Cloud.
       */
      clc_server?: {
        /**
         * Default: None
         *
         * The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_id'.
         */
        anti_affinity_policy_name?: string;
        /**
         * Default: standard
         *
         * The type of storage to attach to the server.
         */
        storage_type?: "standard" | "hyperscale";
        /**
         * Default: None
         *
         * The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_name'.
         */
        anti_affinity_policy_id?: string;
        /**
         * Default: None
         *
         * The time to live for the server in seconds.  The server will be deleted when this time expires.
         */
        ttl?: string;
        /**
         * Default: None
         *
         * Required when exact_count is specified.  The Server Group use to determine how many severs to deploy.
         */
        count_group?: string;
        /**
         * Default: None
         *
         * Secondary DNS used by the server.
         */
        secondary_dns?: string;
        /**
         * The list of custom fields to set on the server.
         */
        custom_fields?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: None
         *
         * Password for the administrator / root user
         */
        password?: string;
        /**
         * The list of blue print packages to run on the server after its created.
         */
        packages?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: Default Group
         *
         * The Server Group to create servers under.
         */
        group?: string;
        /**
         * Default: None
         *
         * Run in idempotent mode.  Will insure that this exact number of servers are running in the provided group, creating and deleting them to reach that count.  Requires count_group to be set.
         */
        exact_count?: number | string;
        /**
         * Default: present
         *
         * The state to insure that the provided resources are in.
         */
        state?: "present" | "absent" | "started" | "stopped";
        /**
         * Default: None
         *
         * The autoscale policy to assign to the server.
         */
        cpu_autoscale_policy_id?: string;
        /**
         * Default: None
         *
         * The template to use for server creation.  Will search for a template if a partial string is provided. This is required when state is 'present'
         */
        template?: string;
        /**
         * Default: 1
         *
         * Memory in GB.
         */
        memory?: string;
        /**
         * Required for started, stopped, and absent states. A list of server Ids to insure are started, stopped, or absent.
         */
        server_ids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: standard
         *
         * The type of server to create.
         */
        type?: "standard" | "hyperscale" | "bareMetal";
        /**
         * Whether to create the server as 'Managed' or not.
         */
        managed_os?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * The Datacenter to create servers in.
         */
        location?: string;
        /**
         * The list of additional disks for the server
         */
        additional_disks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: None
         *
         * The description to set for the server.
         */
        description?: string;
        /**
         * Whether to add a public ip to the server
         */
        add_public_ip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * Only required for bare metal servers. Specifies the identifier for the specific configuration type of bare metal server to deploy.
         */
        configuration_id?: string;
        /**
         * Default: None
         *
         * The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_id'.
         */
        alert_policy_name?: string;
        /**
         * Default: None
         *
         * The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_name'.
         */
        alert_policy_id?: string;
        /**
         * A list of ports to allow on the firewall to the servers public ip, if add_public_ip is set to True.
         */
        public_ip_ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: None
         *
         * The IP Address for the server. One is assigned if not provided.
         */
        ip_address?: string;
        /**
         * Default: TCP
         *
         * The protocol to use for the public ip if add_public_ip is set to True.
         */
        public_ip_protocol?: "TCP" | "UDP" | "ICMP";
        /**
         * Default: True
         *
         * Whether to wait for the provisioning tasks to finish before returning.
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * The number of servers to build (mutually exclusive with exact_count)
         */
        count?: number | string;
        /**
         * Default: None
         *
         * A 1 to 6 character identifier to use for the server. This is required when state is 'present'
         */
        name?: string;
        /**
         * Default: None
         *
         * The network UUID on which to create servers.
         */
        network_id?: string;
        /**
         * Default: None
         *
         * Primary DNS used by the server.
         */
        primary_dns?: string;
        /**
         * Default: None
         *
         * The account alias to provision the servers under.
         */
        alias?: string;
        /**
         * Default: None
         *
         * The password for the source server if a clone is specified.
         */
        source_server_password?: string;
        /**
         * Default: None
         *
         * Only required for bare metal servers. Specifies the OS to provision with the bare metal server.
         */
        os_type?: "redHat6_64Bit" | "centOS6_64Bit" | "windows2012R2Standard_64Bit" | "ubuntu14_64Bit";
        /**
         * Default: 1
         *
         * How many CPUs to provision on the server
         */
        cpu?: string;
        [k: string]: unknown;
      };
      /**
       * Installs packages using Chocolatey (http://chocolatey.org/). If Chocolatey is missing from the system, the module will install it. List of packages can be found at http://chocolatey.org/packages
       */
      win_chocolatey?: {
        /**
         * If package is already installed it, try to upgrade to the latest version or to the specified version
         */
        upgrade?: string;
        /**
         * Forces install of the package (even if it already exists). Using Force will cause ansible to always report that a change was made
         */
        force?: string;
        /**
         * Name of the package to be installed
         */
        name?: string;
        /**
         * Ignore Checksums
         */
        ignore_checksums?: string;
        /**
         * Allow empty Checksums to be used
         */
        allow_empty_checksums?: string;
        /**
         * Arguments to pass to the native installer
         */
        install_args?: string;
        /**
         * Specify source rather than using default chocolatey repository
         */
        source?: string;
        /**
         * Default: present
         *
         * State of the package on the system
         */
        state?: string;
        /**
         * Specific version of the package to be installed
         * Ignored when state == 'absent'
         */
        version?: string;
        /**
         * Parameters to pass to the package
         */
        params?: string;
        /**
         * Ignore dependencies, only install/upgrade the package itself
         */
        ignore_dependencies?: string;
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running iosxr.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      iosxr_facts?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * C(synchronize) is a wrapper around the rsync command, meant to make common tasks with rsync easier. It is run and originates on the local host where Ansible is being run. Of course, you could just use the command action to call rsync yourself, but you also have to add a fair number of boilerplate options and host facts. You `still` may need to call rsync directly via C(command) or C(shell) depending on your use case. C(synchronize) does not provide access to the full power of rsync, but does make most invocations easier to follow.
       */
      synchronize?: {
        /**
         * Tells rsync to keep the partial file which should make a subsequent transfer of the rest of the file much faster.
         */
        partial?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: the value of the archive option
         *
         * Copy symlinks as symlinks.
         */
        links?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Copy symlinks as the item that they point to (the referent) is copied, rather than the symlink.
         */
        copy_links?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: the value of the archive option
         *
         * Preserve permissions.
         */
        perms?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: the value of the archive option
         *
         * Preserve owner (super user only)
         */
        owner?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Mirrors the rsync archive flag, enables recursive, links, perms, times, owner, group flags and -D.
         */
        archive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: Value of ansible_ssh_port for this host, remote_port config setting, or the value from ssh client configuration if none of those are set
         *
         * Port number for ssh on the destination host. Prior to ansible 2.0, the ansible_ssh_port inventory var took precedence over this value.
         */
        dest_port?: number | string;
        _local_rsync_path?: string;
        /**
         * Default: the value of the archive option
         *
         * Preserve group
         */
        group?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Skip creating new files on receiver.
         */
        existing_only?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the rsync command to run on the remote host. See C(--rsync-path) on the rsync man page.
         */
        rsync_path?: string;
        /**
         * Path on the destination host that will be synchronized from the source; The path can be absolute or relative.
         */
        dest: string;
        /**
         * Verify destination host key.
         */
        verify_host?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: no
         *
         * Transfer directories without recursing
         */
        dirs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        private_key?: string;
        _substitute_controller?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Compress file data during the transfer. In most cases, leave this enabled unless it causes problems.
         */
        compress?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify a --timeout for the rsync command in seconds.
         */
        rsync_timeout?: number | string;
        /**
         * Specify additional rsync options by passing in an array.
         */
        rsync_opts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: True
         *
         * put user@ for the remote paths. If you have a custom ssh config to define the remote user for a host that does not match the inventory user, you should set this parameter to "no".
         */
        set_remote_user?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: the value of the archive option
         *
         * Recurse into directories.
         */
        recursive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Path on the source host that will be synchronized to the destination; The path can be absolute or relative.
         */
        src: string;
        /**
         * Default: no
         *
         * Skip based on checksum, rather than mod-time & size; Note that that "archive" option is still enabled by default - the "checksum" option will not disable it.
         */
        checksum?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: the value of the archive option
         *
         * Preserve modification times
         */
        times?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: push
         *
         * Specify the direction of the synchronization. In push mode the localhost or delegate is the source; In pull mode the remote host in context is the source.
         */
        mode?: "push" | "pull";
        ssh_args?: string;
        /**
         * Default: no
         *
         * Delete files in C(dest) that don't exist (after transfer, not before) in the C(src) path. This option requires C(recursive=yes).
         */
        delete?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running VyOS.  This module prepends all of the base network fact keys with U(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      vyos_facts?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Manages OpenWrt packages
       */
      opkg?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * This module prints statements during execution and can be useful for debugging variables or expressions without necessarily halting the playbook. Useful for debugging together with the 'when:' directive.
       */
      debug?: {
        /**
         * Default: Hello world!
         *
         * The customized message that is printed. If omitted, prints a generic message.
         */
        msg?: string;
        /**
         * A variable name to debug.  Mutually exclusive with the 'msg' option.
         */
        var?: string;
        /**
         * A number that controls when the debug is run, if you set to 3 it will only run debug when -vvv or above
         */
        verbosity?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows to manage dns zones on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
       */
      udm_dns_zone?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage route tables for AWS virtual private clouds
       */
      ec2_vpc_route_table?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Change ACL (Access Control List) inheritance and optionally copy inherited ACE's (Access Control Entry) to dedicated ACE's or vice versa.
       */
      win_acl_inheritance?: {
        /**
         * Path to be used for changing inheritance
         */
        path?: string;
        /**
         * Default: absent
         *
         * Specify whether to enable I(present) or disable I(absent) ACL inheritance
         */
        state?: string;
        /**
         * For P(state) = I(absent), indicates if the inherited ACE's should be copied from the parent directory. This is necessary (in combination with removal) for a simple ACL instead of using multiple ACE deny entries.
         * For P(state) = I(present), indicates if the inherited ACE's should be deduplicated compared to the parent directory. This removes complexity of the ACL structure.
         */
        reorganize?: string;
        [k: string]: unknown;
      };
      /**
       * Manages VTP version configuration.
       */
      nxos_vtp_version?: {
        /**
         * VTP version number.
         */
        version?: string;
        [k: string]: unknown;
      };
      /**
       * Manages Homebrew casks.
       */
      homebrew_cask?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Adds or removes Vertica database role and, optionally, assign other roles.
       */
      vertica_role?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Create and remove instance groups.
       */
      cs_instancegroup?: {
        /**
         * Account the instance group is related to.
         */
        account?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Project the instance group is related to.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the instance group.
         */
        state?: "present" | "absent";
        /**
         * Domain the instance group is related to.
         */
        domain?: string;
        api_key?: string;
        /**
         * Name of the instance group.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, remove and revert VM from snapshots.
       */
      cs_vmsnapshot?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Execute vrouter-bgp-add, vrouter-bgp-remove, vrouter-bgp-modify command.
       * Each fabric, cluster, standalone switch, or virtual network (VNET) can provide its tenants with a vRouter service that forwards traffic between networks and implements Layer 4 protocols.
       */
      pn_vrouterbgp?: {
        /**
         * Specify a neighbor IP address to use for BGP.
         * Required for vrouter-bgp-add.
         */
        pn_neighbor?: string;
        /**
         * Specify a name for the vRouter service.
         */
        pn_vrouter_name: string;
        /**
         * Specify if you want a soft reconfiguration of inbound traffic.
         */
        pn_soft_reconfig?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify a value for external BGP to accept or attempt BGP connections to external peers, not directly connected, on the network. This is a value between 1 and 255.
         */
        pn_ebgp?: number | string;
        /**
         * Specify if a route reflector client is used.
         */
        pn_route_reflector?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify BGP neighbor keepalive interval in seconds.
         */
        pn_keepalive?: string;
        /**
         * Specify a multi-protocol for BGP.
         */
        pn_multiprotocol?: "ipv4-unicast" | "ipv6-unicast";
        /**
         * State the action to perform. Use 'present' to add bgp, 'absent' to remove bgp and 'update' to modify bgp.
         */
        state: "present" | "absent" | "update";
        /**
         * Target switch(es) to run the cli on.
         */
        pn_cliswitch?: string;
        /**
         * Specify the maximum number of prefixes.
         */
        pn_max_prefix?: number | string;
        /**
         * Specify outbound route map for neighbor.
         */
        pn_route_mapout?: string;
        /**
         * Specify if you want BFD protocol support for fault detection.
         */
        pn_bfd?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify inbound route map for neighbor.
         */
        pn_route_mapin?: string;
        /**
         * Specify if you want to override capability.
         */
        pn_override_capability?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the prefix list to filter traffic inbound.
         */
        pn_prefix_listin?: string;
        /**
         * Specify a password, if desired.
         */
        pn_password?: string;
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Specify if you want announce default routes to the neighbor or not.
         */
        pn_default_originate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Specify a default weight value between 0 and 65535 for the neighbor routes.
         */
        pn_weight?: number | string;
        /**
         * Specify the prefix list to filter traffic outbound.
         */
        pn_prefix_listout?: string;
        /**
         * Specify the remote Autonomous System(AS) number. This value is between 1 and 4294967295.
         * Required for vrouter-bgp-add.
         */
        pn_remote_as?: string;
        /**
         * Specify if you want a warning message when the maximum number of prefixes is exceeded.
         */
        pn_max_prefix_warn?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify BGP neighbor holdtime in seconds.
         */
        pn_holdtime?: string;
        /**
         * Specify if the next-hop is the same router or not.
         */
        pn_next_hop_self?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * The M(expect) module executes a command and responds to prompts
       * The given command will be executed on all selected nodes. It will not be processed through the shell, so variables like C($HOME) and operations like C("<"), C(">"), C("|"), and C("&") will not work
       */
      expect?: {
        /**
         * cd into this directory before running the command
         */
        chdir?: string;
        /**
         * Mapping of expected string/regex and string to respond with. If the response is a list, successive matches return successive responses. List functionality is new in 2.1.
         */
        responses: {
          [k: string]: unknown;
        };
        /**
         * a filename, when it does not exist, this step will B(not) be run.
         */
        removes?: string;
        /**
         * Whether or not to echo out your response strings
         */
        echo?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * a filename, when it already exists, this step will B(not) be run.
         */
        creates?: string;
        /**
         * the command module takes command to run.
         */
        command: string;
        /**
         * Default: 30
         *
         * Amount of time in seconds to wait for the expected strings
         */
        timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Adds or removes firewall rules from a gateway in a vca environment
       */
      vca_fw?: {
        /**
         * A list of firewall rules to be added to the gateway, Please see examples on valid entries
         */
        fw_rules?: string;
        [k: string]: unknown;
      };
      /**
       * Add or Remove a subnet to an OpenStack network
       */
      os_subnet?: {
        /**
         * The gateway IP would not be assigned for this subnet
         */
        no_gateway_ip?: string;
        /**
         * The name of the subnet that should be created. Although Neutron allows for non-unique subnet names, this module enforces subnet name uniqueness.
         */
        name?: string;
        /**
         * Default: True
         *
         * Whether DHCP should be enabled for this subnet.
         */
        enable_dhcp?: string;
        /**
         * Default: None
         *
         * List of DNS nameservers for this subnet.
         */
        dns_nameservers?: string;
        /**
         * Default: None
         *
         * Project name or ID containing the subnet (name admin-only)
         */
        project?: string;
        /**
         * Default: None
         *
         * IPv6 router advertisement mode
         */
        ipv6_ra_mode?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: string;
        /**
         * Default: None
         *
         * From the subnet pool the starting address from which the IP should be allocated.
         */
        allocation_pool_start?: string;
        /**
         * Default: None
         *
         * A list of host route dictionaries for the subnet.
         */
        host_routes?: string;
        /**
         * Default: None
         *
         * IPv6 address mode
         */
        ipv6_address_mode?: string;
        /**
         * Default: 4
         *
         * The IP version of the subnet 4 or 6
         */
        ip_version?: string;
        /**
         * Default: None
         *
         * The ip that would be assigned to the gateway for this subnet
         */
        gateway_ip?: string;
        /**
         * Default: None
         *
         * The CIDR representation of the subnet that should be assigned to the subnet. Required when I(state) is 'present'
         */
        cidr?: string;
        /**
         * Name of the network to which the subnet should be attached
         * Required when I(state) is 'present'
         */
        network_name?: string;
        /**
         * Default: None
         *
         * From the subnet pool the last IP that should be assigned to the virtual machines.
         */
        allocation_pool_end?: string;
        [k: string]: unknown;
      };
      /**
       * Add and remove load balancer rule members.
       */
      cs_loadbalancer_rule_member?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Create or destroy Azure Resource Manager template deployments via the Azure SDK for Python. You can find some quick start templates in GitHub here https://github.com/azure/azure-quickstart-templates. For more information on Azue resource manager templates see https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-deploy/.
       */
      azure_rm_deployment?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module will update settings for OpenDJ with the command set-backend-prop.
       * It will check first via de get-backend-prop if configuration needs to be applied.
       */
      opendj_backendprop?: {
        /**
         * Default: cn=Directory Manager
         *
         * The username to connect to.
         */
        username?: string;
        /**
         * The configuration setting to update.
         */
        name: string;
        /**
         * The hostname of the OpenDJ server.
         */
        hostname: string;
        /**
         * The value for the configuration item.
         */
        value: string;
        /**
         * Default: present
         *
         * If configuration needs to be added/updated
         */
        state?: string;
        /**
         * Location to the password file which holds the password for the cn=Directory Manager user.
         * Either password or passwordfile is needed.
         */
        passwordfile?: string;
        /**
         * The password for the cn=Directory Manager user.
         * Either password or passwordfile is needed.
         */
        password?: string;
        /**
         * Default: /opt/opendj/bin
         *
         * The path to the bin directory of OpenDJ.
         */
        opendj_bindir?: string;
        /**
         * The Admin port on which the OpenDJ instance is available.
         */
        port: string;
        /**
         * The name of the backend on which the property needs to be updated.
         */
        backend: string;
        [k: string]: unknown;
      };
      /**
       * creates / deletes a Rackspace Public Cloud queue.
       */
      rax_queue?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage the network devices. Create, modify, and manage, ethernet, teams, bonds, vlans etc.
       */
      nmcli?: {
        /**
         * Where conn_name will be the name used to call the connection. when not provided a default name is generated: <type>[-<ifname>][-<num>]
         */
        conn_name: string;
        /**
         * Default: None
         *
         * This is only used with VLAN - VLAN ingress priority mapping
         */
        ingress?: string;
        /**
         * Default: 32
         *
         * This is only used with 'bridge-slave' - [<0-63>] - STP priority of this slave
         */
        slavepriority?: string;
        /**
         * Default: None
         *
         * This is only used with VLAN - parent device this VLAN is on, can use ifname
         */
        vlandev?: string;
        /**
         * Default: 15
         *
         * This is only used with bridge - [forward-delay <2-30>] STP forwarding delay, in seconds
         */
        forwarddelay?: string;
        /**
         * Default: None
         *
         * This is only used with VLAN - VLAN egress priority mapping
         */
        egress?: string;
        /**
         * Default: None
         *
         * This is only used with VLAN - VLAN ID in range <0-4095>
         */
        vlanid?: string;
        /**
         * Default: None
         *
         * A list of upto 3 dns servers, ipv4 format e.g. To add two IPv4 DNS server addresses: ["192.0.2.53", "198.51.100.53"]
         */
        dns4?: string;
        /**
         * Default: 2
         *
         * This is only used with bridge - [hello-time <1-10>] STP hello time, in seconds
         */
        hellotime?: string;
        /**
         * Default: 20
         *
         * This is only used with bridge - [max-age <6-42>] STP maximum message age, in seconds
         */
        maxage?: string;
        /**
         * Default: 300
         *
         * This is only used with bridge - [ageing-time <0-1000000>] the Ethernet MAC address aging time, in seconds
         */
        ageingtime?: string;
        /**
         * Default: 128
         *
         * This is only used with 'bridge' - sets STP priority
         */
        priority?: string;
        /**
         * The IPv4 gateway for this interface using this format ie: "192.0.2.1"
         */
        gw4?: string;
        /**
         * Whether the device should exist or not, taking action if the state is different from what is stated.
         */
        state: "present" | "absent";
        /**
         * Default: None
         *
         * The IPv6 gateway for this interface using this format ie: "2001:db8::1"
         */
        gw6?: string;
        /**
         * Default: None
         *
         * master <master (ifname, or connection UUID or conn_name) of bridge, team, bond master connection profile.
         */
        master?: string;
        /**
         * Default: None
         *
         * This is only used with bridge and controls whether Spanning Tree Protocol (STP) is enabled for this bridge
         */
        stp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: conn_name
         *
         * Where IFNAME will be the what we call the interface name.
         * interface to bind the connection to. The connection will only be applicable to this interface name.
         * A special value of "*" can be used for interface-independent connections.
         * The ifname argument is mandatory for all connection types except bond, team, bridge and vlan.
         */
        ifname?: string;
        /**
         * This is the type of device or network connection that you wish to create.
         */
        type?: "ethernet" | "team" | "team-slave" | "bond" | "bond-slave" | "bridge" | "vlan";
        /**
         * Default: 100
         *
         * This is only used with bond - miimon
         */
        miimon?: string;
        /**
         * Default: None
         *
         * This is only used with bond - ARP IP target
         */
        arp_ip_target?: string;
        /**
         * Default: None
         *
         * This is only used with bond - downdelay
         */
        downdelay?: string;
        /**
         * Default: None
         *
         * This is only used with bridge - MAC address of the bridge (note: this requires a recent kernel feature, originally introduced in 3.15 upstream kernel)
         */
        mac?: string;
        /**
         * Default: None
         *
         * The IPv6 address to this interface using this format ie: "abbe::cafe"
         */
        ip6?: string;
        /**
         * Default: None
         *
         * The IPv4 address to this interface using this format ie: "192.0.2.24/24"
         */
        ip4?: string;
        /**
         * Default: yes
         *
         * Whether the connection should start on boot.
         * Whether the connection profile can be automatically activated
         */
        autoconnect?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A list of upto 3 dns servers, ipv6 format e.g. To add two IPv6 DNS server addresses: ["2001:4860:4860::8888 2001:4860:4860::8844"]
         */
        dns6?: string;
        /**
         * Default: 1500
         *
         * The connection MTU, e.g. 9000. This can't be applied when creating the interface and is done once the interface has been created.
         * Can be used when modifying Team, VLAN, Ethernet (Future plans to implement wifi, pppoe, infiniband)
         */
        mtu?: string;
        /**
         * Default: None
         *
         * This is only used with bond - ARP interval
         */
        arp_interval?: string;
        /**
         * Default: None
         *
         * This is only used with VLAN - flags
         */
        flags?: string;
        /**
         * Default: balence-rr
         *
         * This is the type of device or network connection that you wish to create for a bond, team or bridge.
         */
        mode?: "balance-rr" | "active-backup" | "balance-xor" | "broadcast" | "802.3ad" | "balance-tlb" | "balance-alb";
        /**
         * Default: None
         *
         * This is only used with bond - updelay
         */
        updelay?: string;
        [k: string]: unknown;
      };
      /**
       * Manage an AWS VPC Internet gateway
       */
      ec2_vpc_igw?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage OVH (French European hosting provider) LoadBalancing IP backends
       */
      ovh_ip_loadbalancing_backend?: {
        /**
         * The endpoint to use ( for instance ovh-eu)
         */
        endpoint: string;
        /**
         * Name of the LoadBalancing internal name (ip-X.X.X.X)
         */
        name: string;
        /**
         * Default: 8
         *
         * Determines the weight for this backend
         */
        weight?: number | string;
        /**
         * Default: none
         *
         * Determines the type of probe to use for this backend
         */
        probe?: "none" | "http" | "icmp" | "oco";
        /**
         * The applicationKey to use
         */
        application_key: string;
        /**
         * Default: present
         *
         * Determines wether the backend is to be created/modified or deleted
         */
        state?: "present" | "absent";
        /**
         * The application secret to use
         */
        application_secret: string;
        /**
         * Default: 120
         *
         * The timeout in seconds used to wait for a task to be completed. Default is 120 seconds.
         */
        timeout?: number | string;
        /**
         * The consumer key to use
         */
        consumer_key: string;
        /**
         * The IP address of the backend to update / modify / delete
         */
        backend: string;
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific resource group or all resource groups.
       */
      azure_rm_resouregroup_facts?: {
        profile?: string;
        cli_default_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Limit results to a specific resource group.
         */
        name?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        cloud_environment?: string;
        ad_user?: string;
        secret?: string;
        client_id?: string;
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * allows you to upload/delete templates in Proxmox VE cluster
       */
      proxmox_template?: {
        /**
         * Proxmox VE node, when you will operate with template
         */
        node?: string;
        /**
         * path to uploaded file
         * required only for C(state=present)
         */
        src?: string;
        /**
         * can be used only with C(state=present), exists template will be overwritten
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * the host of the Proxmox VE cluster
         */
        api_host: string;
        /**
         * the user to authenticate with
         */
        api_user: string;
        /**
         * the password to authenticate with
         * you can use PROXMOX_PASSWORD environment variable
         */
        api_password?: string;
        /**
         * Default: local
         *
         * target storage
         */
        storage?: string;
        /**
         * Default: 30
         *
         * timeout for operations
         */
        timeout?: number | string;
        /**
         * Default: present
         *
         * Indicate desired state of the template
         */
        state?: "present" | "absent";
        /**
         * Default: vztmpl
         *
         * content type
         * required only for C(state=present)
         */
        content_type?: "vztmpl" | "iso";
        /**
         * enable / disable https certificate verification
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * the template name
         * required only for states C(absent), C(info)
         */
        template?: string;
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running Dell OS9.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      dellos9_facts?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Consumes docker compose to start, shutdown and scale services.
       * Works with compose versions 1 and 2.
       * Compose can be read from a docker-compose.yml (or .yaml) file or inline using the C(definition) option.
       * See the examples for more details.
       * Supports check mode.
       */
      docker_service?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages a VRF for an OSPF router.
       */
      nxos_ospf_vrf?: {
        /**
         * Router Identifier (ID) of the OSPF router VRF instance.
         */
        router_id?: string;
        /**
         * Specify the max interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.
         */
        timer_throttle_lsa_max?: string;
        /**
         * Specify the maximum wait time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.
         */
        timer_throttle_spf_max?: string;
        /**
         * Specify the hold interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.
         */
        timer_throttle_lsa_hold?: string;
        /**
         * Specify the default Metric value. Valid values are an integer or the keyword 'default'.
         */
        default_metric?: string;
        /**
         * Controls the level of log messages generated whenever a neighbor changes state. Valid values are 'log', 'detail', and 'default'.
         */
        log_adjacency?: string;
        /**
         * Specify the start interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.
         */
        timer_throttle_lsa_start?: string;
        /**
         * Default: default
         *
         * Name of the resource instance. Valid value is a string. The name 'default' is a valid VRF representing the global OSPF.
         */
        vrf?: string;
        /**
         * Specifies the reference bandwidth used to assign OSPF cost. Valid values are an integer, in Mbps, or the keyword 'default'.
         */
        auto_cost?: string;
        /**
         * Specify initial Shortest Path First (SPF) schedule delay. Valid values are an integer, in milliseconds, or the keyword 'default'.
         */
        timer_throttle_spf_start?: string;
        /**
         * Name of the OSPF instance.
         */
        ospf?: string;
        /**
         * Specify minimum hold time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.
         */
        timer_throttle_spf_hold?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about a image image from OpenStack.
       */
      os_image_facts?: {
        /**
         * Name or ID of the image
         */
        image?: string;
        [k: string]: unknown;
      };
      /**
       * Manages VTP domain configuration.
       */
      nxos_vtp_domain?: {
        /**
         * VTP domain name.
         */
        domain?: string;
        [k: string]: unknown;
      };
      /**
       * Can create or delete AWS metric alarms.
       * Metrics you wish to alarm on must already exist.
       */
      ec2_metric_alarm?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can be used to configure VSAN clustering on an ESXi host
       */
      vmware_vsan_cluster?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Add or Remove network from OpenStack.
       */
      quantum_network?: {
        /**
         * Default: None
         *
         * Name of the region
         */
        region_name?: string;
        /**
         * Default: None
         *
         * The type of the network to be created, gre, vlan, local. Available types depend on the plugin. The Quantum service decides if not specified.
         */
        provider_network_type?: "local" | "vlan" | "flat" | "gre";
        availability_zone?: string;
        /**
         * If 'yes', specifies that the virtual network is a external network (public).
         */
        router_external?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * The name of the tenant for whom the network is created
         */
        tenant_name?: string;
        /**
         * Default: True
         *
         * Whether the state should be marked as up or down
         */
        admin_state_up?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * The physical network which would realize the virtual network for flat and vlan networks.
         */
        provider_physical_network?: string;
        /**
         * Default: yes
         *
         * The tenant name of the login user
         */
        login_tenant_name?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: "present" | "absent";
        /**
         * Default: http://127.0.0.1:35357/v2.0/
         *
         * The keystone url for authentication
         */
        auth_url?: string;
        /**
         * Default: yes
         *
         * Password of login user
         */
        login_password: string;
        /**
         * Default: admin
         *
         * login username to authenticate to keystone
         */
        login_username?: string;
        /**
         * Whether this network is shared or not
         */
        shared?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * The id that has to be assigned to the network, in case of vlan networks that would be vlan id and for gre the tunnel id
         */
        provider_segmentation_id?: string;
        /**
         * Default: None
         *
         * Name to be assigned to the network
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Dell OS10 configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with Dell OS10 configuration sections in a deterministic way.
       */
      dellos10_config?: {
        [k: string]: unknown;
      };
      /**
       * This module creates and manages CloudWatch event rules and targets.
       */
      cloudwatchevent_rule?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manipulate Rackspace Cloud Autoscale Scaling Policy
       */
      rax_scaling_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create an annotation event on the given annotation stream :name. If the annotation stream does not exist, it will be created automatically
       */
      librato_annotation?: {
        /**
         * The annotation stream name
         * If the annotation stream does not exist, it will be created automatically
         */
        name?: string;
        /**
         * See examples
         */
        links?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The title of an annotation is a string and may contain spaces
         * The title should be a short, high-level summary of the annotation e.g. v45 Deployment
         */
        title: string;
        /**
         * The unix timestamp indicating the the time at which the event referenced by this annotation started
         */
        start_time?: number | string;
        /**
         * A string which describes the originating source of an annotation when that annotation is tracked across multiple members of a population
         */
        source?: string;
        /**
         * The unix timestamp indicating the the time at which the event referenced by this annotation ended
         * For events that have a duration, this is a useful way to annotate the duration of the event
         */
        end_time?: number | string;
        /**
         * Librato account username
         */
        user: string;
        /**
         * Librato account api key
         */
        api_key: string;
        /**
         * The description contains extra meta-data about a particular annotation
         * The description should contain specifics on the individual annotation e.g. Deployed 9b562b2 shipped new feature foo!
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows users to manage their objects/buckets in Google Cloud Storage.  It allows upload and download operations and can set some canned permissions. It also allows retrieval of URLs for objects for use in playbooks, and retrieval of string contents of objects.  This module requires setting the default project in GCS prior to playbook usage.  See U(https://developers.google.com/storage/docs/reference/v1/apiversion1) for information about setting the default project.
       */
      gc_storage?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages SELinux file context mapping definitions
       * Similar to the C(semanage fcontext) command
       */
      sefcontext?: {
        /**
         * Target path (expression).
         */
        target?: string;
        /**
         * SELinux range for the specified target.
         */
        selevel?: string;
        /**
         * SELinux user for the specified target.
         */
        seuser?: string;
        /**
         * Default: present
         *
         * Desired boolean value.
         */
        state?: string;
        /**
         * Default: True
         *
         * Reload SELinux policy after commit.
         */
        reload?: string;
        /**
         * SELinux type for the specified target.
         */
        setype?: string;
        /**
         * Default: a
         *
         * File type.
         */
        ftype?: string;
        [k: string]: unknown;
      };
      /**
       * Gathering facts from the API of an instance.
       */
      cs_instance_facts?: {
        /**
         * Account the instance is related to.
         */
        account?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Domain the instance is related to.
         */
        domain?: string;
        api_region?: string;
        /**
         * Project the instance is related to.
         */
        project?: string;
        api_key?: string;
        /**
         * Name or display name of the instance.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove a host from distributed virtual switch
       */
      vmware_dvs_host?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Add and remove users from groups
       */
      os_user_group?: {
        /**
         * Default: present
         *
         * Should the user be present or absent in the group
         */
        state?: string;
        /**
         * Name or id for the group.
         */
        group?: string;
        /**
         * Name or id for the user
         */
        user?: string;
        [k: string]: unknown;
      };
      /**
       * Manage S3 buckets in AWS, Ceph, Walrus and FakeS3
       */
      s3_bucket?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage the state of a virtual host in RabbitMQ.
       */
      rabbitmq_policy?: {
        /**
         * Default: rabbit
         *
         * Erlang node name of the rabbit we wish to configure.
         */
        node?: string;
        /**
         * The name of the policy to manage.
         */
        name?: string;
        /**
         * A dict or string describing the policy.
         */
        tags?: string;
        /**
         * A regex of queues to apply the policy to.
         */
        pattern?: string;
        /**
         * The priority of the policy.
         */
        priority?: string;
        /**
         * Default: /
         *
         * The name of the vhost to apply to.
         */
        vhost?: string;
        /**
         * Default: present
         *
         * The state of the policy.
         */
        state?: string;
        /**
         * Default: all
         *
         * What the policy applies to. Requires RabbitMQ 3.2.0 or later.
         */
        apply_to?: string;
        [k: string]: unknown;
      };
      /**
       * Gets various details related to Route53 zone, record set or health check details
       */
      route53_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Tap external Homebrew repositories.
       */
      homebrew_tap?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Installs Python libraries, optionally in a I(virtualenv)
       */
      easy_install?: {
        /**
         * an optional I(virtualenv) directory path to install into. If the I(virtualenv) does not exist, it is created automatically
         */
        virtualenv?: string;
        /**
         * The explicit executable or a pathname to the executable to be used to run easy_install for a specific version of Python installed in the system. For example C(easy_install-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run easy_install for the Python 3.3 installation.
         */
        executable?: string;
        /**
         * A Python library name
         */
        name: string;
        /**
         * Default: virtualenv
         *
         * The command to create the virtual environment with. For example C(pyvenv), C(virtualenv), C(virtualenv2).
         */
        virtualenv_command?: string;
        /**
         * Default: no
         *
         * Whether the virtual environment will inherit packages from the global site-packages directory.  Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created.
         */
        virtualenv_site_packages?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * The desired state of the library. C(latest) ensures that the latest version is installed.
         */
        state?: "present" | "latest";
        [k: string]: unknown;
      };
      /**
       * Installs, upgrade, removes, and lists packages and groups with the I(yum) package manager.
       */
      yum?: {
        [k: string]: unknown;
      };
      /**
       * Create or delete a Rackspace Cloud Monitoring notification plan by associating existing rax_mon_notifications with severity levels. Rackspace monitoring module flow | rax_mon_entity -> rax_mon_check -> rax_mon_notification -> *rax_mon_notification_plan* -> rax_mon_alarm
       */
      rax_mon_notification_plan?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Set owner of files or directories
       */
      win_owner?: {
        /**
         * Path to be used for changing owner
         */
        path?: string;
        /**
         * Indicates if the owner should be changed recursively
         */
        recurse?: string;
        /**
         * Name to be used for changing owner
         */
        user?: string;
        [k: string]: unknown;
      };
      /**
       * Allows for the management of Lambda functions.
       */
      lambda?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates and deletes DNS Health checks in Amazons Route53 service
       * Only the port, resource_path, string_match and request_interval are considered when updating existing health-checks.
       */
      route53_health_check?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or delete or update firewall polices on Centurylink Cloud
       */
      clc_firewall_policy?: {
        /**
         * Default: None
         *
         * CLC alias for the destination account
         */
        destination_account_alias?: string;
        /**
         * Default: None
         *
         * The list of destination addresses for traffic on the terminating firewall. This is required when state is 'present'
         */
        destination?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: True
         *
         * Whether the firewall policy is enabled or disabled
         */
        enabled?: true | false;
        /**
         * Default: None
         *
         * The list  of source addresses for traffic on the originating firewall. This is required when state is 'present"
         */
        source?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Whether to create or delete the firewall policy
         */
        state?: "present" | "absent";
        /**
         * Target datacenter for the firewall policy
         */
        location: string;
        /**
         * CLC alias for the source account
         */
        source_account_alias: string;
        /**
         * Default: None
         *
         * Id of the firewall policy. This is required to update or delete an existing firewall policy
         */
        firewall_policy_id?: string;
        /**
         * Default: None
         *
         * The list of ports associated with the policy. TCP and UDP can take in single ports or port ranges.
         */
        ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: True
         *
         * Whether to wait for the provisioning tasks to finish before returning.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * This module can allocate or release an EIP.
       * This module can associate/disassociate an EIP with instances or network interfaces.
       */
      ec2_eip?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages Kibana plugins.
       */
      kibana_plugin?: {
        /**
         * Delete and re-install the plugin. Can be useful for plugins update
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: /opt/kibana/bin/kibana
         *
         * Location of the plugin binary
         */
        plugin_bin?: string;
        /**
         * Default: None
         *
         * Set exact URL to download the plugin from. For local file, prefix its absolute path with file://
         */
        url?: string;
        /**
         * Default: present
         *
         * Desired state of a plugin.
         */
        state?: "present" | "absent";
        /**
         * Default: None
         *
         * Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated if C(force) is not set to yes
         */
        version?: string;
        /**
         * Default: 1m
         *
         * Timeout setting: 30s, 1m, 1h...
         */
        timeout?: string;
        /**
         * Default: /opt/kibana/installedPlugins/
         *
         * Your configured plugin directory specified in Kibana
         */
        plugin_dir?: string;
        /**
         * Name of the plugin to install
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an ASA node and returns the results read from the device. The M(asa_command) module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      asa_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: string;
        /**
         * List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.
         */
        commands?: string;
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
         */
        wait_for?: string;
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: string;
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: string;
        [k: string]: unknown;
      };
      /**
       * Collects fact information from a remote device running the Junos operating system.  By default, the module will collect basic fact information from the device to be included with the hostvars. Additional fact information can be collected based on the configured set of arguments.
       */
      junos_facts?: {
        /**
         * Default: text
         *
         * The C(config_format) argument is used to specify the desired format of the configuration file.  Devices support three configuration file formats.  By default, the configuration from the device is returned as text.  The other options include set and xml.  If the xml option is chosen, the configuration file is returned as both xml and json.
         */
        config_format?: string;
        /**
         * The C(config) argument instructs the fact module to collect the configuration from the remote device.  The configuration is then included in return facts.  By default, the configuration is returned as text.  The C(config_format) can be used to return different Junos configuration formats.
         */
        config?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or delete a network interface. When creating a network interface you must provide the name of an existing virtual network, the name of an existing subnet within the virtual network. A default security group and public IP address will be created automatically, or you can provide the name of an existing security group and public IP address. See the examples below for more details.
       */
      azure_rm_networkinterface?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an SR OS node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(sros_config) to configure SR OS devices.
       */
      sros_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: string;
        /**
         * List of commands to send to the remote SR OS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.
         */
        commands?: string;
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
         */
        wait_for?: string;
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the wait_for must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: string;
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: string;
        [k: string]: unknown;
      };
      /**
       * Send a message to jabber
       */
      jabber?: {
        /**
         * message encoding
         */
        encoding?: string;
        /**
         * user ID or name of the room, when using room use a slash to indicate your nick.
         */
        to: string;
        /**
         * host to connect, overrides user info
         */
        host?: string;
        /**
         * User as which to connect
         */
        user: string;
        /**
         * The message body.
         */
        msg: string;
        /**
         * password for user to connect
         */
        password: string;
        /**
         * Default: 5222
         *
         * port to connect to, overrides default
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * List the MFA (Multi-Factor Authentication) devices registered for a user
       */
      iam_mfa_device_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create host groups if they do not exist.
       * Delete existing host groups if they exist.
       */
      zabbix_group?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Allows for the management of IAM users, user API keys, groups, roles.
       */
      iam?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Upload files to a vCenter datastore
       */
      vsphere_copy?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Get I(openstack) client config data from clouds.yaml or environment
       */
      os_client_config?: {
        /**
         * List of clouds to limit the return list to. No value means return information on all configured clouds
         */
        clouds?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Controls services on remote hosts. Supported init systems include BSD init, OpenRC, SysV, Solaris SMF, systemd, upstart.
       */
      service?: {
        [k: string]: unknown;
      };
      /**
       * Returns information about the load balancer.
       * Will be marked changed when called only if state is changed.
       */
      ec2_elb_lb?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or delete VNICs on Solaris/illumos systems.
       */
      dladm_vnic?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Collects facts from Cisco Nexus devices running the NX-OS operating system.  Fact collection is supported over both Cli and Nxapi transports.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      nxos_facts?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, legacy, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Manages HSRP configuration on NX-OS switches.
       */
      nxos_hsrp?: {
        /**
         * Authentication type.
         */
        auth_type?: string;
        /**
         * HSRP group number.
         */
        group?: string;
        /**
         * Authentication string.
         */
        auth_string?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: string;
        /**
         * HSRP priority.
         */
        priority?: string;
        /**
         * HSRP virtual IP address.
         */
        vip?: string;
        /**
         * Default: 2
         *
         * HSRP version.
         */
        version?: string;
        /**
         * Full name of interface that is being managed for HSRP.
         */
        interface?: string;
        [k: string]: unknown;
      };
      /**
       * Runs I(puppet) agent or apply in a reliable manner
       */
      puppet?: {
        [k: string]: unknown;
      };
      /**
       * creates an EC2 snapshot from an existing EBS volume
       */
      ec2_snapshot?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages UDLD interface configuration params.
       */
      nxos_udld_interface?: {
        /**
         * FULL name of the interface, i.e. Ethernet1/1-
         */
        interface?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Manages UDLD mode for an interface.
         */
        mode?: string;
        [k: string]: unknown;
      };
      /**
       * Gets information about an AWS CloudFormation stack
       */
      cloudformation_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * creates / deletes a Rackspace Public Cloud isolated network.
       */
      rax_network?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an iosxr node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(iosxr_config) to configure iosxr devices.
       */
      iosxr_command?: {
        [k: string]: unknown;
      };
      /**
       * Create, update, delete snapshot groups for NetApp E-series storage arrays
       */
      netapp_e_snapshot_group?: {
        /**
         * Default: 20
         *
         * The size of the repository in relation to the size of the base volume
         */
        repo_pct?: number | string;
        ssid: string;
        /**
         * Default: medium
         *
         * The importance of the rollback operation.
         * This value is overridden by consistency group setting if this snapshot group is associated with a consistency group
         */
        rollback_priority?: "highest" | "high" | "medium" | "low" | "lowest";
        /**
         * Default: 30
         *
         * The automatic deletion indicator.
         * If non-zero, the oldest snapshot image will be automatically deleted when creating a new snapshot image to keep the total number of snapshot images limited to the number specified.
         * This value is overridden by the consistency group setting if this snapshot group is associated with a consistency group.
         */
        delete_limit?: number | string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * The name to give the snapshot group
         */
        name: string;
        /**
         * Whether to ensure the group is present or absent.
         */
        state: "present" | "absent";
        /**
         * The name of the storage pool on which to allocate the repository volume.
         */
        storage_pool_name?: string;
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * The name of the base volume or thin volume to use as the base for the new snapshot group.
         * If a snapshot group with an identical C(name) already exists but with a different base volume an error will be returned.
         */
        base_volume_name: string;
        /**
         * Default: purgepit
         *
         * The behavior on when the data repository becomes full.
         * This value is overridden by consistency group setting if this snapshot group is associated with a consistency group
         */
        full_policy?: "unknown" | "failbasewrites" | "purgepit";
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 80
         *
         * The repository utilization warning threshold, as a percentage of the repository volume capacity.
         */
        warning_threshold?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages NTP options, e.g. authoritative server and logging.
       */
      nxos_ntp_options?: {
        /**
         * Sets whether NTP logging is enabled on the device.
         */
        logging?: string;
        /**
         * If C(master=true), an optional stratum can be supplied (1-15). The device default is 8.
         */
        stratrum?: string;
        /**
         * Sets whether the device is an authoritative NTP server.
         */
        master?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * Configures a bond interface on Cumulus Linux To configure a bridge port use the cl_bridge module. To configure any other type of interface use the cl_interface module. Follow the guidelines for bonding found in the Cumulus User Guide at U(http://docs.cumulusnetworks.com).
       */
      cl_bond?: {
        /**
         * Default: 1
         *
         * The lacp rate.
         */
        lacp_rate?: number | string;
        /**
         * Specify a unique clag_id for every dual connected bond on each peer switch. The value must be between 1 and 65535 and must be the same on both peer switches in order for the bond to be considered dual-connected.
         */
        clag_id?: string;
        /**
         * Default: layer3+4
         *
         * Transmit load balancing algorithm. As of Cumulus Linux 2.5 only I(layer3+4) policy is supported.
         */
        xmit_hash_policy?: string;
        /**
         * Enables admin edge port.
         */
        mstpctl_portadminedge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * Minimum number of links.
         */
        min_links?: number | string;
        /**
         * Description of the port.
         */
        alias_name?: string;
        /**
         * Enables BPDU Guard on a port in vlan-aware mode.
         */
        mstpctl_bpduguard?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: ['/etc/network/interfaces.d']
         *
         * Interface directory location.
         */
        location?: string;
        /**
         * List of IPv6 addresses to configure on the interface. In the form I(X:X:X::X/YYY).
         */
        ipv6?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * In vlan-aware mode, lists VLANs defined under the interface.
         */
        vids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Enables bridge assurance in vlan-aware mode.
         */
        mstpctl_portnetwork?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of IPv4 addresses to configure on the interface. In the form I(X.X.X.X/YY).
         */
        ipv4?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Define IPv4 virtual IP used by the Cumulus Linux VRR feature.
         */
        virtual_ip?: string;
        /**
         * Default: 100
         *
         * The mii link monitoring interval.
         */
        miimon?: number | string;
        /**
         * Define Ethernet mac associated with Cumulus Linux VRR feature.
         */
        virtual_mac?: string;
        /**
         * Activate all interfaces for bypass. It is recommended to configure all_active instead of using bypass_priority.
         */
        lacp_bypass_all_active?: number | string;
        /**
         * Period for enabling LACP bypass. Max value is 900.
         */
        lacp_bypass_period?: number | string;
        /**
         * Enable LACP bypass.
         */
        lacp_bypass_allow?: number | string;
        /**
         * List of ports and priorities. Example I("swp1=10, swp2=20").
         */
        lacp_bypass_priority?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Configures the port to use DHCP. To enable this feature use the option I(dhcp).
         */
        addr_method?: "" | "dhcp";
        /**
         * Name of the interface.
         */
        name: string;
        /**
         * Set MTU. Configure Jumbo Frame by setting MTU to I(9000).
         */
        mtu?: string;
        /**
         * In vlan-aware mode, defines vlan that is the untagged vlan.
         */
        pvid?: string;
        /**
         * Default: 802.3ad
         *
         * The bond mode, as of Cumulus Linux 2.5 only LACP bond mode is supported.
         */
        mode?: string;
        /**
         * Bond members.
         */
        slaves:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Allows to post events to DataDog (www.datadoghq.com) service.
       * Uses http://docs.datadoghq.com/api/#events API.
       */
      datadog_event?: {
        /**
         * Default: now
         *
         * POSIX timestamp of the event.
         * Default value is now.
         */
        date_happened?: number | string;
        /**
         * Default: info
         *
         * Type of alert.
         */
        alert_type?: "error" | "warning" | "info" | "success";
        /**
         * The event title.
         */
        title: string;
        /**
         * The body of the event.
         */
        text: string;
        /**
         * Comma separated list of tags to apply to the event.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Your DataDog app key.
         */
        app_key: string;
        /**
         * Default: normal
         *
         * The priority of the event.
         */
        priority?: "normal" | "low";
        /**
         * An arbitrary string to use for aggregation.
         */
        aggregation_key?: string;
        /**
         * Your DataDog API key.
         */
        api_key: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage limits of resources for domains, accounts and projects.
       */
      cs_resourcelimit?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Creates or terminates ec2 instances.
       * C(state=restarted) was added in 2.2
       */
      ec2?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or Remove key pair from nova .
       */
      nova_keypair?: {
        /**
         * Default: None
         *
         * The public key that would be uploaded to nova and injected to vm's upon creation
         */
        public_key?: string;
        /**
         * Default: None
         *
         * Name of the region
         */
        region_name?: string;
        availability_zone?: string;
        /**
         * Default: yes
         *
         * The tenant name of the login user
         */
        login_tenant_name?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: "present" | "absent";
        /**
         * Default: http://127.0.0.1:35357/v2.0/
         *
         * The keystone url for authentication
         */
        auth_url?: string;
        /**
         * Default: yes
         *
         * Password of login user
         */
        login_password: string;
        /**
         * Default: admin
         *
         * login username to authenticate to keystone
         */
        login_username?: string;
        /**
         * Default: None
         *
         * Name that has to be given to the key pair
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manage bower packages with bower
       */
      bower?: {
        /**
         * The name of a bower package to install
         */
        name?: string;
        /**
         * Default: present
         *
         * The state of the bower package
         */
        state?: "present" | "absent" | "latest";
        /**
         * Install with --production flag
         */
        production?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The version to be installed
         */
        version?: string;
        /**
         * Relative path to bower executable from install path
         */
        relative_execpath?: string;
        /**
         * The base path where to install the bower packages
         */
        path: string;
        /**
         * Install packages from local cache, if the packages were installed before
         */
        offline?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Execute vrouter-ospf-add, vrouter-ospf-remove command.
       * This command adds/removes Open Shortest Path First(OSPF) area to/from a virtual router(vRouter) service.
       */
      pn_ospfarea?: {
        /**
         * Specify the OSPF area number.
         */
        pn_ospf_area: string;
        /**
         * Login password.
         */
        pn_clipassword: string;
        /**
         * Specify the name of the vRouter.
         */
        pn_vrouter_name: string;
        /**
         * Login username.
         */
        pn_cliusername: string;
        /**
         * OSPF prefix list for filtering incoming packets.
         */
        pn_prefix_listin?: string;
        /**
         * State the action to perform. Use 'present' to add ospf-area, 'absent' to remove ospf-area and 'update' to modify ospf-area.
         */
        state: "present" | "absent" | "update";
        /**
         * OSPF prefix list for filtering outgoing packets.
         */
        pn_prefix_listout?: string;
        /**
         * Specify the OSPF stub type.
         */
        pn_stub_type?: "none" | "stub" | "stub-no-summary" | "nssa" | "nssa-no-summary";
        /**
         * Target switch(es) to run the CLI on.
         */
        pn_cliswitch?: string;
        /**
         * Default: True
         *
         * Enable/disable system information.
         */
        pn_quiet?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Netconf is a network management protocol developed and standardized by the IETF. It is documented in RFC 6241.
       * This module allows the user to send a configuration XML file to a netconf device, and detects if there was a configuration change.
       */
      netconf_config?: {
        /**
         * the XML content to send to the device
         */
        xml: string;
        /**
         * the username to authenticate with
         */
        username: string;
        /**
         * the hostname or ip address of the netconf device
         */
        host: string;
        /**
         * Default: True
         *
         * if true, the ssh host key of the device must match a ssh key present on the host
         * if false, the ssh host key of the device is not checked
         */
        hostkey_verify?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * password of the user to authenticate with
         */
        password: string;
        /**
         * Default: 830
         *
         * the netconf port
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, start, stop and delete Solaris zones. This module doesn't currently allow changing of options for a zone that's already been created.
       */
      solaris_zone?: {
        /**
         * Default: empty string
         *
         * Extra options to the zoneadm(1M) install command. To automate Solaris 11 zone creation, use this to specify the profile XML file, e.g. install_options="-c sc_profile.xml"
         */
        install_options?: string;
        /**
         * Default: 600
         *
         * Timeout, in seconds, for zone to boot.
         */
        timeout?: number | string;
        /**
         * Default: empty string
         *
         * Extra options to the zonecfg(1M) create command.
         */
        create_options?: string;
        /**
         * Default: present
         *
         * C(present), configure and install the zone.
         * C(installed), synonym for C(present).
         * C(running), if the zone already exists, boot it, otherwise, configure and install the zone first, then boot it.
         * C(started), synonym for C(running).
         * C(stopped), shutdown a zone.
         * C(absent), destroy the zone.
         * C(configured), configure the ready so that it's to be attached.
         * C(attached), attach a zone, but do not boot it.
         * C(detached), shutdown and detach a zone
         */
        state?:
          | "present"
          | "installed"
          | "started"
          | "running"
          | "stopped"
          | "absent"
          | "configured"
          | "attached"
          | "detached";
        /**
         * The password hash for the root account. If not specified, the zone's root account will not have a password.
         */
        root_password?: string;
        /**
         * Whether to create a sparse (C(true)) or whole root (C(false)) zone.
         */
        sparse?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The path where the zone will be created. This is required when the zone is created, but not used otherwise.
         */
        path?: string;
        /**
         * Default: empty string
         *
         * The zonecfg configuration commands for this zone. See zonecfg(1M) for the valid options and syntax. Typically this is a list of options separated by semi-colons or new lines, e.g. "set auto-boot=true;add net;set physical=bge0;set address=10.1.1.1;end"
         */
        config?: string;
        /**
         * Default: empty string
         *
         * Extra options to the zoneadm attach command. For example, this can be used to specify whether a minimum or full update of packages is required and if any packages need to be deleted. For valid values, see zoneadm(1M)
         */
        attach_options?: string;
        /**
         * Zone name.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Reboot a network device.
       */
      nxos_reboot?: {
        /**
         * Safeguard boolean. Set to true if you're sure you want to reboot.
         */
        confirm?: string;
        [k: string]: unknown;
      };
      /**
       * The M(copy) module copies a file on the local box to remote locations. Use the M(fetch) module to copy files from remote locations to the local box. If you need variable interpolation in copied files, use the M(template) module.
       */
      copy?: {
        [k: string]: unknown;
      };
      /**
       * The M(unarchive) module unpacks an archive. By default, it will copy the source file from the local system to the target before unpacking - set remote_src=yes to unpack an archive which already exists on the target..
       */
      unarchive?: {
        /**
         * If remote_src=no (default), local path to archive file to copy to the target server; can be absolute or relative. If remote_src=yes, path on the target server to existing archive file to unpack.
         * If remote_src=yes and src contains ://, the remote machine will download the file from the url first. (version_added 2.0)
         */
        src: string;
        /**
         * Default: no
         *
         * Set to C(yes) to indicate the archived file is already on the remote system and not local to the Ansible controller.
         * This option is mutually exclusive with C(copy).
         */
        remote_src?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Remote absolute path where the archive should be unpacked
         */
        dest: string;
        /**
         * Default: no
         *
         * If set to True, return the list of files that are contained in the tarball.
         */
        list_files?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Do not replace existing files that are newer than files from the archive.
         */
        keep_newer?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * a filename, when it already exists, this step will B(not) be run.
         */
        creates?: string;
        original_basename?: string;
        /**
         * List the directory and file entries that you would like to exclude from the unarchive action.
         */
        exclude?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Specify additional options by passing in an array.
         */
        extra_opts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: yes
         *
         * If true, the file is copied from local 'master' to the target machine, otherwise, the plugin will look for src archive at the target machine.
         * This option has been deprecated in favor of C(remote_src)
         * This option is mutually exclusive with C(remote_src).
         */
        copy?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * This only applies if using a https url as the source of the file.
         * This should only set to C(no) used on personally controlled sites using self-signed cer
         * Prior to 2.2 the code worked as if this was set to C(yes).
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Migrates a virtual machine from a standard vswitch to distributed
       */
      vmware_vm_vss_dvs_migrate?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * The M(pam_limits) module modify PAM limits, default in /etc/security/limits.conf. For the full documentation, see man limits.conf(5).
       */
      pam_limits?: {
        /**
         * Comment associated with the limit.
         */
        comment?: string;
        /**
         * Default: no
         *
         * If set to C(yes), the maximal value will be used or conserved. If the specified value is superior to the value in the file, file content is replaced with the new value, else content is not modified.
         */
        use_max?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A username, @groupname, wildcard, uid/gid range.
         */
        domain: string;
        /**
         * Default: /etc/security/limits.conf
         *
         * Modify the limits.conf path.
         */
        dest?: string;
        /**
         * The value of the limit.
         */
        value: string;
        /**
         * Default: no
         *
         * If set to C(yes), the minimal value will be used or conserved. If the specified value is inferior to the value in the file, file content is replaced with the new value, else content is not modified.
         */
        use_min?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The limit to be set
         */
        limit_item:
          | "core"
          | "data"
          | "fsize"
          | "memlock"
          | "nofile"
          | "rss"
          | "stack"
          | "cpu"
          | "nproc"
          | "as"
          | "maxlogins"
          | "maxsyslogins"
          | "priority"
          | "locks"
          | "sigpending"
          | "msgqueue"
          | "nice"
          | "rtprio"
          | "chroot";
        /**
         * Limit type, see C(man limits) for an explanation
         */
        limit_type: "hard" | "soft" | "-";
        /**
         * Default: no
         *
         * Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * makes an OS computer speak!  Amuse your friends, annoy your coworkers!
       */
      osx_say?: {
        /**
         * What to say
         */
        msg: string;
        /**
         * What voice to use
         */
        voice?: string;
        [k: string]: unknown;
      };
      /**
       * Templates are processed by the Jinja2 templating language (U(http://jinja.pocoo.org/docs/)) - documentation on the template formatting can be found in the Template Designer Documentation (U(http://jinja.pocoo.org/docs/templates/)).
       * Six additional variables can be used in templates: C(ansible_managed) (configurable via the C(defaults) section of C(ansible.cfg)) contains a string which can be used to describe the template name, host, modification time of the template file and the owner uid, C(template_host) contains the node name of the template's machine, C(template_uid) the owner, C(template_path) the absolute path of the template, C(template_fullpath) is the absolute path of the template, and C(template_run_date) is the date that the template was rendered. Note that including a string that uses a date in the template will result in the template being marked 'changed' each time.
       */
      win_template?: {
        /**
         * Location to render the template to on the remote machine.
         */
        dest?: string;
        /**
         * Path of a Jinja2 formatted template on the local server. This can be a relative or absolute path.
         */
        src?: string;
        [k: string]: unknown;
      };
      /**
       * Manages global, zone, account, storage and cluster configurations.
       */
      cs_configuration?: {
        /**
         * Default: ROOT
         *
         * Domain the account is related to.
         * Only considered if C(account) is used.
         */
        domain?: string;
        api_key?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Ensure the value for corresponding storage pool.
         */
        storage?: string;
        api_region?: string;
        /**
         * Value of the configuration.
         */
        value: string;
        /**
         * Ensure the value for corresponding cluster.
         */
        cluster?: string;
        /**
         * Ensure the value for corresponding account.
         */
        account?: string;
        /**
         * Ensure the value for corresponding zone.
         */
        zone?: string;
        /**
         * Name of the configuration.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manage (add, remove, change) individual settings in an INI-style file without having to manage the file as a whole with, say, M(template) or M(assemble). Adds missing sections if they don't exist.
       * Before version 2.0, comments are discarded when the source file is read, and therefore will not show up in the destination file.
       */
      ini_file?: {
        /**
         * if set (required for changing a I(value)), this is the name of the option.
         * May be omitted if adding/removing a whole I(section).
         */
        option?: string;
        /**
         * Path to the INI-style file; this file is created if required
         */
        dest: string;
        /**
         * Default: yes
         *
         * If set to 'no', the module will fail if the file does not already exist. By default it will create the file if it is missing.
         */
        create?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * do not insert spaces before and after '=' symbol
         */
        no_extra_spaces?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * the string value to be associated with an I(option). May be omitted when removing an I(option).
         */
        value?: string;
        /**
         * Default: present
         *
         * If set to C(absent) the option or section will be removed if present instead of created.
         */
        state?: "present" | "absent";
        /**
         * Default: no
         *
         * Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Section name in INI file. This is added if C(state=present) automatically when a single value is being set.
         */
        section: string;
        [k: string]: unknown;
      };
      /**
       * Manage VMware vSphere Datacenters
       */
      vmware_datacenter?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Can create or delete scaling policies for autoscaling groups
       * Referenced autoscaling groups must already exist
       */
      ec2_scaling_policy?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * creates / deletes a Rackspace Public Cloud load balancer.
       */
      rax_clb?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Returns list of matching Launch Configurations for a given name, along with other useful information
       * Results can be sorted and sliced
       * It depends on boto
       * Based on the work by Tom Bamford (https://github.com/tombamford)
       */
      ec2_lc_find?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage InfluxDB databases
       */
      influxdb_database?: {
        /**
         * Default: root
         *
         * Username that will be used to authenticate against InfluxDB server
         */
        username?: string;
        /**
         * Name of the database that will be created/destroyed
         */
        database_name: string;
        /**
         * The hostname or IP address on which InfluxDB server is listening
         */
        hostname: string;
        /**
         * Default: present
         *
         * Determines if the database should be created or destroyed
         */
        state?: "present" | "absent";
        /**
         * Default: root
         *
         * Password that will be used to authenticate against InfluxDB server
         */
        password?: string;
        /**
         * Default: 8086
         *
         * The port on which InfluxDB server is listening
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages Citrix NetScaler server and service entities.
       */
      netscaler?: {
        /**
         * Default: hostname
         *
         * name of the entity
         */
        name?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: https
         *
         * protocol used to access netscaler
         */
        nsc_protocol?: string;
        /**
         * hostname or ip of your netscaler
         */
        nsc_host: string;
        /**
         * username
         */
        user: string;
        /**
         * Default: disable
         *
         * the action you want to perform on the entity
         */
        action?: "enable" | "disable";
        /**
         * password
         */
        password: string;
        /**
         * Default: server
         *
         * type of the entity
         */
        type?: "server" | "service";
        [k: string]: unknown;
      };
      /**
       * This module affects the configuration files located in the interfaces folder defined by ifupdown2. Interfaces port and port ranges listed in the "allowed" parameter define what interfaces will be available on the switch. If the user runs this module and has an interface configured on the switch, but not found in the "allowed" list, this interface will be unconfigured. By default this is `/etc/network/interface.d` For more details go the Configuring Interfaces at U(http://docs.cumulusnetworks.com).
       */
      cl_interface_policy?: {
        /**
         * Default: /etc/network/interfaces.d/
         *
         * Directory to store interface files.
         */
        location?: string;
        /**
         * List of ports to run initial run at 10G.
         */
        allowed:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM tcp monitors via iControl SOAP API
       */
      bigip_monitor_tcp?: {
        /**
         * Default: none
         *
         * The interval specifying how frequently the monitor instance of this template will run. By default, this interval is used for up and down states. The default API setting is 5.
         */
        interval?: string;
        /**
         * Monitor name
         */
        name?: string;
        /**
         * Default: tcp
         *
         * The parent template of this monitor template
         */
        parent?: string;
        /**
         * Default: none
         *
         * The receive string for the monitor call
         */
        receive?: string;
        /**
         * Default: none
         *
         * IP address part of the ipport definition. The default API setting is "0.0.0.0".
         */
        ip?: string;
        /**
         * Default: Common
         *
         * Partition for the monitor
         */
        partition?: string;
        /**
         * Default: none
         *
         * The send string for the monitor call
         */
        send?: string;
        /**
         * Default: present
         *
         * Monitor state
         */
        state?: string;
        /**
         * Default: none
         *
         * Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. The default API setting is 0.
         */
        time_until_up?: string;
        /**
         * Default: none
         *
         * The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. The default API setting is 16.
         */
        timeout?: string;
        /**
         * Default: Common
         *
         * Partition for the parent monitor
         */
        parent_partition?: string;
        /**
         * Default: tcp
         *
         * The template type of this monitor template
         */
        type?: string;
        /**
         * Default: none
         *
         * Port address part op the ipport definition. The default API setting is 0.
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * Network devices running the Junos operating system provide a command driven interface both over CLI and RPC.  This module provides an interface to execute commands using these functions and return the results to the Ansible playbook.  In addition, this module can specify a set of conditionals to be evaluated against the returned output, only returning control to the playbook once the entire set of conditionals has been met.
       */
      junos_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed.  The command is run on the target device every retry and evaluated against the I(waitfor) conditionals.
         */
        retries?: string;
        /**
         * The C(commands) to send to the remote device over the Netconf transport.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.
         */
        commands?: string;
        /**
         * The C(rpcs) argument accepts a list of RPCs to be executed over a netconf session and the results from the RPC execution is return to the playbook via the modules results dictionary.
         */
        rpcs?: string;
        /**
         * Default: xml
         *
         * Configures the encoding scheme to use when serializing output from the device.  This handles how to properly understand the output and apply the conditionals path to the result set.
         */
        format?: string;
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between retries of the command.  If the command does not pass the specified conditional, the interval indicates how to long to wait before trying the command again.
         */
        interval?: string;
        /**
         * Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.
         */
        wait_for?: string;
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the I(wait_for) must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about a one or more OpenStack projects
       */
      os_project_facts?: {
        /**
         * Default: None
         *
         * Name or ID of the domain containing the project if the cloud supports domains
         */
        domain?: string;
        /**
         * Name or ID of the project
         */
        name?: string;
        /**
         * Default: None
         *
         * A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
         */
        filters?: string;
        [k: string]: unknown;
      };
      /**
       * osx_defaults allows users to read, write, and delete Mac OS X user defaults from Ansible scripts. Mac OS X applications and other programs use the defaults system to record user preferences and other information that must be maintained when the applications aren't running (such as default font for new documents, or the position of an Info panel).
       */
      osx_defaults?: {
        /**
         * Default: NSGlobalDomain
         *
         * The domain is a domain name of the form com.companyname.appname.
         */
        domain?: string;
        /**
         * Default: present
         *
         * The state of the user defaults
         */
        state?: "present" | "absent";
        /**
         * The value to write. Only required when state = present.
         */
        value?: string;
        /**
         * The host on which the preference should apply. The special value "currentHost" corresponds to the "-currentHost" switch of the defaults commandline tool.
         */
        host?: string;
        /**
         * The key of the user preference
         */
        key?: string;
        path?: string;
        /**
         * Default: string
         *
         * The type of value to write.
         */
        type?: "array" | "bool" | "boolean" | "date" | "float" | "int" | "integer" | "string";
        /**
         * Add new elements to the array for a key which has an array as its value.
         */
        array_add?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create, update and remove static NATs.
       */
      cs_staticnat?: {
        /**
         * VM guest NIC secondary IP address for the static NAT.
         */
        vm_guest_ip?: string;
        /**
         * Domain the static NAT is related to.
         */
        domain?: string;
        api_key?: string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Network the IP address is related to.
         */
        network?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Name of virtual machine which we make the static NAT for.
         * Required if C(state=present).
         */
        vm?: string;
        api_region?: string;
        /**
         * Name of the project the static NAT is related to.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the static NAT.
         */
        state?: "present" | "absent";
        /**
         * Account the static NAT is related to.
         */
        account?: string;
        /**
         * Name of the zone in which the virtual machine is in.
         * If not set, default zone is used.
         */
        zone?: string;
        /**
         * Public IP address the static NAT is assigned to.
         */
        ip_address: string;
        api_url?: string;
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running OS6.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      dellos6_facts?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Manage the atomic host platform
       * Rebooting of Atomic host platform should be done outside this module
       */
      atomic_host?: {
        [k: string]: unknown;
      };
      /**
       * This module fails the progress with a custom message. It can be useful for bailing out when a certain condition is met using C(when).
       */
      fail?: {
        host?: string;
        connect_timeout?: number | string;
        delay?: number | string;
        state?: "started" | "stopped" | "present" | "absent" | "drained";
        timeout?: number | string;
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        search_regex?: string;
        path?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Management of LXC containers
       */
      lxc_container?: {
        /**
         * Create zfs under given zfsroot.
         */
        zfs_root?: string;
        /**
         * Name of the new cloned server. This is only used when state is clone.
         */
        clone_name?: string;
        /**
         * list of 'key=value' options to use when configuring a container.
         */
        container_config?: string;
        /**
         * Default: ext4
         *
         * Create fstype TYPE.
         */
        fs_type?: string;
        /**
         * Create an archive of a container. This will create a tarball of the running container.
         */
        archive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enable a container log for host actions to the container.
         */
        container_log?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: started
         *
         * Define the state of a container. If you clone a container using `clone_name` the newly cloned container created in a stopped state. The running container will be stopped while the clone operation is happening and upon completion of the clone the original container state will be restored.
         */
        state?: "absent" | "restarted" | "started" | "clone" | "frozen" | "stopped";
        /**
         * Default: ubuntu
         *
         * Name of the template to use within an LXC create.
         */
        template?: string;
        /**
         * Path to the LXC configuration file.
         */
        config?: string;
        /**
         * Path the save the archived container. If the path does not exist the archive method will attempt to create it.
         */
        archive_path?: string;
        /**
         * Default: INFO
         *
         * Set the log level for a container where *container_log* was set.
         */
        container_log_level?: "info" | "INFO" | "Info" | "debug" | "DEBUG" | "Debug" | "error" | "ERROR" | "Error";
        /**
         * Template options when building the container.
         */
        template_options?: string;
        /**
         * Run a command within a container.
         */
        container_command?: string;
        /**
         * Place container under PATH
         */
        lxc_path?: string;
        /**
         * Default: gzip
         *
         * Type of compression to use when creating an archive of a running container.
         */
        archive_compression?: "gzip" | "bzip2" | "none";
        /**
         * Use LVM thin pool called TP.
         */
        thinpool?: string;
        /**
         * Create a snapshot a container when cloning. This is not supported by all container storage backends. Enabling this may fail if the backing store does not support snapshots.
         */
        clone_snapshot?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of a container.
         */
        name: string;
        /**
         * Default: $CONTAINER_NAME
         *
         * Name of the logical volume, defaults to the container name.
         */
        lv_name?: string;
        /**
         * Default: 5G
         *
         * File system Size.
         */
        fs_size?: string;
        /**
         * Default: dir
         *
         * Backend storage type for the container.
         */
        backing_store?: "dir" | "lvm" | "loop" | "btrfs" | "overlayfs" | "zfs";
        /**
         * Default: lxc
         *
         * If Backend store is lvm, specify the name of the volume group.
         */
        vg_name?: string;
        /**
         * Place rootfs directory under DIR.
         */
        directory?: string;
        [k: string]: unknown;
      };
      /**
       * Offers ability to enable and disable features in NX-OS.
       */
      nxos_feature?: {
        /**
         * Default: enabled
         *
         * Desired state of the feature.
         */
        state?: string;
        /**
         * Name of feature.
         */
        feature?: string;
        [k: string]: unknown;
      };
      /**
       * Use to enable or disable eAPI access, and set the port and state of http, https, local_http and unix-socket servers.
       * When enabling eAPI access the default is to enable HTTP on port 80, enable HTTPS on port 443, disable local HTTP, and disable Unix socket server. Use the options listed below to override the default configuration.
       * Requires EOS v4.12 or greater.
       */
      eos_eapi?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates (empty) files, updates file modification stamps of existing files, and can create or remove directories. Unlike M(file), does not modify ownership, permissions or manipulate links.
       */
      win_file?: {
        /**
         * path to the file being managed.  Aliases: I(dest), I(name)
         */
        path?: string;
        /**
         * Default: file
         *
         * If C(directory), all immediate subdirectories will be created if they do not exist. If C(file), the file will NOT be created if it does not exist, see the M(copy) or M(template) module if you want that behavior.  If C(absent), directories will be recursively deleted, and files will be removed. If C(touch), an empty file will be created if the c(path) does not exist, while an existing file or directory will receive updated file access and modification times (similar to the way `touch` works from the command line).
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * Send code deploy and annotation events to Stackdriver
       */
      stackdriver?: {
        /**
         * The repository (or project) deployed
         */
        repository?: string;
        /**
         * Default: INFO
         *
         * one of INFO/WARN/ERROR, defaults to INFO if not supplied. May affect display.
         */
        level?: "INFO" | "WARN" | "ERROR";
        /**
         * Default: Ansible
         *
         * The person or robotwho the annotation should be attributed to.
         */
        annotated_by?: string;
        /**
         * Default: Ansible
         *
         * The person or robot responsible for deploying the code
         */
        deployed_by?: string;
        /**
         * The environment code was deployed to. (ie: development, staging, production)
         */
        deployed_to?: string;
        /**
         * id of an EC2 instance that this event should be attached to, which will limit the contexts where this event is shown
         */
        instance_id?: string;
        /**
         * API key.
         */
        key: string;
        /**
         * The contents of the annotation message, in plain text. Limited to 256 characters. Required for annotation.
         */
        msg?: string;
        /**
         * Unix timestamp of where the event should appear in the timeline, defaults to now. Be careful with this.
         */
        event_epoch?: string;
        /**
         * The revision of the code that was deployed. Required for deploy events
         */
        revision_id?: string;
        /**
         * The type of event to send, either annotation or deploy
         */
        event: "annotation" | "deploy";
        [k: string]: unknown;
      };
      /**
       * Searches, downloads, and installs Windows updates synchronously by automating the Windows Update client
       */
      win_updates?: {
        /**
         * If set, win_updates will append update progress to the specified file. The directory must already exist.
         */
        log_path?: string;
        /**
         * Default: installed
         *
         * Controls whether found updates are returned as a list or actually installed.
         * This module also supports Ansible check mode, which has the same effect as setting state=searched
         */
        state?: string;
        /**
         * Default: ['CriticalUpdates', 'SecurityUpdates', 'UpdateRollups']
         *
         * A scalar or list of categories to install updates from
         */
        category_names?: string;
        [k: string]: unknown;
      };
      znode?: {
        /**
         * The path of the znode.
         */
        name: string;
        /**
         * Default: None
         *
         * The value assigned to the znode.
         */
        value?: string;
        /**
         * Default: None
         *
         * The state to enforce. Mutually exclusive with op.
         */
        state?: "present" | "absent";
        /**
         * A list of ZooKeeper servers (format '[server]:[port]').
         */
        hosts: string;
        /**
         * Default: 300
         *
         * The amount of time to wait for a node to appear.
         */
        timeout?: number | string;
        /**
         * Default: None
         *
         * An operation to perform. Mutually exclusive with state.
         */
        op?: "get" | "wait" | "list";
        /**
         * Recursively delete node and all its children.
         */
        recursive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages filesystem user defined extended attributes, requires that they are enabled on the target filesystem and that the setfattr/getfattr utilities are present.
       */
      xattr?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Retrieve facts about one or more subnets from OpenStack.
       */
      os_subnets_facts?: {
        /**
         * Name or ID of the subnet
         */
        subnet?: string;
        /**
         * A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
         */
        filters?: string;
        [k: string]: unknown;
      };
      /**
       * creates / deletes a Rackspace Public Cloud instance and optionally waits for it to be 'running'.
       */
      rax?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Gathers Vertica database facts.
       */
      vertica_facts?: {
        /**
         * Default: dbadmin
         *
         * The username used to authenticate with.
         */
        login_user?: string;
        /**
         * Default: localhost
         *
         * Name of the cluster running the schema.
         */
        cluster?: string;
        /**
         * Name of the database running the schema.
         */
        db?: string;
        /**
         * Default: 5433
         *
         * Database port to connect to.
         */
        port?: string;
        /**
         * The password used to authenticate with.
         */
        login_password?: string;
        [k: string]: unknown;
      };
      /**
       * Acquires and associates a public IP to an account or project. Due to API limitations this is not an idempotent call, so be sure to only conditionally call this when C(state=present)
       */
      cs_ip_address?: {
        /**
         * Account the IP address is related to.
         */
        account?: string;
        api_key?: string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Name of the project the IP address is related to.
         */
        project?: string;
        state?: "present" | "absent";
        /**
         * Domain the IP address is related to.
         */
        domain?: string;
        /**
         * Name of the zone in which the IP address is in.
         * If not set, default zone is used.
         */
        zone?: string;
        /**
         * Public IP address.
         * Required if C(state=absent)
         */
        ip_address?: string;
        /**
         * VPC the IP address is related to.
         */
        vpc?: string;
        /**
         * Network the IP address is related to.
         */
        network?: string;
        [k: string]: unknown;
      };
      /**
       * Manages MySQL server replication, slave, master status get and change master host.
       */
      mysql_replication?: {
        ssl_key?: string;
        /**
         * does the host uses GTID based replication or not
         */
        master_auto_position?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * same as mysql variable
         */
        master_ssl_cert?: string;
        login_user?: string;
        /**
         * same as mysql variable
         */
        master_port?: number | string;
        /**
         * same as mysql variable
         */
        master_host?: string;
        /**
         * same as mysql variable
         */
        master_ssl_ca?: string;
        /**
         * same as mysql variable
         */
        master_ssl_cipher?: string;
        /**
         * same as mysql variable
         */
        relay_log_file?: string;
        /**
         * same as mysql variable
         */
        master_log_pos?: number | string;
        connect_timeout?: number | string;
        /**
         * same as mysql variable
         */
        relay_log_pos?: number | string;
        /**
         * same as mysql variable
         */
        master_password?: string;
        config_file?: string;
        /**
         * same as mysql variable
         */
        master_ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        login_host?: string;
        /**
         * same as mysql variable
         */
        master_ssl_capath?: string;
        login_unix_socket?: string;
        /**
         * same as mysql variable
         */
        master_connect_retry?: number | string;
        /**
         * same as mysql variable
         */
        master_user?: string;
        login_password?: string;
        /**
         * same as mysql variable
         */
        master_log_file?: string;
        login_port?: number | string;
        ssl_cert?: string;
        ssl_ca?: string;
        /**
         * same as mysql variable
         */
        master_ssl_key?: string;
        /**
         * Default: getslave
         *
         * module operating mode. Could be getslave (SHOW SLAVE STATUS), getmaster (SHOW MASTER STATUS), changemaster (CHANGE MASTER TO), startslave (START SLAVE), stopslave (STOP SLAVE), resetslave (RESET SLAVE), resetslaveall (RESET SLAVE ALL)
         */
        mode?: "getslave" | "getmaster" | "changemaster" | "stopslave" | "startslave" | "resetslave" | "resetslaveall";
        [k: string]: unknown;
      };
      /**
       * Create or terminate AWS virtual private clouds.  This module has a dependency on python-boto.
       */
      ec2_vpc_net?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Module allows create, search and destroy Amazon EFS file systems
       */
      efs?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or remove Zypper repositories on SUSE and openSUSE
       */
      zypper_repository?: {
        [k: string]: unknown;
      };
      /**
       * Add or Remove images from the OpenStack Image Repository
       */
      os_image?: {
        /**
         * Default: None
         *
         * The name of an existing ramdisk image that will be associated with this image
         */
        ramdisk?: string;
        /**
         * Default: None
         *
         * The name of an existing kernel image that will be associated with this image
         */
        kernel?: string;
        /**
         * Default: None
         *
         * Name that has to be given to the image
         */
        name?: string;
        /**
         * Default: bare
         *
         * The format of the container
         */
        container_format?: string;
        /**
         * Default: None
         *
         * The minimum ram (in MB) required to boot this image
         */
        min_ram?: string;
        /**
         * Default: qcow2
         *
         * The format of the disk that is getting uploaded
         */
        disk_format?: string;
        /**
         * Default: None
         *
         * The path to the file which has to be uploaded
         */
        filename?: string;
        /**
         * Default: None
         *
         * The minimum disk space (in GB) required to boot this image
         */
        min_disk?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: None
         *
         * The owner of the image
         */
        owner?: string;
        /**
         * Default: yes
         *
         * Whether the image can be accessed publicly. Note that publicizing an image requires admin role by default.
         */
        is_public?: string;
        /**
         * Additional properties to be associated with this image
         */
        properties?: string;
        [k: string]: unknown;
      };
      /**
       * Create/remove Docker networks and connect containers to them.
       * Performs largely the same function as the "docker network" CLI subcommand.
       */
      docker_network?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Create a keypair for use with Rackspace Cloud Servers
       */
      rax_keypair?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Use variables to create new hosts and groups in inventory for use in later plays of the same playbook. Takes variables so you can define the new hosts more fully.
       */
      add_host?: {
        /**
         * The hostname/ip of the host to add to the inventory, can include a colon and a port number.
         */
        name?: string;
        /**
         * The groups to add the hostname to, comma separated.
         */
        groups?: string;
        [k: string]: unknown;
      };
      /**
       * Sets machine time to the specified timezone, the module will check if the provided timezone is supported on the machine.
       */
      win_timezone?: {
        /**
         * Timezone to set to.  Example Central Standard Time
         */
        timezone?: string;
        [k: string]: unknown;
      };
      /**
       * Manages Elasticsearch plugins.
       */
      elasticsearch_plugin?: {
        /**
         * Default: /usr/share/elasticsearch/bin/plugin
         *
         * Location of the plugin binary
         */
        plugin_bin?: string;
        /**
         * Default: None
         *
         * Proxy host to use during plugin installation
         */
        proxy_host?: string;
        /**
         * Default: None
         *
         * Set exact URL to download the plugin from (Only works for ES 1.x)
         */
        url?: string;
        /**
         * Default: None
         *
         * Proxy port to use during plugin installation
         */
        proxy_port?: string;
        /**
         * Default: present
         *
         * Desired state of a plugin.
         */
        state?: "present" | "absent";
        /**
         * Default: None
         *
         * Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated
         */
        version?: string;
        /**
         * Default: 1m
         *
         * Timeout setting: 30s, 1m, 1h...
         */
        timeout?: string;
        /**
         * Default: /usr/share/elasticsearch/plugins/
         *
         * Your configured plugin directory specified in Elasticsearch
         */
        plugin_dir?: string;
        /**
         * Name of the plugin to install. In ES 2.x, the name can be an url or file location
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manage NTP servers on a BIG-IP
       */
      bigip_device_ntp?: {
        /**
         * A list of NTP servers to set on the device. At least one of C(ntp_servers) or C(timezone) is required.
         */
        ntp_servers?: string;
        /**
         * Default: UTC
         *
         * The timezone to set for NTP lookups. At least one of C(ntp_servers) or C(timezone) is required.
         */
        timezone?: string;
        /**
         * Default: present
         *
         * The state of the NTP servers on the system. When C(present), guarantees that the NTP servers are set on the system. When C(absent), removes the specified NTP servers from the device configuration.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * Create and optionally attach an Elastic Network Interface (ENI) to an instance. If an ENI ID or private_ip is       provided, the existing ENI (if any) will be modified. The 'attached' parameter controls the attachment status       of the network interface.
       */
      ec2_eni?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages configuration of a Protocol Independent Multicast (PIM) instance.
       */
      nxos_pim?: {
        /**
         * Configure group ranges for Source Specific Multicast (SSM). Valid values are multicast addresses or the keyword 'none'.
         */
        ssm_range?: string;
        [k: string]: unknown;
      };
      /**
       * OpenSwitch configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with ops configuration sections in a deterministic way.
       */
      ops_config?: {
        /**
         * The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.
         */
        src?: string;
        /**
         * The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.
         * Note this argument should be considered deprecated.  To achieve the equivalent, set the C(match=none) which is idempotent.  This argument will be removed in a future release.
         */
        force?: string;
        /**
         * The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
         */
        after?: string;
        /**
         * The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
         */
        lines?: string;
        /**
         * Default: line
         *
         * Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct.
         */
        replace?: string;
        /**
         * The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
         */
        parents?: string;
        /**
         * The C(save) argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.
         */
        save?: string;
        /**
         * The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
         */
        config?: string;
        /**
         * Default: line
         *
         * Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device.
         */
        match?: string;
        /**
         * The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
         */
        before?: string;
        [k: string]: unknown;
      };
      /**
       * Can create or delete AWS Autoscaling Configurations
       * Works with the ec2_asg module to manage Autoscaling Groups
       */
      ec2_lc?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * LogicMonitor is a hosted, full-stack, infrastructure monitoring platform.
       * This module collects facts about hosts abd host groups within your LogicMonitor account.
       */
      logicmonitor_facts?: {
        /**
         * Default: hostname -f
         *
         * The display name of a host in your LogicMonitor account or the desired display name of a device to add into monitoring.
         */
        displayname?: string;
        /**
         * The LogicMonitor object you wish to manage.
         */
        target: "host" | "hostgroup";
        /**
         * The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes".
         */
        company: string;
        /**
         * Default: hostname -f
         *
         * The hostname of a host in your LogicMonitor account, or the desired hostname of a device to add into monitoring.
         * Required for managing hosts (target=host).
         */
        hostname?: string;
        /**
         * A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.
         */
        user: string;
        /**
         * The fullpath of the hostgroup object you would like to manage.
         * Recommend running on a single ansible host.
         * Required for management of LogicMonitor host groups (target=hostgroup).
         */
        fullpath?: string;
        /**
         * The password for the chosen LogicMonitor User.
         * If an md5 hash is used, the digest flag must be set to true.
         */
        password: string;
        /**
         * The fully qualified domain name of a collector in your LogicMonitor account.
         * This is optional for querying a LogicMonitor host when a displayname is specified.
         * This is required for querying a LogicMonitor host when a displayname is not specified.
         */
        collector?: string;
        [k: string]: unknown;
      };
      /**
       * creates / deletes or resize a Rackspace Cloud Databases instance and optionally waits for it to be 'running'. The name option needs to be unique since it's used to identify the instance.
       */
      rax_cdb?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Return various information about NetApp E-Series storage arrays (eg, configuration, disks)
       */
      netapp_e_facts?: {
        /**
         * The ID of the array to manage. This value must be unique for each array.
         */
        ssid: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        [k: string]: unknown;
      };
      /**
       * Manage OpenStack Projects. Projects can be created, updated or deleted using this module. A project will be updated if I(name) matches an existing project and I(state) is present. The value for I(name) cannot be updated without deleting and re-creating the project.
       */
      os_project?: {
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: True
         *
         * Is the project enabled
         */
        enabled?: string;
        /**
         * Default: None
         *
         * Description for the project
         */
        description?: string;
        /**
         * Name for the project
         */
        name?: string;
        /**
         * Default: None
         *
         * Domain id to create the project in if the cloud supports domains. The domain_id parameter requires shade >= 1.8.0
         */
        domain_id?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 volume snapshots in AWS
       */
      ec2_snapshot_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages global VPC configuration
       */
      nxos_vpc?: {
        /**
         * VPC domain
         */
        domain?: string;
        /**
         * System priority device.  Remember they must match between peers.
         */
        system_priority?: string;
        /**
         * Role priority for device. Remember lower is better.
         */
        role_priority?: string;
        /**
         * Enables/Disables auto recovery
         */
        auto_recovery?: string;
        /**
         * Default: management
         *
         * VRF used for peer keepalive link
         */
        pkl_vrf?: string;
        /**
         * manages delay restore command and config value in seconds
         */
        delay_restore?: string;
        /**
         * Enables/Disables peer gateway
         */
        peer_gw?: string;
        /**
         * Manages desired state of the resource
         */
        state?: string;
        /**
         * Destination (remote) IP address used for peer keepalive link
         */
        pkl_dest?: string;
        /**
         * Source IP address used for peer keepalive link
         */
        pkl_src?: string;
        [k: string]: unknown;
      };
      /**
       * Manage the SSHD settings of a BIG-IP
       */
      bigip_device_sshd?: {
        /**
         * Specifies the minimum SSHD message level to include in the system log.
         */
        log_level?: string;
        /**
         * Specifies the text to include on the pre-login banner that displays when a user attempts to login to the system using SSH.
         */
        banner_text?: string;
        /**
         * Specifies, if you have enabled SSH access, the IP address or address range for other systems that can use SSH to communicate with this system.
         */
        allow?: string;
        /**
         * Specifies the number of seconds before inactivity causes an SSH session to log out.
         */
        inactivity_timeout?: string;
        /**
         * Specifies, when checked C(enabled), that the system accepts SSH communications.
         */
        login?: string;
        /**
         * Whether to enable the banner or not.
         */
        banner?: string;
        /**
         * Port that you want the SSH daemon to run on.
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * Manage I(bzr) branches to deploy files or software.
       */
      bzr?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Create, update, disable, lock, enable and remove users.
       */
      cs_user?: {
        /**
         * Username of the user.
         */
        username: string;
        /**
         * Default: ROOT
         *
         * Domain the user is related to.
         */
        domain?: string;
        /**
         * Last name of the user.
         * Required on C(state=present).
         */
        last_name?: string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Account the user will be created under.
         * Required on C(state=present).
         */
        account?: string;
        api_region?: string;
        api_key?: string;
        /**
         * Default: present
         *
         * State of the user.
         * C(unlocked) is an alias for C(enabled).
         */
        state?: "present" | "absent" | "enabled" | "disabled" | "locked" | "unlocked";
        /**
         * First name of the user.
         * Required on C(state=present).
         */
        first_name?: string;
        /**
         * Timezone of the user.
         */
        timezone?: string;
        /**
         * Password of the user to be created.
         * Required on C(state=present).
         * Only considered on creation and will not be updated if user exists.
         */
        password?: string;
        /**
         * Email of the user.
         * Required on C(state=present).
         */
        email?: string;
        [k: string]: unknown;
      };
      /**
       * Add, update and remove load balancer rules.
       */
      cs_loadbalancer_rule?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Create or remove a distributed vSwitch
       */
      vmware_dvswitch?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Creates and removes firewall rules.
       */
      cs_firewall?: {
        [k: string]: unknown;
      };
      /**
       * Manage subnets in AWS virtual private clouds
       */
      ec2_vpc_subnet?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Perform server actions on an existing compute instance from OpenStack. This module does not return any data other than changed true/false.
       */
      os_server_actions?: {
        /**
         * Default: present
         *
         * Perform the given action. The lock and unlock actions always return changed as the servers API does not provide lock status.
         */
        action?: string;
        /**
         * Default: yes
         *
         * If the module should wait for the instance action to be performed.
         */
        wait?: string;
        /**
         * Default: 180
         *
         * The amount of time the module should wait for the instance to perform the requested action.
         */
        timeout?: string;
        /**
         * Name or ID of the instance
         */
        server?: string;
        [k: string]: unknown;
      };
      /**
       * Adds, modifies and removes nodes from a Rackspace Cloud Load Balancer
       */
      rax_clb_nodes?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or remove MySQL databases from a remote host.
       */
      mysql_db?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Add or remove an I(apt) key, optionally downloading it
       */
      apt_key?: {
        key?: string;
        /**
         * Default: none
         *
         * keyserver to retrieve key from.
         */
        keyserver?: string;
        /**
         * Default: none
         *
         * url to retrieve key from.
         */
        url?: string;
        /**
         * Default: none
         *
         * keyfile contents to add to the keyring
         */
        data?: string;
        /**
         * Default: none
         *
         * path to specific keyring file in /etc/apt/trusted.gpg.d
         */
        keyring?: string;
        /**
         * Default: present
         *
         * used to specify if key is being added or revoked
         */
        state?: "absent" | "present";
        /**
         * Default: none
         *
         * path to a keyfile to add to the keyring
         */
        file?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: none
         *
         * identifier of key. Including this allows check mode to correctly report the changed state.
         * If specifying a subkey's id be aware that apt-key does not understand how to remove keys via a subkey id.  Specify the primary key's id instead.
         */
        id?: string;
        [k: string]: unknown;
      };
      /**
       * Creates/deletes an issue in a Taiga Project Management Platform (U(https://taiga.io)).
       * An issue is identified by the combination of project, issue subject and issue type.
       * This module implements the creation or deletion of issues (not the update).
       */
      taiga_issue?: {
        /**
         * Default: New
         *
         * The issue status. Must exist previously.
         */
        status?: string;
        /**
         * Name of the project containing the issue. Must exist previously.
         */
        project: string;
        /**
         * The issue description.
         */
        description?: string;
        /**
         * A lists of tags to be assigned to the issue.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: Normal
         *
         * The issue priority. Must exist previously.
         */
        priority?: string;
        /**
         * Default: https://api.taiga.io
         *
         * The hostname of the Taiga instance.
         */
        taiga_host?: string;
        /**
         * Default: present
         *
         * Whether the issue should be present or not.
         */
        state?: "present" | "absent";
        /**
         * Default: None
         *
         * Path to a file to be attached to the issue.
         */
        attachment?: string;
        /**
         * The issue type. Must exist previously.
         */
        issue_type: string;
        /**
         * The issue subject.
         */
        subject: string;
        /**
         * A string describing the file to be attached to the issue.
         */
        attachment_description?: string;
        /**
         * Default: Normal
         *
         * The issue severity. Must exist previously.
         */
        severity?: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM monitors via iControl SOAP API
       */
      bigip_monitor_http?: {
        /**
         * Default: none
         *
         * The interval specifying how frequently the monitor instance of this template will run. By default, this interval is used for up and down states. The default API setting is 5.
         */
        interval?: string;
        /**
         * Monitor name
         */
        name?: string;
        /**
         * Default: http
         *
         * The parent template of this monitor template
         */
        parent?: string;
        /**
         * Default: none
         *
         * The receive string for the monitor call
         */
        receive?: string;
        /**
         * Default: none
         *
         * IP address part of the ipport definition. The default API setting is "0.0.0.0".
         */
        ip?: string;
        /**
         * Default: Common
         *
         * Partition for the monitor
         */
        partition?: string;
        /**
         * Default: none
         *
         * The send string for the monitor call
         */
        send?: string;
        /**
         * Default: present
         *
         * Monitor state
         */
        state?: string;
        /**
         * Default: none
         *
         * Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. The default API setting is 0.
         */
        time_until_up?: string;
        /**
         * Default: none
         *
         * The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. The default API setting is 16.
         */
        timeout?: string;
        /**
         * Default: Common
         *
         * Partition for the parent monitor
         */
        parent_partition?: string;
        /**
         * Default: none
         *
         * Port address part of the ip/port definition. The default API setting is 0.
         */
        port?: string;
        /**
         * Default: none
         *
         * The receive disable string for the monitor call
         */
        receive_disable?: string;
        [k: string]: unknown;
      };
      /**
       * Manipulate Rackspace Cloud Block Storage Volumes
       */
      rax_cbs?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, Update or Destroy a Managed Instance Group (MIG).  See U(https://cloud.google.com/compute/docs/instance-groups) for an overview. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.
       */
      gce_mig?: {
        service_account_permissions?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Name of the Managed Instance Group.
         */
        name: string;
        /**
         * The GCE zone to use for this Managed Instance Group.
         */
        zone: string;
        /**
         * service account email
         */
        service_account_email?: string;
        /**
         * A dictionary of configuration for the autoscaler. 'enabled (bool)', 'name (str)' and policy.max_instances (int) are required fields if autoscaling is used. See U(https://cloud.google.com/compute/docs/reference/beta/autoscalers) for more information on Autoscaling.
         */
        autoscaling?: {
          [k: string]: unknown;
        };
        recreate_instances?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        pem_file?: string;
        /**
         * Default: present
         *
         * desired state of the resource
         */
        state?: "absent" | "present";
        /**
         * Instance Template to be used in creating the VMs.  See U(https://cloud.google.com/compute/docs/instance-templates) to learn more about Instance Templates.  Required for creating MIGs.
         */
        template?: string;
        /**
         * Path to the JSON file associated with the service account email
         */
        credentials_file?: string;
        /**
         * GCE project ID
         */
        project_id?: string;
        /**
         * Size of Managed Instance Group.  If MIG already exists, it will be resized to the number provided here.  Required for creating MIGs.
         */
        size?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages BGP address-family's neighbors configurations on NX-OS switches.
       */
      nxos_bgp_neighbor_af?: {
        /**
         * Activate the default-originate feature.
         */
        default_originate?: string;
        /**
         * Activate the next-hop-self feature.
         */
        next_hop_self?: string;
        /**
         * suppress-inactive feature.
         */
        suppress_inactive?: string;
        /**
         * Weight value. Valid values are an integer value or 'default'.
         */
        weight?: string;
        /**
         * Site-of-origin. Valid values are a string defining a VPN extcommunity or 'default'.
         */
        soo?: string;
        /**
         * Valid values are enable for basic command enablement; disable for disabling the command at the neighbor af level (it adds the disable keyword to the basic command); and inherit to remove the command at this level (the command value is inherited from a higher BGP layer).
         */
        additional_paths_receive?: string;
        /**
         * Router reflector client.
         */
        route_reflector_client?: string;
        /**
         * maximum-prefix limit value. Valid values are an integer value or 'default'.
         */
        max_prefix_limit?: string;
        /**
         * Valid values are a string defining a prefix-list name, or 'default'.
         */
        prefix_list_out?: string;
        /**
         * Activate the as-override feature.
         */
        as_override?: string;
        /**
         * Valid values are a string defining a filter-list name, or 'default'.
         */
        filter_list_out?: string;
        /**
         * Valid values are enable for basic command enablement; disable for disabling the command at the neighbor af level (it adds the disable keyword to the basic command); and inherit to remove the command at this level (the command value is inherited from a higher BGP layer).
         */
        additional_paths_send?: string;
        /**
         * Activate allowas-in property
         */
        allowas_in?: string;
        /**
         * Optional warning-only keyword. Requires max_prefix_limit.
         */
        max_prefix_warning?: string;
        /**
         * BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.
         */
        asn?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: string;
        /**
         * Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the non-exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_non_exist_map']. This command is mutually exclusive with the advertise_map_exist property.
         */
        advertise_map_non_exist?: string;
        /**
         * Optional route-map for the default_originate property. Can be used independently or in conjunction with C(default_originate). Valid values are a string defining a route-map name, or 'default'.
         */
        default_originate_route_map?: string;
        /**
         * Sub Address Family Identifier.
         */
        safi?: string;
        /**
         * Valid values are a string defining a filter-list name, or 'default'.
         */
        filter_list_in?: string;
        /**
         * Default: default
         *
         * Name of the VRF. The name 'default' is a valid VRF representing the global bgp.
         */
        vrf?: string;
        /**
         * unsuppress-map. Valid values are a string defining a route-map name or 'default'.
         */
        unsuppress_map?: string;
        /**
         * Optional threshold percentage at which to generate a warning. Valid values are an integer value. Requires max_prefix_limit.
         */
        max_prefix_threshold?: string;
        /**
         * Valid values are a string defining a route-map name, or 'default'.
         */
        route_map_in?: string;
        /**
         * Address Family Identifier.
         */
        afi?: string;
        /**
         * Valid values are 'enable' for basic command enablement; 'always' to add the always keyword to the basic command; and 'inherit' to remove the command at this level (the command value is inherited from a higher BGP layer).
         */
        soft_reconfiguration_in?: string;
        /**
         * Optional restart interval. Valid values are an integer. Requires max_prefix_limit.
         */
        max_prefix_interval?: string;
        /**
         * Valid values are a string defining a route-map name, or 'default'.
         */
        route_map_out?: string;
        /**
         * send-community attribute.
         */
        send_community?: string;
        /**
         * Valid values are a string defining a prefix-list name, or 'default'.
         */
        prefix_list_in?: string;
        /**
         * Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.
         */
        neighbor?: string;
        /**
         * Activate the next-hop-third-party feature.
         */
        next_hop_third_party?: string;
        /**
         * Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_exist_map']. This command is mutually exclusive with the advertise_map_non_exist property.
         */
        advertise_map_exist?: string;
        /**
         * Optional max-occurrences value for allowas_in. Valid values are an integer value or 'default'. Can be used independently or in conjunction with allowas_in.
         */
        allowas_in_max?: string;
        [k: string]: unknown;
      };
      /**
       * Manages ZFS file systems, volumes, clones and snapshots.
       */
      zfs?: {
        createparent?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Whether to create (C(present)), or remove (C(absent)) a file system, snapshot or volume. All parents/children will be created/destroyed as needed to reach the desired state.
         */
        state: "present" | "absent";
        /**
         * File system, snapshot or volume name e.g. C(rpool/myfs)
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module will insert/update/remove a block of multi-line text surrounded by customizable marker lines.
       */
      blockinfile?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * The M(rocketchat) module sends notifications to Rocket Chat via the Incoming WebHook integration
       */
      rocketchat?: {
        /**
         * Default: Ansible
         *
         * This is the sender of the message.
         */
        username?: string;
        /**
         * The domain for your environment without protocol. (i.e. C(subdomain.domain.com or chat.domain.tld))
         */
        domain: string;
        /**
         * Default: https
         *
         * Specify the protocol used to send notification messages before the webhook url. (i.e. http or https)
         */
        protocol?: "http" | "https";
        /**
         * Default: None
         *
         * Define a list of attachments.
         */
        attachments?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: normal
         *
         * Allow text to use default colors - use the default of 'normal' to not send a custom color bar at the start of the message
         */
        color?: "normal" | "good" | "warning" | "danger";
        /**
         * Default: https://www.ansible.com/favicon.ico
         *
         * URL for the message sender's icon.
         */
        icon_url?: string;
        /**
         * Rocket Chat Incoming Webhook integration token.  This provides authentication to Rocket Chat's Incoming webhook for posting messages.
         */
        token: string;
        /**
         * Default: None
         *
         * Emoji for the message sender. The representation for the available emojis can be got from Rocket Chat. (for example :thumbsup:) (if I(icon_emoji) is set, I(icon_url) will not be used)
         */
        icon_emoji?: string;
        /**
         * Default: 1
         *
         * Automatically create links for channels and usernames in I(msg).
         */
        link_names?: number | string;
        /**
         * Default: None
         *
         * Message to be sent.
         */
        msg?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * Channel to send the message to. If absent, the message goes to the channel selected for the I(token) specifed during the creation of webhook.
         */
        channel?: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP GTM wide ip
       */
      bigip_gtm_wide_ip?: {
        /**
         * LB method of wide ip
         */
        lb_method?: string;
        /**
         * Wide IP name
         */
        wide_ip?: string;
        [k: string]: unknown;
      };
      /**
       * This module will load a candidate configuration from a template file onto a remote device running Junos.  The module will return the differences in configuration if the diff option is specified on the Ansible command line
       */
      junos_template?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        password?: string;
        ssh_keyfile?: string;
        /**
         * The C(confirm) argument will configure a time out value for the commit to be confirmed before it is automatically rolled back.  If the C(confirm) argument is set to False, this argument is silently ignored.  If the value for this argument is set to 0, the commit is confirmed immediately.
         */
        confirm?: number | string;
        auth_pass?: string;
        /**
         * Default: configured by junos_template
         *
         * The C(comment) argument specifies a text string to be used when committing the configuration.  If the C(confirm) argument is set to False, this argument is silently ignored.
         */
        comment?: string;
        host: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        /**
         * Default: merge
         *
         * The C(action) argument specifies how the module will apply changes.
         */
        action?: "merge" | "overwrite" | "replace";
        /**
         * The C(format) argument specifies the format of the configuration template specified in C(src).  If the format argument is not specified, the module will attempt to infer the configuration format based of file extension.  Files that end in I(xml) will set the format to xml.  Files that end in I(set) will set the format to set and all other files will default the format to text.
         */
        config_format?: "text" | "xml" | "set";
        /**
         * The path to the config source.  The source can be either a file with config or a template that will be merged during runtime.  By default the task will search for the source file in role or playbook root folder in templates directory.
         */
        src: string;
        /**
         * When this argument is configured true, the module will backup the configuration from the node prior to making any changes. The backup file will be written to backup_{{ hostname }} in the root of the playbook directory.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "netconf";
        [k: string]: unknown;
      };
      /**
       * Pauses playbook execution for a set amount of time, or until a prompt is acknowledged. All parameters are optional. The default behavior is to pause with a prompt.
       * You can use C(ctrl+c) if you wish to advance a pause earlier than it is set to expire or if you need to abort a playbook run entirely. To continue early: press C(ctrl+c) and then C(c). To abort a playbook: press C(ctrl+c) and then C(a).
       * The pause module integrates into async/parallelized playbooks without any special considerations (see also: Rolling Updates). When using pauses with the C(serial) playbook parameter (as in rolling updates) you are only prompted once for the current group of hosts.
       */
      pause?: {
        host?: string;
        connect_timeout?: number | string;
        delay?: number | string;
        state?: "started" | "stopped" | "present" | "absent" | "drained";
        timeout?: number | string;
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        search_regex?: string;
        path?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Manages network device configurations over SSH or NXAPI.  This module allows implementers to work with the device running-config.  It provides a way to push a set of commands onto a network device by evaluating the current running-config and only pushing configuration commands that are not already configured.  The config source can be a set of commands or a template.
       */
      nxos_template?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        /**
         * The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The path to the config source.  The source can be either a file with config or a template that will be merged during runtime.  By default the task will search for the source file in role or playbook root folder in templates directory.
         */
        src?: string;
        /**
         * The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
         */
        config?: string;
        auth_pass?: string;
        /**
         * The module, by default, will collect the current device running-config to use as a base for comparisons to the commands in I(src).  Setting this value to true will cause the module to issue the command C(show running-config all) to include all device settings.
         */
        include_defaults?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host: string;
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * When this argument is configured true, the module will backup the running-config from the node prior to making any changes. The backup file will be written to backup_{{ hostname }} in the root of the playbook directory.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Gathers various details related to Lambda functions, including aliases, versions and event source mappings. Use module M(lambda) to manage the lambda function itself, M(lambda_alias) to manage function aliases and M(lambda_event) to manage lambda event source mappings.
       */
      lambda_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage InfluxDB retention policies
       */
      influxdb_retention_policy?: {
        /**
         * Default: root
         *
         * Username that will be used to authenticate against InfluxDB server
         */
        username?: string;
        /**
         * Sets the retention policy as default retention policy
         */
        default?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the database where retention policy will be created
         */
        database_name: string;
        /**
         * The hostname or IP address on which InfluxDB server is listening
         */
        hostname: string;
        /**
         * Name of the retention policy
         */
        policy_name: string;
        /**
         * Determines how many independent copies of each point are stored in the cluster
         */
        replication: number | string;
        /**
         * Determines how long InfluxDB should keep the data
         */
        duration: string;
        /**
         * Default: root
         *
         * Password that will be used to authenticate against InfluxDB server
         */
        password?: string;
        /**
         * Default: 8086
         *
         * The port on which InfluxDB server is listening
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Allows you to create/remove/update or powermanage virtual machines on a RHEV/oVirt platform.
       */
      rhevm?: {
        [k: string]: unknown;
      };
      /**
       * Uses Layman to manage an additional repositories for the Portage package manager on Gentoo Linux. Please note that Layman must be installed on a managed node prior using this module.
       */
      layman?: {
        [k: string]: unknown;
      };
      /**
       * Creates, Removes and configures a IIS Web Application Pool
       */
      win_iis_webapppool?: {
        /**
         * Application Pool attributes from string where attributes are seperated by a pipe and attribute name/values by colon Ex. "foo:1|bar:2"
         */
        attributes?: string;
        /**
         * State of the binding
         */
        state?: string;
        /**
         * Names of application pool
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Use this module to manage order of boot devices
       */
      ipmi_boot?: {
        /**
         * Set boot device to use on next reboot
         */
        bootdev: "network" | "hd" | "safe" | "optical" | "setup" | "default";
        /**
         * Hostname or ip address of the BMC.
         */
        name: string;
        /**
         * If set, ask that system firmware uses this device beyond next boot. Be aware many systems do not honor this.
         */
        persistent?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * If set, request UEFI boot explicitly. Strictly speaking, the spec suggests that if not set, the system should BIOS boot and offers no "don't care" option. In practice, this flag not being set does not preclude UEFI boot on any system I've encountered.
         */
        uefiboot?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Whether to ensure that boot devices is desired.
         */
        state?: "present" | "absent";
        /**
         * Username to use to connect to the BMC.
         */
        user: string;
        /**
         * Password to connect to the BMC.
         */
        password: string;
        /**
         * Default: 623
         *
         * Remote RMCP port.
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * This module fetches data from the metadata servers in ec2 (aws) as per http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html. The module must be called from within the EC2 instance itself.
       */
      ec2_facts?: {
        [k: string]: unknown;
      };
      /**
       * Iptables is used to set up, maintain, and inspect the tables of IP packet filter rules in the Linux kernel. This module does not handle the saving and/or loading of rules, but rather only manipulates the current rules that are present in memory. This is the same as the behaviour of the "iptables" and "ip6tables" command which this module uses internally.
       */
      iptables?: {
        /**
         * This specifies a comment that will be added to the rule
         */
        comment?: string;
        /**
         * This enables the administrator to initialize the packet and byte counters of a rule (during INSERT, APPEND, REPLACE operations).
         */
        set_counters?: string;
        /**
         * Chain to operate on. This option can either be the name of a user defined chain or any of the builtin chains: 'INPUT', 'FORWARD', 'OUTPUT', 'PREROUTING', 'POSTROUTING', 'SECMARK', 'CONNSECMARK'.
         */
        chain?: string;
        /**
         * Default: ipv4
         *
         * Which version of the IP protocol this rule should apply to.
         */
        ip_version?: "ipv4" | "ipv6";
        /**
         * Name of an interface via which a packet is going to be sent (for packets entering the FORWARD, OUTPUT and POSTROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.
         */
        out_interface?: string;
        /**
         * Specifies the maximum burst before the above limit kicks in.
         */
        limit_burst?: string;
        /**
         * ctstate is a list of the connection states to match in the conntrack module. Possible states are: 'INVALID', 'NEW', 'ESTABLISHED', 'RELATED', 'UNTRACKED', 'SNAT', 'DNAT'
         */
        ctstate?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * This specifies the target of the rule; i.e., what to do if the packet matches it. The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below).  If this option is omitted in a rule (and the goto paramater is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented.
         */
        jump?: string;
        /**
         * This specifies a destination port or range of ports to use: without this, the destination port is never altered. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.
         */
        to_ports?: string;
        /**
         * Flushes the specified table and chain of all rules. If no chain is specified then the entire table is purged. Ignores all other parameters.
         */
        flush?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: filter
         *
         * This option specifies the packet matching table which the command should operate on. If the kernel is configured with automatic module loading, an attempt will be made to load the appropriate module for that table if it is not already there.
         */
        table?: "filter" | "nat" | "mangle" | "raw" | "security";
        /**
         * This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'
         */
        icmp_type?: string;
        /**
         * This specifies a destination address to use with DNAT: without this, the destination address is never altered.
         */
        to_destination?: string;
        /**
         * Specifies the UID or username to use in match by owner rule.
         */
        uid_owner?: string;
        /**
         * This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark. Mutually exclusive with C(set_dscp_mark).
         */
        set_dscp_mark_class?: string;
        /**
         * Destination specification. Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address. Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea. The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A "!" argument before the address specification inverts the sense of the address.
         */
        destination?: string;
        /**
         * Default: present
         *
         * Whether the rule should be absent or present.
         */
        state?: "present" | "absent";
        /**
         * The protocol of the rule or of the packet to check. The specified protocol can be one of tcp, udp, udplite, icmp, esp, ah, sctp or the special keyword "all", or it can be a numeric value, representing one of these protocols or a different one. A protocol name from /etc/protocols is also allowed. A "!" argument before the protocol inverts the test.  The number zero is equivalent to all. "all" will match with all protocols and is taken as default when this option is omitted.
         */
        protocol?: string;
        /**
         * Source specification. Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address. Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea. The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A "!" argument before the address specification inverts the sense of the address.
         */
        source?: string;
        /**
         * This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value. Mutually exclusive with C(set_dscp_mark_class).
         */
        set_dscp_mark?: string;
        /**
         * Set the policy for the chain to the given target. Valid targets are ACCEPT, DROP, QUEUE, RETURN. Only built in chains can have policies. This parameter requires the chain parameter. Ignores all other parameters.
         */
        policy?: "ACCEPT" | "DROP" | "QUEUE" | "RETURN";
        /**
         * Specifies a match to use, that is, an extension module that tests for a specific property. The set of matches make up the condition under which a target is invoked. Matches are evaluated first to last if specified as an array and work in short-circuit fashion, i.e. if one extension yields false, evaluation will stop.
         */
        match?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * This specifies that the processing should continue in a user specified chain. Unlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump.
         */
        goto?: string;
        /**
         * This means that the rule only refers to second and further fragments of fragmented packets. Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them. When the "!" argument precedes fragment argument, the rule will only match head fragments, or unfragmented packets.
         */
        fragment?: string;
        /**
         * This specifies a source address to use with SNAT: without this, the source address is never altered.
         */
        to_source?: string;
        /**
         * Default: append
         *
         * Whether the rule should be appended at the bottom or inserted at the top. If the rule already exists the chain won't be modified.
         */
        action?: "append" | "insert";
        /**
         * Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.
         */
        destination_port?: string;
        /**
         * Specifies the error packet type to return while rejecting.
         */
        reject_with?: string;
        /**
         * Specifies the maximum average number of matches to allow per second. The number can specify units explicitly, using `/second', `/minute', `/hour' or `/day', or parts of them (so `5/second' is the same as `5/s').
         */
        limit?: string;
        /**
         * Source port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.
         */
        source_port?: string;
        /**
         * Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.
         */
        in_interface?: string;
        [k: string]: unknown;
      };
      /**
       * Installs or uninstalls a package.
       * Optionally uses a product_id to check if the package needs installing. You can find product ids for installed programs in the windows registry either in C(HKLM:Software\Microsoft\Windows\CurrentVersion\Uninstall) or for 32 bit programs C(HKLM:Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall)
       */
      win_package?: {
        /**
         * product id of the installed package (used for checking if already installed)
         * You can find product ids for installed programs in the windows registry either in C(HKLM:Software\Microsoft\Windows\CurrentVersion\Uninstall) or for 32 bit programs C(HKLM:Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall)'
         */
        product_id?: string;
        /**
         * Password of an account with access to the package if its located on a file share. Only needed if the winrm user doesn't have access to the package. Also specify user_name for this to function properly.
         */
        user_password?: string;
        /**
         * Default: present
         *
         * Install or Uninstall
         */
        state?: string;
        /**
         * Any arguments the installer needs
         */
        arguments?: string;
        /**
         * Location of the package to be installed (either on file system, network share or url)
         */
        path?: string;
        /**
         * Username of an account with access to the package if its located on a file share. Only needed if the winrm user doesn't have access to the package. Also specify user_password for this to function properly.
         */
        user_name?: string;
        /**
         * Name of the package, if name isn't specified the path will be used for log messages
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manipulate Rackspace Cloud Autoscale Groups
       */
      rax_scaling_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, modifies, and deletes Redshift cluster subnet groups.
       */
      redshift_subnet_group?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Create or delete a Rackspace Cloud Monitoring entity, which represents a device to monitor. Entities associate checks and alarms with a target system and provide a convenient, centralized place to store IP addresses. Rackspace monitoring module flow | *rax_mon_entity* -> rax_mon_check -> rax_mon_notification -> rax_mon_notification_plan -> rax_mon_alarm
       */
      rax_mon_entity?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * The command module allows running one or more commands on remote devices running VyOS.  This module can also be introspected to validate key parameters before returning successfully.  If the conditional statements are not met in the wait period, the task fails.
       */
      vyos_command?: {
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 ENI interfaces in AWS
       */
      ec2_eni_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running eos.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      eos_facts?: {
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove a database on a Webfaction host. Further documentation at http://github.com/quentinsf/ansible-webfaction.
       */
      webfaction_db?: {
        /**
         * The name of the database
         */
        name: string;
        /**
         * The machine name to use (optional for accounts with only one machine)
         */
        machine?: string;
        /**
         * Default: present
         *
         * Whether the database should exist
         */
        state?: "present" | "absent";
        /**
         * The webfaction password to use
         */
        login_password: string;
        /**
         * Default: None
         *
         * The password for the new database user.
         */
        password?: string;
        /**
         * The type of database to create.
         */
        type: string;
        /**
         * The webfaction account to use
         */
        login_name: string;
        [k: string]: unknown;
      };
      /**
       * This module authenticates to oVirt engine and creates SSO token, which should be later used in all other oVirt modules, so all modules don't need to perform login and logout. This module returns an Ansible fact called I(ovirt_auth). Every module can use this fact as C(auth) parameter, to perform authentication.
       */
      ovirt_auth?: {
        /**
         * The name of the user. For example: I(admin@internal).
         */
        username?: string;
        /**
         * A PEM file containing the trusted CA certificates. The certificate presented by the server will be verified using these CA certificates. If C(ca_file) parameter is not set, system wide CA certificate store is used.
         */
        ca_file?: string;
        /**
         * A string containing the base URL of the server. For example: I(https://server.example.com/ovirt-engine/api).
         */
        url?: string;
        /**
         * A boolean flag that indicates if the server TLS certificate and host name should be checked.
         */
        insecure?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A boolean flag indicating if Kerberos authentication should be used instead of the default basic authentication.
         */
        kerberos?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A boolean flag indicating if the SDK should ask the server to send compressed responses. The default is I(True). Note that this is a hint for the server, and that it may return uncompressed data even when this parameter is set to I(True).
         */
        compress?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Specifies if a token should be created or revoked.
         */
        state?: "present" | "absent";
        ovirt_auth?: {
          [k: string]: unknown;
        };
        /**
         * The maximum total time to wait for the response, in seconds. A value of zero (the default) means wait forever. If the timeout expires before the response is received an exception will be raised.
         */
        timeout?: number | string;
        /**
         * The password of the user.
         */
        password?: string;
        [k: string]: unknown;
      };
      /**
       * Sends a text message to a phone number through the Twilio messaging API.
       */
      twilio?: {
        /**
         * user's Twilio authentication token
         */
        auth_token: string;
        /**
         * one or more phone numbers to send the text message to, format +15551112222
         */
        to_number: string;
        /**
         * user's Twilio account token found on the account page
         */
        account_sid: string;
        /**
         * the Twilio number to send the text message from, format +15551112222
         */
        from_number: string;
        /**
         * the body of the text message
         */
        msg: string;
        /**
         * a URL with a picture, video or sound clip to send with an MMS (multimedia message) instead of a plain SMS
         */
        media_url?: string;
        [k: string]: unknown;
      };
      /**
       * Manages BGP neighbors configurations on NX-OS switches.
       */
      nxos_bgp_neighbor?: {
        /**
         * Specify the encryption type the password will use. Valid values are '3des' or 'cisco_type_7' encryption.
         */
        pwd_type?: string;
        /**
         * Configure whether or not to enable dynamic capability.
         */
        dynamic_capability?: string;
        /**
         * Configure to administratively shutdown this neighbor.
         */
        shutdown?: string;
        /**
         * Specify whether or not to shut down this neighbor under memory pressure.
         */
        low_memory_exempt?: string;
        /**
         * Specify the config to remove private AS number from outbound updates. Valid values are 'enable' to enable this config, 'disable' to disable this config, 'all' to remove all private AS number, or 'replace-as', to replace the private AS number.
         */
        remove_private_as?: string;
        /**
         * Configure to suppress 4-byte AS Capability.
         */
        suppress_4_byte_as?: string;
        /**
         * Configure whether or not to check for directly connected peer.
         */
        connected_check?: string;
        /**
         * Specify Autonomous System Number of the neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.
         */
        remote_as?: string;
        /**
         * Specify multihop TTL for a remote peer. Valid values are integers between 2 and 255, or keyword 'default' to disable this property.
         */
        ebgp_multihop?: string;
        /**
         * Specify Maximum number of peers for this neighbor prefix Valid values are between 1 and 1000, or 'default', which does not impose the limit.
         */
        maximum_peers?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: string;
        /**
         * Specify holdtime timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 180.
         */
        timers_holdtime?: string;
        /**
         * Specify source interface of BGP session and updates.
         */
        update_source?: string;
        /**
         * Description of the neighbor.
         */
        description?: string;
        /**
         * Specify the local-as number for the eBGP neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.
         */
        local_as?: string;
        /**
         * Specify keepalive timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 60.
         */
        timers_keepalive?: string;
        /**
         * Specify the password for neighbor. Valid value is string.
         */
        pwd?: string;
        /**
         * Default: default
         *
         * Name of the VRF. The name 'default' is a valid VRF representing the global bgp.
         */
        vrf?: string;
        /**
         * Specify whether or not to enable log messages for neighbor up/down event.
         */
        log_neighbor_changes?: string;
        /**
         * BGP autonomous system number. Valid values are string, Integer in ASPLAIN or ASDOT notation.
         */
        asn?: string;
        /**
         * Specify whether or not to only allow passive connection setup. Valid values are 'true', 'false', and 'default', which defaults to 'false'. This property can only be configured when the neighbor is in 'ip' address format without prefix length. This property and the transport_passive_mode property are mutually exclusive.
         */
        transport_passive_only?: string;
        /**
         * Configure whether or not to negotiate capability with this neighbor.
         */
        capability_negotiation?: string;
        /**
         * Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.
         */
        neighbor?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, remove snapshot volumes for NetApp E/EF-Series storage arrays.
       */
      netapp_e_snapshot_volume?: {
        /**
         * storage array ID
         */
        ssid: string;
        /**
         * The identifier of the snapshot image used to create the new snapshot volume.
         * Note: You'll likely want to use the M(netapp_e_facts) module to find the ID of the image you want.
         */
        snapshot_image_id: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * Whether to create or remove the snapshot volume
         */
        state: "absent" | "present";
        /**
         * Default: 20
         *
         * The size of the view in relation to the size of the base volume
         */
        repo_percentage?: number | string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * Default: 85
         *
         * The repository utilization warning threshold percentage
         */
        full_threshold?: number | string;
        /**
         * The snapshot volume access mode
         */
        view_mode?: "readOnly" | "readWrite" | "modeUnknown" | "__Undefined";
        /**
         * Name of the storage pool on which to allocate the repository volume.
         */
        storage_pool_name: string;
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name you wish to give the snapshot volume
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * The M(slack) module sends notifications to U(http://slack.com) via the Incoming WebHook integration
       */
      slack?: {
        /**
         * Default: Ansible
         *
         * This is the sender of the message.
         */
        username?: string;
        /**
         * Default: None
         *
         * Slack (sub)domain for your environment without protocol. (i.e. C(future500.slack.com)) In 1.8 and beyond, this is deprecated and may be ignored.  See token documentation for information.
         */
        domain?: string;
        /**
         * Default: None
         *
         * Define a list of attachments. This list mirrors the Slack JSON API. For more information, see https://api.slack.com/docs/attachments
         */
        attachments?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: normal
         *
         * Allow text to use default colors - use the default of 'normal' to not send a custom color bar at the start of the message
         */
        color?: "normal" | "good" | "warning" | "danger";
        /**
         * Url for the message sender's icon (default C(https://www.ansible.com/favicon.ico))
         */
        icon_url?: string;
        /**
         * Default: None
         *
         * Setting for the message parser at Slack
         */
        parse?: "full" | "none";
        /**
         * Slack integration token.  This authenticates you to the slack service. Prior to 1.8, a token looked like C(3Ffe373sfhRE6y42Fg3rvf4GlK).  In 1.8 and above, ansible adapts to the new slack API where tokens look like C(G922VJP24/D921DW937/3Ffe373sfhRE6y42Fg3rvf4GlK).  If tokens are in the new format then slack will ignore any value of domain.  If the token is in the old format the domain is required.  Ansible has no control of when slack will get rid of the old API.  When slack does that the old format will stop working.
         */
        token: string;
        /**
         * Default: None
         *
         * Emoji for the message sender. See Slack documentation for options. (if I(icon_emoji) is set, I(icon_url) will not be used)
         */
        icon_emoji?: string;
        /**
         * Default: 1
         *
         * Automatically create links for channels and usernames in I(msg).
         */
        link_names?: number | string;
        /**
         * Default: None
         *
         * Message to send.
         */
        msg?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * Channel to send the message to. If absent, the message goes to the channel selected for the I(token).
         */
        channel?: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM virtual servers via iControl SOAP API
       */
      bigip_virtual_server?: {
        /**
         * Default: Common
         *
         * Partition
         */
        partition?: string;
        /**
         * Virtual server name
         */
        name?: string;
        /**
         * Default: None
         *
         * Default Profile which manages the session persistence
         */
        default_persistence_profile?: string;
        /**
         * Destination IP of the virtual server (only host is currently supported). Required when state=present and vs does not exist.
         */
        destination?: string;
        /**
         * Default: None
         *
         * List of all Profiles (HTTP,ClientSSL,ServerSSL,etc) that must be used by the virtual server
         */
        all_profiles?: string;
        /**
         * Default: None
         *
         * List of rules to be applied in priority order
         */
        all_rules?: string;
        /**
         * Default: None
         *
         * List of vlans to be enabled. When a VLAN named C(ALL) is used, all VLANs will be allowed.
         */
        enabled_vlans?: string;
        /**
         * Default: present
         *
         * Virtual Server state
         * Absent, delete the VS if present
         * C(present) (and its synonym enabled), create if needed the VS and set state to enabled
         * C(disabled), create if needed the VS and set state to disabled
         */
        state?: string;
        /**
         * Default: None
         *
         * Source network address policy
         */
        snat?: string;
        /**
         * Default: None
         *
         * Port of the virtual server . Required when state=present and vs does not exist
         */
        port?: string;
        /**
         * Default: None
         *
         * Default pool for the virtual server
         */
        pool?: string;
        /**
         * Default: None
         *
         * Virtual server description
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Create or Delete routers from OpenStack
       */
      quantum_router?: {
        /**
         * Default: None
         *
         * Name of the region
         */
        region_name?: string;
        /**
         * Default: True
         *
         * desired admin state of the created router .
         */
        admin_state_up?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * Name of the tenant for which the router has to be created, if none router would be created for the login tenant.
         */
        tenant_name?: string;
        availability_zone?: string;
        /**
         * Default: yes
         *
         * The tenant name of the login user
         */
        login_tenant_name?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: "present" | "absent";
        /**
         * Default: http://127.0.0.1:35357/v2.0/
         *
         * The keystone url for authentication
         */
        auth_url?: string;
        /**
         * Default: yes
         *
         * Password of login user
         */
        login_password: string;
        /**
         * Default: admin
         *
         * login username to authenticate to keystone
         */
        login_username?: string;
        /**
         * Default: None
         *
         * Name to be give to the router
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module will let you create PagerDuty maintenance windows
       */
      pagerduty?: {
        [k: string]: unknown;
      };
      /**
       * Modify protocol properties on Solaris/illumos systems.
       */
      ipadm_prop?: {
        /**
         * Specifies the procotol for which we want to manage properties.
         */
        protocol: "ipv4" | "ipv6" | "icmp" | "tcp" | "udp" | "sctp";
        /**
         * Default: present
         *
         * Set or reset the property value.
         */
        state?: "present" | "absent" | "reset";
        /**
         * Specifies the name of property we want to manage.
         */
        property: string;
        /**
         * Specifies that the property value is temporary. Temporary property values do not persist across reboots.
         */
        temporary?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specifies the value we want to set for the property.
         */
        value?: string;
        [k: string]: unknown;
      };
      /**
       * Manage binary packages for FreeBSD using 'pkgng' which is available in versions after 9.0.
       */
      pkgng?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Apply patch files using the GNU patch tool.
       */
      patch?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about one or more networks from OpenStack.
       */
      os_networks_facts?: {
        /**
         * Name or ID of the Network
         */
        name?: string;
        /**
         * A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.
         */
        filters?: string;
        [k: string]: unknown;
      };
      /**
       * Create and renew SSL certificates with Let's Encrypt. Lets Encrypt is a free, automated, and open certificate authority (CA), run for the publics benefit. For details see U(https://letsencrypt.org). The current implementation supports the http-01, tls-sni-02 and dns-01 challenges.
       * To use this module, it has to be executed at least twice. Either as two different tasks in the same run or during multiple runs.
       * Between these two tasks you have to fulfill the required steps for the choosen challenge by whatever means necessary. For http-01 that means creating the necessary challenge file on the destination webserver. For dns-01 the necessary dns record has to be created. tls-sni-02 requires you to create a SSL certificate with the appropriate subjectAlternativeNames. It is I(not) the responsibility of this module to perform these steps.
       * For details on how to fulfill these challenges, you might have to read through U(https://tools.ietf.org/html/draft-ietf-acme-acme-02#section-7)
       * Although the defaults are choosen so that the module can be used with the Let's Encrypt CA, the module can be used with any service using the ACME protocol.
       */
      letsencrypt?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Send a SMS message via nexmo
       */
      nexmo?: {
        [k: string]: unknown;
      };
      /**
       * Discover targets on given portal, (dis)connect targets, mark targets to manually or auto start, return device nodes of connected targets.
       */
      open_iscsi?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage slb service-group objects on A10 Networks devices via aXAPI
       */
      a10_service_group?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Dell OS9 configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with Dell OS9 configuration sections in a deterministic way.
       */
      dellos9_config?: {
        [k: string]: unknown;
      };
      /**
       * Create or terminates AWS virtual private clouds.  This module has a dependency on python-boto.
       */
      ec2_vpc?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * An Ansible module to Create, Delete shared loadbalancers in CenturyLink Cloud.
       */
      clc_loadbalancer?: {
        /**
         * Default: enabled
         *
         * The status of the loadbalancer
         */
        status?: "enabled" | "disabled";
        /**
         * Default: None
         *
         * A description for the loadbalancer
         */
        description?: string;
        /**
         * Default: None
         *
         * -The balancing method for the load balancer pool
         */
        method?: "leastConnection" | "roundRobin";
        /**
         * The alias of your CLC Account
         */
        alias: string;
        /**
         * Default: present
         *
         * Whether to create or delete the load balancer pool
         */
        state?: "present" | "absent" | "port_absent" | "nodes_present" | "nodes_absent";
        /**
         * The location of the datacenter where the load balancer resides in
         */
        location: string;
        /**
         * A list of nodes that needs to be added to the load balancer pool
         */
        nodes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: None
         *
         * Port to configure on the public-facing side of the load balancer pool
         */
        port?: 80 | 443;
        /**
         * Default: None
         *
         * The persistence method for the load balancer
         */
        persistence?: "standard" | "sticky";
        /**
         * The name of the loadbalancer
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Loads and executes a role as a task, this frees roles from the `role:` directive and allows them to be treated more as tasks.
       */
      include_role?: {
        host?: string;
        connect_timeout?: number | string;
        delay?: number | string;
        state?: "started" | "stopped" | "present" | "absent" | "drained";
        timeout?: number | string;
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        search_regex?: string;
        path?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Trigger a graceful removal or insertion (GIR) of the switch.
       */
      nxos_gir?: {
        /**
         * When C(system_mode_maintenance_dont_generate_profile=true) it prevents the dynamic searching of enabled protocols and executes commands configured in a maintenance-mode profile. Use this option if you want the system to use a maintenance-mode profile that you have created. When C(system_mode_maintenance_dont_generate_profile=false) it prevents the dynamic searching of enabled protocols and executes commands configured in a normal-mode profile. Use this option if you want the system to use a normal-mode profile that you have created.
         */
        system_mode_maintenance_dont_generate_profile?: string;
        /**
         * Shuts down all protocols, vPC domains, and interfaces except the management interface (using the shutdown command). This option is disruptive while C(system_mode_maintenance) (which uses the isolate command) is not.
         */
        system_mode_maintenance_shutdown?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: string;
        /**
         * Keeps the switch in maintenance mode for a specified number of minutes. Range is 5-65535.
         */
        system_mode_maintenance_timeout?: string;
        /**
         * When C(system_mode_maintenance=true) it puts all enabled protocols in maintenance mode (using the isolate command). When C(system_mode_maintenance=false) it puts all enabled protocols in normal mode (using the no isolate command).
         */
        system_mode_maintenance?: string;
        /**
         * Boots the switch into maintenance mode automatically in the event of a specified system crash.
         */
        system_mode_maintenance_on_reload_reset_reason?: string;
        [k: string]: unknown;
      };
      /**
       * This module can create and delete GCE private images from gzipped compressed tarball containing raw disk data or from existing detached disks in any zone. U(https://cloud.google.com/compute/docs/images)
       */
      gce_img?: {
        /**
         * an optional description
         */
        description?: string;
        /**
         * an optional family name
         */
        family?: string;
        /**
         * service account email
         */
        service_account_email?: string;
        /**
         * path to the pem file associated with the service account email
         */
        pem_file?: string;
        /**
         * the source disk or the Google Cloud Storage URI to create the image from
         */
        source?: string;
        /**
         * Default: present
         *
         * desired state of the image
         */
        state?: "present" | "absent";
        /**
         * Default: us-central1-a
         *
         * the zone of the disk specified by source
         */
        zone?: string;
        /**
         * Default: 180
         *
         * timeout for the operation
         */
        timeout?: number | string;
        /**
         * your GCE project ID
         */
        project_id?: string;
        /**
         * the name of the image to create or delete
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Set up, reconfigure, or remove SSL termination for an existing load balancer.
       */
      rax_clb_ssl?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module will let you pause/unpause Pingdom alerts
       */
      pingdom?: {
        /**
         * Pingdom user password.
         */
        passwd: string;
        /**
         * Pingdom ID of the check.
         */
        checkid: string;
        /**
         * Define whether or not the check should be running or paused.
         */
        state: "running" | "paused" | "started" | "stopped";
        /**
         * Pingdom user ID.
         */
        uid: string;
        /**
         * Pingdom API key.
         */
        key: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 Auto Scaling Groups (ASGs) in AWS
       */
      ec2_asg_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update, stop and start a virtual machine. Provide an existing storage account and network interface or allow the module to create these for you. If you choose not to provide a network interface, the resource group must contain a virtual network with at least one subnet.
       * Currently requires an image found in the Azure Marketplace. Use azure_rm_virtualmachineimage_facts module to discover the publisher, offer, sku and version of a particular image.
       */
      azure_rm_virtualmachine?: {
        /**
         * Name of the resource group containing the virtual machine.
         */
        resource_group?: string;
        /**
         * Default: ['Static']
         *
         * If a public IP address is created when creating the VM (because a Network Interface was not provided), determines if the public IP address remains permanently associated with the Network Interface. If set to 'Dynamic' the public IP address may change any time the VM is rebooted or power cycled.
         */
        public_ip_allocation_method?: string;
        /**
         * A dictionary describing the Marketplace image used to build the VM. Will contain keys: publisher, offer, sku and version. NOTE: set image.version to 'latest' to get the most recent version of a given image.
         */
        image?: string;
        /**
         * For os_type Linux provide a list of SSH keys. Each item in the list should be a dictionary where the dictionary contains two keys: path and key_data. Set the path to the default location of the authorized_keys files. On an Enterprise Linux host, for example, the path will be /home/<admin username>/.ssh/authorized_keys. Set key_data to the actual value of the public key.
         */
        ssh_public_keys?: string;
        /**
         * Default: vhds
         *
         * Name of the container to use within the storage account to store VHD blobs. If no name is specified a default container will created.
         */
        storage_container_name?: string;
        /**
         * Default: True
         *
         * Toggle that controls if the machine is allocated/deallocated, only useful with state='present'.
         */
        allocated?: string;
        /**
         * Default: True
         *
         * When the os_type is Linux, setting ssh_password_enabled to false will disable SSH password authentication and require use of SSH keys.
         */
        ssh_password_enabled?: string;
        /**
         * Name fo the storage blob used to hold the VM's OS disk image. If no name is provided, defaults to the VM name + '.vhd'. If you provide a name, it must end with '.vhd'
         */
        storage_blob_name?: string;
        /**
         * Default: ['all']
         *
         * When removing a VM using state 'absent', also remove associated resources
         * It can be 'all' or a list with any of the following: ['network_interfaces', 'virtual_storage', 'public_ips']
         * Any other input will be ignored
         */
        remove_on_absent?: string;
        /**
         * Name assigned internally to the host. On a linux VM this is the name returned by the `hostname` command. When creating a virtual machine, short_hostname defaults to name.
         */
        short_hostname?: string;
        /**
         * Default: True
         *
         * Use with state 'present' to start the machine. Set to false to have the machine be 'stopped'.
         */
        started?: string;
        /**
         * Default: present
         *
         * Assert the state of the virtual machine.
         * State 'present' will check that the machine exists with the requested configuration. If the configuration of the existing machine does not match, the machine will be updated. Use options started, allocated and restarted to change the machine's power state.
         * State 'absent' will remove the virtual machine.
         */
        state?: string;
        /**
         * When creating a virtual machine, if a network interface name is not provided, one will be created. The new network interface will be assigned to the first subnet found in the virtual network. Use this parameter to provide a specific subnet instead.
         */
        subnet_name?: string;
        /**
         * Valid Azure location. Defaults to location of the resource group.
         */
        location?: string;
        /**
         * List of existing network interface names to add to the VM. If a network interface name is not provided when the VM is created, a default network interface will be created. In order for the module to create a network interface, at least one Virtual Network with one Subnet must exist.
         */
        network_interface_names?: string;
        /**
         * Password for the admin username. Not required if the os_type is Linux and SSH password authentication is disabled by setting ssh_password_enabled to false.
         */
        admin_password?: string;
        /**
         * When creating a virtual machine, if a network interface name is not provided, one will be created. The new network interface will be assigned to the first virtual network found in the resource group. Use this parameter to provide a specific virtual network instead.
         */
        virtual_network_name?: string;
        /**
         * If a network interface is created when creating the VM, a security group will be created as well. For Linux hosts a rule will be added to the security group allowing inbound TCP connections to the default SSH port 22, and for Windows hosts ports 3389 and 5986 will be opened. Override the default open ports by providing a list of ports.
         */
        open_ports?: string;
        /**
         * Default: Standard_D1
         *
         * A valid Azure VM size value. For example, 'Standard_D4'. The list of choices varies depending on the subscription and location. Check your subscription for available choices.
         */
        vm_size?: string;
        /**
         * Name of the virtual machine.
         */
        name?: string;
        /**
         * Use with state 'present' to restart a running VM.
         */
        restarted?: string;
        /**
         * Admin username used to access the host after it is created. Required when creating a VM.
         */
        admin_username?: string;
        /**
         * Default: ['Linux']
         *
         * Base type of operating system.
         */
        os_type?: string;
        /**
         * Name of an existing storage account that supports creation of VHD blobs. If not specified for a new VM, a new storage account named <vm name>01 will be created using storage type 'Standard_LRS'.
         */
        storage_account_name?: string;
        /**
         * Default: ReadOnly
         *
         * Type of OS disk caching.
         */
        os_disk_caching?: string;
        [k: string]: unknown;
      };
      /**
       * This module allows to manage samba shares on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
       */
      udm_share?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Update a storage array to become the primary or secondary instance in an asynchronous mirror group
       */
      netapp_e_amg_role?: {
        /**
         * The ID of the primary storage array for the async mirror action
         */
        ssid: string;
        /**
         * Whether to force the role reversal regardless of the online-state of the primary
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password?: string;
        /**
         * Whether the array should be the primary or secondary array for the AMG
         */
        role: "primary" | "secondary";
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username?: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Whether to avoid synchronization prior to role reversal
         */
        noSync?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages SNMP host configuration parameters.
       */
      nxos_snmp_host?: {
        /**
         * Name of VRF to filter.
         */
        vrf_filter?: string;
        /**
         * UDP port number (0-65535).
         */
        udp?: string;
        /**
         * Source interface.
         */
        src_intf?: string;
        /**
         * IP address of hostname of target host.
         */
        snmp_host?: string;
        /**
         * Community string or v3 username.
         */
        community?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Default: v2c
         *
         * SNMP version.
         */
        version?: string;
        /**
         * VRF to use to source traffic to source.
         */
        vrf?: string;
        /**
         * Default: traps
         *
         * type of message to send to host.
         */
        snmp_type?: string;
        [k: string]: unknown;
      };
      /**
       * Manage Self-IPs on a BIG-IP system
       */
      bigip_selfip?: {
        /**
         * Default: Value of C(address)
         *
         * The self IP to create.
         */
        name?: string;
        /**
         * The VLAN that the new self IPs will be on.
         */
        vlan?: string;
        /**
         * The netmasks for the self IP.
         */
        netmask?: string;
        /**
         * Configure port lockdown for the Self IP. By default, the Self IP has a "default deny" policy. This can be changed to allow TCP and UDP ports as well as specific protocols. This list should contain C(protocol):C(port) values.
         */
        allow_service?: string;
        /**
         * Default: present
         *
         * The state of the variable on the system. When C(present), guarantees that the Self-IP exists with the provided attributes. When C(absent), removes the Self-IP from the system.
         */
        state?: string;
        /**
         * The IP addresses for the new self IP. This value is ignored upon update as addresses themselves cannot be changed after they are created.
         */
        address?: string;
        /**
         * The traffic group for the self IP addresses in an active-active, redundant load balancer configuration.
         */
        traffic_group?: string;
        [k: string]: unknown;
      };
      /**
       * Manages local Windows user accounts
       */
      win_user?: {
        /**
         * Default: always
         *
         * C(always) will update passwords if they differ.  C(on_create) will only set the password for newly created users.
         */
        update_password?: string;
        /**
         * C(yes) will set the password to never expire.  C(no) will allow the password to expire.
         */
        password_never_expires?: string;
        /**
         * Name of the user to create, remove or modify.
         */
        name?: string;
        /**
         * Default: replace
         *
         * If C(replace), the user is added as a member of each group in I(groups) and removed from any other groups.  If C(add), the user is added to each group in I(groups) where not already a member.  If C(remove), the user is removed from each group in I(groups).
         */
        groups_action?: string;
        /**
         * C(yes) will require the user to change their password at next login. C(no) will clear the expired password flag.
         */
        password_expired?: string;
        /**
         * Default: present
         *
         * When C(present), creates or updates the user account.  When C(absent), removes the user account if it exists.  When C(query) (new in 1.9), retrieves the user account details without making any changes.
         */
        state?: string;
        /**
         * Adds or removes the user from this comma-separated lis of groups, depending on the value of I(groups_action). When I(groups_action) is C(replace) and I(groups) is set to the empty string ('groups='), the user is removed from all groups.
         */
        groups?: string;
        /**
         * C(yes) will disable the user account.  C(no) will clear the disabled flag.
         */
        account_disabled?: string;
        /**
         * Full name of the user
         */
        fullname?: string;
        /**
         * Optionally set the user's password to this (plain text) value.
         */
        password?: string;
        /**
         * C(no) will unlock the user account if locked.
         */
        account_locked?: string;
        /**
         * C(yes) will prevent the user from changing their password.  C(no) will allow the user to change their password.
         */
        user_cannot_change_password?: string;
        /**
         * Description of the user
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an OpenSwitch node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      ops_command?: {
        /**
         * Default: 10
         *
         * Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the I(wait_for) conditions.
         */
        retries?: string;
        /**
         * List of commands to send to the remote ops device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.
         */
        commands?: string;
        /**
         * List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.
         */
        wait_for?: string;
        /**
         * Default: all
         *
         * The I(match) argument is used in conjunction with the I(wait_for) argument to specify the match policy.  Valid values are C(all) or C(any).  If the value is set to C(all) then all conditionals in the I(wait_for) must be satisfied.  If the value is set to C(any) then only one of the values must be satisfied.
         */
        match?: string;
        /**
         * Default: 1
         *
         * Configures the interval in seconds to wait between I(retries) of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.
         */
        interval?: string;
        [k: string]: unknown;
      };
      /**
       * Configures anycast gateway MAC of the switch.
       */
      nxos_overlay_global?: {
        /**
         * Anycast gateway mac of the switch.
         */
        anycast_gateway_mac?: string;
        [k: string]: unknown;
      };
      /**
       * Send a message to an IRC channel. This is a very simplistic implementation.
       */
      irc?: {
        [k: string]: unknown;
      };
      /**
       * Create a VMware VMkernel Interface
       */
      vmware_vmkernel?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Execute show command in the nodes and returns the results read from the device.
       */
      pn_show?: {
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword: string;
        /**
         * The C(pn_command) takes a CLI show command as value.
         */
        pn_command: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername: string;
        /**
         * Display output using a specific parameter. Use 'all' to display possible output. List of comma separated parameters.
         */
        pn_parameters?: string;
        /**
         * Specify formatting options.
         */
        pn_options?: string;
        /**
         * Target switch(es) to run the cli on.
         */
        pn_cliswitch?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove network from OpenStack.
       */
      os_network?: {
        /**
         * Name to be assigned to the network.
         */
        name?: string;
        /**
         * Default: None
         *
         * The type of physical network that maps to this network resource.
         */
        provider_network_type?: string;
        /**
         * Default: True
         *
         * Whether the state should be marked as up or down.
         */
        admin_state_up?: string;
        /**
         * Default: None
         *
         * The physical network where this network object is implemented.
         */
        provider_physical_network?: string;
        /**
         * Default: None
         *
         * Project name or ID containing the network (name admin-only)
         */
        project?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource.
         */
        state?: string;
        /**
         * Default: None
         *
         * An isolated segment on the physical network. The I(network_type) attribute defines the segmentation model. For example, if the I(network_type) value is vlan, this ID is a vlan identifier. If the I(network_type) value is gre, this ID is a gre key.
         */
        provider_segmentation_id?: string;
        /**
         * Whether this network is externally accessible.
         */
        external?: string;
        /**
         * Whether this network is shared or not.
         */
        shared?: string;
        [k: string]: unknown;
      };
      /**
       * Manage BIG-IP device DNS settings
       */
      bigip_device_dns?: {
        /**
         * A list of domains that the system searches for local domain lookups, to resolve local host names.
         */
        search?: string;
        /**
         * Default: disable
         *
         * Specifies whether the system caches DNS lookups or performs the operation each time a lookup is needed. Please note that this applies only to Access Policy Manager features, such as ACLs, web application rewrites, and authentication.
         */
        cache?: string;
        /**
         * Specifies whether the DNS specifies IP addresses using IPv4 or IPv6.
         */
        ip_version?: string;
        /**
         * Default: present
         *
         * The state of the variable on the system. When C(present), guarantees that an existing variable is set to C(value).
         */
        state?: string;
        /**
         * A list of BIND servers that the system can use to perform DNS lookups
         */
        forwarders?: string;
        /**
         * A list of name serverz that the system uses to validate DNS lookups
         */
        name_servers?: string;
        [k: string]: unknown;
      };
      /**
       * creates an EBS volume and optionally attaches it to an instance.  If both an instance ID and a device name is given and the instance has a device at the device name, then no volume is created and no attachment is made.  This module has a dependency on python-boto.
       */
      ec2_vol?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * An Ansible module to modify servers in CenturyLink Cloud.
       */
      clc_modify_server?: {
        /**
         * Default: None
         *
         * The alert policy name to be associated to the server. This is mutually exclusive with 'alert_policy_id'
         */
        alert_policy_name?: string;
        /**
         * Default: None
         *
         * The anti affinity policy name to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_id'
         */
        anti_affinity_policy_name?: string;
        /**
         * Default: present
         *
         * The state to insure that the provided resources are in.
         */
        state?: "present" | "absent";
        /**
         * Default: None
         *
         * The anti affinity policy id to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_name'
         */
        anti_affinity_policy_id?: string;
        /**
         * Default: None
         *
         * The alert policy id to be associated to the server. This is mutually exclusive with 'alert_policy_name'
         */
        alert_policy_id?: string;
        /**
         * Default: None
         *
         * Memory (in GB) to set to the server.
         */
        memory?: string;
        /**
         * A list of server Ids to modify.
         */
        server_ids:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: None
         *
         * How many CPUs to update on the server
         */
        cpu?: string;
        /**
         * Default: True
         *
         * Whether to wait for the provisioning tasks to finish before returning.
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module uses rabbitMQ Rest API to create/delete queues
       */
      rabbitmq_queue?: {
        /**
         * Default: 15672
         *
         * rabbitMQ management api port
         */
        login_port?: string;
        /**
         * Default: None
         *
         * Optional name of an exchange to which messages will be republished if they
         * are rejected or expire
         */
        dead_letter_exchange?: string;
        /**
         * Name of the queue to create
         */
        name: string;
        /**
         * Default: guest
         *
         * rabbitMQ user for connection
         */
        login_user?: string;
        /**
         * Default: localhost
         *
         * rabbitMQ host for connection
         */
        login_host?: string;
        /**
         * rabbitMQ password for connection
         */
        login_password?: string;
        /**
         * Default: /
         *
         * rabbitMQ virtual host
         */
        vhost?: string;
        /**
         * Default: present
         *
         * Whether the queue should be present or absent
         * Only present implemented atm
         */
        state?: "present" | "absent";
        /**
         * Default: no limit
         *
         * How many messages can the queue contain before it starts rejecting
         */
        max_length?: number | string;
        /**
         * extra arguments for queue. If defined this argument is a key/value dictionary
         */
        arguments?: {
          [k: string]: unknown;
        };
        /**
         * if the queue should delete itself after all queues/queues unbound from it
         */
        auto_delete?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: forever
         *
         * How long a message can live in queue before it is discarded (milliseconds)
         */
        message_ttl?: number | string;
        /**
         * Default: forever
         *
         * How long a queue can be unused before it is automatically deleted (milliseconds)
         */
        auto_expires?: number | string;
        /**
         * Default: None
         *
         * Optional replacement routing key to use when a message is dead-lettered.
         * Original routing key will be used if unset
         */
        dead_letter_routing_key?: string;
        /**
         * Default: True
         *
         * whether queue is durable or not
         */
        durable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create, update, remove hosts on NetApp E-series storage arrays
       */
      netapp_e_host?: {
        /**
         * the id of the storage array you wish to act against
         */
        ssid: string;
        /**
         * the group you want the host to be a member of
         */
        group?: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        force_port?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        state: "absent" | "present";
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * The index that maps to host type you wish to create. It is recommended to use the M(netapp_e_facts) module to gather this information. Alternatively you can use the WSP portal to retrieve the information.
         */
        host_type_index: number | string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * a list of of dictionaries of host ports you wish to associate with the newly created host
         */
        ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * If the host doesnt yet exist, the label to assign at creation time.
         * If the hosts already exists, this is what is used to identify the host to apply any desired changes
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove server groups from OpenStack.
       */
      os_server_group?: {
        /**
         * Default: present
         *
         * Indicate desired state of the resource. When I(state) is 'present', then I(policies) is required.
         */
        state?: string;
        /**
         * Server group name.
         */
        name?: string;
        /**
         * A list of one or more policy names to associate with the server group. The list must contain at least one policy name. The current valid policy names are anti-affinity, affinity, soft-anti-affinity and soft-affinity.
         */
        policies?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove PostgreSQL extensions from a database.
       */
      postgresql_ext?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manages Homebrew packages
       */
      homebrew?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add or remove kernel modules.
       */
      modprobe?: {
        /**
         * Default: present
         *
         * Whether the module should be present or absent.
         */
        state?: "present" | "absent";
        /**
         * Modules parameters.
         */
        params?: string;
        /**
         * Name of kernel module to manage.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove PostgreSQL users (roles) from a remote host and, optionally, grant the users access to an existing database or tables.
       * The fundamental function of the module is to create, or delete, roles from a PostgreSQL cluster. Privilege assignment, or removal, is an optional step, which works on one database at a time. This allows for the module to be called several times in the same module to modify the permissions on different databases, or to grant permissions to already existing users.
       * A user cannot be removed until all the privileges have been stripped from the user. In such situation, if the module tries to remove the user it will fail. To avoid this from happening the fail_on_user option signals the module to try to remove the user, but if not possible keep going; the module will report if changes happened and separately if the user was removed or not.
       */
      postgresql_user?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Gather facts for Rackspace Cloud Servers.
       */
      rax_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Allows you to create or remove a volume from a ProfitBricks datacenter. This module has a dependency on profitbricks >= 1.0.0
       */
      profitbricks_volume?: {
        /**
         * Default: 1
         *
         * The number of volumes you wish to create.
         */
        count?: number | string;
        /**
         * The datacenter in which to create the volumes.
         */
        datacenter?: string;
        /**
         * Public SSH keys allowing access to the virtual machine.
         */
        ssh_keys?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environement variable.
         */
        subscription_user?: string;
        /**
         * Password set for the administrative user.
         */
        image_password?: string;
        /**
         * Default: UNKNOWN
         *
         * The licence type for the volume. This is used when the image is non-standard.
         */
        licence_type?: string;
        /**
         * Default: True
         *
         * Whether or not to increment a single number in the name for created virtual machines.
         */
        auto_increment?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The system image ID for the volume, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8. This can also be a snapshot image ID.
         */
        image?: string;
        /**
         * list of instance ids, currently only used when state='absent' to remove instances.
         */
        instance_ids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The name of the volumes. You can enumerate the names using auto_increment.
         */
        name?: string;
        /**
         * THe ProfitBricks password. Overrides the PB_PASSWORD environement variable.
         */
        subscription_password?: string;
        /**
         * Default: present
         *
         * create or terminate datacenters
         */
        state?: string;
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * Default: VIRTIO
         *
         * The bus type.
         */
        bus?: "IDE" | "VIRTIO";
        /**
         * Default: yes
         *
         * wait for the datacenter to be created before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: HDD
         *
         * The disk type of the volume.
         */
        disk_type?: "HDD" | "SSD";
        server?: string;
        /**
         * Default: 10
         *
         * The size of the volume.
         */
        size?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete a Public IP address. Allows setting and updating the address allocation method and domain name label. Use the azure_rm_networkinterface module to associate a Public IP with a network interface.
       */
      azure_rm_publicipaddress?: {
        [k: string]: unknown;
      };
      /**
       * Sends an arbitrary set of commands to an EOS node and returns the results read from the device.  This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       */
      eos_command?: {
        [k: string]: unknown;
      };
      /**
       * This module can install new and updated packages on remote devices running Junos.  The module will compare the specified package with the one running on the remote device and install the specified version if there is a mismatch
       */
      junos_package?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Create and remove affinity groups.
       */
      cs_affinitygroup?: {
        /**
         * Account the affinity group is related to.
         */
        account?: string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        /**
         * Description of the affinity group.
         */
        description?: string;
        api_timeout?: number | string;
        /**
         * Type of the affinity group. If not specified, first found affinity type is used.
         */
        affinty_type?: string;
        api_region?: string;
        /**
         * Name of the project the affinity group is related to.
         */
        project?: string;
        /**
         * Default: present
         *
         * State of the affinity group.
         */
        state?: "present" | "absent";
        /**
         * Domain the affinity group is related to.
         */
        domain?: string;
        api_key?: string;
        /**
         * Name of the affinity group.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP LTM pools via iControl SOAP API
       */
      bigip_pool?: {
        /**
         * Monitor template name list. Always use the full path to the monitor.
         */
        monitors?: string;
        /**
         * Default: round_robin
         *
         * Load balancing method
         */
        lb_method?: string;
        /**
         * Monitor quorum value when monitor_type is m_of_n
         */
        quorum?: string;
        /**
         * Default: Common
         *
         * Partition of pool/pool member
         */
        partition?: string;
        /**
         * Sets the ramp-up time (in seconds) to gradually ramp up the load on newly added or freshly detected up pool members
         */
        slow_ramp_time?: string;
        /**
         * Pool member IP
         */
        host?: string;
        /**
         * Sets the action to take when node goes down in pool
         */
        service_down_action?: string;
        /**
         * Sets the number of times the system tries to contact a pool member after a passive failure
         */
        reselect_tries?: string;
        /**
         * Monitor rule type when monitors > 1
         */
        monitor_type?: string;
        /**
         * Default: present
         *
         * Pool/pool member state
         */
        state?: string;
        /**
         * Pool member port
         */
        port?: string;
        /**
         * Pool name
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Ensure the state of AWS VPC NAT Gateways based on their id, allocation and subnet ids.
       */
      ec2_vpc_nat_gateway?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages MTU settings on Nexus switch.
       */
      nxos_mtu?: {
        /**
         * Full name of interface, i.e. Ethernet1/1.
         */
        interface?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: string;
        /**
         * System jumbo MTU.
         */
        sysmtu?: string;
        /**
         * MTU for a specific interface.
         */
        mtu?: string;
        [k: string]: unknown;
      };
      /**
       * Create, destroy, update, start, stop, and reboot a ProfitBricks virtual machine. When the virtual machine is created it can optionally wait for it to be 'running' before returning. This module has a dependency on profitbricks >= 1.0.0
       */
      profitbricks?: {
        /**
         * The system image ID for creating the virtual machine, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8.
         */
        image?: string;
        /**
         * Default: 2048
         *
         * The amount of memory to allocate to the virtual machine.
         */
        ram?: number | string;
        /**
         * THe ProfitBricks password. Overrides the PB_PASSWORD environement variable.
         */
        subscription_password?: string;
        /**
         * Public SSH keys allowing access to the virtual machine.
         */
        ssh_keys?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environement variable.
         */
        subscription_user?: string;
        /**
         * Default: 10
         *
         * The size in GB of the boot volume.
         */
        volume_size?: number | string;
        /**
         * Default: present
         *
         * create or terminate instances
         */
        state?: string;
        /**
         * Default: us/las
         *
         * The datacenter location. Use only if you want to create the Datacenter or else this value is ignored.
         */
        location?: "us/las" | "de/fra" | "de/fkb";
        /**
         * This will assign the machine to the public LAN. If no LAN exists with public Internet access it is created.
         */
        assign_public_ip?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: True
         *
         * Whether or not to increment a single number in the name for created virtual machines.
         */
        auto_increment?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * The ID of the LAN you wish to add the servers to.
         */
        lan?: number | string;
        /**
         * Password set for the administrative user.
         */
        image_password?: string;
        /**
         * Default: VIRTIO
         *
         * The bus type for the volume.
         */
        bus?: "IDE" | "VIRTIO";
        /**
         * list of instance ids, currently only used when state='absent' to remove instances.
         */
        instance_ids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * Default: AMD_OPTERON
         *
         * The CPU family type to allocate to the virtual machine.
         */
        cpu_family?: "AMD_OPTERON" | "INTEL_XEON";
        disk_type?: "HDD" | "SSD";
        /**
         * Default: yes
         *
         * wait for the instance to be in state 'running' before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 1
         *
         * The number of virtual machines to create.
         */
        count?: number | string;
        /**
         * The datacenter to provision this virtual machine.
         */
        datacenter?: string;
        /**
         * Default: yes
         *
         * remove the bootVolume of the virtual machine you're destroying.
         */
        remove_boot_volume?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the virtual machine.
         */
        name?: string;
        /**
         * Default: 2
         *
         * The number of CPU cores to allocate to the virtual machine.
         */
        cores?: number | string;
        [k: string]: unknown;
      };
      /**
       * Creates or removes managed zones in Google Cloud DNS.
       */
      gcdns_zone?: {
        /**
         * An arbitrary text string to use for the zone description.
         */
        description?: string;
        /**
         * The DNS domain name of the zone.
         * This is NOT the Google Cloud DNS zone ID (e.g., example-com). If you attempt to specify a zone ID, this module will attempt to create a TLD and will fail.
         */
        zone?: string;
        /**
         * The e-mail address for a service account with access to Google Cloud DNS.
         */
        service_account_email?: string;
        /**
         * The path to the PEM file associated with the service account email.
         * This option is deprecated and may be removed in a future release. Use I(credentials_file) instead.
         */
        pem_file?: string;
        /**
         * Default: present
         *
         * Whether the given zone should or should not be present.
         */
        state?: string;
        /**
         * The path to the JSON file associated with the service account email.
         */
        credentials_file?: string;
        /**
         * The Google Cloud Platform project ID to use.
         */
        project_id?: string;
        [k: string]: unknown;
      };
      /**
       * Manage binary packages for Slackware using 'slackpkg' which is available in versions after 12.2.
       */
      slackpkg?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Manage the state of a virtual host in RabbitMQ
       */
      rabbitmq_vhost?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Manages interface VPC configuration
       */
      nxos_vpc_interface?: {
        /**
         * Set to true/false for peer link config on associated portchannel.
         */
        peer_link?: string;
        /**
         * Manages desired state of the resource.
         */
        state?: string;
        /**
         * Group number of the portchannel that will be configured.
         */
        portchannel?: string;
        /**
         * VPC group/id that will be configured on associated portchannel.
         */
        vpc?: string;
        [k: string]: unknown;
      };
      /**
       * Deploy to nodes controlled by Ironic.
       */
      os_ironic_node?: {
        /**
         * An integer value representing the number of seconds to wait for the node activation or deactivation to complete.
         */
        timeout?: string;
        /**
         * Default: None
         *
         * globally unique identifier (UUID) to be given to the resource.
         */
        uuid?: string;
        /**
         * Default: present
         *
         * A setting to allow power state to be asserted allowing nodes that are not yet deployed to be powered on, and nodes that are deployed to be powered off.
         */
        power?: string;
        /**
         * Default: True
         *
         * Indicates if the resource should be deployed. Allows for deployment logic to be disengaged and control of the node power or maintenance state to be changed.
         */
        deploy?: string;
        /**
         * Default: None
         *
         * If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.
         */
        ironic_url?: string;
        /**
         * Default: None
         *
         * A string expression regarding the reason a node is in a maintenance mode.
         */
        maintenance_reason?: string;
        /**
         * Default: present
         *
         * Indicates desired state of the resource
         */
        state?: string;
        /**
         * A setting to allow the direct control if a node is in maintenance mode.
         */
        maintenance?: string;
        /**
         * A boolean value instructing the module to wait for node activation or deactivation to complete before returning.
         */
        wait?: string;
        /**
         * Definition of the instance information which is used to deploy the node.  This information is only required when an instance is set to present.
         */
        instance_info?: string;
        /**
         * Default: None
         *
         * A configdrive file or HTTP(S) URL that will be passed along to the node.
         */
        config_drive?: string;
        [k: string]: unknown;
      };
      /**
       * Sends arbitrary commands to an ios node and returns the results read from the device. This module includes an argument that will cause the module to wait for a specific condition before returning or timing out if the condition is not met.
       * This module does not support running commands in configuration mode. Please use M(ios_config) to configure IOS devices.
       */
      ios_command?: {
        [k: string]: unknown;
      };
      /**
       * Manages network device configurations over SSH.  This module allows implementers to work with the device running-config.  It provides a way to push a set of commands onto a network device by evaluating the current running-config and only pushing configuration commands that are not already configured.  The config source can be a set of commands or a template.
       */
      iosxr_template?: {
        /**
         * The path to the config source.  The source can be either a file with config or a template that will be merged during runtime.  By default the task will first search for the source file in role or playbook root folder in templates unless a full path to the file is given.
         */
        src?: string;
        /**
         * The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
         */
        config?: string;
        /**
         * The force argument instructs the module not to consider the current device running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.
         */
        force?: string;
        /**
         * When this argument is configured true, the module will backup the running-config from the node prior to making any changes. The backup file will be written to backup_{{ hostname }} in the root of the playbook directory.
         */
        backup?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 VPCs in AWS
       */
      ec2_vpc_net_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage I(libvirt) networks.
       */
      virt_net?: {
        [k: string]: unknown;
      };
      /**
       * This module manages whole lifecycle of the Virtual Machine(VM) in oVirt. Since VM can hold many states in oVirt, this see notes to see how the states of the VM are handled.
       */
      ovirt_vms?: {
        /**
         * Amount of minimal guaranteed memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
         * C(memory_guaranteed) parameter can't be lower than C(memory) parameter. Default value is set by engine.
         */
        memory_guaranteed?: string;
        /**
         * Please check to I(Synopsis) to more detailed description of force parameter, it can behave differently in different situations.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the cluster, where Virtual Machine should be created. Required if creating VM.
         */
        cluster?: string;
        fetch_nested?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * ID of the the Virtual Machine to manage.
         */
        id?: string;
        /**
         * Number of virtual CPUs sockets of the Virtual Machine. Default value is set by oVirt engine.
         */
        cpu_sockets?: number | string;
        /**
         * If I(True) Virtual Machine will be set as highly available.
         * If I(False) Virtual Machine won't be set as highly available.
         * If no value is passed, default value is set by oVirt engine.
         */
        high_availability?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of NICs, which should be attached to Virtual Machine. NIC is described by following dictionary:
         * C(name) - Name of the NIC.
         * C(profile_name) - Profile name where NIC should be attached.
         * C(interface) -  Type of the network interface. One of following: I(virtio), I(e1000), I(rtl8139), default is I(virtio).
         * C(mac_address) - Custom MAC address of the network interface, by default it's obtained from MAC pool.
         * C(Note:)
         * This parameter is used only when C(state) is I(running) or I(present) and is able to only create NICs. To manage NICs of the VM in more depth please use M(ovirt_nics) module instead.
         */
        nics?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Dictionary with values for Windows Virtual Machine initialization using sysprep:
         * C(host_name) - Hostname to be set to Virtual Machine when deployed.
         * C(active_directory_ou) - Active Directory Organizational Unit, to be used for login of user.
         * C(org_name) - Organization name to be set to Windows Virtual Machine.
         * C(domain) - Domain to be set to Windows Virtual Machine.
         * C(timezone) - Timezone to be set to Windows Virtual Machine.
         * C(ui_language) - UI language of the Windows Virtual Machine.
         * C(system_locale) - System localization of the Windows Virtual Machine.
         * C(input_locale) - Input localization of the Windows Virtual Machine.
         * C(windows_license_key) - License key to be set to Windows Virtual Machine.
         * C(user_name) - Username to be used for set password to Windows Virtual Machine.
         * C(root_password) - Password to be set for username to Windows Virtual Machine.
         */
        sysprep?: {
          [k: string]: unknown;
        };
        /**
         * Number of virtual CPUs cores of the Virtual Machine. Default value is set by oVirt engine.
         */
        cpu_cores?: number | string;
        /**
         * Default: present
         *
         * Should the Virtual Machine be running/stopped/present/absent/suspended/next_run.
         * I(present) and I(running) are equal states.
         * I(next_run) state updates the VM and if the VM has next run configuration it will be rebooted.
         * Please check I(notes) to more detailed description of states.
         */
        state?: "running" | "stopped" | "present" | "absent" | "suspended" | "next_run";
        /**
         * Name of the template, which should be used to create Virtual Machine. Required if creating VM.
         * If template is not specified and VM doesn't exist, VM will be created from I(Blank) template.
         */
        template?: string;
        /**
         * Amount of memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).
         * Default value is set by engine.
         */
        memory?: string;
        /**
         * ISO file from ISO storage domain which should be attached to Virtual Machine.
         * If you pass empty string the CD will be ejected from VM.
         * If used with C(state) I(running) or I(present) and VM is running the CD will be attached to VM.
         * If used with C(state) I(running) or I(present) and VM is down the CD will be attached to VM persistently.
         */
        cd_iso?: string;
        /**
         * If I(True) then the permissions of the template (only the direct ones, not the inherited ones) will be copied to the created virtual machine.
         * This parameter is used only when C(state) is I(running) or I(present) and VM didn't exist before.
         */
        clone_permissions?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Type of the Virtual Machine. Default value is set by oVirt engine.
         */
        type?: "server" | "desktop";
        /**
         * If I(True) Virtual Machine will be set as delete protected.
         * If I(False) Virtual Machine won't be set as delete protected.
         * If no value is passed, default value is set by oVirt engine.
         */
        delete_protected?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * If I(True) then the disks of the created virtual machine will be cloned and independent of the template.
         * This parameter is used only when C(state) is I(running) or I(present) and VM didn't exist before.
         */
        clone?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of boot devices which should be used to boot. Choices I(network), I(hd) and I(cdrom).
         * For example: ['cdrom', 'hd']. Default value is set by oVirt engine.
         */
        boot_devices?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        nested_attributes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Specify host where Virtual Machine should be running. By default the host is chosen by engine scheduler.
         * This parameter is used only when C(state) is I(running) or I(present).
         */
        host?: string;
        auth: {
          [k: string]: unknown;
        };
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * If I(True) Virtual Machine will be set as stateless.
         * If I(False) Virtual Machine will be unset as stateless.
         * If no value is passed, default value is set by oVirt engine.
         */
        stateless?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Operating system of the Virtual Machine. Default value is set by oVirt engine.
         */
        operating_system?:
          | "rhel_6_ppc64"
          | "other"
          | "freebsd"
          | "windows_2003x64"
          | "windows_10"
          | "rhel_6x64"
          | "rhel_4x64"
          | "windows_2008x64"
          | "windows_2008R2x64"
          | "debian_7"
          | "windows_2012x64"
          | "ubuntu_14_04"
          | "ubuntu_12_04"
          | "ubuntu_13_10"
          | "windows_8x64"
          | "other_linux_ppc64"
          | "windows_2003"
          | "other_linux"
          | "windows_10x64"
          | "windows_2008"
          | "rhel_3"
          | "rhel_5"
          | "rhel_4"
          | "other_ppc64"
          | "sles_11"
          | "rhel_6"
          | "windows_xp"
          | "rhel_7x64"
          | "freebsdx64"
          | "rhel_7_ppc64"
          | "windows_7"
          | "rhel_5x64"
          | "ubuntu_14_04_ppc64"
          | "sles_11_ppc64"
          | "windows_8"
          | "windows_2012R2x64"
          | "windows_2008r2x64"
          | "ubuntu_13_04"
          | "ubuntu_12_10"
          | "windows_7x64";
        /**
         * Name of the the Virtual Machine to manage. If VM don't exists C(name) is required. Otherwise C(id) or C(name) can be used.
         */
        name?: string;
        /**
         * Dictionary with values for Unix-like Virtual Machine initialization using cloud init:
         * C(host_name) - Hostname to be set to Virtual Machine when deployed.
         * C(timezone) - Timezone to be set to Virtual Machine when deployed.
         * C(user_name) - Username to be used to set password to Virtual Machine when deployed.
         * C(root_password) - Password to be set for user specified by C(user_name) parameter.
         * C(authorized_ssh_keys) - Use this SSH keys to login to Virtual Machine.
         * C(regenerate_ssh_keys) - If I(True) SSH keys will be regenerated on Virtual Machine.
         * C(custom_script) - Cloud-init script which will be executed on Virtual Machine when deployed.
         * C(dns_servers) - DNS servers to be configured on Virtual Machine.
         * C(dns_search) - DNS search domains to be configured on Virtual Machine.
         * C(nic_boot_protocol) - Set boot protocol of the network interface of Virtual Machine. Can be one of None, DHCP or Static.
         * C(nic_ip_address) - If boot protocol is static, set this IP address to network interface of Virtual Machine.
         * C(nic_netmask) - If boot protocol is static, set this netmask to network interface of Virtual Machine.
         * C(nic_gateway) - If boot protocol is static, set this gateway to network interface of Virtual Machine.
         * C(nic_name) - Set name to network interface of Virtual Machine.
         * C(nic_on_boot) - If I(True) network interface will be set to start on boot.
         */
        cloud_init?: {
          [k: string]: unknown;
        };
        /**
         * List of disks, which should be attached to Virtual Machine. Disk is described by following dictionary:
         * C(name) - Name of the disk. Either C(name) or C(id) is reuqired.
         * C(id) - ID of the disk. Either C(name) or C(id) is reuqired.
         * C(interface) - Interface of the disk, either I(virtio) or I(IDE), default is I(virtio).
         * C(bootable) - I(True) if the disk should be bootable, default is non bootable.
         * C(activate) - I(True) if the disk should be activated, default is activated.
         * C(Note:)
         * This parameter is used only when C(state) is I(running) or I(present) and is able to only attach disks. To manage disks of the VM in more depth please use M(ovirt_disks) module instead.
         */
        disks?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        poll_interval?: number | string;
        timeout?: number | string;
        /**
         * Set a CPU shares for this Virtual Machine. Default value is set by oVirt engine.
         */
        cpu_shares?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create/delete a droplet in DigitalOcean and optionally wait for it to be 'running', or deploy an SSH key.
       */
      digital_ocean?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add and remove security group rules.
       */
      cs_securitygroup_rule?: {
        [k: string]: unknown;
      };
      /**
       * Manage the container images on the atomic host platform
       * Allows to execute the commands on the container images
       */
      atomic_image?: {
        /**
         * Default: True
         *
         * Start or Stop the continer
         */
        started?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: latest
         *
         * The state of the container image.
         * The state ```latest``` will ensure container image is upgraded to the latest version and forcefully restart container, if running.
         */
        state?: "present" | "absent" | "latest";
        /**
         * Name of the container image
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages CSW packages (SVR4 format) on Solaris 10 and 11.
       * These were the native packages on Solaris <= 10 and are available as a legacy feature in Solaris 11.
       * Pkgutil is an advanced packaging system, which resolves dependency on installation. It is designed for CSW packages.
       */
      pkgutil?: {
        /**
         * Whether to install (C(present)), or remove (C(absent)) a package.
         * The upgrade (C(latest)) operation will update/install the package to the latest version available.
         * Note: The module has a limitation that (C(latest)) only works for one package, not lists of them.
         */
        state: "present" | "absent" | "latest";
        /**
         * Specifies the repository path to install the package from.
         * Its global definition is done in C(/etc/opt/csw/pkgutil.conf).
         */
        site?: string;
        /**
         * Package name, e.g. (C(CSWnrpe))
         */
        name: string;
        /**
         * If you want to refresh your catalog from the mirror, set this to (C(yes)).
         */
        update_catalog?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Gathering facts from the API of a zone.
       */
      cs_zone_facts?: {
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        api_key?: string;
        /**
         * Name of the zone.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Configures the NXAPI feature on devices running Cisco NXOS.  The NXAPI feature is absent from the configuration by default.  Since this module manages the NXAPI feature it only supports the use of the C(Cli) transport.
       */
      nxos_nxapi?: {
        /**
         * Default: 80
         *
         * Configure the port with which the HTTP server will listen on for requests.  By default, NXAPI will bind the HTTP service to the standard HTTP port 80.  This argument accepts valid port values in the range of 1 to 65535.
         */
        http_port?: string;
        /**
         * Default: True
         *
         * Controls the operating state of the HTTP protocol as one of the underlying transports for NXAPI.  By default, NXAPI will enable the HTTP transport when the feature is first configured.  To disable the use of the HTTP transport, set the value of this argument to False.
         */
        http?: string;
        /**
         * Default: 443
         *
         * Configure the port with which the HTTPS server will listen on for requests.  By default, NXAPI will bind the HTTPS service to the standard HTTPS port 443.  This argument accepts valid port values in the range of 1 to 65535.
         */
        https_port?: string;
        /**
         * The NXAPI feature provides a web base UI for developers for entering commands.  This feature is initially disabled when the NXAPI feature is configured for the first time.  When the C(sandbox) argument is set to True, the developer sandbox URL will accept requests and when the value is set to False, the sandbox URL is unavailable.
         */
        sandbox?: string;
        /**
         * Default: present
         *
         * The C(state) argument controls whether or not the NXAPI feature is configured on the remote device.  When the value is C(present) the NXAPI feature configuration is present in the device running-config.  When the values is C(absent) the feature configuration is removed from the running-config.
         */
        state?: string;
        /**
         * Controls the operating state of the HTTPS protocol as one of the underlying transports for NXAPI.  By default, NXAPI will disable the HTTPS transport when the feature is first configured.  To enable the use of the HTTPS transport, set the value of this argument to True.
         */
        https?: string;
        /**
         * The C(config) argument provides an optional argument to specify the device running-config to used as the basis for configuring the remote system.  The C(config) argument accepts a string value that represents the device configuration.
         */
        config?: string;
        [k: string]: unknown;
      };
      /**
       * Wraps the reg.exe command to import the contents of a registry file.
       * Suitable for use with registry files created using M(win_template).
       * Windows registry files have a specific format and must be constructed correctly with carriage return and line feed line endings otherwise they will not be merged.
       * Exported registry files often start with a Byte Order Mark which must be removed if the file is to templated using M(win_template).
       * Registry file format is described at U(https://support.microsoft.com/en-us/kb/310516)
       * See also M(win_template), M(win_regedit)
       */
      win_regmerge?: {
        /**
         * Default: no default
         *
         * The full path including file name to the registry file on the remote machine to be merged
         */
        path?: string;
        /**
         * Default: no default
         *
         * The parent key to use when comparing the contents of the registry to the contents of the file.  Needs to be in HKLM or HKCU part of registry.  Use a PS-Drive style path for example HKLM:\SOFTWARE not HKEY_LOCAL_MACHINE\SOFTWARE If not supplied, or the registry key is not found, no comparison will be made, and the module will report changed.
         */
        compare_key?: string;
        [k: string]: unknown;
      };
      /**
       * Obtain a session token from the AWS Security Token Service
       */
      sts_session_token?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module manages boundary meters
       */
      boundary_meter?: {
        /**
         * Organizations boundary API ID
         */
        apiid: string;
        /**
         * Organizations boundary API KEY
         */
        apikey: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * meter name
         */
        name?: string;
        /**
         * Default: True
         *
         * Whether to create or remove the client from boundary
         */
        state: "present" | "absent";
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about ports from OpenStack.
       */
      os_port_facts?: {
        /**
         * Unique name or ID of a port.
         */
        port?: string;
        /**
         * A dictionary of meta data to use for further filtering. Elements of this dictionary will be matched against the returned port dictionaries. Matching is currently limited to strings within the port dictionary, or strings within nested dictionaries.
         */
        filters?: string;
        [k: string]: unknown;
      };
      /**
       * Manage which I(sensu channels) a machine should subscribe to
       */
      sensu_subscription?: {
        /**
         * Default: /etc/sensu/conf.d/subscriptions.json
         *
         * Path to the subscriptions json file
         */
        path?: string;
        /**
         * Default: present
         *
         * Whether the machine should subscribe or unsubscribe from the channel
         */
        state?: "present" | "absent";
        /**
         * Create a backup file (if yes), including the timestamp information so you
         * can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the channel
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages static route configuration
       */
      nxos_static_route?: {
        /**
         * Next hop address or interface of static route. If interface, it must be the fully-qualified interface name.
         */
        next_hop?: string;
        /**
         * Preference or administrative difference of route (range 1-255).
         */
        pref?: string;
        /**
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Name of the route. Used with the name parameter on the CLI.
         */
        route_name?: string;
        /**
         * Destination prefix of static route.
         */
        prefix?: string;
        /**
         * Route tag value (numeric).
         */
        tag?: string;
        /**
         * Default: default
         *
         * VRF for static route.
         */
        vrf?: string;
        [k: string]: unknown;
      };
      /**
       * Gather facts about EC2 Elastic Load Balancers in AWS
       */
      ec2_elb_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages physical attributes of interfaces of NX-OS switches.
       */
      nxos_interface?: {
        /**
         * Interface description.
         */
        description?: string;
        /**
         * Associate SVI with anycast gateway under VLAN configuration mode.
         */
        fabric_forwarding_anycast_gateway?: string;
        /**
         * Interface type to be unconfigured from the device.
         */
        interface_type?: string;
        /**
         * Enable/Disable ip forward feature on SVIs.
         */
        ip_forward?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: string;
        /**
         * Default: up
         *
         * Administrative state of the interface.
         */
        admin_state?: string;
        /**
         * Manage Layer 2 or Layer 3 state of the interface.
         */
        mode?: string;
        /**
         * Full name of interface, i.e. Ethernet1/1, port-channel10.
         */
        interface?: string;
        [k: string]: unknown;
      };
      /**
       * Manage packages on SUSE and openSUSE using the zypper and rpm tools.
       */
      zypper?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * This module asserts that given expressions are true with an optional custom message.
       */
      assert?: {
        host?: string;
        connect_timeout?: number | string;
        delay?: number | string;
        state?: "started" | "stopped" | "present" | "absent" | "drained";
        timeout?: number | string;
        exclude_hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        search_regex?: string;
        path?: string;
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Enables or disables a specified module of the Apache2 webserver.
       */
      apache2_module?: {
        /**
         * Default: present
         *
         * indicate the desired state of the resource
         */
        state?: "present" | "absent";
        /**
         * force disabling of default modules and override Debian warnings
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * name of the module to enable/disable
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * This module controls active and configured mount points in C(/etc/fstab).
       */
      mount?: {
        /**
         * Device to be mounted on I(name). Required when I(state) set to C(present) or C(mounted).
         */
        src?: string;
        /**
         * Path to the mount point (e.g. C(/mnt/files))
         */
        name: string;
        /**
         * Dump (see fstab(5)). Note that if set to C(null) and I(state) set to C(present), it will cease to work and duplicate entries will be made with subsequent runs.
         * Has no effect on Solaris systems.
         */
        dump?: string;
        /**
         * Default: True
         *
         * Determines if the filesystem should be mounted on boot.
         * Only applies to Solaris systems.
         */
        boot?: "yes" | "no";
        /**
         * Default: /etc/fstab (/etc/vfstab on Solaris)
         *
         * File to use instead of C(/etc/fstab). You shouldn't use this option unless you really know what you are doing. This might be useful if you need to configure mountpoints in a chroot environment.  OpenBSD does not allow specifying alternate fstab files with mount so do not use this on OpenBSD with any state that operates on the live filesystem.
         */
        fstab?: string;
        /**
         * Passno (see fstab(5)). Note that if set to C(null) and I(state) set to C(present), it will cease to work and duplicate entries will be made with subsequent runs.
         * Deprecated on Solaris systems.
         */
        passno?: string;
        /**
         * Filesystem type. Required when I(state) is C(present) or C(mounted).
         */
        fstype?: string;
        /**
         * If C(mounted) or C(unmounted), the device will be actively mounted or unmounted as needed and appropriately configured in I(fstab).
         * C(absent) and C(present) only deal with I(fstab) but will not affect current mounting.
         * If specifying C(mounted) and the mount point is not present, the mount point will be created.
         * Similarly, specifying C(absent) will remove the mount point directory.
         */
        state: "present" | "absent" | "mounted" | "unmounted";
        /**
         * Mount options (see fstab(5), or vfstab(4) on Solaris).
         */
        opts?: string;
        [k: string]: unknown;
      };
      /**
       * Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool, using HTTP POST and GET requests. The httpd mod_proxy balancer-member status page has to be enabled and accessible, as this module relies on parsing this page. This module supports ansible check_mode, and requires BeautifulSoup python module.
       */
      apache2_mod_proxy?: {
        /**
         * Use https to access balancer management page.
         */
        tls?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * (ipv4|ipv6|fqdn):port of the Apache httpd 2.4 mod_proxy balancer pool.
         */
        balancer_vhost: string;
        /**
         * Default: /balancer-manager/
         *
         * Suffix of the balancer pool url required to access the balancer pool status page (e.g. balancer_vhost[:port]/balancer_url_suffix).
         */
        balancer_url_suffix?: string;
        /**
         * Default: None
         *
         * (ipv4|ipv6|fqdn) of the balancer member to get or to set attributes to. Port number is autodetected and should not be specified here. If undefined, apache2_mod_proxy module will return a members list of dictionaries of all the current balancer pool members' attributes.
         */
        member_host?: string;
        /**
         * Default: None
         *
         * Desired state of the member host. (absent|disabled),drained,hot_standby,ignore_errors can be simultaneously invoked by separating them with a comma (e.g. state=drained,ignore_errors).
         */
        state?: string;
        /**
         * Default: True
         *
         * Validate ssl/tls certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Adds or removes SSH authorized keys for particular user accounts
       */
      authorized_key?: {
        /**
         * Default: no
         *
         * Whether to remove all other non-specified keys from the authorized_keys file. Multiple keys can be specified in a single C(key) string value by separating them by newlines.
         * This option is not loop aware, so if you use C(with_) , it will be exclusive per iteration of the loop, if you want multiple keys in the file you need to pass them all to C(key) in a single batch as mentioned above.
         */
        exclusive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A string of ssh key options to be prepended to the key in the authorized_keys file
         */
        key_options?: string;
        /**
         * Default: present
         *
         * Whether the given key (with the given key_options) should or should not be in the file
         */
        state?: "present" | "absent";
        /**
         * The username on the remote host whose authorized_keys file will be modified
         */
        user: string;
        /**
         * The SSH public key(s), as a string or (since 1.9) url (https://github.com/username.keys)
         */
        key: string;
        /**
         * Default: (homedir)+/.ssh/authorized_keys
         *
         * Alternate path to the authorized_keys file
         */
        path?: string;
        unique?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * This only applies if using a https url as the source of the keys. If set to C(no), the SSL certificates will not be validated.
         * This should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.
         * Prior to 2.1 the code worked as if this was set to C(yes).
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * Whether this module should manage the directory of the authorized key file.  If set, the module will create the directory, as well as set the owner and permissions of an existing directory. Be sure to set C(manage_dir=no) if you are using an alternate directory for authorized_keys, as set with C(path), since you could lock yourself out of SSH access. See the example below.
         */
        manage_dir?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage VMware ESXi DNS Configuration
       */
      vmware_dns_config?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Configures a bridge interface on Cumulus Linux To configure a bond port use the cl_bond module. To configure any other type of interface use the cl_interface module. Follow the guidelines for bridging found in the Cumulus User Guide at U(http://docs.cumulusnetworks.com)
       */
      cl_bridge?: {
        /**
         * Configures the port to use DHCP. To enable this feature use the option I(dhcp).
         */
        addr_method?: "" | "dhcp";
        /**
         * Name of the interface.
         */
        name: string;
        /**
         * Enables vlan-aware mode.
         */
        vlan_aware?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set spanning tree root priority. Must be a multiple of 4096.
         */
        mstpctl_treeprio?: string;
        /**
         * Define Ethernet mac associated with Cumulus Linux VRR feature.
         */
        virtual_mac?: string;
        /**
         * Set MTU. Configure Jumbo Frame by setting MTU to I(9000).
         */
        mtu?: string;
        /**
         * In vlan-aware mode, defines vlan that is the untagged vlan.
         */
        pvid?: string;
        /**
         * List of IPv4 addresses to configure on the interface. In the form I(X.X.X.X/YY).
         */
        ipv4?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: yes
         *
         * Enables spanning tree Protocol. As of Cumulus Linux 2.5 the default bridging mode, only per vlan RSTP or 802.1d is supported. For the vlan aware mode, only common instance STP is supported
         */
        stp?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Define IPv4 virtual IP used by the Cumulus Linux VRR feature.
         */
        virtual_ip?: string;
        /**
         * List of IPv6 addresses to configure on the interface. In the form I(X:X:X::X/YYY).
         */
        ipv6?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * In vlan-aware mode, lists VLANs defined under the interface.
         */
        vids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Description of the port.
         */
        alias_name?: string;
        /**
         * List of bridge members.
         */
        ports:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: ['/etc/network/interfaces.d']
         *
         * Interface directory location.
         */
        location?: string;
        [k: string]: unknown;
      };
      /**
       * Send a message to a flowdock team inbox or chat using the push API (see https://www.flowdock.com/api/team-inbox and https://www.flowdock.com/api/chat)
       */
      flowdock?: {
        /**
         * (inbox only) Name of the message sender
         */
        from_name?: string;
        /**
         * (inbox only - required) Email address of the message sender
         */
        from_address?: string;
        /**
         * tags of the message, separated by commas
         */
        tags?: string;
        /**
         * Whether to post to 'inbox' or 'chat'
         */
        type: "inbox" | "chat";
        /**
         * (chat only - required) Name of the "user" sending the message
         */
        external_user_name?: string;
        /**
         * (inbox only) Human readable identifier for more detailed message categorization
         */
        project?: string;
        /**
         * (inbox only - required) Human readable identifier of the application that uses the Flowdock API
         */
        source?: string;
        /**
         * API token.
         */
        token: string;
        /**
         * (inbox only) Link associated with the message. This will be used to link the message subject in Team Inbox.
         */
        link?: string;
        /**
         * (inbox only) Email address for replies
         */
        reply_to?: string;
        /**
         * (inbox only - required) Subject line of the message
         */
        subject?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Content of the message
         */
        msg: string;
        [k: string]: unknown;
      };
      /**
       * Manage route domains on a BIG-IP
       */
      bigip_routedomain?: {
        /**
         * The eviction policy to use with this route domain. Apply an eviction policy to provide customized responses to flow overflows and slow flows on the route domain.
         */
        flow_eviction_policy?: string;
        /**
         * Service policy to associate with the route domain.
         */
        service_policy?: string;
        /**
         * Specifies descriptive text that identifies the route domain.
         */
        description?: string;
        /**
         * Specifies the route domain the system searches when it cannot
         * find a route in the configured domain.
         *
         */
        parent?: string;
        /**
         * The maximum number of concurrent connections allowed for the route domain. Setting this to C(0) turns off connection limits.
         */
        connection_limit?: string;
        /**
         * Specifies whether the system enforces cross-routing restrictions or not.
         */
        strict?: string;
        /**
         * Default: present
         *
         * Whether the route domain should exist or not.
         */
        state?: string;
        /**
         * Dynamic routing protocols for the system to use in the route domain.
         */
        routing_protocol?: string;
        /**
         * The bandwidth controller for the route domain.
         */
        bwc_policy?: string;
        /**
         * VLANs for the system to use in the route domain
         */
        vlans?: string;
        /**
         * The unique identifying integer representing the route domain.
         */
        id?: string;
        [k: string]: unknown;
      };
      /**
       * Manages locales by editing /etc/locale.gen and invoking locale-gen.
       */
      locale_gen?: {
        /**
         * Default: present
         *
         * Whether the locale shall be present.
         */
        state?: "present" | "absent";
        /**
         * Name and encoding of the locale, such as "en_GB.UTF-8".
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and remove domains.
       */
      cs_domain?: {
        api_key?: string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Clean up all domain resources like child domains and accounts.
         * Considered on C(state=absent).
         */
        clean_up?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * State of the domain.
         */
        state?: "present" | "absent";
        /**
         * Path of the domain.
         * Prefix C(ROOT/) or C(/ROOT/) in path is optional.
         */
        path: string;
        /**
         * Network domain for networks in the domain.
         */
        network_domain?: string;
        [k: string]: unknown;
      };
      /**
       * Installs or uninstalls a Windows MSI file that is already located on the target server
       */
      win_msi?: {
        /**
         * Additional arguments to pass to the msiexec.exe command
         */
        extra_args?: string;
        /**
         * File system path to the MSI file to install
         */
        path?: string;
        /**
         * Default: present
         *
         * Whether the MSI file should be installed or uninstalled
         */
        state?: string;
        /**
         * Path to a file created by installing the MSI to prevent from attempting to reinstall the package on every run
         */
        creates?: string;
        /**
         * Specify whether to wait for install or uninstall to complete before continuing.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * create / delete a database in the Cloud Databases.
       */
      rax_cdb_database?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Use this module to manage crontab variables. This module allows you to create, update, or delete cron variable definitions.
       */
      cronvar?: {
        /**
         * Name of the crontab variable.
         */
        name: string;
        /**
         * Used with C(state=present). If specified, the variable will be inserted just before the variable specified.
         */
        insertbefore?: string;
        /**
         * If specified, uses this file instead of an individual user's crontab. Without a leading /, this is assumed to be in /etc/cron.d.  With a leading /, this is taken as absolute.
         */
        cron_file?: string;
        /**
         * The value to set this variable to.  Required if state=present.
         */
        value?: string;
        /**
         * Default: present
         *
         * Whether to ensure that the variable is present or absent.
         */
        state?: "present" | "absent";
        /**
         * Default: root
         *
         * The specific user whose crontab should be modified.
         */
        user?: string;
        /**
         * Used with C(state=present). If specified, the variable will be inserted after the variable specified.
         */
        insertafter?: string;
        /**
         * If set, create a backup of the crontab before it is modified. The location of the backup is returned in the C(backup) variable by this module.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages virtual machines supported by I(libvirt).
       */
      virt?: {
        [k: string]: unknown;
      };
      /**
       * Tests reachability using ping from switch to a remote destination.
       */
      nxos_ping?: {
        /**
         * IP address or hostname (resolvable by switch) of remote node.
         */
        dest?: string;
        /**
         * Default: 2
         *
         * Number of packets to send.
         */
        count?: string;
        /**
         * Outgoing VRF.
         */
        vrf?: string;
        /**
         * Source IP Address.
         */
        source?: string;
        [k: string]: unknown;
      };
      /**
       * This module will let you trigger, acknowledge or resolve a PagerDuty incident by sending events
       */
      pagerduty_alert?: {
        /**
         * The URL of the monitoring client that is triggering this event.
         */
        client_url?: string;
        /**
         * PagerDuty unique subdomain.
         */
        name: string;
        /**
         * Type of event to be sent.
         */
        state: "triggered" | "acknowledged" | "resolved";
        /**
         * Identifies the incident to which this I(state) should be applied.
         * For C(triggered) I(state) - If there's no open (i.e. unresolved) incident with this key, a new one will be created. If there's already an open incident with a matching key, this event will be appended to that incident's log. The event key provides an easy way to "de-dup" problem reports.
         * For C(acknowledged) or C(resolved) I(state) - This should be the incident_key you received back when the incident was first opened by a trigger event. Acknowledge events referencing resolved or nonexistent incidents will be discarded.
         */
        incident_key?: string;
        /**
         * The name of the monitoring client that is triggering this event.
         */
        client?: string;
        /**
         * The GUID of one of your "Generic API" services.
         * This is the "service key" listed on a Generic API's service detail page.
         */
        service_key: string;
        /**
         * The pagerduty API key (readonly access), generated on the pagerduty site.
         */
        api_key: string;
        /**
         * Default: Created via Ansible
         *
         * For C(triggered) I(state) - Required. Short description of the problem that led to this trigger. This field (or a truncated version) will be used when generating phone calls, SMS messages and alert emails. It will also appear on the incidents tables in the PagerDuty UI. The maximum length is 1024 characters.
         * For C(acknowledged) or C(resolved) I(state) - Text that will appear in the incident's log associated with this event.
         */
        desc?: string;
        [k: string]: unknown;
      };
      /**
       * Creates, removes, or updates GitHub access keys.
       */
      github_key?: {
        /**
         * Default: none
         *
         * SSH public key value. Required when C(state=present).
         */
        pubkey?: string;
        /**
         * GitHub Access Token with permission to list and create public keys.
         */
        token: string;
        /**
         * Default: yes
         *
         * The default is C(yes), which will replace the existing remote key if it's different than C(pubkey). If C(no), the key will only be set if no key with the given C(name) exists.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * SSH key name
         */
        name: string;
        /**
         * Default: present
         *
         * Whether to remove a key, ensure that it exists, or update its value.
         */
        state?: "present" | "absent";
        [k: string]: unknown;
      };
      /**
       * Register a template from URL, create a template from a ROOT volume of a stopped VM or its snapshot, extract and delete templates.
       */
      cs_template?: {
        /**
         * Domain the template, snapshot or VM is related to.
         */
        domain?: string;
        api_http_method?: "get" | "post";
        /**
         * VM name the template will be created from its volume or alternatively from a snapshot.
         * VM must be in stopped state if created from its volume.
         * Mutually exclusive with C(url).
         */
        vm?: string;
        /**
         * True if the template or its derivatives are extractable.
         */
        is_extractable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name the hypervisor to be used for creating the new template.
         * Relevant when using C(state=present).
         */
        hypervisor?:
          | "KVM"
          | "kvm"
          | "VMware"
          | "vmware"
          | "BareMetal"
          | "baremetal"
          | "XenServer"
          | "xenserver"
          | "LXC"
          | "lxc"
          | "HyperV"
          | "hyperv"
          | "UCS"
          | "ucs"
          | "OVM"
          | "ovm"
          | "Simulator"
          | "simulator";
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        /**
         * Name of the zone you wish the template to be registered or deleted from.
         * If not specified, first found zone will be used.
         */
        zone?: string;
        /**
         * True if the template supports the sshkey upload feature.
         */
        sshkey_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Register the template having XS/VMWare tools installed in order to support dynamic scaling of VM CPU/memory.
         * Only used if C(state) is present.
         */
        is_dynamically_scalable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * State of the template.
         */
        state?: "present" | "absent" | "extracted";
        /**
         * This flag is used for searching existing templates.
         * If set to C(true), it will only list template ready for deployment e.g. successfully downloaded and installed.
         * Recommended to set it to C(false).
         */
        is_ready?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Template details in key/value pairs.
         */
        details?: string;
        /**
         * True if the template type is routing i.e., if template is used to deploy router.
         * Only considered if C(url) is used.
         */
        is_routing?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Register the template to be featured.
         * Only used if C(state) is present.
         */
        is_featured?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_key?: string;
        /**
         * Default: 64
         *
         * 32 or 64 bits support.
         */
        bits?: number | string;
        /**
         * The format for the template.
         * Relevant when using C(state=present).
         */
        format?: "QCOW2" | "RAW" | "VHD" | "OVA";
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Register the template to be publicly available to all users.
         * Only used if C(state) is present.
         */
        is_public?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * true if this template requires HVM.
         */
        requires_hvm?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * True if the template supports the password reset feature.
         */
        password_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Display text of the template.
         */
        display_text?: string;
        /**
         * Account the template, snapshot or VM is related to.
         */
        account?: string;
        /**
         * the tag for this template.
         */
        template_tag?: string;
        /**
         * Name of the template.
         */
        name: string;
        /**
         * URL of where the template is hosted on C(state=present).
         * URL to which the template would be extracted on C(state=extracted).
         * Mutually exclusive with C(vm).
         */
        url?: string;
        /**
         * Default: self
         *
         * Name of the filter used to search for the template.
         */
        template_filter?: "featured" | "self" | "selfexecutable" | "sharedexecutable" | "executable" | "community";
        api_region?: string;
        /**
         * Whether the template should be synced or removed across zones.
         * Only used if C(state) is present or absent.
         */
        cross_zones?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the project the template to be registered in.
         */
        project?: string;
        /**
         * Name of the snapshot, created from the VM ROOT volume, the template will be created from.
         * C(vm) is required together with this argument.
         */
        snapshot?: string;
        /**
         * Default: http_download
         *
         * Mode for the template extraction.
         * Only used if C(state=extracted).
         */
        mode?: "http_download" | "ftp_upload";
        /**
         * The MD5 checksum value of this template.
         * If set, we search by checksum instead of name.
         */
        checksum?: string;
        /**
         * OS type that best represents the OS of this template.
         */
        os_type?: string;
        [k: string]: unknown;
      };
      /**
       * Allows you to attach or detach a volume from a ProfitBricks server. This module has a dependency on profitbricks >= 1.0.0
       */
      profitbricks_volume_attachments?: {
        /**
         * The datacenter in which to operate.
         */
        datacenter?: string;
        /**
         * The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environement variable.
         */
        subscription_user?: string;
        /**
         * The name of the server you wish to detach or attach the volume.
         */
        server?: string;
        /**
         * The volume name or ID.
         */
        volume?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: string;
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * THe ProfitBricks password. Overrides the PB_PASSWORD environement variable.
         */
        subscription_password?: string;
        /**
         * Default: yes
         *
         * wait for the operation to complete before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Retrieve an auth token from an OpenStack Cloud
       */
      os_auth?: {
        [k: string]: unknown;
      };
      /**
       * Change an administrative parameter on a MongoDB server.
       */
      mongodb_parameter?: {
        /**
         * Default: 27017
         *
         * The port to connect to
         */
        login_port?: number | string;
        /**
         * The username used to authenticate with
         */
        login_user?: string;
        /**
         * Default: localhost
         *
         * The host running the database
         */
        login_host?: string;
        /**
         * The password used to authenticate with
         */
        login_password?: string;
        /**
         * MongoDB administrative parameter to modify
         */
        param: string;
        /**
         * Whether to use an SSL connection when connecting to the database
         */
        ssl?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: str
         *
         * Define the parameter value (str, int)
         */
        param_type?: "str" | "int";
        /**
         * MongoDB administrative parameter value to set
         */
        value: string;
        /**
         * The database where login credentials are stored
         */
        login_database?: string;
        /**
         * Replica set to connect to (automatically connects to primary for writes)
         */
        replica_set?: string;
        [k: string]: unknown;
      };
      /**
       * Notify Rollbar about app deployments (see https://rollbar.com/docs/deploys_other/)
       */
      rollbar_deployment?: {
        /**
         * Deploy comment (e.g. what is being deployed).
         */
        comment?: string;
        /**
         * Rollbar username of the user who deployed.
         */
        rollbar_user?: string;
        /**
         * Default: https://api.rollbar.com/api/1/deploy/
         *
         * Optional URL to submit the notification to.
         */
        url?: string;
        /**
         * Name of the environment being deployed, e.g. 'production'.
         */
        environment: string;
        /**
         * Your project access token.
         */
        token: string;
        /**
         * User who deployed.
         */
        user?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Revision number/sha being deployed.
         */
        revision: string;
        [k: string]: unknown;
      };
      /**
       * Returns information about a Windows file
       */
      win_stat?: {
        /**
         * The full path of the file/object to get the facts of; both forward and back slashes are accepted.
         */
        path?: string;
        /**
         * Default: True
         *
         * Whether to return the checksum sum of the file. As of Ansible 1.9 this is no longer a MD5, but a SHA1 instead.
         */
        get_md5?: string;
        /**
         * Default: True
         *
         * Whether to return a checksum of the file (only sha1 currently supported)
         */
        get_checksum?: string;
        [k: string]: unknown;
      };
      /**
       * Run targets in a Makefile.
       */
      make?: {
        /**
         * cd into this directory before running make
         */
        chdir: string;
        /**
         * Default: none
         *
         * Any extra parameters to pass to make
         */
        params?: {
          [k: string]: unknown;
        };
        /**
         * Default: none
         *
         * The target to run
         */
        target?: string;
        [k: string]: unknown;
      };
      /**
       * This is a simple module that supports creating or removing vDCs. A vDC is required before you can create servers. This module has a dependency on profitbricks >= 1.0.0
       */
      profitbricks_datacenter?: {
        /**
         * The description of the virtual datacenter.
         */
        description?: string;
        /**
         * The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environement variable.
         */
        subscription_user?: string;
        /**
         * The name of the virtual datacenter.
         */
        name?: string;
        /**
         * THe ProfitBricks password. Overrides the PB_PASSWORD environement variable.
         */
        subscription_password?: string;
        /**
         * Default: present
         *
         * create or terminate datacenters
         */
        state?: string;
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: string;
        /**
         * Default: us/las
         *
         * The datacenter location.
         */
        location?: "us/las" | "de/fra" | "de/fkb";
        /**
         * Default: yes
         *
         * wait for the datacenter to be created before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manages PIM interface configuration settings.
       */
      nxos_pim_interface?: {
        /**
         * Policy for join-prune messages (inbound).
         */
        jp_policy_in?: string;
        /**
         * Default: True
         *
         * Enable/disable sparse-mode on the interface.
         */
        sparse?: string;
        /**
         * Type of policy mapped to C(jp_policy_in).
         */
        jp_type_in?: string;
        /**
         * Policy for join-prune messages (outbound).
         */
        jp_policy_out?: string;
        /**
         * Type of policy mapped to neighbor_policy.
         */
        neighbor_type?: string;
        /**
         * Default: present
         *
         * Manages desired state of the resource.
         */
        state?: string;
        /**
         * Configures a neighbor policy for filtering adjacencies.
         */
        neighbor_policy?: string;
        /**
         * Hello interval in milliseconds for this interface.
         */
        hello_interval?: string;
        /**
         * Full name of the interface such as Ethernet1/33.
         */
        interface?: string;
        /**
         * Authentication for hellos on this interface.
         */
        hello_auth_key?: string;
        /**
         * Configures interface to be a boundary of a PIM domain.
         */
        border?: string;
        /**
         * Type of policy mapped to C(jp_policy_out).
         */
        jp_type_out?: string;
        [k: string]: unknown;
      };
      /**
       * Create a VMware portgroup
       */
      vmware_portgroup?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Get facts for a specific network interface or all network interfaces within a resource group.
       */
      azure_rm_networkinterface_facts?: {
        profile?: string;
        cli_default_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Only show results for a specific network interface.
         */
        name?: string;
        /**
         * Name of the resource group containing the network interface(s). Required when searching by name.
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        secret?: string;
        client_id?: string;
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Manages IGMP interface configuration settings.
       */
      nxos_igmp_interface?: {
        /**
         * Query interval used when the IGMP process starts up. The range is from 1 to 18000. The default is 31.
         */
        startup_query_interval?: string;
        /**
         * Configures report-link-local-groups. Enables sending reports for groups in 224.0.0.0/24. Reports are always sent for nonlink local groups. By default, reports are not sent for link local groups.
         */
        report_llg?: string;
        /**
         * Sets the query interval waited after sending membership reports before the software deletes the group state. Values can range from 1 to 25 seconds. The default is 1 second.
         */
        last_member_qrt?: string;
        /**
         * Sets the group membership timeout for IGMPv2. Values can range from 3 to 65,535 seconds. The default is 260 seconds.
         */
        group_timeout?: string;
        /**
         * Sets the robustness variable. Values can range from 1 to 7. The default is 2.
         */
        robustness?: string;
        /**
         * Query count used when the IGMP process starts up. The range is from 1 to 10. The default is 2.
         */
        startup_query_count?: string;
        /**
         * Configure a routemap for static outgoing interface (OIF).
         */
        oif_routemap?: string;
        /**
         * Enables the device to remove the group entry from the multicast routing table immediately upon receiving a leave message for the group. Use this command to minimize the leave latency of IGMPv2 group memberships on a given IGMP interface because the device does not send group-specific queries. The default is disabled.
         */
        immediate_leave?: string;
        /**
         * Configure a source for static outgoing interface (OIF).
         */
        oif_source?: string;
        /**
         * Default: present
         *
         * Manages desired state of the resource.
         */
        state?: string;
        /**
         * IGMP version. It can be 2 or 3.
         */
        version?: string;
        /**
         * Configure a prefix for static outgoing interface (OIF).
         */
        oif_prefix?: string;
        /**
         * The full interface name for IGMP configuration. e.g. I(Ethernet1/2).
         */
        interface?: string;
        /**
         * Sets the querier timeout that the software uses when deciding to take over as the querier. Values can range from 1 to 65535 seconds. The default is 255 seconds.
         */
        querier_timeout?: string;
        /**
         * Sets the number of times that the software sends an IGMP query in response to a host leave message. Values can range from 1 to 5. The default is 2.
         */
        last_member_query_count?: string;
        /**
         * Sets the frequency at which the software sends IGMP host query messages. Values can range from 1 to 18000 seconds. he default is 125 seconds.
         */
        query_interval?: string;
        /**
         * Restart IGMP.
         */
        restart?: string;
        /**
         * Sets the response time advertised in IGMP queries. Values can range from 1 to 25 seconds. The default is 10 seconds.
         */
        query_mrt?: string;
        [k: string]: unknown;
      };
      /**
       * Create or delete Server Groups at Centurylink Centurylink Cloud
       */
      clc_group?: {
        /**
         * The name of the Server Group
         */
        name: string;
        /**
         * The parent group of the server group. If parent is not provided, it creates the group at top level.
         */
        parent?: string;
        /**
         * A description of the Server Group
         */
        description?: string;
        /**
         * Default: present
         *
         * Whether to create or delete the group
         */
        state?: "present" | "absent";
        /**
         * Datacenter to create the group in. If location is not provided, the group gets created in the default datacenter associated with the account
         */
        location?: string;
        /**
         * Default: True
         *
         * Whether to wait for the tasks to finish before returning.
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module allows to manage dns records on a univention corporate server (UCS). It uses the python API of the UCS to create a new object or edit it.
       */
      udm_dns_record?: {
        /**
         * Additional data for this record, e.g. ['a': '192.0.2.1']. Required if C(state=present).
         */
        data?: string;
        /**
         * Default: present
         *
         * Whether the dns record is present or not.
         */
        state?: string;
        /**
         * Define the record type. C(host_record) is a A or AAAA record, C(alias) is a CNAME, C(ptr_record) is a PTR record, C(srv_record) is a SRV record and C(txt_record) is a TXT record.
         */
        type?: string;
        /**
         * Name of the record, this is also the DNS record. E.g. www for www.example.com.
         */
        name?: string;
        /**
         * Corresponding DNS zone for this record, e.g. example.com.
         */
        zone?: string;
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific security group or all security groups within a resource group.
       */
      azure_rm_securitygroup_facts?: {
        profile?: string;
        cli_default_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Only show results for a specific security group.
         */
        name?: string;
        /**
         * Name of the resource group to use.
         */
        resource_group: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        secret?: string;
        client_id?: string;
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Manage user accounts and user attributes.
       */
      user?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Creates/Removes a gateway interface from the router, used to associate a external network with a router to route external traffic.
       */
      quantum_router_gateway?: {
        /**
         * Default: None
         *
         * Name of the region
         */
        region_name?: string;
        availability_zone?: string;
        /**
         * Default: None
         *
         * Name of the external network which should be attached to the router.
         */
        network_name: string;
        /**
         * Default: yes
         *
         * The tenant name of the login user
         */
        login_tenant_name?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: "present" | "absent";
        /**
         * Default: http://127.0.0.1:35357/v2.0/
         *
         * The keystone URL for authentication
         */
        auth_url?: string;
        /**
         * Default: yes
         *
         * Password of login user
         */
        login_password: string;
        /**
         * Default: admin
         *
         * login username to authenticate to keystone
         */
        login_username?: string;
        /**
         * Default: None
         *
         * Name of the router to which the gateway should be attached.
         */
        router_name: string;
        [k: string]: unknown;
      };
      /**
       * Manage domains on Rackspace Cloud DNS
       */
      rax_dns?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Execute vrouter-interface-add, vrouter-interface-remove, vrouter-interface-modify command.
       * You configure interfaces to vRouter services on a fabric, cluster, standalone switch or virtual network(VNET).
       */
      pn_vrouterif?: {
        /**
         * Specify if the NIC is enabled or not
         */
        pn_nic_enable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Specify if the interface is exclusive to the configuration. Exclusive means that other configurations cannot use the interface. Exclusive is specified when you configure the interface as span interface and allows higher throughput through the interface.
         */
        pn_exclusive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the type of NIC. Used for vrouter-interface remove/modify.
         */
        pn_nic_str?: string;
        /**
         * Specify the ID for the VRRP interface. The IDs on both vRouters must be the same IS number.
         */
        pn_vrrp_id?: number | string;
        /**
         * Specify a VRRP advertisement interval in milliseconds. The range is from 30 to 40950 with a default value of 1000.
         */
        pn_vrrp_adv_int?: string;
        /**
         * Specify the priority for the VRRP interface. This is a value between 1 (lowest) and 255 (highest).
         */
        pn_vrrp_priority?: number | string;
        /**
         * Specify an alias for the interface.
         */
        pn_alias?: string;
        /**
         * Specify a secondary MAC address for the interface.
         */
        pn_secondary_macs?: string;
        /**
         * Specify the name of the vRouter interface.
         */
        pn_vrouter_name: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Specify the IP address of the interface in x.x.x.x/n format.
         */
        pn_interface_ip: string;
        /**
         * State the action to perform. Use 'present' to add vrouter interface, 'absent' to remove vrouter interface and 'update' to modify vrouter interface.
         */
        state: "present" | "absent";
        /**
         * Specify the VLAN identifier. This is a value between 1 and 4092.
         */
        pn_vlan?: number | string;
        /**
         * Specify if the interface is management, data or span interface.
         */
        pn_interface?: "mgmt" | "data" | "span";
        /**
         * Specify a Layer 3 port for the interface.
         */
        pn_l3port?: string;
        /**
         * Specify the VXLAN identifier. This is a value between 1 and 16777215.
         */
        pn_vxlan?: number | string;
        /**
         * Target switch to run the cli on.
         */
        pn_cliswitch?: string;
        /**
         * Specify the DHCP method for IP address assignment.
         */
        pn_assignment?: "none" | "dhcp" | "dhcpv6" | "autov6";
        [k: string]: unknown;
      };
      /**
       * Manages VTP password configuration.
       */
      nxos_vtp_password?: {
        /**
         * VTP password
         */
        vtp_password?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove a website on a Webfaction host.  Further documentation at http://github.com/quentinsf/ansible-webfaction.
       */
      webfaction_site?: {
        /**
         * A mapping of URLs to apps
         */
        site_apps?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Whether the website should exist
         */
        state?: "present" | "absent";
        /**
         * A list of subdomains associated with this site.
         */
        subdomains?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The webfaction host on which the site should be created.
         */
        host: string;
        /**
         * Default: false
         *
         * Whether or not to use HTTPS
         */
        https?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The webfaction password to use
         */
        login_password: string;
        /**
         * The webfaction account to use
         */
        login_name: string;
        /**
         * The name of the website
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Interacts with HTTP and HTTPS web services and supports Digest, Basic and WSSE HTTP authentication mechanisms.
       */
      uri?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Configure a .deb package using debconf-set-selections. Or just query existing selections.
       */
      debconf?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages F5 BIG-IP LTM nodes via iControl SOAP API
       */
      bigip_node?: {
        /**
         * Set new session availability status for node
         */
        session_state?: string;
        /**
         * Node name
         */
        name?: string;
        /**
         * Set monitor availability status for node
         */
        monitor_state?: string;
        /**
         * Node description.
         */
        description?: string;
        /**
         * Default: Common
         *
         * Partition
         */
        partition?: string;
        /**
         * Node IP. Required when state=present and node does not exist. Error when state=absent.
         */
        host?: string;
        /**
         * Monitor template name list. Always use the full path to the monitor.
         */
        monitors?: string;
        /**
         * Default: present
         *
         * Pool member state
         */
        state?: string;
        /**
         * Monitor rule type when monitors > 1
         */
        monitor_type?: string;
        /**
         * Monitor quorum value when monitor_type is m_of_n
         */
        quorum?: string;
        [k: string]: unknown;
      };
      /**
       * Downloads an artifact from a maven repository given the maven coordinates provided to the module. Can retrieve
       * snapshots or release versions of the artifact and will resolve the latest available version if one is not
       * available.
       */
      maven_artifact?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * IPS packages are the native packages in Solaris 11 and higher.
       */
      pkg5?: {
        [k: string]: unknown;
      };
      /**
       * Manipulate Rackspace Cloud Files Containers
       */
      rax_files?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create and delete snapshots images on snapshot groups for NetApp E-series storage arrays.
       * Only the oldest snapshot image can be deleted so consistency is preserved.
       * Related: Snapshot volumes are created from snapshot images.
       */
      netapp_e_snapshot_images?: {
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url?: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password?: string;
        /**
         * Whether a new snapshot image should be created or oldest be deleted.
         */
        state?: string;
        /**
         * The name of the snapshot group in which you want to create a snapshot image.
         */
        snapshot_group?: string;
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username?: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?: string;
        [k: string]: unknown;
      };
      /**
       * This module creates file system.
       */
      filesystem?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This is the original Ansible module for managing the Docker container life cycle.
       * NOTE: Additional and newer modules are available. For the latest on orchestrating containers with Ansible visit our Getting Started with Docker Guide at https://github.com/ansible/ansible/blob/devel/docsite/rst/guide_docker.rst.
       */
      docker?: {
        /**
         * Publish all exposed ports to the host interfaces.
         */
        publish_all_ports?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Allocate a pseudo-tty within the container.
         */
        tty?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Additional options to pass to the logging driver selected above. See Docker `log-driver <https://docs.docker.com/reference/logging/overview/>` documentation for more information. Requires docker >=1.7.0.
         */
        log_opt?: {
          [k: string]: unknown;
        };
        /**
         * Use insecure private registry by HTTP instead of HTTPS. Needed for docker-py >= 0.5.0.
         */
        insecure_registry?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of other containers to link within this container with an optional
         * alias. Use docker CLI-style syntax: C(redis:myredis).
         */
        links?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Container domain name.
         */
        domainname?: string;
        /**
         * Default: ${DOCKER_HOST} or unix://var/run/docker.sock
         *
         * URL of the host running the docker daemon. This will default to the env var DOCKER_HOST if unspecified.
         */
        docker_url?: string;
        /**
         * Container image used to match and launch containers.
         */
        image: string;
        /**
         * Set container labels. Requires docker >= 1.6 and docker-py >= 1.2.0.
         */
        labels?: {
          [k: string]: unknown;
        };
        /**
         * Default: None
         *
         * Set the PID namespace mode for the container (currently only supports 'host'). Requires docker-py >= 1.0.0 and docker >= 1.5.0
         */
        pid?: string;
        /**
         * Default: docker-py default remote API version
         *
         * Remote API version to use. This defaults to the current default as specified by docker-py.
         */
        docker_api_version?: string;
        /**
         * Default: 10
         *
         * How many seconds to wait for the container to stop before killing it.
         */
        stop_timeout?: number | string;
        /**
         * Default: ${DOCKER_CERT_PATH}/key.pem
         *
         * Path to the PEM-encoded key used to authenticate docker client. If specified tls_client_cert must be valid
         */
        tls_client_key?: string;
        /**
         * Pass in a path to a file with environment variable (FOO=BAR). If a key value is present in both explicitly presented (i.e. as 'env') and in the environment file, the explicit value will override. Requires docker-py >= 1.4.0.
         */
        env_file?: string;
        /**
         * Mount the container's root filesystem as read only
         */
        read_only?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Whether to use tls to connect to the docker server.  "no" means not to use tls (and ignore any other tls related parameters). "encrypt" means to use tls to encrypt the connection to the server.  "verify" means to also verify that the server's certificate is valid for the server (this both verifies the certificate against the CA and that the certificate was issued for that host. If this is unspecified, tls will only be used if one of the other tls options require it.
         */
        use_tls?: "no" | "encrypt" | "verify";
        /**
         * Remote API password.
         */
        password?: string;
        /**
         * Container hostname.
         */
        hostname?: string;
        /**
         * LXC configuration parameters, such as C(lxc.aa_profile:unconfined).
         */
        lxc_conf?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: ${DOCKER_CERT_PATH}/ca.pem
         *
         * Path to a PEM-encoded certificate authority to secure the Docker connection. This has no effect if use_tls is encrypt.
         */
        tls_ca_cert?: string;
        /**
         * Default: started
         *
         * Assert the container's desired state. "present" only asserts that the matching containers exist. "started" asserts that the matching containers both exist and are running, but takes no action if any configuration has changed. "reloaded" (added in Ansible 1.9) asserts that all matching containers are running and restarts any that have any images or configuration out of date. "restarted" unconditionally restarts (or starts) the matching containers. "stopped" and '"killed" stop and kill all matching containers. "absent" stops and then' removes any matching containers.
         */
        state?: "present" | "started" | "reloaded" | "restarted" | "stopped" | "killed" | "absent" | "running";
        /**
         * Default: ${DOCKER_CERT_PATH}/cert.pem
         *
         * Path to the PEM-encoded certificate used to authenticate docker client. If specified tls_client_key must be valid
         */
        tls_client_cert?: string;
        /**
         * Corresponds to ``--entrypoint`` option of ``docker run`` command and ``ENTRYPOINT`` directive of Dockerfile. Used to match and launch containers.
         */
        entrypoint?: string;
        /**
         * List of custom DNS servers for the container.
         */
        dns?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List of names of containers to mount volumes from.
         */
        volumes_from?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Network mode for the launched container: bridge, none, container:<name|id>
         * or host. Requires docker >= 0.11.
         */
        net?: string;
        /**
         * Whether the container should run in privileged mode or not.
         */
        privileged?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Remote API username.
         */
        username?: string;
        /**
         * Username or UID to use within the container
         */
        docker_user?: string;
        /**
         * Dict of custom host-to-IP mappings to be defined in the container
         */
        extra_hosts?: {
          [k: string]: unknown;
        };
        /**
         * Default: json-file
         *
         * You can specify a different logging driver for the container than for the daemon. "json-file" Default logging driver for Docker. Writes JSON messages to file. docker logs command is available only for this logging driver. "none" disables any logging for the container. "syslog" Syslog logging driver for Docker. Writes log messages to syslog. docker logs command is not available for this logging driver. "journald" Journald logging driver for Docker. Writes log messages to "journald". "gelf" Graylog Extended Log Format (GELF) logging driver for Docker. Writes log messages to a GELF endpoint likeGraylog or Logstash. "fluentd" Fluentd logging driver for Docker. Writes log messages to "fluentd" (forward input). "awslogs" (added in 2.1) Awslogs logging driver for Docker. Writes log messages to AWS Cloudwatch Logs. If not defined explicitly, the Docker daemon's default ("json-file") will apply. Requires docker >= 1.6.0.
         */
        log_driver?: "json-file" | "none" | "syslog" | "journald" | "gelf" | "fluentd" | "awslogs";
        /**
         * List of additional container ports to expose for port mappings or links. If the port is already exposed using EXPOSE in a Dockerfile, you don't need to expose it again.
         */
        expose?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Keep stdin open after a container is launched.
         */
        stdin_open?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * RAM allocated to the container as a number of bytes or as a human-readable string like "512MB". Leave as "0" to specify no limit.
         */
        memory_limit?: string;
        /**
         * Default: Taken from docker_url
         *
         * A hostname to check matches what's supplied in the docker server's certificate.  If unspecified, the hostname is taken from the docker_url.
         */
        tls_hostname?: string;
        /**
         * Default: DockerHub
         *
         * Remote registry URL to pull images from.
         */
        registry?: string;
        /**
         * List of volumes to mount within the container
         * Use docker CLI-style syntax: C(/host:/container[:mode])
         * You can specify a read mode for the mount with either C(ro) or C(rw). Starting at version 2.1, SELinux hosts can additionally use C(z) or C(Z) mount options to use a shared or private label for the volume.
         */
        volumes?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: True
         *
         * Enable detached mode to leave the container running in background. If disabled, fail unless the process exits cleanly.
         */
        detach?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        memory_swap?: number | string;
        /**
         * CPUs in which to allow execution. Requires docker-py >= 0.6.0.
         */
        cpu_set?: string;
        /**
         * Default: missing
         *
         * Control when container images are updated from the C(docker_url) registry. If "missing," images will be pulled only when missing from the host; if '"always," the registry will be checked for a newer version of the image' each time the task executes.
         */
        pull?: "missing" | "always";
        /**
         * Name used to match and uniquely name launched containers. Explicit names are used to uniquely identify a single container or to link among containers. Mutually exclusive with a "count" other than "1".
         */
        name?: string;
        /**
         * Pass a dict of environment variables to the container.
         */
        env?: {
          [k: string]: unknown;
        };
        /**
         * Default: KILL
         *
         * With the state "killed", you can alter the signal sent to the container.
         */
        signal?: string;
        /**
         * Add capabilities for the container. Requires docker-py >= 0.5.0.
         */
        cap_add?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Container restart policy.
         * The 'unless-stopped' choice is only available starting in Ansible 2.1 and for Docker 1.9 and above.
         */
        restart_policy?: "no" | "on-failure" | "always" | "unless-stopped";
        /**
         * Default: 1
         *
         * Number of matching containers that should be in the desired state.
         */
        count?: number | string;
        /**
         * List of host devices to expose to container
         */
        devices?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Remote API email.
         */
        email?: string;
        /**
         * Command used to match and launch containers.
         */
        command?: string;
        /**
         * Maximum number of times to restart a container. Leave as "0" for unlimited retries.
         */
        restart_policy_retry?: number | string;
        /**
         * Default: 60
         *
         * Docker daemon response timeout in seconds.
         */
        timeout?: number | string;
        debug?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Drop capabilities for the container. Requires docker-py >= 0.5.0.
         */
        cap_drop?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List containing private to public port mapping specification. Use docker 'CLI-style syntax: C(8000), C(9000:8000), or C(0.0.0.0:9000:8000)' where 8000 is a container port, 9000 is a host port, and 0.0.0.0 is - a host interface. The container ports need to be exposed either in the Dockerfile or via the C(expose) option.
         */
        ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * ulimits, list ulimits with name, soft and optionally hard limit separated by colons. e.g. nofile:1024:2048 Requires docker-py >= 1.2.0 and docker >= 1.6.0
         */
        ulimits?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * CPU shares (relative weight). Requires docker-py >= 0.6.0.
         */
        cpu_shares?: number | string;
        [k: string]: unknown;
      };
      /**
       * Execute vlan-create or vlan-delete command.
       * VLANs are used to isolate network traffic at Layer 2.The VLAN identifiers 0 and 4095 are reserved and cannot be used per the IEEE 802.1Q standard. The range of configurable VLAN identifiers is 2 through 4092.
       */
      pn_vlan?: {
        /**
         * Specify a scope for the VLAN.
         * Required for vlan-create.
         */
        pn_scope?: "fabric" | "local";
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Specify a VLAN identifier for the VLAN. This is a value between 2 and 4092.
         */
        pn_vlanid: number | string;
        /**
         * State the action to perform. Use 'present' to create vlan and 'absent' to delete vlan.
         */
        state: "present" | "absent";
        /**
         * Specifies the switch network data port number, list of ports, or range of ports. Port numbers must ne in the range of 1 to 64.
         */
        pn_ports?: string;
        /**
         * Specifies the ports that should have untagged packets mapped to the VLAN. Untagged packets are packets that do not contain IEEE 802.1Q VLAN tags.
         */
        pn_untagged_ports?: string;
        /**
         * Target switch(es) to run the cli on.
         */
        pn_cliswitch?: string;
        /**
         * Specify if you want to collect statistics for a VLAN. Statistic collection is enabled by default.
         */
        pn_stats?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify a description for the VLAN.
         */
        pn_description?: string;
        [k: string]: unknown;
      };
      /**
       * Associates or disassociates a specific floating IP with a particular instance
       */
      quantum_floating_ip_associate?: {
        /**
         * Default: None
         *
         * name of the region
         */
        region_name?: string;
        availability_zone?: string;
        /**
         * Default: None
         *
         * name of the instance to which the public IP should be assigned
         */
        instance_name: string;
        /**
         * Default: True
         *
         * the tenant name of the login user
         */
        login_tenant_name?: string;
        /**
         * Default: present
         *
         * indicates the desired state of the resource
         */
        state?: "present" | "absent";
        /**
         * Default: http://127.0.0.1:35357/v2.0/
         *
         * the keystone url for authentication
         */
        auth_url?: string;
        /**
         * Default: yes
         *
         * password of login user
         */
        login_password: string;
        /**
         * Default: admin
         *
         * login username to authenticate to keystone
         */
        login_username?: string;
        /**
         * Default: None
         *
         * floating ip that should be assigned to the instance
         */
        ip_address: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or delete a subnet within a given virtual network. Allows setting and updating the address prefix CIDR, which must be valid within the context of the virtual network. Use the azure_rm_networkinterface module to associate interfaces with the subnet and assign specific IP addresses.
       */
      azure_rm_subnet?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates a maintenance window for status.io
       * Deletes a maintenance window for status.io
       */
      statusio_maintenance?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Send notifications via telegram bot, to a verified group or user
       */
      telegram?: {
        /**
         * What message you wish to send.
         */
        msg: string;
        /**
         * Token identifying your telegram bot.
         */
        token: string;
        /**
         * Telegram group or user chat_id
         */
        chat_id: string;
        [k: string]: unknown;
      };
      /**
       * Manages a Django application using the I(manage.py) application frontend to I(django-admin). With the I(virtualenv) parameter, all management commands will be executed by the given I(virtualenv) installation.
       */
      django_manage?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or delete etherstubs on Solaris/illumos systems.
       */
      dladm_etherstub?: {
        /**
         * Default: present
         *
         * Create or delete Solaris/illumos etherstub.
         */
        state?: "present" | "absent";
        /**
         * Specifies that the etherstub is temporary. Temporary etherstubs do not persist across reboots.
         */
        temporary?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Etherstub name.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Execute vrouter-create, vrouter-delete, vrouter-modify command.
       * Each fabric, cluster, standalone switch, or virtual network (VNET) can provide its tenants with a virtual router (vRouter) service that forwards traffic between networks and implements Layer 3 protocols.
       * C(vrouter-create) creates a new vRouter service.
       * C(vrouter-delete) deletes a vRouter service.
       * C(vrouter-modify) modifies a vRouter service.
       */
      pn_vrouter?: {
        /**
         * Specify how OSPF routes are redistributed.
         */
        pn_ospf_redistribute?: "static" | "connected" | "bgp" | "rip";
        /**
         * Specify the name of the vRouter.
         */
        pn_name: string;
        /**
         * Target switch(es) to run the CLI on.
         */
        pn_cliswitch?: string;
        /**
         * State the action to perform. Use 'present' to create vrouter, 'absent' to delete vrouter and 'update' to modify vrouter.
         */
        state: "present" | "absent" | "update";
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Specify how BGP routes are redistributed.
         */
        pn_bgp_redistribute?: "static" | "connected" | "rip" | "ospf";
        /**
         * Specify if the vRouter uses software or hardware.
         * Note that if you specify hardware as router type, you cannot assign IP addresses using DHCP. You must specify a static IP address.
         */
        pn_router_type?: "hardware" | "software";
        /**
         * Specifies the VRRP ID for a hardware vrouter.
         */
        pn_hw_vrrp_id?: number | string;
        /**
         * Specify the name of the VNET.
         * Required for vrouter-create.
         */
        pn_vnet?: string;
        /**
         * Specify other OSPF options as a whitespaces separated string within single quotes ''.
         */
        pn_ospf_options?: string;
        /**
         * Specify how RIP routes are redistributed.
         */
        pn_rip_redistribute?: "static" | "connected" | "ospf" | "bgp";
        /**
         * Specify other BGP options as a whitespaces separated string within single quotes ''.
         */
        pn_bgp_options?: string;
        /**
         * Specify the vRouter IP address.
         */
        pn_router_id?: string;
        /**
         * Specify the maximum number of paths for BGP. This is a number between 1 and 255 or 0 to unset.
         */
        pn_bgp_max_paths?: number | string;
        /**
         * Specify to enable or disable vRouter service.
         */
        pn_service_state?: "enable" | "disable";
        /**
         * Specify if the vRouter is a dedicated or shared VNET service.
         */
        pn_service_type?: "dedicated" | "shared";
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        pn_vrrp_track_port?: string;
        /**
         * Specify the Autonomous System Number(ASN) if the vRouter runs Border Gateway Protocol(BGP).
         */
        pn_bgp_as?: number | string;
        [k: string]: unknown;
      };
      /**
       * Notify Honeybadger.io about app deployments (see http://docs.honeybadger.io/article/188-deployment-tracking)
       */
      honeybadger_deployment?: {
        /**
         * Default: None
         *
         * URL of the project repository
         */
        repo?: string;
        /**
         * Default: https://api.honeybadger.io/v1/deploys
         *
         * Optional URL to submit the notification to.
         */
        url?: string;
        /**
         * The environment name, typically 'production', 'staging', etc.
         */
        environment: string;
        /**
         * API token.
         */
        token: string;
        /**
         * Default: None
         *
         * The username of the person doing the deployment
         */
        user?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * A hash, number, tag, or other identifier showing what revision was deployed
         */
        revision?: string;
        [k: string]: unknown;
      };
      /**
       * Can create or delete AWS Autoscaling Groups
       * Works with the ec2_lc module to manage Launch Configurations
       */
      ec2_asg?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create, update and delete blob containers and blob objects. Use to upload a file and store it as a blob object, or download a blob object to a file.
       */
      azure_rm_storageblob?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Sets or updates the password for a storage array.  When the password is updated on the storage array, it must be updated on the SANtricity Web Services proxy. Note, all storage arrays do not have a Monitor or RO role.
       */
      netapp_e_auth?: {
        /**
         * the identifier of the storage array in the Web Services Proxy.
         */
        ssid?: string;
        /**
         * The full API url.
         * Example: http://ENDPOINT:8080/devmgr/v2
         * This can optionally be set via an environment variable, API_URL
         */
        api_url: string;
        /**
         * The password you would like to set. Cannot be more than 30 characters.
         */
        new_password: string;
        /**
         * The password used to authenticate against the API
         * This can optionally be set via an environment variable, API_PASSWORD
         */
        api_password?: string;
        /**
         * The current admin password. This is not required if the password hasn't been set before.
         */
        current_password?: string;
        /**
         * The username used to authenticate against the API
         * This can optionally be set via an environment variable, API_USERNAME
         */
        api_username?: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Boolean value on whether to update the admin password. If set to false then the RO account is updated.
         */
        set_admin:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the storage array. Note that if more than one storage array with this name is detected, the task will fail and you'll have to use the ID instead.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, or delete OpenStack Identity domains. If a domain with the supplied name already exists, it will be updated with the new description and enabled attributes.
       */
      os_keystone_domain?: {
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: True
         *
         * Is the domain enabled
         */
        enabled?: string;
        /**
         * Name that has to be given to the instance
         */
        name?: string;
        /**
         * Default: None
         *
         * Description of the domain
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Create or delete AWS Dynamo DB tables.
       * Can update the provisioned throughput on existing tables.
       * Returns the status of the specified table.
       */
      dynamodb_table?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates and deletes DNS records in Amazons Route53 service
       */
      route53?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * allows you to create new instances, either from scratch or an image, in addition to deleting or stopping instances on the oVirt/RHEV platform
       */
      ovirt?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        };
      /**
       * Manages VRF AF
       */
      nxos_vrf_af?: {
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: string;
        /**
         * Sub Address-Family Identifier (SAFI).
         */
        safi?: string;
        /**
         * Enable/Disable the EVPN route-target 'auto' setting for both import and export target communities.
         */
        route_target_both_auto_evpn?: string;
        /**
         * Address-Family Identifier (AFI).
         */
        afi?: string;
        /**
         * Name of the VRF.
         */
        vrf?: string;
        [k: string]: unknown;
      };
      /**
       * Allows for the creation, removal and updating of Asynchronous Mirror Groups for NetApp E-series storage arrays
       */
      netapp_e_amg?: {
        new_name?: string;
        /**
         * The ID of the primary storage array for the async mirror action
         */
        ssid: string;
        /**
         * Default: 10
         *
         * The synchronization interval in minutes
         */
        syncIntervalMinutes?: number | string;
        /**
         * Default: 20
         *
         * Recovery point warning threshold (minutes). The user will be warned when the age of the last good failures point exceeds this value
         */
        recoveryWarnThresholdMinutes?: number | string;
        /**
         * The ID of the secondary array to be used in mirroing process
         */
        secondaryArrayId: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * The name of the async array you wish to target, or create.
         * If C(state) is present and the name isn't found, it will attempt to create.
         */
        name: string;
        /**
         * Default: 80
         *
         * Recovery point warning threshold
         */
        repoUtilizationWarnThreshold?: number | string;
        /**
         * A C(state) of present will either create or update the async mirror group.
         * A C(state) of absent will remove the async mirror group.
         */
        state: "present" | "absent";
        /**
         * The intended protocol to use if both Fibre and iSCSI are available.
         */
        interfaceType?: "iscsi" | "fibre";
        /**
         * Setting this to true will cause other synchronization values to be ignored
         */
        manualSync?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * Default: 10
         *
         * The threshold (in minutes) for notifying the user that periodic synchronization has taken too long to complete.
         */
        syncWarnThresholdMinutes?: number | string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        [k: string]: unknown;
      };
      /**
       * Manage registration and subscription to the Red Hat Subscription Management entitlement platform using the C(subscription-manager) command
       */
      redhat_subscription?: {
        /**
         * Default: Current value from C(/etc/rhsm/rhsm.conf) is the default
         *
         * Specify an alternative Red Hat Subscription Management or Sat6 server
         */
        server_hostname?: string;
        /**
         * access.redhat.com or Sat6  username
         */
        username?: string;
        /**
         * access.redhat.com or Sat6 password
         */
        password?: string;
        /**
         * The type of unit to register, defaults to system
         */
        consumer_type?: string;
        /**
         * Organization ID to use in conjunction with activationkey
         */
        org_id?: string;
        /**
         * References an existing consumer ID to resume using a previous registration for this system. If the  system's identity certificate is lost or corrupted, this option allows it to resume using its previous identity and subscriptions. The default is to not specify a consumer ID so a new ID is created.
         */
        consumer_id?: string;
        /**
         * Register with a specific environment in the destination org. Used with Red Hat Satellite 6.x or Katello
         */
        environment?: string;
        /**
         * Register the system even if it is already registered
         */
        force_register?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * whether to register and subscribe (C(present)), or unregister (C(absent)) a system
         */
        state?: "present" | "absent";
        /**
         * Upon successful registration, auto-consume available subscriptions
         */
        autosubscribe?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * supply an activation key for use with registration
         */
        activationkey?: string;
        /**
         * Default: Current value from C(/etc/rhsm/rhsm.conf) is the default
         *
         * Enable or disable https server certificate verification when connecting to C(server_hostname)
         */
        server_insecure?: string;
        /**
         * Name of the system to register, defaults to the hostname
         */
        consumer_name?: string;
        /**
         * Default: Current value from C(/etc/rhsm/rhsm.conf) is the default
         *
         * Specify CDN baseurl
         */
        rhsm_baseurl?: string;
        /**
         * Default: ^$
         *
         * Specify a subscription pool name to consume.  Regular expressions accepted.
         */
        pool?: string;
        [k: string]: unknown;
      };
      /**
       * Execute vrouter-loopback-interface-add, vrouter-loopback-interface-remove commands.
       * Each fabric, cluster, standalone switch, or virtual network (VNET) can provide its tenants with a virtual router (vRouter) service that forwards traffic between networks and implements Layer 3 protocols.
       */
      pn_vrouterlbif?: {
        /**
         * Specify the name of the vRouter.
         */
        pn_vrouter_name: string;
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Specify the IP address.
         */
        pn_interface_ip?: string;
        /**
         * State the action to perform. Use 'present' to add vrouter loopback interface and 'absent' to remove vrouter loopback interface.
         */
        state: "present" | "absent";
        /**
         * Specify the interface index from 1 to 255.
         */
        pn_index?: number | string;
        /**
         * Target switch(es) to run the cli on.
         */
        pn_cliswitch?: string;
        [k: string]: unknown;
      };
      /**
       * This module manipulates files privileges using the Linux capabilities(7) system.
       */
      capabilities?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages Layer 3 attributes for IPv4 and IPv6 interfaces.
       */
      nxos_ip_interface?: {
        /**
         * Full name of interface, i.e. Ethernet1/1, vlan10.
         */
        interface?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: string;
        /**
         * Subnet mask for IPv4 or IPv6 Address in decimal format.
         */
        mask?: string;
        /**
         * IPv4 or IPv6 Address.
         */
        addr?: string;
        [k: string]: unknown;
      };
      /**
       * Deploy given repository URL / revision to dest. If dest exists, update to the specified revision, otherwise perform a checkout.
       */
      subversion?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Use facts to create ad-hoc groups that can be used later in a playbook.
       */
      group_by?: {
        /**
         * The variables whose values will be used as groups
         */
        key?: string;
        [k: string]: unknown;
      };
      /**
       * Create or delete a Rackspace Cloud Monitoring notification that specifies a channel that can be used to communicate alarms, such as email, webhooks, or PagerDuty. Rackspace monitoring module flow | rax_mon_entity -> rax_mon_check -> *rax_mon_notification* -> rax_mon_notification_plan -> rax_mon_alarm
       */
      rax_mon_notification?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * When the group does not exists in Gitlab, it will be created.
       * When the group does exists and state=absent, the group will be deleted.
       */
      gitlab_group?: {
        [k: string]: unknown;
      };
      /**
       * This module provides an implementation for working with the active configuration running on Juniper JUNOS devices.  It provides a set of arguments for loading configuration, performing rollback operations and zeroing the active configuration on the device.
       */
      junos_config?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        /**
         * The C(rollback) argument instructs the module to rollback the current configuration to the identifier specified in the argument.  If the specified rollback identifier does not exist on the remote device, the module will fail.  To rollback to the most recent commit, set the C(rollback) argument to 0.
         */
        rollback?: number | string;
        timeout?: number | string;
        /**
         * The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) argument.
         */
        src?: string;
        auth_pass?: string;
        /**
         * This argument takes a list of C(set) or C(delete) configuration lines to push into the remote device.  Each line must start with either C(set) or C(delete).  This argument is mutually exclusive with the I(src) argument.
         */
        lines?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The C(confirm) argument will configure a time out value for the commit to be confirmed before it is automatically rolled back.  If the C(confirm) argument is set to False, this argument is silently ignored.  If the value for this argument is set to 0, the commit is confirmed immediately.
         */
        confirm?: number | string;
        /**
         * Default: configured by junos_config
         *
         * The C(comment) argument specifies a text string to be used when committing the configuration.  If the C(confirm) argument is set to False, this argument is silently ignored.
         */
        comment?: string;
        /**
         * The C(replace) argument will instruct the remote device to replace the current configuration hierarchy with the one specified in the corresponding hierarchy of the source configuration loaded from this module.
         * Note this argument should be considered deprecated.  To achieve the equivalent, set the I(update) argument to C(replace).  This argument will be removed in a future release.
         */
        replace?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        host: string;
        /**
         * The C(zeroize) argument is used to completely sanitize the remote device configuration back to initial defaults.  This argument will effectively remove all current configuration statements on the remote device.
         */
        zeroize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The I(src_format) argument specifies the format of the configuration found int I(src).  If the I(src_format) argument is not provided, the module will attempt to determine the format of the configuration file specified in I(src).
         */
        src_format?: "xml" | "set" | "text" | "json";
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        /**
         * This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        port?: number | string;
        transport?: "netconf";
        [k: string]: unknown;
      };
      /**
       * This module will let you start and pause Uptime Robot Monitoring
       */
      uptimerobot?: {
        /**
         * ID of the monitor to check.
         */
        monitorid: string;
        /**
         * Define whether or not the monitor should be running or paused.
         */
        state: "started" | "paused";
        /**
         * Uptime Robot API key.
         */
        apikey: string;
        [k: string]: unknown;
      };
      /**
       * Management of LXD profiles
       */
      lxd_profile?: {
        /**
         * A new name of a profile.
         * If this parameter is specified a profile will be renamed to this name. See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-11)
         */
        new_name?: string;
        description?: string;
        /**
         * Default: unix:/var/lib/lxd/unix.socket
         *
         * The unix domain socket path or the https URL for the LXD server.
         */
        url?: string;
        /**
         * The config for the container (e.g. {"limits.memory": "4GB"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)
         * If the profile already exists and its "config" value in metadata obtained from GET /1.0/profiles/<name> U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#get-19) are different, they this module tries to apply the configurations.
         * Not all config values are supported to apply the existing profile. Maybe you need to delete and recreate a profile.
         */
        config?: {
          [k: string]: unknown;
        };
        /**
         * Default: "{}/.config/lxc/client.crt" .format(os.environ["HOME"])
         *
         * The client certificate file path.
         */
        cert_file?: string;
        /**
         * The devices for the profile (e.g. {"rootfs": {"path": "/dev/kvm", "type": "unix-char"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)
         */
        devices?: {
          [k: string]: unknown;
        };
        /**
         * Default: present
         *
         * Define the state of a profile.
         */
        state?: "present" | "absent";
        /**
         * Default: "{}/.config/lxc/client.key" .format(os.environ["HOME"])
         *
         * The client certificate key file path.
         */
        key_file?: string;
        /**
         * The client trusted password.
         * You need to set this password on the LXD server before running this module using the following command. lxc config set core.trust_password <some random password> See U(https://www.stgraber.org/2016/04/18/lxd-api-direct-interaction/)
         * If trust_password is set, this module send a request for authentication before sending any requests.
         */
        trust_password?: string;
        /**
         * Name of a profile.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Add, Update or Remove ports from an OpenStack cloud. A I(state) of 'present' will ensure the port is created or updated if required.
       */
      os_port?: {
        /**
         * Default: None
         *
         * Name that has to be given to the port.
         */
        name?: string;
        /**
         * Default: None
         *
         * Allowed address pairs list.  Allowed address pairs are supported with dictionary structure. e.g.  allowed_address_pairs: - ip_address: 10.1.0.12 mac_address: ab:cd:ef:12:34:56 - ip_address: ...
         */
        allowed_address_pairs?: string;
        /**
         * Default: None
         *
         * Sets admin state.
         */
        admin_state_up?: string;
        /**
         * Default: None
         *
         * Extra dhcp options to be assigned to this port.  Extra options are supported with dictionary structure. e.g.  extra_dhcp_opts: - opt_name: opt name1 opt_value: value1 - opt_name: ...
         */
        extra_dhcp_opts?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: None
         *
         * The ID of the entity that uses this port.
         */
        device_owner?: string;
        /**
         * Do not associate a security group with this port.
         */
        no_security_groups?: string;
        /**
         * Default: None
         *
         * MAC address of this port.
         */
        mac_address?: string;
        /**
         * Default: None
         *
         * Device ID of device using this port.
         */
        device_id?: string;
        /**
         * Default: None
         *
         * Desired IP and/or subnet for this port.  Subnet is referenced by subnet_id and IP is referenced by ip_address.
         */
        fixed_ips?: string;
        /**
         * Default: None
         *
         * Security group(s) ID(s) or name(s) associated with the port (comma separated string or YAML list)
         */
        security_groups?: string;
        /**
         * Network ID or name this port belongs to.
         */
        network?: string;
        [k: string]: unknown;
      };
      /**
       * Handles the EVPN control plane for VXLAN.
       */
      nxos_evpn_global?: {
        /**
         * EVPN control plane.
         */
        nv_overlay_evpn?: string;
        [k: string]: unknown;
      };
      /**
       * Manages AAA server host-specific configuration.
       */
      nxos_aaa_server_host?: {
        /**
         * The server type is either radius or tacacs.
         */
        server_type?: string;
        /**
         * The state of encryption applied to the entered key. O for clear text, 7 for encrypted. Type-6 encryption is not supported.
         */
        encrypt_type?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Alternate UDP port for RADIUS authentication.
         */
        auth_port?: string;
        /**
         * Alternate TCP port TACACS Server.
         */
        tacacs_port?: string;
        /**
         * Timeout period for specified host, in seconds. Range is 1-60.
         */
        host_timeout?: string;
        /**
         * Shared secret for the specified host.
         */
        key?: string;
        /**
         * Address or name of the radius or tacacs host.
         */
        address?: string;
        /**
         * Alternate UDP port for RADIUS accounting.
         */
        acct_port?: string;
        [k: string]: unknown;
      };
      /**
       * Create or delete a Rackspace Cloud Monitoring check associated with an existing rax_mon_entity. A check is a specific test or measurement that is performed, possibly from different monitoring zones, on the systems you monitor. Rackspace monitoring module flow | rax_mon_entity -> *rax_mon_check* -> rax_mon_notification -> rax_mon_notification_plan -> rax_mon_alarm
       */
      rax_mon_check?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Similar to the M(facter) module, this runs the I(Ohai) discovery program (U(http://wiki.opscode.com/display/chef/Ohai)) on the remote host and returns JSON inventory data. I(Ohai) data is a bit more verbose and nested than I(facter).
       */
      ohai?: {
        [k: string]: unknown;
      };
      /**
       * The OpenSwitch platform provides a library for pushing JSON structured configuration files into the current running-config.  This module will read the current configuration from OpenSwitch and compare it against a provided candidate configuration. If there are changes, the candidate configuration is merged with the current configuration and pushed into OpenSwitch
       */
      ops_template?: {
        /**
         * The path to the config source.  The source can be either a file with config or a template that will be merged during runtime.  By default the task will search for the source file in role or playbook root folder in templates directory.
         */
        src?: string;
        /**
         * The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
         */
        config?: string;
        /**
         * The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.
         */
        force?: string;
        /**
         * When this argument is configured true, the module will backup the running-config from the node prior to making any changes. The backup file will be written to backups/ in the root of the playbook directory.
         */
        backup?: string;
        [k: string]: unknown;
      };
      /**
       * Uses .net Environment to set or remove environment variables and can set at User, Machine or Process level.
       * User level environment variables will be set, but not available until the user has logged off and on again.
       */
      win_environment?: {
        /**
         * Default: present
         *
         * present to ensure environment variable is set, or absent to ensure it is removed
         */
        state?: string;
        /**
         * Default: no default
         *
         * The name of the environment variable
         */
        name?: string;
        /**
         * Default: no default
         *
         * The value to store in the environment variable. Can be omitted for state=absent
         */
        value?: string;
        /**
         * Default: no default
         *
         * The level at which to set the environment variable.
         * Use 'machine' to set for all users.
         * Use 'user' to set for the current user that ansible is connected as.
         * Use 'process' to set for the current process.  Probably not that useful.
         */
        level?: string;
        [k: string]: unknown;
      };
      /**
       * Create or Delete a Kinesis Stream.
       * Update the retention period of a Kinesis Stream.
       * Update Tags on a Kinesis Stream.
       */
      kinesis_stream?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Perform software maintenance upgrades (SMUs) on Cisco NX-OS devices.
       */
      nxos_smu?: {
        /**
         * Name of the remote package.
         */
        pkg?: string;
        /**
         * The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.
         */
        file_system?: string;
        [k: string]: unknown;
      };
      /**
       * Requests Ironic to set a node into inspect state in order to collect metadata regarding the node. This command may be out of band or in-band depending on the ironic driver configuration. This is only possible on nodes in 'manageable' and 'available' state.
       */
      os_ironic_inspect?: {
        /**
         * Default: None
         *
         * unique mac address that is used to attempt to identify the host.
         */
        mac?: string;
        /**
         * Default: None
         *
         * If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API. Use with "auth" and "auth_type" settings set to None.
         */
        ironic_url?: string;
        /**
         * Default: None
         *
         * unique name identifier to identify the host in Ironic.
         */
        name?: string;
        /**
         * Default: 1200
         *
         * A timeout in seconds to tell the role to wait for the node to complete introspection if wait is set to True.
         */
        timeout?: string;
        /**
         * Default: None
         *
         * globally unique identifier (UUID) to identify the host.
         */
        uuid?: string;
        [k: string]: unknown;
      };
      /**
       * Manages I(apt) packages (such as for Debian/Ubuntu).
       */
      apt?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or delete AWS SQS queues.
       * Update attributes on existing queues.
       */
      sqs_queue?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages SNMP contact information.
       */
      nxos_snmp_contact?: {
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Contact information.
         */
        contact?: string;
        [k: string]: unknown;
      };
      /**
       * This module uses rabbitMQ Rest API to create/delete bindings
       */
      rabbitmq_binding?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manage s3 bucket lifecycle rules in AWS
       */
      s3_lifecycle?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages VLAN configurations on NX-OS switches.
       */
      nxos_vlan?: {
        /**
         * Default: active
         *
         * Manage the vlan operational state of the VLAN (equivalent to state {active | suspend} command.
         */
        vlan_state?: string;
        /**
         * Name of VLAN.
         */
        name?: string;
        /**
         * The Virtual Network Identifier (VNI) ID that is mapped to the VLAN. Valid values are integer and keyword 'default'.
         */
        mapped_vni?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Default: up
         *
         * Manage the VLAN administrative state of the VLAN equivalent to shut/no shut in VLAN config mode.
         */
        admin_state?: string;
        /**
         * Range of VLANs such as 2-10 or 2,5,10-15, etc.
         */
        vlan_range?: string;
        /**
         * Single VLAN ID.
         */
        vlan_id?: string;
        [k: string]: unknown;
      };
      /**
       * Manage packages for FreeBSD using 'portinstall'.
       */
      portinstall?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Dell OS6 configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with Dell OS6 configuration sections in a deterministic way.
       */
      dellos6_config?: {
        [k: string]: unknown;
      };
      /**
       * Manages SELinux network port type definitions.
       */
      seport?: {
        /**
         * Default: True
         *
         * Reload SELinux policy after commit.
         */
        reload?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * SELinux type for the specified port.
         */
        setype: string;
        /**
         * Protocol for the specified port.
         */
        proto: "tcp" | "udp";
        /**
         * Default: present
         *
         * Desired boolean value.
         */
        state: "present" | "absent";
        /**
         * Ports or port ranges, separated by a comma
         */
        ports: string;
        [k: string]: unknown;
      };
      /**
       * Manages interface specific VRF configuration.
       */
      nxos_vrf_interface?: {
        /**
         * Full name of interface to be managed, i.e. Ethernet1/1.
         */
        interface?: string;
        /**
         * Default: present
         *
         * Manages desired state of the resource.
         */
        state?: string;
        /**
         * Name of VRF to be managed.
         */
        vrf?: string;
        [k: string]: unknown;
      };
      /**
       * Add or Remove security groups from an OpenStack cloud.
       */
      os_security_group?: {
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Name that has to be given to the security group. This module requires that security group names be unique.
         */
        name?: string;
        /**
         * Default: None
         *
         * Long description of the purpose of the security group
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Manages configuration of an ospf instance.
       */
      nxos_ospf?: {
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: string;
        /**
         * Name of the ospf instance.
         */
        ospf?: string;
        [k: string]: unknown;
      };
      /**
       * Cisco IOS XR configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with IOS XR configuration sections in a deterministic way.
       */
      iosxr_config?: {
        /**
         * Default: configured by iosxr_config
         *
         * Allows a commit description to be specified to be included when the configuration is committed.  If the configuration is not changed or committed, this argument is ignored.
         */
        comment?: string;
        /**
         * Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).
         */
        src?: string;
        /**
         * The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.
         * Note this argument should be considered deprecated.  To achieve the equivalent, set the C(match=none) which is idempotent.  This argument will be removed in a future release.
         */
        force?: string;
        /**
         * This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.
         */
        backup?: string;
        /**
         * The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
         */
        after?: string;
        /**
         * The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
         */
        lines?: string;
        /**
         * Default: line
         *
         * Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct.
         */
        replace?: string;
        /**
         * The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
         */
        parents?: string;
        /**
         * The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.
         */
        config?: string;
        /**
         * Default: line
         *
         * Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device.
         */
        match?: string;
        /**
         * The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
         */
        before?: string;
        [k: string]: unknown;
      };
      /**
       * Manages SNMP traps configurations.
       */
      nxos_snmp_traps?: {
        /**
         * Default: enabled
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Case sensitive group.
         */
        group?: string;
        [k: string]: unknown;
      };
      /**
       * Manage the checks that should be run on a machine by I(Sensu).
       * Most options do not have a default and will not be added to the check definition unless specified.
       * All defaults except I(path), I(state), I(backup) and I(metric) are not managed by this module,
       * they are simply specified for your convenience.
       */
      sensu_check?: {
        /**
         * Whether the check is a metric
         */
        metric?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * When to disable handling of check failures
         */
        subdue_begin?: string;
        /**
         * Default: 1
         *
         * Number of event occurrences before the handler should take action
         */
        occurrences?: number | string;
        /**
         * The low threshhold for flap detection
         */
        low_flap_threshold?: number | string;
        /**
         * List of handlers to notify when the check fails
         */
        handlers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: True
         *
         * Whether the check should be scheduled at all.
         * You can still issue it via the sensu api
         */
        publish?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A hash/dictionary of custom parameters for mixing to the configuration.
         * You can't rewrite others module parameters using this
         */
        custom?: {
          [k: string]: unknown;
        };
        /**
         * The check source, used to create a JIT Sensu client for an external resource (e.g. a network switch).
         */
        source?: string;
        /**
         * Default: present
         *
         * Whether the check should be present or not
         */
        state?: "present" | "absent";
        /**
         * When to enable handling of check failures
         */
        subdue_end?: string;
        /**
         * Default: True
         *
         * Whether the check should be handled or not
         */
        handle?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Other checks this check depends on, if dependencies fail,
         * handling of this check will be disabled
         */
        dependencies?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List of subscribers/channels this check should run for
         * See sensu_subscribers to subscribe a machine to a channel
         */
        subscribers?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Classifies the check as an aggregate check,
         * making it available via the aggregate API
         */
        aggregate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: /etc/sensu/conf.d/checks.json
         *
         * Path to the json file of the check to be added/removed.
         * Will be created if it does not exist (unless I(state=absent)).
         * The parent folders need to exist when I(state=present), otherwise an error will be thrown
         */
        path?: string;
        /**
         * The name of the check
         * This is the key that is used to determine whether a check exists
         */
        name: string;
        /**
         * Whether the check should be scheduled by the sensu client or server
         * This option obviates the need for specifying the I(subscribers) option
         */
        standalone?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Check interval in seconds
         */
        interval?: number | string;
        /**
         * Number of seconds handlers should wait before taking second action
         */
        refresh?: number | string;
        /**
         * Path to the sensu check to run (not required when I(state=absent))
         */
        command?: string;
        /**
         * The high threshhold for flap detection
         */
        high_flap_threshold?: number | string;
        /**
         * Default: 10
         *
         * Timeout for the check
         */
        timeout?: number | string;
        /**
         * Create a backup file (if yes), including the timestamp information so
         * you can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Send a message to typetalk using typetalk API ( http://developers.typetalk.in/ )
       */
      typetalk?: {
        /**
         * message body
         */
        msg: string;
        /**
         * topic id to post message
         */
        topic: number | string;
        /**
         * OAuth2 client ID
         */
        client_id: string;
        /**
         * OAuth2 client secret
         */
        client_secret: string;
        [k: string]: unknown;
      };
      /**
       * Grant and revoke roles in either project or domain context for OpenStack Identity Users.
       */
      os_user_role?: {
        /**
         * ID of the domain to scope the role association to. Valid only with keystone version 3, and required if I(project) is not specified.
         */
        domain?: string;
        /**
         * Name or ID for the group. Valid only with keystone version 3. If I(group) is not specified, then I(user) is required. Both may not be specified.
         */
        group?: string;
        /**
         * Name or ID of the project to scope the role assocation to. If you are using keystone version 2, then this value is required.
         */
        project?: string;
        /**
         * Default: present
         *
         * Should the roles be present or absent on the user.
         */
        state?: string;
        /**
         * Name or ID for the role.
         */
        role?: string;
        /**
         * Name or ID for the user. If I(user) is not specified, then I(group) is required. Both may not be specified.
         */
        user?: string;
        [k: string]: unknown;
      };
      /**
       * Manage iRules across different modules on a BIG-IP.
       */
      bigip_irule?: {
        /**
         * The iRule file to interpret and upload to the BIG-IP. Either one of C(src) or C(content) must be provided.
         */
        src?: string;
        /**
         * The name of the iRule.
         */
        name?: string;
        /**
         * Default: Common
         *
         * The partition to create the iRule on.
         */
        partition?: string;
        /**
         * The BIG-IP module to add the iRule to.
         */
        module?: string;
        /**
         * When used instead of 'src', sets the contents of an iRule directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. Either one of C(src) or C(content) must be provided.
         */
        content?: string;
        /**
         * Default: present
         *
         * Whether the iRule should exist or not.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * Add and remove domain from the list of permissive domain.
       */
      selinux_permissive?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage registration to the Red Hat Network.
       */
      rhn_register?: {
        /**
         * Red Hat Network username
         */
        username?: string;
        /**
         * Default: None
         *
         * supply an organizational id for use with registration
         */
        systemorgid?: string;
        enable_eus?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: Current value of I(serverURL) from C(/etc/sysconfig/rhn/up2date) is the default
         *
         * Specify an alternative Red Hat Network server URL
         */
        server_url?: string;
        /**
         * Optionally specify a list of comma-separated channels to subscribe to upon successful registration.
         */
        channels?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * whether to register (C(present)), or unregister (C(absent)) a system
         */
        state?: "present" | "absent";
        /**
         * Default: None
         *
         * supply a custom ssl CA certificate file for use with registration
         */
        sslcacert?: string;
        /**
         * supply an activation key for use with registration
         */
        activationkey?: string;
        /**
         * supply an profilename for use with registration
         */
        profilename?: string;
        /**
         * Red Hat Network password
         */
        password?: string;
        [k: string]: unknown;
      };
      /**
       * Add or Remove a floating IP to an instance
       */
      quantum_floating_ip?: {
        /**
         * Default: None
         *
         * Name of the region
         */
        region_name?: string;
        availability_zone?: string;
        /**
         * Default: yes
         *
         * Password of login user
         */
        login_password: string;
        /**
         * Default: None
         *
         * The name of the instance to which the IP address should be assigned
         */
        instance_name: string;
        /**
         * Default: yes
         *
         * The tenant name of the login user
         */
        login_tenant_name?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: "present" | "absent";
        /**
         * Default: http://127.0.0.1:35357/v2.0/
         *
         * The keystone url for authentication
         */
        auth_url?: string;
        /**
         * Default: None
         *
         * The name of the network of the port to associate with the floating ip. Necessary when VM multiple networks.
         */
        internal_network_name?: string;
        /**
         * Default: admin
         *
         * login username to authenticate to keystone
         */
        login_username?: string;
        /**
         * Default: None
         *
         * Name of the network from which IP has to be assigned to VM. Please make sure the network is an external network
         */
        network_name: string;
        [k: string]: unknown;
      };
      /**
       * Fetches a file from a URL and saves to locally
       */
      win_get_url?: {
        /**
         * Basic authentication username
         */
        username?: string;
        /**
         * Default: True
         *
         * If C(yes), will always download the file.  If C(no), will only download the file if it does not exist or the remote file has been modified more recently than the local file.  This works by sending an http HEAD request to retrieve last modified time of the requested resource, so for this to work, the remote web server must support HEAD requests.
         */
        force?: string;
        /**
         * The full URL of a file to download
         */
        url?: string;
        /**
         * Skip SSL certificate validation if true
         */
        skip_certificate_validation?: string;
        /**
         * The full URL of the proxy server to download through.
         */
        proxy_url?: string;
        /**
         * Proxy authentication password
         */
        proxy_password?: string;
        /**
         * The absolute path of the location to save the file at the URL. Be sure to include a filename and extension as appropriate.
         */
        dest?: string;
        /**
         * Proxy authentication username
         */
        proxy_username?: string;
        /**
         * Basic authentication password
         */
        password?: string;
        [k: string]: unknown;
      };
      /**
       * Add, modify or remove Windows share and set share permissions.
       */
      win_share?: {
        /**
         * Default: none
         *
         * Specify user list that should get no access, regardless of implied access on share, separated by comma.
         */
        deny?: string;
        /**
         * Default: none
         *
         * Specify user list that should get full access on share, separated by comma.
         */
        full?: string;
        /**
         * Share name
         */
        name?: string;
        /**
         * Default: none
         *
         * Specify user list that should get read access on share, separated by comma.
         */
        read?: string;
        /**
         * Default: none
         *
         * Specify whether to allow or deny file listing, in case user got no permission on share
         */
        list?: string;
        /**
         * Default: present
         *
         * Specify whether to add C(present) or remove C(absent) the specified share
         */
        state?: string;
        /**
         * Share directory
         */
        path?: string;
        /**
         * Default: none
         *
         * Specify user list that should get read and write access on share, separated by comma.
         */
        change?: string;
        /**
         * Default: none
         *
         * Share description
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * maintains ec2 key pairs. This module has a dependency on python-boto >= 2.5
       */
      ec2_key?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages BGP configurations on NX-OS switches.
       */
      nxos_bgp?: {
        /**
         * Enable/Disable handle BGP neighbor down event, due to various reasons.
         */
        neighbor_down_fib_accelerate?: string;
        /**
         * AS confederation parameters.
         */
        confederation_peers?: string;
        /**
         * Routing domain confederation AS.
         */
        confederation_id?: string;
        /**
         * Enable/Disable graceful restart helper mode.
         */
        graceful_restart_helper?: string;
        /**
         * Enable/Disable MED comparison on paths from different autonomous systems.
         */
        bestpath_always_compare_med?: string;
        /**
         * Route Reflector Cluster-ID.
         */
        cluster_id?: string;
        /**
         * Administratively shutdown the BGP protocol.
         */
        shutdown?: string;
        /**
         * Set BGP hold timer.
         */
        timer_bgp_hold?: string;
        /**
         * Enable/Disable load sharing across the providers with different (but equal-length) AS paths.
         */
        bestpath_aspath_multipath_relax?: string;
        /**
         * Set maximum time that BGP keeps the stale routes from the restarting BGP peer.
         */
        graceful_restart_timers_stalepath_time?: string;
        /**
         * Specify Maximum number of AS numbers allowed in the AS-path attribute. Valid values are between 1 and 512.
         */
        maxas_limit?: string;
        /**
         * Enable/Disable enforcement of bestpath to do a MED comparison only between paths originated within a confederation.
         */
        bestpath_med_confed?: string;
        /**
         * Enable/Disable isolate this router from BGP perspective.
         */
        isolate?: string;
        /**
         * Set BGP keepalive timer.
         */
        timer_bgp_keepalive?: string;
        /**
         * Enable/Disable Ignores the cost community for BGP best-path calculations.
         */
        bestpath_cost_community_ignore?: string;
        /**
         * Enable/Disable immediately reset the session if the link to a directly connected BGP peer goes down.  Only supported in the global BGP context.
         */
        fast_external_fallover?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: string;
        /**
         * Enable/Disable the batching evaluation of prefix advertisement to all peers.
         */
        disable_policy_batching?: string;
        /**
         * Enable/Disable advertise only routes programmed in hardware to peers.
         */
        suppress_fib_pending?: string;
        /**
         * Enable/Disable assigns the value of infinity to received routes that do not carry the MED attribute, making these routes the least desirable.
         */
        bestpath_med_missing_as_worst?: string;
        /**
         * Router Identifier (ID) of the BGP router VRF instance.
         */
        router_id?: string;
        /**
         * Specify timeout for the first best path after a restart, in seconds.
         */
        timer_bestpath_limit?: string;
        /**
         * Local AS number to be used within a VRF instance.
         */
        local_as?: string;
        /**
         * Enable/Disable periodic event history buffer.
         */
        event_history_periodic?: string;
        /**
         * Enable/Disable update-delay-always option.
         */
        timer_bestpath_limit_always?: string;
        /**
         * Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.
         */
        disable_policy_batching_ipv4_prefix_list?: string;
        /**
         * Name of the VRF. The name 'default' is a valid VRF representing the global BGP.
         */
        vrf?: string;
        /**
         * Enable/Disable cli event history buffer.
         */
        event_history_cli?: string;
        /**
         * Enable/Disable message logging for neighbor up/down event.
         */
        log_neighbor_changes?: string;
        /**
         * Enable/Disable event history buffer.
         */
        event_history_events?: string;
        /**
         * BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.
         */
        asn?: string;
        /**
         * Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.
         */
        disable_policy_batching_ipv6_prefix_list?: string;
        /**
         * Enable/Disable detail event history buffer.
         */
        event_history_detail?: string;
        /**
         * Enable/Disable graceful restart.
         */
        graceful_restart?: string;
        /**
         * Enable/Disable flush routes in RIB upon controlled restart. On NX-OS, this property is only supported in the global BGP context.
         */
        flush_routes?: string;
        /**
         * Enable/Disable enforces the neighbor autonomous system to be the first AS number listed in the AS path attribute for eBGP. On NX-OS, this property is only supported in the global BGP context.
         */
        enforce_first_as?: string;
        /**
         * Enable/Disable deterministic selection of the best MED pat from among the paths from the same autonomous system.
         */
        bestpath_med_non_deterministic?: string;
        /**
         * The BGP reconnection interval for dropped sessions. Valid values are between 1 and 60.
         */
        reconnect_interval?: string;
        /**
         * Set maximum time for a restart sent to the BGP peer.
         */
        graceful_restart_timers_restart?: string;
        /**
         * Enable/Disable comparison of router IDs for identical eBGP paths.
         */
        bestpath_compare_routerid?: string;
        [k: string]: unknown;
      };
      /**
       * If behind NAT and need to know the public IP of your internet gateway.
       */
      ipify_facts?: {
        /**
         * Default: https://api.ipify.org
         *
         * URL of the ipify.org API service.
         * C(?format=json) will be appended per default.
         */
        api_url?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, restart and delete networks.
       */
      cs_network?: {
        /**
         * Domain the network is related to.
         */
        domain?: string;
        /**
         * The ending IPv6 address of the network belongs to.
         * If not specified, value of C(start_ipv6) is used.
         * Only considered on create.
         */
        end_ipv6?: string;
        api_http_method?: "get" | "post";
        /**
         * The gateway of the network.
         * Required for shared networks and isolated networks when it belongs to a VPC.
         * Only considered on create.
         */
        gateway?: string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        /**
         * Name of the zone in which the network should be deployed.
         * If not set, default zone is used.
         */
        zone?: string;
        /**
         * The beginning IPv6 address of the network belongs to.
         * Only considered on create.
         */
        start_ipv6?: string;
        /**
         * CIDR of IPv6 network, must be at least /64.
         * Only considered on create.
         */
        cidr_ipv6?: string;
        /**
         * Default: present
         *
         * State of the network.
         */
        state?: "present" | "absent" | "restarted";
        /**
         * The ending IPv4 address of the network belongs to.
         * If not specified, value of C(start_ip) is used.
         * Only considered on create.
         */
        end_ip?: string;
        api_key?: string;
        /**
         * The ID or VID of the network.
         */
        vlan?: string;
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Cleanup old network elements.
         * Only considered on C(state=restarted).
         */
        clean_up?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The netmask of the network.
         * Required for shared networks and isolated networks when it belongs to a VPC.
         * Only considered on create.
         */
        netmask?: string;
        /**
         * Name of the offering for the network.
         * Required if C(state=present).
         */
        network_offering?: string;
        /**
         * Name of the VPC of the network.
         */
        vpc?: string;
        /**
         * The beginning IPv4 address of the network belongs to.
         * Only considered on create.
         */
        start_ip?: string;
        /**
         * The gateway of the IPv6 network.
         * Required for shared networks.
         * Only considered on create.
         */
        gateway_ipv6?: string;
        /**
         * Display text of the network.
         * If not specified, C(name) will be used as C(display_text).
         */
        display_text?: string;
        /**
         * The isolated private VLAN for this network.
         */
        isolated_pvlan?: string;
        /**
         * Account the network is related to.
         */
        account?: string;
        /**
         * Default: account
         *
         * Access control type.
         * Only considered on create.
         */
        acl_type?: "account" | "domain";
        /**
         * Name (case sensitive) of the network.
         */
        name: string;
        api_region?: string;
        /**
         * Name of the project the network to be deployed in.
         */
        project?: string;
        /**
         * The network domain.
         */
        network_domain?: string;
        [k: string]: unknown;
      };
      /**
       * This modules launches an ephemeral I(accelerate) daemon on the remote node which Ansible can use to communicate with nodes at high speed.
       * The daemon listens on a configurable port for a configurable amount of time.
       * Fireball mode is AES encrypted
       */
      accelerate?: {
        /**
         * Default: 300
         *
         * The number of seconds the socket will wait for data. If none is received when the timeout value is reached, the connection will be closed.
         */
        timeout?: string;
        /**
         * The listener daemon on the remote host will bind to the ipv6 localhost socket if this parameter is set to true.
         */
        ipv6?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        debug?: number | string;
        password: string;
        /**
         * Default: 30
         *
         * The I(accelerate) listener daemon is started on nodes and will stay around for this number of minutes before turning itself off.
         */
        minutes?: string;
        /**
         * Default: 5099
         *
         * TCP port for the socket connection
         */
        port?: string;
        /**
         * When enabled, the daemon will open a local socket file which can be used by future daemon executions to upload a new key to the already running daemon, so that multiple users can connect using different keys. This access still requires an ssh connection as the uid for which the daemon is currently running.
         */
        multi_key?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage Perl library dependencies.
       */
      cpanm?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or Delete routers from OpenStack. Although Neutron allows routers to share the same name, this module enforces name uniqueness to be more user friendly.
       */
      os_router?: {
        /**
         * Default: True
         *
         * Enable Source NAT (SNAT) attribute.
         */
        enable_snat?: string;
        /**
         * Default: None
         *
         * Unique name or ID of the external gateway network.
         * required I(interfaces) or I(enable_snat) are provided.
         */
        network?: string;
        /**
         * Default: True
         *
         * Desired admin state of the created or existing router.
         */
        admin_state_up?: string;
        /**
         * Default: None
         *
         * List of subnets to attach to the router internal interface.
         */
        interfaces?: string;
        /**
         * Default: None
         *
         * Unique name or ID of the project.
         */
        project?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: string;
        /**
         * Default: None
         *
         * The IP address parameters for the external gateway network. Each is a dictionary with the subnet name or ID (subnet) and the IP address to assign on the subnet (ip). If no IP is specified, one is automatically assigned from that subnet.
         */
        external_fixed_ips?: string;
        /**
         * Name to be give to the router
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manage Open vSwitch bridges
       */
      openvswitch_bridge?: {
        /**
         * Name of bridge to manage
         */
        bridge: string;
        /**
         * Default: present
         *
         * Whether the bridge should exist
         */
        state?: "present" | "absent";
        /**
         * Default: None
         *
         * Set bridge fail-mode. The default value (None) is a No-op.
         */
        fail_mode?: string;
        /**
         * Default: None
         *
         * A dictionary of external-ids. Omitting this parameter is a No-op. To  clear all external-ids pass an empty value.
         */
        external_ids?: {
          [k: string]: unknown;
        };
        /**
         * Default: 5
         *
         * How long to wait for ovs-vswitchd to respond
         */
        timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create/delete a DNS record in DigitalOcean.
       */
      digital_ocean_domain?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create/modify/remove networking bandwidth and associated resources for a type of traffic on a particular link.
       */
      flowadm?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Cisco ASA configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with ASA configuration sections in a deterministic way.
       */
      asa_config?: {
        [k: string]: unknown;
      };
      /**
       * Unified utility to interact with redis instances. 'slave' sets a redis instance in slave or master mode. 'flush' flushes all the instance or a specified db. 'config' (new in 1.6), ensures a configuration setting on an instance.
       */
      redis?: {
        /**
         * Default: 6379
         *
         * The port to connect to
         */
        login_port?: number | string;
        /**
         * The password used to authenticate with (usually not used)
         */
        login_password?: string;
        /**
         * A redis config key.
         */
        name?: string;
        /**
         * Default: all
         *
         * Type of flush (all the dbs in a redis instance or a specific one) [flush command]
         */
        flush_mode?: "all" | "db";
        /**
         * The host of the master instance [slave command]
         */
        master_host?: string;
        /**
         * Default: localhost
         *
         * The host running the database
         */
        login_host?: string;
        /**
         * The port of the master instance [slave command]
         */
        master_port?: number | string;
        /**
         * The database to flush (used in db mode) [flush command]
         */
        db?: number | string;
        /**
         * A redis config value.
         */
        value?: string;
        /**
         * The selected redis command
         */
        command?: "slave" | "flush" | "config";
        /**
         * Default: slave
         *
         * the mode of the redis instance [slave command]
         */
        slave_mode?: "master" | "slave";
        [k: string]: unknown;
      };
      /**
       * Send a message to Campfire.
       * Messages with newlines will result in a "Paste" message being sent.
       */
      campfire?: {
        /**
         * The message body.
         */
        msg: string;
        /**
         * API token.
         */
        token: string;
        /**
         * The subscription name to use.
         */
        subscription: string;
        /**
         * Room number to which the message should be sent.
         */
        room: string;
        /**
         * Send a notification sound before the message.
         */
        notify?:
          | "56k"
          | "bell"
          | "bezos"
          | "bueller"
          | "clowntown"
          | "cottoneyejoe"
          | "crickets"
          | "dadgummit"
          | "dangerzone"
          | "danielsan"
          | "deeper"
          | "drama"
          | "greatjob"
          | "greyjoy"
          | "guarantee"
          | "heygirl"
          | "horn"
          | "horror"
          | "inconceivable"
          | "live"
          | "loggins"
          | "makeitso"
          | "noooo"
          | "nyan"
          | "ohmy"
          | "ohyeah"
          | "pushit"
          | "rimshot"
          | "rollout"
          | "rumble"
          | "sax"
          | "secret"
          | "sexyback"
          | "story"
          | "tada"
          | "tmyk"
          | "trololo"
          | "trombone"
          | "unix"
          | "vuvuzela"
          | "what"
          | "whoomp"
          | "yeah"
          | "yodel";
        [k: string]: unknown;
      };
      /**
       * Manages NTP authentication.
       */
      nxos_ntp_auth?: {
        /**
         * Default: text
         *
         * Whether the given md5string is in cleartext or has been encrypted. If in cleartext, the device will encrypt it before storing it.
         */
        auth_type?: string;
        /**
         * Whether the given key is required to be supplied by a time source for the device to synchronize to the time source.
         */
        trusted_key?: string;
        /**
         * MD5 String.
         */
        md5string?: string;
        /**
         * Turns NTP authentication on or off.
         */
        authentication?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Authentication key identifier (numeric).
         */
        key_id?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or delete a storage account.
       */
      azure_rm_storageaccount?: {
        /**
         * Default: Storage
         *
         * The 'kind' of storage.
         */
        kind?: string;
        /**
         * Type of storage account. Required when creating a storage account. NOTE: Standard_ZRS and Premium_LRS accounts cannot be changed to other account types, and other account types cannot be changed to Standard_ZRS or Premium_LRS.
         */
        account_type?: string;
        /**
         * User domain assigned to the storage account. Must be a dictionary with 'name' and 'use_sub_domain' keys where 'name' is the CNAME source. Only one custom domain is supported per storage account at this time. To clear the existing custom domain, use an empty string for the custom domain name property.
         * Can be added to an existing storage account. Will be ignored during storage account creation.
         */
        custom_domain?: string;
        /**
         * Name of the resource group to use.
         */
        resource_group?: string;
        /**
         * Default: present
         *
         * Assert the state of the storage account. Use 'present' to create or update a storage account and 'absent' to delete an account.
         */
        state?: string;
        /**
         * Default: resource_group location
         *
         * Valid azure location. Defaults to location of the resource group.
         */
        location?: string;
        /**
         * Name of the storage account to update or create.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * This module creates, removes or resizes logical volumes.
       */
      lvol?: {
        /**
         * Comma separated list of physical volumes e.g. /dev/sda,/dev/sdb
         */
        pvs?: string;
        /**
         * Default: no
         *
         * Shrink or remove operations of volumes requires this switch. Ensures that that filesystems get never corrupted/destroyed by mistake.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The volume group this logical volume is part of.
         */
        vg: string;
        /**
         * The name of the logical volume.
         */
        lv: string;
        /**
         * Default: present
         *
         * Control if the logical volume exists. If C(present) and the volume does not already exist then the C(size) option is required.
         */
        state?: "present" | "absent";
        /**
         * The name of the snapshot volume
         */
        snapshot?: string;
        /**
         * Default: yes
         *
         * Whether the volume is activate and visible to the host.
         */
        active?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: True
         *
         * shrink if current size is higher than size requested
         */
        shrink?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Free-form options to be passed to the lvcreate command
         */
        opts?: string;
        /**
         * The size of the logical volume, according to lvcreate(8) --size, by default in megabytes or optionally with one of [bBsSkKmMgGtTpPeE] units; or according to lvcreate(8) --extents as a percentage of [VG|PVS|FREE]; Float values must begin with a digit. Resizing using percentage values was not supported prior to 2.1.
         */
        size?: string;
        [k: string]: unknown;
      };
      /**
       * Add or remove users to RabbitMQ and assign permissions
       */
      rabbitmq_user?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Add or remove MSSQL databases from a remote host.
       */
      mssql_db?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manage BIG-IP system database variables
       */
      bigip_sys_db?: {
        /**
         * Default: present
         *
         * The state of the variable on the system. When C(present), guarantees that an existing variable is set to C(value). When C(reset) sets the variable back to the default value. At least one of value and state C(reset) are required.
         */
        state?: string;
        /**
         * The value to set the key to. At least one of value and state C(reset) are required.
         */
        value?: string;
        /**
         * The database variable to manipulate.
         */
        key?: string;
        [k: string]: unknown;
      };
      /**
       * Configures a front panel, sub-interface, SVI, management or loopback port on a Cumulus Linux switch. For bridge ports use the cl_bridge module. For bond ports use the cl_bond module. When configuring bridge related features like the "vid" option, please follow the guidelines for configuring "vlan aware" bridging. For more details review the Layer2 Interface Guide at U(http://docs.cumulusnetworks.com)
       */
      cl_interface?: {
        /**
         * Clagd system mac address. Recommended to use the range starting with 44:38:39:ff. Needs to be the same between 2 Clag switches.
         */
        clagd_sys_mac?: string;
        /**
         * Name of the interface.
         */
        name: string;
        /**
         * Enables the clagd daemon. This command should only be applied to the clag peerlink interface.
         */
        clagd_enable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enables bridge assurance in vlan-aware mode.
         */
        mstpctl_portnetwork?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Enables BPDU Guard on a port in vlan-aware mode.
         */
        mstpctl_bpduguard?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * List of IPv6 addresses to configure on the interface. In the form I(X:X:X::X/YYY).
         */
        ipv6?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Integer that changes the role the switch has in the clag domain. The lower priority switch will assume the primary role. The number can be between 0 and 65535.
         */
        clagd_priority?: string;
        /**
         * Enables admin edge port.
         */
        mstpctl_portadminedge?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set MTU. Configure Jumbo Frame by setting MTU to I(9000).
         */
        mtu?: string;
        /**
         * In vlan-aware mode, defines vlan that is the untagged vlan.
         */
        pvid?: string;
        /**
         * In vlan-aware mode, lists VLANs defined under the interface.
         */
        vids?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Define IPv4 virtual IP used by the Cumulus Linux VRR feature.
         */
        virtual_ip?: string;
        /**
         * IP address of the directly connected peer switch interface.
         */
        clagd_peer_ip?: string;
        /**
         * Define Ethernet mac associated with Cumulus Linux VRR feature.
         */
        virtual_mac?: string;
        /**
         * Address method.
         */
        addr_method?: "" | "loopback" | "dhcp";
        clagd_args?: string;
        /**
         * Description of the port.
         */
        alias_name?: string;
        /**
         * List of IPv4 addresses to configure on the interface. In the form I(X.X.X.X/YY).
         */
        ipv4?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Set speed of the swp(front panel) or management(eth0) interface. speed is in MB.
         */
        speed?: string;
        /**
         * Default: ['/etc/network/interfaces.d']
         *
         * Interface directory location
         */
        location?: string;
        [k: string]: unknown;
      };
      /**
       * Adds or removes Vertica database user and, optionally, assigns roles.
       * A user will not be removed until all the dependencies have been dropped.
       * In such a situation, if the module tries to remove the user it will fail and only remove roles granted to the user.
       */
      vertica_user?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Add or remove flavors from OpenStack.
       */
      os_nova_flavor?: {
        /**
         * Default: auto
         *
         * ID for the flavor. This is optional as a unique UUID will be assigned if a value is not specified.
         */
        flavorid?: string;
        /**
         * Flavor name.
         */
        name?: string;
        /**
         * Amount of memory, in MB.
         */
        ram?: string;
        /**
         * Ephemeral space size, in GB.
         */
        ephemeral?: string;
        /**
         * Number of virtual CPUs.
         */
        vcpus?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource. When I(state) is 'present', then I(ram), I(vcpus), and I(disk) are all required. There are no default values for those parameters.
         */
        state?: string;
        /**
         * Swap space size, in MB.
         */
        swap?: string;
        /**
         * Default: 1.0
         *
         * RX/TX factor.
         */
        rxtx_factor?: string;
        /**
         * Default: True
         *
         * Make flavor accessible to the public.
         */
        is_public?: string;
        /**
         * Size of local disk, in GB.
         */
        disk?: string;
        [k: string]: unknown;
      };
      /**
       * Assembles a configuration file from fragments. Often a particular program will take a single configuration file and does not support a C(conf.d) style structure where it is easy to build up the configuration from multiple sources. M(assemble) will take a directory of files that can be local or have already been transferred to the system, and concatenate them together to produce a destination file. Files are assembled in string sorting order. Puppet calls this idea I(fragments).
       */
      assemble?: {
        /**
         * A boolean that controls if files that start with a '.' will be included or not.
         */
        ignore_hidden?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * An already existing directory full of source files.
         */
        src: string;
        /**
         * Default: True
         *
         * If False, it will search for src at originating/master machine, if True it will go to the remote/target machine for the src. Default is True.
         */
        remote_src?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A file to create using the concatenation of all of the source files.
         */
        dest: string;
        /**
         * A delimiter to separate the file contents.
         */
        delimiter?: string;
        /**
         * Assemble files only if C(regex) matches the filename. If not set, all files are assembled. All "\" (backslash) must be escaped as "\\" to comply yaml syntax. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).
         */
        regexp?: string;
        /**
         * The validation command to run before copying into place.  The path to the file to validate is passed in via '%s' which must be present as in the sshd example below. The command is passed securely so shell features like expansion and pipes won't work.
         */
        validate?: string;
        /**
         * Default: no
         *
         * Create a backup file (if C(yes)), including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Create, delete, enable or disable IP interfaces on Solaris/illumos systems.
       */
      ipadm_if?: {
        /**
         * Default: present
         *
         * Create or delete Solaris/illumos IP interfaces.
         */
        state?: "present" | "absent" | "enabled" | "disabled";
        /**
         * Specifies that the IP interface is temporary. Temporary IP interfaces do not persist across reboots.
         */
        temporary?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * IP interface name.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or destroy host groups on a NetApp E-Series storage array.
       */
      netapp_e_hostgroup?: {
        /**
         * specify this when you need to update the name of a host group
         */
        new_name?: string;
        /**
         * The ID of the array to manage (as configured on the web services proxy).
         */
        ssid: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password: string;
        /**
         * The name of the host group to manage. Either this or C(id_num) must be supplied.
         */
        name?: string;
        /**
         * Whether the specified host group should exist or not.
         */
        state: "present" | "absent";
        hosts?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?: string;
        /**
         * The id number of the host group to manage. Either this or C(name) must be supplied.
         */
        id?: string;
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url: string;
        [k: string]: unknown;
      };
      /**
       * Copy a file to the flash (or bootflash) remote network device on NXOS devices.
       */
      nxos_file_copy?: {
        /**
         * Remote file path of the copy. Remote directories must exist. If omitted, the name of the local file will be used.
         */
        remote_file?: string;
        /**
         * Path to local file. Local directory must exist.
         */
        local_file?: string;
        /**
         * The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.
         */
        file_system?: string;
        [k: string]: unknown;
      };
      /**
       * Retrieve facts about available OpenStack instance flavors. By default, facts about ALL flavors are retrieved. Filters can be applied to get facts for only matching flavors. For example, you can filter on the amount of RAM available to the flavor, or the number of virtual CPUs available to the flavor, or both. When specifying multiple filters, *ALL* filters must match on a flavor before that flavor is returned as a fact.
       */
      os_flavor_facts?: {
        /**
         * A string used for filtering flavors based on the number of virtual CPUs desired. Format is the same as the I(ram) parameter.
         */
        vcpus?: string;
        /**
         * A string used for filtering flavors based on the amount of RAM (in MB) desired. This string accepts the following special values: 'MIN' (return flavors with the minimum amount of RAM), and 'MAX' (return flavors with the maximum amount of RAM).
         * A specific amount of RAM may also be specified. Any flavors with this exact amount of RAM will be returned.
         * A range of acceptable RAM may be given using a special syntax. Simply prefix the amount of RAM with one of these acceptable range values: '<', '>', '<=', '>='. These values represent less than, greater than, less than or equal to, and greater than or equal to, respectively.
         */
        ram?: string;
        /**
         * Default: None
         *
         * Limits the number of flavors returned. All matching flavors are returned by default.
         */
        limit?: string;
        /**
         * Default: None
         *
         * A flavor name. Cannot be used with I(ram) or I(vcpus).
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Manage firewall with UFW.
       */
      ufw?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Enable, disable, and set weights for HAProxy backend servers using socket commands.
       */
      haproxy?: {
        /**
         * Default: /var/run/haproxy.sock
         *
         * Path to the HAProxy socket file.
         */
        socket?: string;
        /**
         * The value passed in argument. If the value ends with the `%` sign, then the new weight will be relative to the initially configured weight. Relative weights are only permitted between 0 and 100% and absolute weights are permitted between 0 and 256.
         */
        weight?: string;
        /**
         * Default: 5
         *
         * Number of seconds to wait between retries.
         */
        wait_interval?: number | string;
        /**
         * Desired state of the provided backend host.
         */
        state: "enabled" | "disabled";
        /**
         * Default: auto-detected
         *
         * Name of the HAProxy backend pool.
         */
        backend?: string;
        /**
         * Default: 25
         *
         * Number of times to check for status after changing the state.
         */
        wait_retries?: number | string;
        /**
         * Name of the backend host to change.
         */
        host: string;
        /**
         * Fail whenever trying to enable/disable a backend host that does not exist
         */
        fail_on_not_found?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * When disabling a server, immediately terminate all the sessions attached to the specified server. This can be used to terminate long-running sessions after a server is put into maintenance mode.
         */
        shutdown_sessions?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Wait until the server reports a status of 'UP' when `state=enabled`, or status of 'MAINT' when `state=disabled`.
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module offers the ability to set a configuration checkpoint file or rollback to a configuration checkpoint file on Cisco NXOS switches.
       */
      nxos_rollback?: {
        /**
         * Name of checkpoint file to create. Mutually exclusive with rollback_to.
         */
        checkpoint_file?: string;
        /**
         * Name of checkpoint file to rollback to. Mutually exclusive with checkpoint_file.
         */
        rollback_to?: string;
        [k: string]: unknown;
      };
      /**
       * The M(win_copy) module copies a file on the local box to remote windows locations.
       */
      win_copy?: {
        /**
         * Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too. Use \ for path separators.
         */
        dest?: string;
        /**
         * Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with "/", only inside contents of that directory are copied to destination. Otherwise, if it does not end with "/", the directory itself with all contents is copied. This behavior is similar to Rsync.
         */
        src?: string;
        [k: string]: unknown;
      };
      /**
       * This module fetches data from the metadata API in CloudStack. The module must be called from within the instance itself.
       */
      cs_facts?: {
        /**
         * Filter for a specific fact.
         */
        filter?:
          | "cloudstack_service_offering"
          | "cloudstack_availability_zone"
          | "cloudstack_public_hostname"
          | "cloudstack_public_ipv4"
          | "cloudstack_local_hostname"
          | "cloudstack_local_ipv4"
          | "cloudstack_instance_id"
          | "cloudstack_user_data";
        [k: string]: unknown;
      };
      /**
       * Installs, upgrade and removes packages using the underlying OS package manager.
       */
      package?: {
        [k: string]: unknown;
      };
      /**
       * Create, update and remove zones.
       */
      cs_zone?: {
        /**
         * Domain the zone is related to.
         * Zone is a public zone if not set.
         */
        domain?: string;
        api_http_method?: "get" | "post";
        /**
         * DHCP provider for the Zone.
         */
        dhcp_provider?: string;
        /**
         * uuid of the exising zone.
         */
        id?: string;
        /**
         * First DNS for IPv6 for the zone.
         */
        dns1_ipv6?: string;
        /**
         * First internal DNS for the zone.
         * If not set C(dns1) will be used on C(state=present).
         */
        internal_dns1?: string;
        /**
         * Second internal DNS for the zone.
         */
        internal_dns2?: string;
        api_url?: string;
        /**
         * Default: present
         *
         * State of the zone.
         */
        state?: "present" | "enabled" | "disabled" | "absent";
        api_key?: string;
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Second DNS for IPv6 for the zone.
         */
        dns2_ipv6?: string;
        securitygroups_enabled?: string;
        /**
         * Name of the zone.
         */
        name: string;
        /**
         * Second DNS for the zone.
         */
        dns2?: string;
        /**
         * First DNS for the zone.
         * Required if C(state=present)
         */
        dns1?: string;
        api_region?: string;
        /**
         * Guest CIDR address for the zone.
         */
        guest_cidr_address?: string;
        /**
         * Network domain for the zone.
         */
        network_domain?: string;
        local_storage_enabled?: string;
        /**
         * Default: basic
         *
         * Network type of the zone.
         */
        network_type?: "Basic" | "basic" | "Advanced" | "advanced";
        [k: string]: unknown;
      };
      /**
       * Allows for the management of server certificates
       */
      iam_cert?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Sets and retrieves file ACL information.
       */
      acl?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * When the project does not exists in Gitlab, it will be created.
       * When the project does exists and state=absent, the project will be deleted.
       * When changes are made to the project, the project will be updated.
       */
      gitlab_project?: {
        [k: string]: unknown;
      };
      /**
       * Add or remove PostgreSQL databases from a remote host.
       */
      postgresql_db?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Creates or terminates azure instances. When created optionally waits for it to be 'running'.
       */
      azure?: {
        /**
         * Default: 22
         *
         * a comma-separated list of TCP ports to expose on the virtual machine (e.g., "22,80")
         */
        endpoints?: string;
        /**
         * Default: Small
         *
         * azure role size for the new virtual machine (e.g., Small, ExtraLarge, A6). You have to pay attention to the fact that instances of type G and DS are not available in all regions (locations). Make sure if you selected the size and type of instance available in your chosen location.
         */
        role_size?:
          | "ExtraSmall"
          | "Small"
          | "Medium"
          | "Large"
          | "ExtraLarge"
          | "A5"
          | "A6"
          | "A7"
          | "A8"
          | "A9"
          | "Basic_A0"
          | "Basic_A1"
          | "Basic_A2"
          | "Basic_A3"
          | "Basic_A4"
          | "Standard_D1"
          | "Standard_D2"
          | "Standard_D3"
          | "Standard_D4"
          | "Standard_D11"
          | "Standard_D12"
          | "Standard_D13"
          | "Standard_D14"
          | "Standard_D1_v2"
          | "Standard_D2_v2"
          | "Standard_D3_v2"
          | "Standard_D4_v2"
          | "Standard_D5_v2"
          | "Standard_D11_v2"
          | "Standard_D12_v2"
          | "Standard_D13_v2"
          | "Standard_D14_v2"
          | "Standard_DS1"
          | "Standard_DS2"
          | "Standard_DS3"
          | "Standard_DS4"
          | "Standard_DS11"
          | "Standard_DS12"
          | "Standard_DS13"
          | "Standard_DS14"
          | "Standard_G1"
          | "Standard_G2"
          | "Standard_G3"
          | "Standard_G4"
          | "Standard_G5";
        /**
         * name of the virtual machine and associated cloud service.
         */
        name?: string;
        /**
         * the azure location to use (e.g. 'East US')
         *
         * Possible choices:
         * South Central US
         * Central US
         * East US 2
         * East US
         * West US
         * North Central US
         * North Europe
         * West Europe
         * East Asia
         * Southeast Asia
         * Japan West
         * Japan East
         * Brazil South
         */
        location?: string;
        /**
         * Name of virtual network.
         */
        virtual_network_name?: string;
        /**
         * system image for creating the virtual machine (e.g., b39f27a8b8c64d52b05eac6a62ebad85__Ubuntu_DAILY_BUILD-precise-12_04_3-LTS-amd64-server-20131205-en-us-30GB)
         */
        image?: string;
        /**
         * hostname to write /etc/hostname. Defaults to <name>.cloudapp.net.
         */
        hostname?: string;
        /**
         * Default: yes
         *
         * Enable winrm on Windows Machines
         */
        enable_winrm?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * create or terminate instances
         */
        state?: string;
        /**
         * Default: 300
         *
         * how long before wait gives up for redirects, in seconds
         */
        wait_timeout_redirects?: string;
        /**
         * path to an azure management certificate associated with the subscription id. Overrides the AZURE_CERT_PATH environment variable.
         */
        management_cert_path?: string;
        /**
         * path to an X509 certificate containing the public ssh key to install in the virtual machine. See http://www.windowsazure.com/en-us/manage/linux/tutorials/intro-to-linux/ for more details.
         * if this option is specified, password-based ssh authentication will be disabled.
         */
        ssh_cert_path?: string;
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: string;
        /**
         * the unix username for the new virtual machine.
         */
        user?: string;
        /**
         * Default: no
         *
         * Enable Auto Updates on Windows Machines
         */
        auto_updates?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * the azure storage account in which to store the data disks.
         */
        storage_account?: string;
        /**
         * Default: linux
         *
         * The type of the os that is gettings provisioned
         */
        os_type?: "windows" | "linux";
        /**
         * the unix password for the new virtual machine.
         */
        password?: string;
        /**
         * azure subscription id. Overrides the AZURE_SUBSCRIPTION_ID environment variable.
         */
        subscription_id?: string;
        /**
         * Default: no
         *
         * wait for the instance to be in state 'running' before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Creates or deletes instances of task definitions.
       */
      ecs_task?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows you to create, modify and delete Zabbix host entries and associated group and template data.
       */
      zabbix_host?: {
        /**
         * Default: enabled
         *
         * Monitoring status of the host.
         */
        status?: string;
        /**
         * Default: None
         *
         * Basic Auth password
         */
        http_login_password?: string;
        /**
         * Default: None
         *
         * Configure the inventory mode.
         */
        inventory_mode?: string;
        /**
         * Default: 10
         *
         * The timeout of API request (seconds).
         */
        timeout?: string;
        /**
         * Zabbix user name, used to authenticate against the server.
         */
        login_user?: string;
        /**
         * List of interfaces to be created for the host (see example below).
         * Available values are: dns, ip, main, port, type and useip.
         * Please review the interface documentation for more information on the supported properties
         * https://www.zabbix.com/documentation/2.0/manual/appendix/api/hostinterface/definitions#host_interface
         */
        interfaces?: string;
        /**
         * Default: None
         *
         * Basic Auth login
         */
        http_login_user?: string;
        /**
         * Url of Zabbix server, with protocol (http or https).
         */
        server_url?: string;
        /**
         * Default: present
         *
         * State of the host.
         * On C(present), it will create if host does not exist or update the host if the associated data is different.
         * On C(absent) will remove a host if it exists.
         */
        state?: string;
        /**
         * Name of the host in Zabbix.
         * host_name is the unique identifier used and cannot be updated using this module.
         */
        host_name?: string;
        /**
         * List of host groups the host is part of.
         */
        host_groups?: string;
        /**
         * Zabbix user password.
         */
        login_password?: string;
        /**
         * Default: yes
         *
         * Overwrite the host configuration, even if already present
         */
        force?: string;
        /**
         * Default: None
         *
         * List of templates linked to the host.
         */
        link_templates?: string;
        /**
         * Default: None
         *
         * The name of the Zabbix Proxy to be used
         */
        proxy?: string;
        [k: string]: unknown;
      };
      /**
       * Will install, upgrade and remove packages with swdepot package manager (HP-UX)
       */
      swdepot?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * creates / deletes a Linode Public Cloud instance and optionally waits for it to be 'running'.
       */
      linode?: {
        [k: string]: unknown;
      };
      /**
       * This module provides configuration file management of VyOS devices.  It provides arguments for managing both the configuration file and state of the active configuration.   All configuration statements are based on `set` and `delete` commands in the device configuration.
       */
      vyos_config?: {
        /**
         * Default: configured by vyos_config
         *
         * Allows a commit description to be specified to be included when the configuration is committed.  If the configuration is not changed or committed, this argument is ignored.
         */
        comment?: string;
        /**
         * The C(src) argument specifies the path to the source config file to load.  The source config file can either be in bracket format or set format.  The source file can include Jinja2 template variables.
         */
        src?: string;
        /**
         * The C(config) argument specifies the base configuration to use to compare against the desired configuration.  If this value is not specified, the module will automatically retrieve the current active configuration from the remote device.
         */
        config?: string;
        /**
         * The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.
         */
        lines?: string;
        /**
         * The C(save) argument controls whether or not changes made to the active configuration are saved to disk.  This is independent of committing the config.  When set to True, the active configuration is saved.
         */
        save?: string;
        /**
         * The C(backup) argument will backup the current devices active configuration to the Ansible control host prior to making any changes.  The backup file will be located in the backup folder in the root of the playbook
         */
        backup?: string;
        /**
         * Default: line
         *
         * The C(match) argument controls the method used to match against the current active configuration.  By default, the desired config is matched against the active config and the deltas are loaded.  If the C(match) argument is set to C(none) the active configuration is ignored and the configuration is always loaded.
         */
        match?: string;
        [k: string]: unknown;
      };
      /**
       * Manage DNS records on Rackspace Cloud DNS
       */
      rax_dns_record?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Provide one or more image names, and the module will inspect each, returning an array of inspection results.
       */
      docker_image_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Creates, deletes, or modifies amazon Redshift cluster instances.
       */
      redshift?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module can create and destroy unformatted GCE persistent disks U(https://developers.google.com/compute/docs/disks#persistentdisks). It also supports attaching and detaching disks from running instances. Full install/configuration instructions for the gce* modules can be found in the comments of ansible/test/gce_tests.py.
       */
      gce_pd?: {
        /**
         * Default: 10
         *
         * whole integer size of disk (in GB) to create, default is 10 GB
         */
        size_gb?: string;
        /**
         * Default: pd-standard
         *
         * type of disk provisioned
         */
        disk_type?: string;
        /**
         * name of the disk
         */
        name: string;
        /**
         * Default: us-central1-b
         *
         * zone in which to create the disk
         */
        zone?: string;
        /**
         * service account email
         */
        service_account_email?: string;
        /**
         * the source image to use for the disk
         */
        image?: string;
        /**
         * path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.
         */
        pem_file?: string;
        /**
         * instance name if you wish to attach or detach the disk
         */
        instance_name?: string;
        /**
         * Default: present
         *
         * desired state of the persistent disk
         */
        state?: string;
        /**
         * the source snapshot to use for the disk
         */
        snapshot?: string;
        /**
         * Default: READ_ONLY
         *
         * GCE mount mode of disk, READ_ONLY (default) or READ_WRITE
         */
        mode?: "READ_WRITE" | "READ_ONLY";
        /**
         * path to the JSON file associated with the service account email
         */
        credentials_file?: string;
        /**
         * your GCE project ID
         */
        project_id?: string;
        /**
         * Default: no
         *
         * do not destroy the disk, merely detach it from an instance
         */
        detach_only?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module allows you to create or restore a volume snapshot. This module has a dependency on profitbricks >= 1.0.0
       */
      profitbricks_nic?: {
        /**
         * The datacenter in which to operate.
         */
        datacenter?: string;
        /**
         * The LAN to place the NIC on. You can pass a LAN that doesn't exist and it will be created. Required on create.
         */
        lan?: string;
        /**
         * The name or ID of the NIC. This is only required on deletes, but not on create.
         */
        name?: string;
        /**
         * The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environement variable.
         */
        subscription_user?: string;
        /**
         * The server name or ID.
         */
        server?: string;
        /**
         * THe ProfitBricks password. Overrides the PB_PASSWORD environement variable.
         */
        subscription_password?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the resource
         */
        state?: string;
        /**
         * Default: 600
         *
         * how long before wait gives up, in seconds
         */
        wait_timeout?: number | string;
        /**
         * Default: yes
         *
         * wait for the operation to complete before returning
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Creates or terminates ecs services.
       */
      ecs_service?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Using VMware vCenter, move a virtual machine using vMotion to a different host.
       */
      vmware_vmotion?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module works like M(fetch). It is used for fetching a base64- encoded blob containing the data in a remote file.
       */
      slurp?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * manages Zabbix host macros, it can create, update or delete them.
       */
      zabbix_hostmacro?: {
        /**
         * Default: None
         *
         * Basic Auth password
         */
        http_login_password?: string;
        /**
         * Name of the host macro.
         */
        macro_name?: string;
        /**
         * Value of the host macro.
         */
        macro_value?: string;
        /**
         * Zabbix user name.
         */
        login_user?: string;
        /**
         * Default: None
         *
         * Basic Auth login
         */
        http_login_user?: string;
        /**
         * Url of Zabbix server, with protocol (http or https).
         */
        server_url?: string;
        /**
         * Default: present
         *
         * State of the macro.
         * On C(present), it will create if macro does not exist or update the macro if the associated data is different.
         * On C(absent) will remove a macro if it exists.
         */
        state?: string;
        /**
         * Name of the host.
         */
        host_name?: string;
        /**
         * Default: 10
         *
         * The timeout of API request (seconds).
         */
        timeout?: string;
        /**
         * Zabbix user password.
         */
        login_password?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or delete a network security group. A security group contains Access Control List (ACL) rules that allow or deny network traffic to subnets or individual network interfaces. A security group is created with a set of default security rules and an empty set of security rules. Shape traffic flow by adding rules to the empty set of security rules.
       */
      azure_rm_securitygroup?: {
        profile?: string;
        cli_default_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the resource group the security group belongs to.
         */
        resource_group: string;
        /**
         * Remove any existing rules not matching those defined in the rules parameters.
         */
        purge_rules?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tags?: {
          [k: string]: unknown;
        };
        /**
         * Set of rules shaping traffic flow to or from a subnet or NIC. Each rule is a dictionary.
         */
        rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        cloud_environment?: string;
        secret?: string;
        /**
         * The set of default rules automatically added to a security group at creation. In general default rules will not be modified. Modify rules to shape the flow of traffic to or from a subnet or NIC. See rules below for the makeup of a rule dict.
         */
        default_rules?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Remove any existing rules not matching those defined in the default_rules parameter.
         */
        purge_default_rules?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * Assert the state of the security group. Set to 'present' to create or update a security group. Set to 'absent' to remove a security group.
         */
        state?: "absent" | "present";
        /**
         * Default: resource_group location
         *
         * Valid azure location. Defaults to location of the resource group.
         */
        location?: string;
        client_id?: string;
        subscription_id?: string;
        password?: string;
        tenant?: string;
        /**
         * Name of the security group to operate on.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, disable, lock, enable and remove accounts.
       */
      cs_account?: {
        /**
         * Username of the user to be created if account did not exist.
         * Required on C(state=present).
         */
        username?: string;
        /**
         * Default: ROOT
         *
         * Domain the account is related to.
         */
        domain?: string;
        /**
         * Last name of the user to be created if account did not exist.
         * Required on C(state=present).
         */
        last_name?: string;
        /**
         * Default: user
         *
         * Type of the account.
         */
        account_type?: "user" | "root_admin" | "domain_admin";
        /**
         * Name of account.
         */
        name: string;
        api_http_method?: "get" | "post";
        /**
         * Network domain of the account.
         */
        network_domain?: string;
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * First name of the user to be created if account did not exist.
         * Required on C(state=present).
         */
        first_name?: string;
        api_region?: string;
        api_key?: string;
        /**
         * Default: present
         *
         * State of the account.
         * C(unlocked) is an alias for C(enabled).
         */
        state?: "present" | "absent" | "enabled" | "disabled" | "locked" | "unlocked";
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Timezone of the user to be created if account did not exist.
         */
        timezone?: string;
        /**
         * Password of the user to be created if account did not exist.
         * Required on C(state=present).
         */
        password?: string;
        /**
         * Email of the user to be created if account did not exist.
         * Required on C(state=present).
         */
        email?: string;
        api_url?: string;
        [k: string]: unknown;
      };
      /**
       * Toggles SELinux booleans.
       */
      seboolean?: {
        /**
         * Desired boolean value
         */
        state:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Set to C(yes) if the boolean setting should survive a reboot
         */
        persistent?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the boolean to configure
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Adds, removes or changes procedural languages with a PostgreSQL database.
       * This module allows you to add a language, remote a language or change the trust relationship with a PostgreSQL database. The module can be used on the machine where executed or on a remote host.
       * When removing a language from a database, it is possible that dependencies prevent the database from being removed. In that case, you can specify casade to automatically drop objects that depend on the language (such as functions in the language). In case the language can't be deleted because it is required by the database system, you can specify fail_on_drop=no to ignore the error.
       * Be carefull when marking a language as trusted since this could be a potential security breach. Untrusted languages allow only users with the PostgreSQL superuser privilege to use this language to create new functions.
       */
      postgresql_lang?: {
        /**
         * name of the procedural language to add, remove or change
         */
        lang: string;
        /**
         * marks the language as trusted, even if it's marked as untrusted in pg_pltemplate.
         * use with care!
         */
        force_trust?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: postgres
         *
         * User used to authenticate with PostgreSQL
         */
        login_user?: string;
        /**
         * Default: localhost
         *
         * Host running PostgreSQL where you want to execute the actions.
         */
        login_host?: string;
        /**
         * name of database where the language will be added, removed or changed
         */
        db: string;
        /**
         * when dropping a language, also delete object that depend on this language.
         * only used when C(state=absent).
         */
        cascade?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: present
         *
         * The state of the language for the selected database
         */
        state?: "present" | "absent";
        /**
         * Password used to authenticate with PostgreSQL (must match C(login_user))
         */
        login_password?: string;
        /**
         * make this language trusted for the selected db
         */
        trust?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: yes
         *
         * if C(yes), fail when removing a language. Otherwise just log and continue
         * in some cases, it is not possible to remove a language (used by the db-system). When         dependencies block the removal, consider using C(cascade).
         */
        fail_on_drop?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: 5432
         *
         * Database port to connect to.
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * allows the addition, modification and deletion of ACL keys and associated rules in a consul cluster via the agent. For more details on using and configuring ACLs, see https://www.consul.io/docs/internals/acl.html.
       */
      consul_acl?: {
        /**
         * the name that should be associated with the acl key, this is opaque to Consul
         */
        name?: string;
        /**
         * an list of the rules that should be associated with a given token.
         */
        rules?: string;
        /**
         * the token key indentifying an ACL rule set. If generated by consul this will be a UUID.
         */
        token?: string;
        /**
         * Default: client
         *
         * the type of token that should be created, either management or client
         */
        token_type?: string;
        /**
         * Default: present
         *
         * whether the ACL pair should be present or absent
         */
        state?: string;
        /**
         * a management token is required to manipulate the acl lists
         */
        mgmt_token?: string;
        /**
         * Default: localhost
         *
         * host of the consul agent defaults to localhost
         */
        host?: string;
        /**
         * Default: http
         *
         * the protocol scheme on which the consul agent is running
         */
        scheme?: string;
        /**
         * Default: True
         *
         * whether to verify the tls certificate of the consul agent
         */
        validate_certs?: string;
        /**
         * Default: 8500
         *
         * the port on which the consul agent is running
         */
        port?: string;
        [k: string]: unknown;
      };
      /**
       * Reads data out of lldpctl
       */
      lldp?: {
        [k: string]: unknown;
      };
      /**
       * Manages SNMP user configuration.
       */
      nxos_snmp_user?: {
        /**
         * Group to which the user will belong to.
         */
        group?: string;
        /**
         * Privacy password for the user.
         */
        privacy?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Auth parameters for the user.
         */
        auth?: string;
        /**
         * Auth password when using md5 or sha.
         */
        pwd?: string;
        /**
         * Name of the user.
         */
        user?: string;
        /**
         * Enables AES-128 bit encryption when using privacy password.
         */
        encrypt?: string;
        [k: string]: unknown;
      };
      /**
       * Manage I(git) checkouts of repositories to deploy files or software.
       */
      git?: {
        /**
         * Create a shallow clone with a history truncated to the specified number or revisions. The minimum possible value is C(1), otherwise ignored. Needs I(git>=1.9.1) to work correctly.
         */
        depth?: string;
        /**
         * Path to git executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.
         */
        executable?: string;
        /**
         * Add an additional refspec to be fetched. If version is set to a I(SHA-1) not reachable from any branch or tag, this option may be necessary to specify the ref containing the I(SHA-1). Uses the same syntax as the 'git fetch' command. An example value could be "refs/meta/config".
         */
        refspec?: string;
        /**
         * Default: no
         *
         * If C(yes), any modified files in the working repository will be discarded.  Prior to 0.7, this was always 'yes' and could not be disabled.  Prior to 1.9, the default was `yes`
         */
        force?: string;
        /**
         * Default: no
         *
         * if C(yes), submodules will track the latest commit on their master branch (or other branch specified in .gitmodules).  If C(no), submodules will be kept at the revision specified by the main project. This is equivalent to specifying the --remote flag to git submodule update.
         */
        track_submodules?: string;
        /**
         * Reference repository (see "git clone --reference ...")
         */
        reference?: string;
        /**
         * Absolute path of where the repository should be checked out to. This parameter is required, unless C(clone) is set to C(no) This change was made in version 1.8.3. Prior to this version, the C(dest) parameter was always required.
         */
        dest?: string;
        /**
         * Default: no
         *
         * if C(yes), when cloning or checking out a C(version) verify the signature of a GPG signed commit. This requires C(git) version>=2.1.0 to be installed. The commit MUST be signed and the public key MUST be trusted in the GPG trustdb.
         */
        verify_commit?: string;
        /**
         * Default: yes
         *
         * If C(no), do not clone the repository if it does not exist locally
         */
        clone?: string;
        /**
         * Default: no
         *
         * if C(yes), adds the hostkey for the repo url if not already added. If ssh_opts contains "-o StrictHostKeyChecking=no", this parameter is ignored.
         */
        accept_hostkey?: string;
        /**
         * Default: yes
         *
         * If C(no), do not retrieve new revisions from the origin repository
         */
        update?: string;
        /**
         * Default: None
         *
         * Creates a wrapper script and exports the path as GIT_SSH which git then automatically uses to override ssh arguments. An example value could be "-o StrictHostKeyChecking=no"
         */
        ssh_opts?: string;
        /**
         * git, SSH, or HTTP(S) protocol address of the git repository.
         */
        repo?: string;
        /**
         * The umask to set before doing any checkouts, or any other repository maintenance.
         */
        umask?: string;
        /**
         * Default: HEAD
         *
         * What version of the repository to check out.  This can be the the literal string C(HEAD), a branch name, a tag name. It can also be a I(SHA-1) hash, in which case C(refspec) needs to be specified if the given revision is not already available.
         */
        version?: string;
        /**
         * Default: no
         *
         * if C(yes), repository will be created as a bare repo, otherwise it will be a standard repo with a workspace.
         */
        bare?: string;
        /**
         * Default: origin
         *
         * Name of the remote.
         */
        remote?: string;
        /**
         * Default: None
         *
         * Specify an optional private key file to use for the checkout.
         */
        key_file?: string;
        /**
         * Default: yes
         *
         * if C(no), repository will be cloned without the --recursive option, skipping sub-modules.
         */
        recursive?: string;
        [k: string]: unknown;
      };
      /**
       * Get facts for a specific virtual network or all virtual networks within a resource group.
       */
      azure_rm_virtualnetwork_facts?: {
        profile?: string;
        cli_default_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Only show results for a specific security group.
         */
        name?: string;
        /**
         * Limit results by resource group. Required when filtering by name.
         */
        resource_group?: string;
        /**
         * Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        ad_user?: string;
        cloud_environment?: string;
        secret?: string;
        client_id?: string;
        subscription_id?: string;
        password?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Add a VMware Standard Switch to an ESXi host
       */
      vmware_vswitch?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Gather facts about Network ACLs in an AWS VPC
       */
      ec2_vpc_nacl_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Create or remove volumes (standard and thin) for NetApp E/EF-series storage arrays.
       */
      netapp_e_volume?: {
        /**
         * Default: 512
         *
         * The segment size of the new volume
         */
        segment_size_kb?: number | string;
        /**
         * Default: None (ignores existing SSD cache setting)
         *
         * Whether an existing SSD cache should be enabled on the volume (fails if no SSD cache defined)
         */
        ssd_cache_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The ID of the array to manage (as configured on the web services proxy).
         */
        ssid: string;
        /**
         * If data assurance should be enabled for the volume
         */
        data_assurance_enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Whether the volume should be thin provisioned.  Thin volumes can only be created on disk pools (raidDiskPool).
         */
        thin_provision?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        log_path?: string;
        /**
         * The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_password?: string;
        /**
         * Default: gb
         *
         * The unit used to interpret the size parameter
         */
        size_unit?: "bytes" | "b" | "kb" | "mb" | "gb" | "tb" | "pb" | "eb" | "zb" | "yb";
        /**
         * The name of the volume to manage
         */
        name: string;
        /**
         * Whether the specified volume should exist or not.
         */
        state: "present" | "absent";
        /**
         * Required only when requested state is 'present'.  The name of the storage pool the volume should exist on.
         */
        storage_pool_name?: string;
        /**
         * Default: same as size (in size_unit)
         *
         * Maximum size that the thin volume repository volume will automatically expand to
         */
        thin_volume_max_repo_size?: number | string;
        /**
         * The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.
         */
        api_username?: string;
        /**
         * Initial size of the thin volume repository volume (in size_unit)
         */
        thin_volume_repo_size?: number | string;
        /**
         * Required only when state = 'present'.  The size of the volume in (size_unit).
         */
        size?: number | string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The url to the SANtricity WebServices Proxy or embedded REST API.
         */
        api_url?: string;
        [k: string]: unknown;
      };
      /**
       * Adds or removes Vertica database schema and, optionally, roles with schema access privileges.
       * A schema will not be removed until all the objects have been dropped.
       * In such a situation, if the module tries to remove the schema it will fail and only remove roles created for the schema if they have no dependencies.
       */
      vertica_schema?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * allows you to create/remove/update firewall rules
       */
      win_firewall_rule?: {
        /**
         * Default: any
         *
         * the profile this rule applies to, e.g. Domain,Private,Public
         */
        profile?: string;
        /**
         * Default: any
         *
         * the remote port this rule applies to
         */
        remoteport?: string;
        /**
         * is this rule for inbound or outbound trafic
         */
        direction?: string;
        /**
         * Default: True
         *
         * is this firewall rule enabled or disabled
         */
        enable?: string;
        /**
         * Default: any
         *
         * the protocol this rule applies to
         */
        protocol?: string;
        /**
         * the rules name
         */
        name?: string;
        /**
         * Default: any
         *
         * the service this rule applies to
         */
        service?: string;
        /**
         * Default: any
         *
         * the local port this rule applies to
         */
        localport?: string;
        /**
         * Default: any
         *
         * the local ip address this rule applies to
         */
        localip?: string;
        /**
         * Default: present
         *
         * should this rule be added or removed
         */
        state?: string;
        /**
         * the program this rule applies to
         */
        program?: string;
        /**
         * Default: any
         *
         * the remote ip address/range this rule applies to
         */
        remoteip?: string;
        /**
         * what to do with the items this rule is for
         */
        action?: string;
        /**
         * Enforces the change if a rule with different values exists
         */
        force?: string;
        /**
         * description for the firewall rule
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Start a program in a VM without the need for network connection
       */
      vmware_vm_shell?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages packages with I(urpmi) (such as for Mageia or Mandriva)
       */
      urpmi?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create/delete/reconfigure a guest VM through VMware vSphere. This module has a dependency on pysphere >= 1.7
       */
      vsphere_guest?: {
        /**
         * Default: None
         *
         * The name of the resource_pool to create the VM in.
         */
        resource_pool?: string;
        /**
         * Desired hardware version identifier (for example, "vmx-08" for vms that needs to be managed with vSphere Client). Note that changing hardware version of existing vm is not supported.
         */
        vm_hw_version?: string;
        /**
         * The hostname of the vcenter server the module will connect to, to create the guest.
         */
        vcenter_hostname?: string;
        /**
         * Default: no
         *
         * Boolean. Allows you to run commands which may alter the running state of a guest. Also used to reconfigure and destroy.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The virtual server name you wish to manage.
         */
        guest: string;
        /**
         * A key, value list of disks and their sizes and which datastore to keep it in.
         */
        vm_disk?: {
          [k: string]: unknown;
        };
        /**
         * Dictionary which includes datacenter and hostname on which the VM should be created. For standalone ESXi hosts, ha-datacenter should be used as the datacenter name
         */
        esxi?: {
          [k: string]: unknown;
        };
        /**
         * A key, value list of nics, their types and what network to put them on.
         */
        vm_nic?: {
          [k: string]: unknown;
        };
        /**
         * A key, value list of VM config settings. Must include ['memory_mb', 'num_cpus', 'osid', 'scsi'].
         */
        vm_hardware?: {
          [k: string]: unknown;
        };
        /**
         * Specifies if the VM should be deployed from a template (mutually exclusive with 'state' parameter). No guest customization changes to hardware such as CPU, RAM, NICs or Disks can be applied when launching from template.
         */
        from_template?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Username to connect to vcenter as.
         */
        username?: string;
        /**
         * Default: None
         *
         * The name of the cluster to create the VM in. By default this is derived from the host you tell the module to build the guest on.
         */
        cluster?: string;
        /**
         * Default: present
         *
         * Indicate desired state of the vm. 'reconfigured' only applies changes to 'vm_cdrom', 'memory_mb', and 'num_cpus' in vm_hardware parameter. The 'memory_mb' and 'num_cpus' changes are applied to powered-on vms when hot-plugging is enabled for the guest.
         */
        state?: "present" | "powered_off" | "absent" | "powered_on" | "restarted" | "reconfigured";
        /**
         * Gather facts from vCenter on a particular VM
         */
        vmware_guest_facts?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A key, value pair of any extra values you want set or changed in the vmx file of the VM. Useful to set advanced options on the VM.
         */
        vm_extra_config?: {
          [k: string]: unknown;
        };
        /**
         * Default: True
         *
         * Specifies if the VM should be powered on after the clone.
         */
        power_on_after_clone?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Password of the user to connect to vcenter as.
         */
        password?: string;
        /**
         * Default: True
         *
         * Validate SSL certs.  Note, if running on python without SSLContext support (typically, python < 2.7.9) you will have to set this to C(no) as pysphere does not support validating certificates on older python. Prior to 2.1, this module would always validate on python >= 2.7.9 and never validate on python <= 2.7.8.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * Name of the source template to deploy from
         */
        template_src?: string;
        /**
         * Default: none
         *
         * A string that when specified, will create a linked clone copy of the VM. Snapshot must already be taken in vCenter.
         */
        snapshot_to_clone?: string;
        [k: string]: unknown;
      };
      /**
       * Add and remove local groups
       */
      win_group?: {
        /**
         * Default: present
         *
         * Create or remove the group
         */
        state?: string;
        /**
         * Name of the group
         */
        name?: string;
        /**
         * Description of the group
         */
        description?: string;
        [k: string]: unknown;
      };
      /**
       * Runs getent against one of it's various databases and returns information into the host's facts, in a getent_<database> prefixed variable
       */
      getent?: {
        /**
         * Default: True
         *
         * If a supplied key is missing this will make the task fail if True
         */
        fail_key?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: None
         *
         * character used to split the database values into lists/arrays such as ':' or '	', otherwise  it will try to pick one depending on the database
         */
        split?: string;
        /**
         * key from which to return values from the specified database, otherwise the full contents are returned.
         */
        key?: string;
        /**
         * the name of a getent database supported by the target system (passwd, group, hosts, etc).
         */
        database: string;
        [k: string]: unknown;
      };
      /**
       * This module will actively managed vCloud Air vApp instances.  Instances can be created and deleted as well as both deployed and undeployed.
       */
      vca_vapp?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module allows the management of AWS Lambda function event source mappings such as DynamoDB and Kinesis stream events via the Ansible framework. These event source mappings are relevant only in the AWS Lambda pull model, where AWS Lambda invokes the function. It is idempotent and supports "Check" mode.  Use module M(lambda) to manage the lambda function itself and M(lambda_alias) to manage function aliases.
       */
      lambda_event?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Use this module for power management
       */
      ipmi_power?: {
        /**
         * Hostname or ip address of the BMC.
         */
        name: string;
        /**
         * Whether to ensure that the machine in desired state.
         */
        state: "on" | "off" | "shutdown" | "reset" | "boot";
        /**
         * Username to use to connect to the BMC.
         */
        user: string;
        /**
         * Default: 300
         *
         * Maximum number of seconds before interrupt request.
         */
        timeout?: number | string;
        /**
         * Password to connect to the BMC.
         */
        password: string;
        /**
         * Default: 623
         *
         * Remote RMCP port.
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Module to manage Virtual Machine and floating disks in oVirt.
       */
      ovirt_disks?: {
        [k: string]: unknown;
      };
      /**
       * Manages F5 BIG-IP GTM virtual servers
       */
      bigip_gtm_virtual_server?: {
        /**
         * Default: None
         *
         * Virtual server host
         */
        host?: string;
        /**
         * Virtual server name
         */
        virtual_server_name?: string;
        /**
         * Virtual server server
         */
        virtual_server_server?: string;
        /**
         * Default: None
         *
         * Virtual server port
         */
        port?: string;
        /**
         * Default: present
         *
         * Virtual server state
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * Manages configuration of an OSPF interface instance.
       */
      nxos_interface_ospf?: {
        /**
         * The cost associated with this cisco_interface_ospf instance.
         */
        cost?: string;
        /**
         * Setting to true will prevent this interface from receiving HELLO packets. Valid values are 'true' and 'false'.
         */
        passive_interface?: string;
        /**
         * Ospf area associated with this cisco_interface_ospf instance. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer.
         */
        area?: string;
        /**
         * Algorithm used for authentication among neighboring routers within an area. Valid values is 'md5'.
         */
        message_digest_algorithm_type?: string;
        /**
         * Md5 authentication key-id associated with the ospf instance. If this is present, message_digest_encryption_type, message_digest_algorithm_type and message_digest_password are mandatory. Valid value is an integer and 'default'.
         */
        message_digest_key_id?: string;
        /**
         * Specifies the scheme used for encrypting message_digest_password. Valid values are '3des' or 'cisco_type_7' encryption.
         */
        message_digest_encryption_type?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: string;
        /**
         * Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer or the keyword 'default'.
         */
        dead_interval?: string;
        /**
         * Time between sending successive hello packets. Valid values are an integer or the keyword 'default'.
         */
        hello_interval?: string;
        /**
         * Specifies the message_digest password. Valid value is a string.
         */
        message_digest_password?: string;
        /**
         * Name of this cisco_interface resource. Valid value is a string.
         */
        interface?: string;
        /**
         * Name of the ospf instance.
         */
        ospf?: string;
        /**
         * Enables or disables the usage of message digest authentication. Valid values are 'true' and 'false'.
         */
        message_digest?: string;
        [k: string]: unknown;
      };
      /**
       * Manages Mercurial (hg) repositories. Supports SSH, HTTP/S and local address.
       */
      hg?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) & {
        [k: string]: unknown;
      };
      /**
       * Interacts with HTTP and HTTPS web services and supports Digest, Basic and WSSE HTTP authentication mechanisms.
       */
      win_uri?: {
        /**
         * The body of the HTTP request/response to the web service.
         */
        body?: string;
        /**
         * HTTP or HTTPS URL in the form of (http|https)://host.domain:port/path
         */
        url?: string;
        /**
         * Default: True
         *
         * This module relies upon 'Invoke-WebRequest', which by default uses the Internet Explorer Engine to parse a webpage. There's an edge-case where if a user hasn't run IE before, this will fail. The only advantage to using the Internet Explorer praser is that you can traverse the DOM in a powershell script. That isn't useful for Ansible, so by default we toggle 'UseBasicParsing'. However, you can toggle that off here.
         */
        use_basic_parsing?: string;
        /**
         * Key Value pairs for headers. Example "Host: www.somesite.com"
         */
        headers?: string;
        /**
         * Sets the "Content-Type" header.
         */
        content_type?: string;
        /**
         * Default: GET
         *
         * The HTTP Method of the request or response.
         */
        method?: string;
        [k: string]: unknown;
      };
      /**
       * Manage VLANs on a BIG-IP system
       */
      bigip_vlan?: {
        /**
         * The description to give to the VLAN.
         */
        description?: string;
        /**
         * Specifies a list of untagged interfaces and trunks that you want to configure for the VLAN.
         */
        untagged_interfaces?: string;
        /**
         * Default: present
         *
         * The state of the VLAN on the system. When C(present), guarantees that the VLAN exists with the provided attributes. When C(absent), removes the VLAN from the system.
         */
        state?: string;
        /**
         * Tag number for the VLAN. The tag number can be any integer between 1 and 4094. The system automatically assigns a tag number if you do not specify a value.
         */
        tag?: string;
        /**
         * Specifies a list of tagged interfaces and trunks that you want to configure for the VLAN. Use tagged interfaces or trunks when you want to assign a single interface or trunk to multiple VLANs.
         */
        tagged_interfaces?: string;
        /**
         * The VLAN to manage. If the special VLAN C(ALL) is specified with the C(state) value of C(absent) then all VLANs will be removed.
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Create, update and delete records.
       */
      exo_dns_record?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows you to create, modify and delete Zabbix screens and associated graph data.
       */
      zabbix_screen?: {
        /**
         * Default: None
         *
         * Basic Auth password
         */
        http_login_password?: string;
        /**
         * Zabbix user name.
         */
        login_user?: string;
        /**
         * Default: None
         *
         * Basic Auth login
         */
        http_login_user?: string;
        /**
         * Url of Zabbix server, with protocol (http or https).
         */
        server_url?: string;
        /**
         * List of screens to be created/updated/deleted(see example).
         * If the screen(s) already been added, the screen(s) name won't be updated.
         * When creating or updating screen(s), C(screen_name), C(host_group) are required.
         * When deleting screen(s), the C(screen_name) is required.
         * The available states are: C(present) (default) and C(absent). If the screen(s) already exists, and the state is not C(absent), the screen(s) will just be updated as needed.
         */
        screens?: string;
        /**
         * Default: 10
         *
         * The timeout of API request (seconds).
         */
        timeout?: string;
        /**
         * Zabbix user password.
         */
        login_password?: string;
        [k: string]: unknown;
      };
      /**
       * Manage packages with the I(pacman) package manager, which is used by Arch Linux and its variants.
       */
      pacman?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Enables or disables RabbitMQ plugins
       */
      rabbitmq_plugin?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * This module allows for addition or deletion of services and ports either tcp or udp in either running or permanent firewalld rules.
       */
      firewalld?: {
        /**
         * Default: system-default(public)
         *
         * The firewalld zone to add/remove to/from (NOTE: default zone can be configured per system but "public" is default from upstream. Available choices can be extended based on per-system configs, listed here are "out of the box" defaults).
         */
        zone?: string;
        /**
         * Name of a service to add/remove to/from firewalld - service must be listed in /etc/services.
         */
        service?: string;
        /**
         * The masquerade setting you would like to enable/disable to/from zones within firewalld
         */
        masquerade?: string;
        /**
         * Should this configuration be applied immediately, if set as permanent
         */
        immediate?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The source/network you would like to add/remove to/from firewalld
         */
        source?: string;
        /**
         * Should this port accept(enabled) or reject(disabled) connections.
         */
        state: "enabled" | "disabled";
        /**
         * Should this configuration be in the running firewalld configuration or persist across reboots.
         */
        permanent?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The amount of time the rule should be in effect for when non-permanent.
         */
        timeout?: number | string;
        /**
         * The interface you would like to add/remove to/from a zone in firewalld
         */
        interface?: string;
        /**
         * Name of a port or port range to add/remove to/from firewalld. Must be in the form PORT/PROTOCOL or PORT-PORT/PROTOCOL for port ranges.
         */
        port?: string;
        /**
         * Rich rule to add/remove to/from firewalld.
         */
        rich_rule?: string;
        [k: string]: unknown;
      };
      /**
       * The M(grove) module sends a message for a service to a Grove.io channel.
       */
      grove?: {
        /**
         * Default: ansible
         *
         * Name of the service (displayed as the "user" in the message)
         */
        service?: string;
        /**
         * Service URL for the web client
         */
        url?: string;
        /**
         * Icon for the service
         */
        icon_url?: string;
        /**
         * Token of the channel to post to.
         */
        channel_token: string;
        /**
         * Message content
         */
        message: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * This module creates, removes or resizes volume groups.
       */
      lvg?: {
        /**
         * Additional options to pass to C(vgcreate) when creating the volume group.
         */
        vg_options?: string;
        /**
         * List of comma-separated devices to use as physical devices in this volume group. Required when creating or resizing volume group.
         * The module will take care of running pvcreate if needed.
         */
        pvs?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: no
         *
         * If yes, allows to remove volume group with logical volumes.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The name of the volume group.
         */
        vg: string;
        /**
         * Default: present
         *
         * Control if the volume group exists.
         */
        state?: "present" | "absent";
        /**
         * Default: 4
         *
         * The size of the physical extent in megabytes. Must be a power of 2.
         */
        pesize?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create or remove a Distributed vSwitch portgroup
       */
      vmware_dvs_portgroup?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Create, destroy, attach, detach volumes.
       */
      cs_volume?: {
        /**
         * Name of the domain the volume to be deployed in.
         */
        domain?: string;
        /**
         * Force removal of volume even it is attached to a VM.
         * Considered on C(state=absnet) only.
         */
        force?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the disk offering to be used.
         * Required one of C(disk_offering), C(snapshot) if volume is not already C(state=present).
         */
        disk_offering?: string;
        api_http_method?: "get" | "post";
        /**
         * Whether to allow to shrink the volume.
         */
        shrink_ok?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: True
         *
         * Whether to display the volume to the end user or not.
         * Allowed to Root Admins only.
         */
        display_volume?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Size of disk in GB
         */
        size?: number | string;
        /**
         * Default: True
         *
         * Poll async jobs until job has finished.
         */
        poll_async?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_url?: string;
        /**
         * Name of the zone in which the volume should be deployed.
         * If not set, default zone is used.
         */
        zone?: string;
        /**
         * Max iops
         */
        max_iops?: number | string;
        /**
         * Default: present
         *
         * State of the volume.
         */
        state?: "present" | "absent" | "attached" | "detached";
        api_key?: string;
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Account the volume is related to.
         */
        account?: string;
        /**
         * Name of the virtual machine to attach the volume to.
         */
        vm?: string;
        /**
         * Min iops
         */
        min_iops?: number | string;
        device_id?: number | string;
        /**
         * Custom id to the resource.
         * Allowed to Root Admins only.
         */
        custom_id?: string;
        /**
         * Name of the volume.
         * C(name) can only contain ASCII letters.
         */
        name: string;
        api_region?: string;
        /**
         * Name of the project the volume to be deployed in.
         */
        project?: string;
        /**
         * The snapshot name for the disk volume.
         * Required one of C(disk_offering), C(snapshot) if volume is not already C(state=present).
         */
        snapshot?: string;
        [k: string]: unknown;
      };
      /**
       * Adds or removes a user from a MongoDB database.
       */
      mongodb_user?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        };
      /**
       * Return canonical (NAA) from an ESXi host based on SCSI target ID
       */
      vmware_target_canonical_facts?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages BGP Address-family configurations on NX-OS switches.
       */
      nxos_bgp_af?: {
        /**
         * Specify max suppress time for route-flap dampening stable route. Valid values are integer and keyword 'default'.
         */
        dampening_max_suppress_time?: string;
        /**
         * Enables the send capability of additional paths for all of the neighbors under this address family for which the capability has not been disabled.
         */
        additional_paths_send?: string;
        /**
         * Install a backup path into the forwarding table and provide prefix independent convergence (PIC) in case of a PE-CE link failure.
         */
        additional_paths_install?: string;
        /**
         * Enable/disable route-flap dampening.
         */
        dampening_state?: string;
        /**
         * Enables the receive capability of additional paths for all of the neighbors under this address family for which the capability has not been disabled.
         */
        additional_paths_receive?: string;
        /**
         * Advertises only active routes to peers.
         */
        suppress_inactive?: string;
        /**
         * Specify route-map for route-flap dampening. Valid values are a string defining the name of the route-map.
         */
        dampening_routemap?: string;
        /**
         * Networks to configure. Valid value is a list of network prefixes to advertise. The list must be in the form of an array. Each entry in the array must include a prefix address and an optional route-map. For example [['10.0.0.0/16', 'routemap_LA'], ['192.168.1.1', 'Chicago'], ['192.168.2.0/24], ['192.168.3.0/24', 'routemap_NYC']].
         */
        networks?: string;
        /**
         * Sets the administrative distance for local BGP routes. Valid values are Integer or keyword 'default'.
         */
        distance_local?: string;
        /**
         * Advertise evpn routes.
         */
        advertise_l2vpn_evpn?: string;
        /**
         * Address Family Identifier.
         */
        afi?: string;
        /**
         * Default information originate.
         */
        default_information_originate?: string;
        /**
         * Sets the administrative distance for iBGP routes. Valid values are Integer or keyword 'default'.
         */
        distance_ibgp?: string;
        /**
         * Default: present
         *
         * Determines whether the config should be present or not on the device.
         */
        state?: string;
        /**
         * Configure a route-map for valid nexthops. Valid values are a string defining the name of the route-map.
         */
        next_hop_route_map?: string;
        /**
         * Filters routes rejected by the route-map and does not download them to the RIB.
         */
        table_map_filter?: string;
        /**
         * Sub Address Family Identifier.
         */
        safi?: string;
        /**
         * Sets default metrics for routes redistributed into BGP. Valid values are Integer or keyword 'default'
         */
        default_metric?: string;
        /**
         * Configure client-to-client route reflection.
         */
        client_to_client?: string;
        /**
         * Specify dampen value for IGP metric-related changes, in seconds. Valid values are integer and keyword 'default'.
         */
        dampen_igp_metric?: string;
        /**
         * Configures the capability of selecting additional paths for a prefix. Valid values are a string defining the name of the route-map.
         */
        additional_paths_selection?: string;
        /**
         * Configures the maximum number of ibgp equal-cost paths for load sharing. Valid value is an integer in the range 1-64.
         */
        maximum_paths_ibgp?: string;
        /**
         * Name of the VRF. The name 'default' is a valid VRF representing the global bgp.
         */
        vrf?: string;
        /**
         * Sets the administrative distance for eBGP routes. Valid values are Integer or keyword 'default'.
         */
        distance_ebgp?: string;
        /**
         * BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.
         */
        asn?: string;
        /**
         * A list of redistribute directives. Multiple redistribute entries are allowed. The list must be in the form of a nested array. the first entry of each array defines the source-protocol to redistribute from; the second entry defines a route-map name. A route-map is highly advised but may be optional on some platforms, in which case it may be omitted from the array list. For example [['direct', 'rm_direct'], ['lisp', 'rm_lisp']].
         */
        redistribute?: string;
        /**
         * Specify route reuse time for route-flap dampening. Valid values are integer and keyword 'default'.
         */
        dampening_reuse_time?: string;
        /**
         * Configures the maximum number of equal-cost paths for load sharing. Valid value is an integer in the range 1-64.
         */
        maximum_paths?: string;
        /**
         * An array of route-map names which will specify prefixes to inject. Each array entry must first specify the inject-map name, secondly an exist-map name, and optionally the copy-attributes keyword which indicates that attributes should be copied from the aggregate. For example [['lax_inject_map', 'lax_exist_map'], ['nyc_inject_map', 'nyc_exist_map', 'copy-attributes'], ['fsd_inject_map', 'fsd_exist_map']].
         */
        inject_map?: string;
        /**
         * Specify route suppress time for route-flap dampening. Valid values are integer and keyword 'default'.
         */
        dampening_suppress_time?: string;
        /**
         * Apply table-map to filter routes downloaded into URIB. Valid values are a string.
         */
        table_map?: string;
        /**
         * Specify decay half-life in minutes for route-flap dampening. Valid values are integer and keyword 'default'.
         */
        dampening_half_time?: string;
        [k: string]: unknown;
      };
      /**
       * Runs the I(facter) discovery program (U(https://github.com/puppetlabs/facter)) on the remote system, returning JSON data that can be useful for inventory purposes.
       */
      facter?: {
        [k: string]: unknown;
      };
      /**
       * Manage Open vSwitch ports
       */
      openvswitch_port?: {
        /**
         * Name of bridge to manage
         */
        bridge: string;
        /**
         * Default: None
         *
         * Set a single property on a port.
         */
        set?: string;
        /**
         * Default: present
         *
         * Whether the port should exist
         */
        state?: "present" | "absent";
        /**
         * VLAN tag for this port
         */
        tag?: string;
        /**
         * Default: 5
         *
         * How long to wait for ovs-vswitchd to respond
         */
        timeout?: number | string;
        /**
         * Dictionary of external_ids applied to a port.
         */
        external_ids?: {
          [k: string]: unknown;
        };
        /**
         * Name of port to manage on the bridge
         */
        port: string;
        [k: string]: unknown;
      };
      /**
       * Create, update, suspend, activate and remove projects.
       */
      cs_project?: {
        [k: string]: unknown;
      };
      /**
       * Query / Set MySQL variables
       */
      mysql_variables?: {
        ssl_key?: string;
        ssl_cert?: string;
        config_file?: string;
        login_port?: number | string;
        login_user?: string;
        login_host?: string;
        /**
         * If set, then sets variable value to this
         */
        value?: string;
        ssl_ca?: string;
        login_unix_socket?: string;
        login_password?: string;
        /**
         * Variable name to operate
         */
        variable?: string;
        connect_timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Create snapshots of the running states of selected features, add new show commands for snapshot creation, delete and compare existing snapshots.
       */
      nxos_snapshot?: {
        /**
         * Snapshot description to be used when C(action=create).
         */
        description?: string;
        /**
         * Used to name the show command output, to be used when C(action=add).
         */
        section?: string;
        /**
         * First snapshot to be used when C(action=compare).
         */
        snapshot1?: string;
        /**
         * Name of the file where snapshots comparison will be store.
         */
        comparison_results_file?: string;
        /**
         * Second snapshot to be used when C(action=compare).
         */
        snapshot2?: string;
        /**
         * Specify the tags used to distinguish among row entries, to be used when C(action=add).
         */
        element_key1?: string;
        /**
         * Specify the tags used to distinguish among row entries, to be used when C(action=add).
         */
        element_key2?: string;
        /**
         * Snapshot name, to be used when C(action=create) or C(action=delete).
         */
        snapshot_name?: string;
        /**
         * Specify a new show command, to be used when C(action=add).
         */
        show_command?: string;
        /**
         * Define what snapshot action the module would perform.
         */
        action?: string;
        /**
         * Default: ./
         *
         * Specify the path of the file where new created snapshot or snapshots comparison will be stored, to be used when C(action=create) and C(save_snapshot_locally=true) or C(action=compare).
         */
        path?: string;
        /**
         * Specifies the tag of each row entry of the show command's XML output, to be used when C(action=add).
         */
        row_id?: string;
        /**
         * Specify to locally store a new created snapshot, to be used when C(action=create).
         */
        save_snapshot_locally?: string;
        /**
         * Snapshot options to be used when C(action=compare).
         */
        compare_option?: string;
        [k: string]: unknown;
      };
      /**
       * The M(nagios) module has two basic functions: scheduling downtime and toggling alerts for services or hosts.
       * All actions require the I(host) parameter to be given explicitly. In playbooks you can use the C({{inventory_hostname}}) variable to refer to the host the playbook is currently running on.
       * You can specify multiple services at once by separating them with commas, .e.g., C(services=httpd,nfs,puppet).
       * When specifying what service to handle there is a special service value, I(host), which will handle alerts/downtime for the I(host itself), e.g., C(service=host). This keyword may not be given with other services at the same time. I(Setting alerts/downtime for a host does not affect alerts/downtime for any of the services running on it.) To schedule downtime for all services on particular host use keyword "all", e.g., C(service=all).
       * When using the M(nagios) module you will need to specify your Nagios server using the C(delegate_to) parameter.
       */
      nagios?: {
        [k: string]: unknown;
      };
      /**
       * Create, update, delete pods.
       */
      cs_pod?: {
        api_key?: string;
        api_url?: string;
        api_http_method?: "get" | "post";
        api_secret?: string;
        api_timeout?: number | string;
        api_region?: string;
        /**
         * Gateway for the Pod.
         * Required on C(state=present)
         */
        gateway?: string;
        /**
         * Default: present
         *
         * State of the pod.
         */
        state?: "present" | "enabled" | "disabled" | "absent";
        /**
         * Ending IP address for the Pod.
         */
        end_ip?: string;
        /**
         * Starting IP address for the Pod.
         * Required on C(state=present)
         */
        start_ip?: string;
        /**
         * Name of the zone in which the pod belongs to.
         * If not set, default zone is used.
         */
        zone?: string;
        /**
         * Netmask for the Pod.
         * Required on C(state=present)
         */
        netmask?: string;
        /**
         * uuid of the exising pod.
         */
        id?: string;
        /**
         * Name of the pod.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create an annotation event with a given category, title and description. Optionally start, end or durations can be provided
       */
      circonus_annotation?: {
        /**
         * Annotation Category
         */
        category: string;
        /**
         * Description of annotation
         */
        description: string;
        /**
         * Title of annotation
         */
        title: string;
        /**
         * Unix timestamp of event end, defaults to now + duration
         */
        stop?: number | string;
        /**
         * Unix timestamp of event start, defaults to now
         */
        start?: number | string;
        /**
         * Duration in seconds of annotation, defaults to 0
         */
        duration?: number | string;
        /**
         * Circonus API key
         */
        api_key: string;
        [k: string]: unknown;
      };
      /**
       * An Ansible module to add or delete public ip addresses on an existing server or servers in CenturyLink Cloud.
       */
      clc_publicip?: {
        /**
         * A list of servers to create public ips on.
         */
        server_ids:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * Determine whether to create or delete public IPs. If present module will not create a second public ip if one already exists.
         */
        state?: "present" | "absent";
        /**
         * Default: TCP
         *
         * The protocol that the public IP will listen for.
         */
        protocol?: "TCP" | "UDP" | "ICMP";
        /**
         * Default: None
         *
         * A list of ports to expose. This is required when state is 'present'
         */
        ports?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: True
         *
         * Whether to wait for the tasks to finish before returning.
         */
        wait?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage OpenStack Identity users. Users can be created, updated or deleted using this module. A user will be updated if I(name) matches an existing user and I(state) is present. The value for I(name) cannot be updated without deleting and re-creating the user.
       */
      os_user?: {
        /**
         * Default: None
         *
         * Project name or ID that the user should be associated with by default
         */
        default_project?: string;
        /**
         * Username for the user
         */
        name?: string;
        /**
         * Default: True
         *
         * Is the user enabled
         */
        enabled?: string;
        /**
         * Default: None
         *
         * Domain to create the user in if the cloud supports domains
         */
        domain?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: None
         *
         * Password for the user
         */
        password?: string;
        /**
         * Default: None
         *
         * Email address for the user
         */
        email?: string;
        [k: string]: unknown;
      };
      /**
       * Use this module to schedule a command or script file to run once in the future.
       * All jobs are executed in the 'a' queue.
       */
      at?: {
        /**
         * The count of units in the future to execute the command or script file.
         */
        count?: number | string;
        /**
         * Default: present
         *
         * The state dictates if the command or script file should be evaluated as present(added) or absent(deleted).
         */
        state?: "present" | "absent";
        /**
         * A command to be executed in the future.
         */
        command?: string;
        /**
         * The type of units in the future to execute the command or script file.
         */
        units?: "minutes" | "hours" | "days" | "weeks";
        /**
         * If a matching job is present a new job will not be added.
         */
        unique?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * An existing script file to be executed in the future.
         */
        script_file?: string;
        [k: string]: unknown;
      };
      /**
       * Sets attributes of files, symlinks, and directories, or removes files/symlinks/directories. Many other modules support the same options as the M(file) module - including M(copy), M(template), and M(assemble).
       */
      file?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * An Ansible module to Create or Delete Anti Affinity Policies at CenturyLink Cloud.
       */
      clc_aa_policy?: {
        /**
         * Default: present
         *
         * Whether to create or delete the policy.
         */
        state?: "present" | "absent";
        /**
         * Datacenter in which the policy lives/should live.
         */
        location: string;
        /**
         * The name of the Anti Affinity Policy.
         */
        name: string;
        /**
         * Default: True
         *
         * Whether to wait for the tasks to finish before returning.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * Manage Python library dependencies. To use this module, one of the following keys is required: C(name) or C(requirements).
       */
      pip?: {
        /**
         * An optional path to a I(virtualenv) directory to install into. It cannot be specified together with the 'executable' parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtualenv_site_packages, virtualenv_command, and virtualenv_python options affect the creation of the virtualenv.
         */
        virtualenv?: string;
        /**
         * Default: no
         *
         * Whether the virtual environment will inherit packages from the global site-packages directory.  Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created.
         */
        virtualenv_site_packages?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The explicit executable or a pathname to the executable to be used to run pip for a specific version of Python installed in the system. For example C(pip-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation. It cannot be specified together with the 'virtualenv' parameter (added in 2.1). By default, it will take the appropriate version for the python interpreter use by ansible, e.g. pip3 on python 3, and pip2 or pip on python 2.
         */
        executable?: string;
        /**
         * cd into this directory before running the command
         */
        chdir?: string;
        /**
         * The path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option.
         */
        requirements?: string;
        /**
         * The name of a Python library to install or the url of the remote package.
         * As of 2.2 you can supply a list of names.
         */
        name?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * The Python executable used for creating the virtual environment. For example C(python3.5), C(python2.7). When not specified, the Python version used to run the ansible module is used.
         */
        virtualenv_python?: string;
        /**
         * The system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., 0077) and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode in octal, with a leading 0 (e.g., 0077).
         */
        umask?: string;
        /**
         * Default: True
         *
         * Pass the editable flag for versioning URLs.
         */
        editable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: virtualenv
         *
         * The command or a pathname to the command to create the virtual environment with. For example C(pyvenv), C(virtualenv), C(virtualenv2), C(~/bin/virtualenv), C(/usr/local/bin/virtualenv).
         */
        virtualenv_command?: string;
        use_mirrors?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Extra arguments passed to pip.
         */
        extra_args?: string;
        /**
         * Default: present
         *
         * The state of module
         * The 'forcereinstall' option is only available in Ansible 2.1 and above.
         */
        state?: "present" | "absent" | "latest" | "forcereinstall";
        /**
         * The version number to install of the Python library specified in the I(name) parameter
         */
        version?: string;
        [k: string]: unknown;
      };
      /**
       * This module configures the timezone setting, both of the system clock and of the hardware clock. I(Currently only Linux platform is supported.) It is recommended to restart C(crond) after changing the timezone, otherwise the jobs may run at the wrong time. It uses the C(timedatectl) command if available. Otherwise, it edits C(/etc/sysconfig/clock) or C(/etc/timezone) for the system clock, and uses the C(hwclock) command for the hardware clock. If you want to set up the NTP, use M(service) module.
       */
      timezone?: {
        [k: string]: unknown;
      };
      /**
       * Cisco IOS configurations use a simple block indent file syntax for segmenting configuration into sections.  This module provides an implementation for working with IOS configuration sections in a deterministic way.
       */
      ios_config?: {
        /**
         * Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).
         */
        src?: string;
        /**
         * The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.
         * Note this argument should be considered deprecated.  To achieve the equivalent, set the C(match=none) which is idempotent.  This argument will be removed in a future release.
         */
        force?: string;
        /**
         * The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.
         */
        config?: string;
        /**
         * The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.
         */
        after?: string;
        /**
         * The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.
         */
        lines?: string;
        /**
         * Default: line
         *
         * Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to I(line) then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to I(block) then the entire command block is pushed to the device in configuration mode if any line is not correct.
         */
        replace?: string;
        /**
         * The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.
         */
        parents?: string;
        /**
         * This argument specifies whether or not to collect all defaults when getting the remote device running config.  When enabled, the module will get the current config by issuing the command C(show running-config all).
         */
        defaults?: string;
        /**
         * The C(save) argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.
         */
        save?: string;
        /**
         * This argument will cause the module to create a full backup of the current C(running-config) from the remote device before any changes are made.  The backup file is written to the C(backup) folder in the playbook root directory.  If the directory does not exist, it is created.
         */
        backup?: string;
        /**
         * Default: line
         *
         * Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to I(line), commands are matched line by line.  If match is set to I(strict), command lines are matched with respect to position.  If match is set to I(exact), command lines must be an equal match.  Finally, if match is set to I(none), the module will not attempt to compare the source configuration with the running configuration on the remote device.
         */
        match?: string;
        /**
         * The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.
         */
        before?: string;
        [k: string]: unknown;
      };
      /**
       * This module uses rabbitMQ Rest API to create/delete exchanges
       */
      rabbitmq_exchange?: {
        [k: string]: unknown;
      };
      /**
       * The M(wakeonlan) module sends magic Wake-on-LAN (WoL) broadcast packets.
       */
      wakeonlan?: {
        /**
         * Default: 255.255.255.255
         *
         * Network broadcast address to use for broadcasting magic Wake-on-LAN packet
         */
        broadcast?: string;
        /**
         * MAC address to send Wake-on-LAN broadcast packet for
         */
        mac: string;
        /**
         * Default: 7
         *
         * UDP port to use for magic Wake-on-LAN packet
         */
        port?: number | string;
        [k: string]: unknown;
      };
      /**
       * Register and remove ISO images.
       */
      cs_iso?: {
        /**
         * Register the ISO to be featured. Only used if C(state) is present.
         */
        is_featured?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_key?: string;
        /**
         * Name of the ISO.
         */
        name: string;
        api_http_method?: "get" | "post";
        /**
         * Default: present
         *
         * State of the ISO.
         */
        state?: "present" | "absent";
        /**
         * Default: True
         *
         * Register the ISO to be bootable. Only used if C(state) is present.
         */
        bootable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        api_secret?: string;
        api_timeout?: number | string;
        /**
         * Domain the ISO is related to.
         */
        domain?: string;
        /**
         * Register the ISO having XS/VMWare tools installed inorder to support dynamic scaling of VM cpu/memory. Only used if C(state) is present.
         */
        is_dynamically_scalable?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Name of the project the ISO to be registered in.
         */
        project?: string;
        /**
         * URL where the ISO can be downloaded from. Required if C(state) is present.
         */
        url?: string;
        /**
         * Default: self
         *
         * Name of the filter used to search for the ISO.
         */
        iso_filter?: "featured" | "self" | "selfexecutable" | "sharedexecutable" | "executable" | "community";
        api_region?: string;
        /**
         * This flag is used for searching existing ISOs. If set to C(true), it will only list ISO ready for deployment e.g. successfully downloaded and installed. Recommended to set it to C(false).
         */
        is_ready?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The MD5 checksum value of this ISO. If set, we search by checksum instead of name.
         */
        checksum?: string;
        /**
         * Account the ISO is related to.
         */
        account?: string;
        /**
         * Name of the OS that best represents the OS of this ISO. If the iso is bootable this parameter needs to be passed. Required if C(state) is present.
         */
        os_type?: string;
        /**
         * Name of the zone you wish the ISO to be registered or deleted from. If not specified, first zone found will be used.
         */
        zone?: string;
        api_url?: string;
        [k: string]: unknown;
      };
      /**
       * Set the initial port attribute defined in the Cumulus Linux ports.conf, file. This module does not do any error checking at the moment. Be careful to not include ports that do not exist on the switch. Carefully read the original ports.conf file for any exceptions or limitations. For more details go the Configure Switch Port Attribute Documentation at U(http://docs.cumulusnetworks.com).
       */
      cl_ports?: {
        /**
         * List of 40G ports that will be unganged to run as 4 10G ports.
         */
        speed_4_by_10g?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List of ports to run initial run at 10G.
         */
        speed_10g?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List of ports to run initial run at 40G.
         */
        speed_40g?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * List of 10G ports that will be ganged to form a 40G port.
         */
        speed_40g_div_4?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      /**
       * Adds service hooks and removes service hooks that have an error status.
       */
      github_hooks?: {
        /**
         * The oauth key provided by github. It can be found/generated on github under "Edit Your Profile" >> "Applications" >> "Personal Access Tokens"
         */
        oauthkey: string;
        /**
         * When creating a new hook, this is the url that you want github to post to. It is only required when creating a new hook.
         */
        hookurl?: string;
        /**
         * This is the API url for the repository you want to manage hooks for. It should be in the form of: https://api.github.com/repos/user:/repo:. Note this is different than the normal repo url.
         */
        repo: string;
        /**
         * Github username.
         */
        user: string;
        /**
         * Default: json
         *
         * Content type to use for requests made to the webhook
         */
        content_type?: "json" | "form";
        /**
         * This tells the githooks module what you want it to do.
         */
        action: "create" | "cleanall" | "list" | "clean504";
        /**
         * Default: yes
         *
         * If C(no), SSL certificates for the target repo will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Read the AWS documentation for Network ACLS U(http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html)
       */
      ec2_vpc_nacl?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module allows the management of AWS Lambda functions aliases via the Ansible framework.  It is idempotent and supports "Check" mode.    Use module M(lambda) to manage the lambda function itself and M(lambda_event) to manage event source mappings.
       */
      lambda_alias?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Collects facts from devices running the OpenSwitch operating system.  Fact collection is supported over both Cli and Rest transports.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       * The facts collected from pre Ansible 2.2 are still available and are collected for backwards compatibility; however, these facts should be considered deprecated and will be removed in a future release.
       */
      ops_facts?: {
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, legacy, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?: string;
        /**
         * Accepts a list of endpoints to retrieve from the remote device using the REST API.  The endpoints should be valid endpoints available on the device.  This argument is only valid when the C(transport=rest).
         */
        endpoints?: string;
        /**
         * When enabled, this argument will collect the current running configuration from the remote device.  If the C(transport=rest) then the collected configuration will be the full system configuration.
         */
        config?: string;
        [k: string]: unknown;
      };
      /**
       * This module executes AWS Lambda functions, allowing synchronous and asynchronous invocation.
       */
      execute_lambda?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * This module will search a file for a line, and ensure that it is present or absent.
       * This is primarily useful when you want to change a single line in a file only.
       */
      win_lineinfile?: {
        /**
         * Used with C(state=present). If specified, the line will be inserted before the last match of specified regular expression. A value is available; C(BOF) for inserting the line at the beginning of the file.
         * If specified regular expression has no matches, the line will be inserted at the end of the file.  May not be used with C(backrefs).
         */
        insertbefore?: string;
        /**
         * Default: auto
         *
         * Specifies the encoding of the source text file to operate on (and thus what the output encoding will be). The default of C(auto) will cause the module to auto-detect the encoding of the source file and ensure that the modified file is written with the same encoding.
         * An explicit encoding can be passed as a string that is a valid value to pass to the .NET framework System.Text.Encoding.GetEncoding() method - see U(https://msdn.microsoft.com/en-us/library/system.text.encoding%28v=vs.110%29.aspx).
         * This is mostly useful with C(create=yes) if you want to create a new file with a specific encoding. If C(create=yes) is specified without a specific encoding, the default encoding (UTF-8, no BOM) will be used.
         */
        encoding?: string;
        /**
         * The path of the file to modify.
         * Note that the Windows path delimiter '' must be escaped as '\' (see examples below)
         */
        dest?: string;
        /**
         * Default: no
         *
         * Used with C(state=present). If specified, the file will be created if it does not already exist. By default it will fail if the file is missing.
         */
        create?: string;
        /**
         * Default: windows
         *
         * Specifies the line separator style to use for the modified file. This defaults to the windows line separator ( ). Note that the indicated line separator will be used for file output regardless of the original line separator that appears in the input file.
         */
        newline?: string;
        /**
         * Default: no
         *
         * Used with C(state=present). If set, line can contain backreferences (both positional and named) that will get populated if the C(regexp) matches. This flag changes the operation of the module slightly; C(insertbefore) and C(insertafter) will be ignored, and if the C(regexp) doesn't match anywhere in the file, the file will be left unchanged.
         * If the C(regexp) does match, the last matching line will be replaced by the expanded line parameter.
         */
        backrefs?: string;
        /**
         * Default: present
         *
         * Whether the line should be there or not.
         */
        state?: string;
        /**
         * Default: EOF
         *
         * Used with C(state=present). If specified, the line will be inserted after the last match of specified regular expression. A special value is available; C(EOF) for inserting the line at the end of the file.
         * If specified regular expression has no matches, EOF will be used instead.  May not be used with C(backrefs).
         */
        insertafter?: string;
        /**
         * The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line to remove.  Uses .NET compatible regular expressions; see U(https://msdn.microsoft.com/en-us/library/hs600312%28v=vs.110%29.aspx).
         */
        regexp?: string;
        /**
         * Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.
         */
        line?: string;
        /**
         * Default: no
         *
         * Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
         */
        backup?: string;
        /**
         * Default: None
         *
         * Validation to run before copying into place.  Use %s in the command to indicate the current file to validate.
         * The command is passed securely so shell features like expansion and pipes won't work.
         */
        validate?: string;
        [k: string]: unknown;
      };
      /**
       * Change dpkg package selection state via --get-selections and --set-selections.
       */
      dpkg_selections?: {
        /**
         * The selection state to set the package to.
         */
        selection?: "install" | "hold" | "deinstall" | "purge";
        /**
         * Name of the package
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Manages applying ACLs to interfaces.
       */
      nxos_acl_interface?: {
        /**
         * Full name of interface, e.g. I(Ethernet1/1).
         */
        interface?: string;
        /**
         * Direction ACL to be applied in on the interface.
         */
        direction?: string;
        /**
         * Case sensitive name of the access list (ACL).
         */
        name?: string;
        /**
         * Default: present
         *
         * Specify desired state of the resource.
         */
        state?: string;
        [k: string]: unknown;
      };
      /**
       * An Ansible module to Create or Delete Alert Policies at CenturyLink Cloud.
       */
      clc_alert_policy?: {
        /**
         * Default: None
         *
         * The name of the alert policy. This is mutually exclusive with id
         */
        name?: string;
        /**
         * Default: None
         *
         * The metric on which to measure the condition that will trigger the alert. This is required for state 'present'
         */
        metric?: "cpu" | "memory" | "disk";
        /**
         * Default: None
         *
         * The alert policy id. This is mutually exclusive with name
         */
        id?: string;
        /**
         * The alias of your CLC Account
         */
        alias: string;
        /**
         * Default: present
         *
         * Whether to create or delete the policy.
         */
        state?: "present" | "absent";
        /**
         * Default: None
         *
         * The threshold that will trigger the alert when the metric equals or exceeds it. This is required for state 'present' This number represents a percentage and must be a value between 5.0 - 95.0 that is a multiple of 5.0
         */
        threshold?: number | string;
        /**
         * Default: None
         *
         * A list of recipient email ids to notify the alert. This is required for state 'present'
         */
        alert_recipients?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: None
         *
         * The length of time in minutes that the condition must exceed the threshold. This is required for state 'present'
         */
        duration?: string;
        [k: string]: unknown;
      };
      /**
       * Creates, Removes and configures a virtual directory in IIS.
       */
      win_iis_virtualdirectory?: {
        /**
         * The application under which the virtual directory is created or exists.
         */
        application?: string;
        /**
         * Default: present
         *
         * Whether to add or remove the specified virtual directory
         */
        state?: string;
        /**
         * The name of the virtual directory to create or remove
         */
        name?: string;
        /**
         * The physical path to the folder in which the new virtual directory is created. The specified folder must already exist.
         */
        physical_path?: string;
        /**
         * The site name under which the virtual directory is created or exists.
         */
        site?: string;
        [k: string]: unknown;
      };
      /**
       * Create or Remove compute instances from OpenStack.
       */
      os_server?: {
        /**
         * The name or id of the base image to boot.
         */
        image?: string;
        /**
         * Text to use to filter image names, for the case, such as HP, where there are multiple image names matching the common identifying portions. image_exclude is a negative match filter - it is text that may not exist in the image name. Defaults to "(deprecated)"
         */
        image_exclude?: string;
        /**
         * Text to use to filter flavor names, for the case, such as Rackspace, where there are multiple flavors that have the same ram count. flavor_include is a positive match filter - it must exist in the flavor name.
         */
        flavor_include?: string;
        /**
         * Default: None
         *
         * A list of key value pairs that should be provided as a metadata to the new instance or a string containing a list of key-value pairs. Eg:  meta: "key1=value1,key2=value2"
         */
        meta?: string;
        /**
         * Default: 1
         *
         * The name or id of the flavor in which the new instance has to be created. Mutually exclusive with flavor_ram
         */
        flavor?: string;
        /**
         * Default: None
         *
         * Names of the security groups to which the instance should be added. This may be a YAML list or a comma separated string.
         */
        security_groups?: string;
        /**
         * Default: None
         *
         * Arbitrary key/value pairs to the scheduler for custom use
         */
        scheduler_hints?: string;
        /**
         * Should the instance boot from a persistent volume created based on the image given. Mututally exclusive with boot_volume.
         */
        boot_from_volume?: string;
        /**
         * Default: None
         *
         * Opaque blob of data which is made available to the instance
         */
        userdata?: string;
        /**
         * Default: None
         *
         * Name or ID of a network to attach this instance to. A simpler version of the nics parameter, only one of network or nics should be supplied.
         */
        network?: string;
        /**
         * Default: None
         *
         * A list of networks to which the instance's interface should be attached. Networks may be referenced by net-id/net-name/port-id or port-name.
         * Also this accepts a string containing a list of (net/port)-(id/name) Eg: nics: "net-id=uuid-1,port-name=myport" Only one of network or nics should be supplied.
         */
        nics?: string;
        /**
         * Default: None
         *
         * list of valid floating IPs that pre-exist to assign to this node
         */
        floating_ips?: string;
        /**
         * Default: 1
         *
         * The minimum amount of ram in MB that the flavor in which the new instance has to be created must have. Mutually exclusive with flavor.
         */
        flavor_ram?: string;
        /**
         * The size of the volume to create in GB if booting from volume based on an image.
         */
        volume_size?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: yes
         *
         * Ensure instance has public ip however the cloud wants to do that
         */
        auto_ip?: string;
        /**
         * Default: no
         *
         * Whether to boot the server with config drive enabled
         */
        config_drive?: string;
        /**
         * If true, delete volume when deleting instance (if booted from volume)
         */
        terminate_volume?: string;
        /**
         * Default: None
         *
         * The key pair name to be used when creating a instance
         */
        key_name?: string;
        /**
         * Default: None
         *
         * Volume name or id to use as the volume to boot from. Implies boot_from_volume. Mutually exclusive with image and boot_from_volume.
         */
        boot_volume?: string;
        /**
         * Default: yes
         *
         * If the module should wait for the instance to be created.
         */
        wait?: string;
        /**
         * Name that has to be given to the instance
         */
        name?: string;
        /**
         * Default: 180
         *
         * The amount of time the module should wait for the instance to get into active state.
         */
        timeout?: string;
        /**
         * When I(state) is absent and this option is true, any floating IP associated with the instance will be deleted along with the instance.
         */
        delete_fip?: string;
        /**
         * A list of preexisting volumes names or ids to attach to the instance
         */
        volumes?: string;
        /**
         * Default: None
         *
         * Name of floating IP pool from which to choose a floating IP
         */
        floating_ip_pools?: string;
        /**
         * Default: True
         *
         * When I(auto_ip) is true and this option is true, the I(auto_ip) code will attempt to re-use unassigned floating ips in the project before creating a new one. It is important to note that it is impossible to safely do this concurrently, so if your use case involves concurrent server creation, it is highly recommended to set this to false and to delete the floating ip associated with a server when the server is deleted using I(delete_fip).
         */
        reuse_ips?: string;
        [k: string]: unknown;
      };
      /**
       * Manage OpenStack DNS zones. Zones can be created, deleted or updated. Only the I(email), I(description), I(ttl) and I(masters) values can be updated.
       */
      os_zone?: {
        /**
         * Default: None
         *
         * Master nameservers (only applies if zone_type is secondary)
         */
        masters?: string;
        /**
         * Default: None
         *
         * Zone description
         */
        description?: string;
        /**
         * Default: present
         *
         * Should the resource be present or absent.
         */
        state?: string;
        /**
         * Default: None
         *
         * TTL (Time To Live) value in seconds
         */
        ttl?: string;
        /**
         * Default: None
         *
         * Zone type
         */
        zone_type?: string;
        /**
         * Email of the zone owner (only applies if zone_type is primary)
         */
        email?: string;
        /**
         * Zone name
         */
        name?: string;
        [k: string]: unknown;
      };
      /**
       * Control Linux encrypted block devices that are set up during system boot in C(/etc/crypttab).
       */
      crypttab?: {
        /**
         * Name of the encrypted block device as it appears in the C(/etc/crypttab) file, or optionaly prefixed with C(/dev/mapper/), as it appears in the filesystem. I(/dev/mapper/) will be stripped from I(name).
         */
        name: string;
        /**
         * Path to the underlying block device or file, or the UUID of a block-device prefixed with I(UUID=)
         */
        backing_device?: string;
        /**
         * Use I(present) to add a line to C(/etc/crypttab) or update it's definition if already present. Use I(absent) to remove a line with matching I(name). Use I(opts_present) to add options to those already present; options with different values will be updated. Use I(opts_absent) to remove options from the existing set.
         */
        state: "present" | "absent" | "opts_present" | "opts_absent";
        /**
         * Default: /etc/crypttab
         *
         * Path to file to use instead of C(/etc/crypttab). This might be useful in a chroot environment.
         */
        path?: string;
        /**
         * Default: none
         *
         * Encryption password, the path to a file containing the pasword, or 'none' or '-' if the password should be entered at boot.
         */
        password?: string;
        /**
         * A comma-delimited list of options. See C(crypttab(5) ) for details.
         */
        opts?: string;
        [k: string]: unknown;
      };
      /**
       * This module can be used to join nodes to a cluster, check the status of the cluster.
       */
      riak?: {
        /**
         * Default: riak@127.0.0.1
         *
         * The target node for certain operations (join, ping)
         */
        target_node?: string;
        /**
         * Default: /etc/riak
         *
         * The path to the riak configuration directory
         */
        config_dir?: string;
        /**
         * Default: None
         *
         * Waits for a riak service to come online before continuing.
         */
        wait_for_service?: "kv";
        /**
         * Default: 127.0.0.1:8098
         *
         * The ip address and port that is listening for Riak HTTP queries
         */
        http_conn?: string;
        /**
         * Number of seconds to wait for all nodes to agree on the ring.
         */
        wait_for_ring?: number | string;
        /**
         * Number of seconds to wait for handoffs to complete.
         */
        wait_for_handoffs?: number | string;
        /**
         * The command you would like to perform against the cluster.
         */
        command?: "ping" | "kv_test" | "join" | "plan" | "commit";
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Gather facts about ec2 volumes in AWS
       */
      ec2_vol_facts?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Retrieves facts for a file similar to the linux/unix 'stat' command.
       */
      stat?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage local users on an ESXi host
       */
      vmware_local_user_manager?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * This module can manage Kubernetes resources on an existing cluster using the Kubernetes server API. Users can specify in-line API data, or specify an existing Kubernetes YAML file. Currently, this module, Only supports HTTP Basic Auth Only supports 'strategic merge' for update, http://goo.gl/fCPYxT SSL certs are not working, use 'validate_certs=off' to disable
       */
      kubernetes?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manage the life cycle of docker containers.
       * Supports check mode. Run with --check and --diff to view config difference and list of actions to be taken.
       */
      docker_container?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Add, Edit, or Remove Registry Keys and Values using ItemProperties Cmdlets
       */
      win_regedit?: {
        /**
         * Default: string
         *
         * Registry Value Data Type
         */
        datatype?: string;
        /**
         * Default: present
         *
         * State of Registry Value
         */
        state?: string;
        /**
         * Registry Value Data.  Binary data should be expressed a yaml byte array or as comma separated hex values.  An easy way to generate this is to run C(regedit.exe) and use the I(Export) option to save the registry values to a file.  In the exported file binary values will look like C(hex:be,ef,be,ef).  The C(hex:) prefix is optional.
         */
        data?: string;
        /**
         * Name of Registry Value
         */
        value?: string;
        /**
         * Name of Registry Key
         */
        key?: string;
        [k: string]: unknown;
      };
      /**
       * Get facts for virtual machine images.
       */
      azure_rm_virtualmachineimage_facts?: {
        profile?: string;
        cli_default_profile?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        tags?: {
          [k: string]: unknown;
        };
        cloud_environment?: string;
        append_tags?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        ad_user?: string;
        secret?: string;
        /**
         * Specific version number of an image.
         */
        version?: string;
        /**
         * Azure location value (ie. westus, eastus, eastus2, northcentralus, etc.). Supplying only a location value will yield a list of available publishers for the location.
         */
        location: string;
        client_id?: string;
        /**
         * Image offering SKU. Combine with offer to see a list of available versions.
         */
        sku?: string;
        /**
         * Name of an image publisher. List image offerings associated with a particular publisher.
         */
        publisher?: string;
        subscription_id?: string;
        password?: string;
        /**
         * Name of an image offering. Combine with sku to see a list of available image versions.
         */
        offer?: string;
        tenant?: string;
        [k: string]: unknown;
      };
      /**
       * Manage PHP packages with the pear package manager.
       */
      pear?: {
        [k: string]: unknown;
      };
      /**
       * Execute trunk-create or trunk-delete command.
       * Trunks can be used to aggregate network links at Layer 2 on the local switch. Use this command to create a new trunk.
       */
      pn_trunk?: {
        /**
         * Specify the name for the trunk configuration.
         */
        pn_name: string;
        /**
         * Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.
         */
        pn_lacp_fallback_timeout?: string;
        /**
         * Specify the LACP time out as slow (30 seconds) or fast (4seconds). The default value is slow.
         */
        pn_lacp_timeout?: string;
        /**
         * Host facing port control setting.
         */
        pn_host?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the MAC address of the port.
         */
        pn_port_macaddr?: string;
        /**
         * Specify the LACP fallback mode as bundles or individual.
         */
        pn_lacp_fallback?: "bundle" | "individual";
        /**
         * Specify if the port participates in routing on the network.
         */
        pn_routing?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify if the configuration receives mirrored traffic.
         */
        pn_mirror_receive?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify an egress port data rate limit for the configuration.
         */
        pn_egress_rate_limit?: string;
        /**
         * State the action to perform. Use 'present' to create trunk, 'absent' to delete trunk and 'update' to modify trunk.
         */
        state: "present" | "absent" | "update";
        /**
         * Specify a broadcast level in percent. The default value is 100%.
         */
        pn_broadcast_level?: string;
        /**
         * Target switch(es) to run the cli on.
         */
        pn_cliswitch?: string;
        pn_unknown_mcast_level?: string;
        pn_unknown_ucast_level?: string;
        /**
         * Specify loopback if you want to use loopback.
         */
        pn_loopback?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify the port speed or disable the port.
         */
        pn_speed?: "disable" | "10m" | "100m" | "1g" | "2.5g" | "10g" | "40g";
        /**
         * Specify if the switch is an edge switch.
         */
        pn_edge_switch?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify if the port can receive jumbo frames.
         */
        pn_jumbo?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Provide login password if user is not root.
         */
        pn_clipassword?: string;
        /**
         * Specify the port number(s) for the link(s) to aggregate into the trunk.
         * Required for trunk-create.
         */
        pn_ports?: string;
        /**
         * Provide login username if user is not root.
         */
        pn_cliusername?: string;
        /**
         * Specify the LACP mode for the configuration.
         */
        pn_lacp_mode?: "off" | "passive" | "active";
        /**
         * Specify a list of looping vlans.
         */
        pn_loopvlans?: string;
        /**
         * Specify the LACP priority. This is a number between 1 and 65535 with a default value of 32768.
         */
        pn_lacp_priority?: number | string;
        /**
         * Specify if pause frames are sent.
         */
        pn_pause?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Specify a description for the trunk configuration.
         */
        pn_description?: string;
        [k: string]: unknown;
      };
      /**
       * This module will replace all instances of a pattern within a file.
       * It is up to the user to maintain idempotence by ensuring that the same pattern would never match any replacements made.
       */
      replace?: {
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      );
      /**
       * Manipulate metadata for Rackspace Cloud Servers
       */
      rax_meta?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Unzips compressed files and archives. For extracting any compression types other than .zip, the PowerShellCommunityExtensions (PSCX) Module is required.  This module (in conjunction with PSCX) has the ability to recursively unzip files within the src zip file provided and also functionality for many other compression types. If the destination directory does not exist, it will be created before unzipping the file.  Specifying rm parameter will force removal of the src file after extraction.
       */
      win_unzip?: {
        /**
         * Destination of zip file (provide absolute path of directory). If it does not exist, the directory will be created.
         */
        dest?: string;
        /**
         * File to be unzipped (provide absolute path)
         */
        src?: string;
        /**
         * Recursively expand zipped files within the src file.
         */
        recurse?: string;
        /**
         * If this file or directory exists the specified src will not be extracted.
         */
        creates?: string;
        /**
         * Remove the zip file, after unzipping
         */
        rm?: string;
        [k: string]: unknown;
      };
      /**
       * Manage slb virtual server objects on A10 Networks devices via aXAPI
       */
      a10_virtual_server?: ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) & {
          [k: string]: unknown;
        } & {
          [k: string]: unknown;
        } & ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )) &
        ({
          [k: string]: unknown;
        } & (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        ));
      /**
       * Manages MacPorts packages
       */
      macports?: {
        [k: string]: unknown;
      } & ({
        [k: string]: unknown;
      } & (
        | {
            [k: string]: unknown;
          }
        | {
            [k: string]: unknown;
          }
      ));
      /**
       * Create/delete an SSH key.
       */
      digital_ocean_sshkey?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages AAA server global configuration
       */
      nxos_aaa_server?: {
        /**
         * Global AAA server timeout period, in seconds. Range is 1-60. Device default is 5.
         */
        server_timeout?: string;
        /**
         * The server type is either radius or tacacs.
         */
        server_type?: string;
        /**
         * The state of encryption applied to the entered global key. O clear text, 7 encrypted. Type-6 encryption is not supported.
         */
        encrypt_type?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        /**
         * Duration for which a non-reachable AAA server is skipped, in minutes. Range is 1-1440. Device default is 0.
         */
        deadtime?: string;
        /**
         * Enables direct authentication requests to AAA server. Device default is disabled.
         */
        directed_request?: string;
        /**
         * Global AAA shared secret.
         */
        global_key?: string;
        [k: string]: unknown;
      };
      /**
       * Controls daemontools services on remote hosts using the svc utility.
       */
      svc?: {
        dist?: string;
        /**
         * Name of the service to manage.
         */
        name: string;
        /**
         * Should a 'down' file exist or not, if it exists it disables auto startup. defaults to no. Downed does not imply stopped.
         */
        downed?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Wheater the service is enabled or not, if disabled it also implies stopped. Make note that a service can be enabled and downed (no auto restart).
         */
        enabled?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * Default: /service
         *
         * directory svscan watches for services
         */
        service_dir?: string;
        /**
         * C(Started)/C(stopped) are idempotent actions that will not run commands unless necessary.  C(restarted) will always bounce the svc (svc -t) and C(killed) will always bounce the svc (svc -k). C(reloaded) will send a sigusr1 (svc -1). C(once) will run a normally downed svc once (svc -o), not really an idempotent operation.
         */
        state?: "started" | "stopped" | "restarted" | "killed" | "reloaded" | "once";
        /**
         * directory where services are defined, the source of symlinks to service_dir.
         */
        service_src?: string;
        [k: string]: unknown;
      };
      /**
       * Collects a base set of device facts from a remote device that is running Dell OS10.  This module prepends all of the base network fact keys with C(ansible_net_<fact>).  The facts module will always collect a base set of facts from the device and can enable or disable collection of additional facts.
       */
      dellos10_facts?: {
        authorize?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        username?: string;
        ssh_keyfile?: string;
        auth_pass?: string;
        host: string;
        /**
         * Default: !config
         *
         * When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.
         */
        gather_subset?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        timeout?: number | string;
        provider?: {
          [k: string]: unknown;
        };
        password?: string;
        port?: number | string;
        transport?: string;
        [k: string]: unknown;
      };
      /**
       * Manages DNS records via the v2 REST API of the DNS Made Easy service.  It handles records only; there is no manipulation of domains or monitor/account support yet. See: U(https://www.dnsmadeeasy.com/integration/restapi/)
       */
      dnsmadeeasy?: {
        /**
         * Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNS Made Easy (e.g. "839989") for faster resolution.
         */
        domain: string;
        /**
         * Record name to get/create/delete/update. If record_name is not specified; all records for the domain will be returned in "result" regardless of the state argument.
         */
        record_name?: string;
        /**
         * Default: 1800
         *
         * record's "Time to live".  Number of seconds the record remains cached in DNS servers.
         */
        record_ttl?: number | string;
        /**
         * Account Secret Key.
         */
        account_secret: string;
        /**
         * Account API Key.
         */
        account_key: string;
        /**
         * Record type.
         */
        record_type?: "A" | "AAAA" | "CNAME" | "HTTPRED" | "MX" | "NS" | "PTR" | "SRV" | "TXT";
        /**
         * whether the record should exist or not
         */
        state: "present" | "absent";
        /**
         * Record value. HTTPRED: <redirection URL>, MX: <priority> <target name>, NS: <name server>, PTR: <target name>, SRV: <priority> <weight> <port> <target name>, TXT: <text value>
         * If record_value is not specified; no changes will be made and the record will be returned in 'result' (in other words, this module can be used to fetch a record's current id, type, and ttl)
         */
        record_value?: string;
        /**
         * Default: yes
         *
         * If C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        [k: string]: unknown;
      };
      /**
       * Manage the state of a program monitored via I(Monit)
       */
      monit?: {
        /**
         * The state of service
         */
        state: "present" | "started" | "stopped" | "restarted" | "monitored" | "unmonitored" | "reloaded";
        /**
         * The name of the I(monit) program/process to manage
         */
        name: string;
        /**
         * Default: 300
         *
         * If there are pending actions for the service monitored by monit, then Ansible will check for up to this many seconds to verify the the requested action has been performed. Ansible will sleep for five seconds between each check.
         */
        timeout?: number | string;
        [k: string]: unknown;
      };
      /**
       * Allows for the creation and removal of volume to host mappings for NetApp E-series storage arrays.
       */
      netapp_e_lun_mapping?: {
        /**
         * The storage system array identifier.
         */
        ssid?: string;
        /**
         * The name of host or hostgroup you wish to assign to the mapping
         * If omitted, the default hostgroup is used.
         * If the supplied I(volume_name) is associated with a different target, it will be updated to what is supplied here.
         */
        target?: string;
        /**
         * The username used to authenticate against the API. This can optionally be set via an environment variable, API_USERNAME
         */
        api_username: string;
        /**
         * The password used to authenticate against the API. This can optionally be set via an environment variable, API_PASSWORD
         */
        api_password: string;
        /**
         * Whether the target is a host or group.
         * Required if supplying an explicit target.
         */
        target_type?: "host" | "group";
        /**
         * Present will ensure the mapping exists, absent will remove the mapping.
         * All parameters I(lun), I(target), I(target_type) and I(volume_name) must still be supplied.
         */
        state: "present" | "absent";
        /**
         * The name of the volume you wish to include in the mapping.
         */
        volume_name: string;
        /**
         * Default: True
         *
         * Should https certificates be validated?
         */
        validate_certs?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The LUN number you wish to give the mapping
         * If the supplied I(volume_name) is associated with a different LUN, it will be updated to what is supplied here.
         */
        lun?: number | string;
        /**
         * The full API url. Example: http://ENDPOINT:8080/devmgr/v2
         * This can optionally be set via an environment variable, API_URL
         */
        api_url: string;
        [k: string]: unknown;
      };
      /**
       * Manages monitors within Datadog
       * Options like described on http://docs.datadoghq.com/api/
       */
      datadog_monitor?: {
        /**
         * A boolean indicating whether tagged users will be notified on changes to this monitor.
         */
        notify_audit?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * A boolean indicating whether changes to this monitor should be restricted to the creator or admins.
         */
        locked?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state.
         */
        timeout_h?: string;
        /**
         * Default: None
         *
         * A list of tags to associate with your monitor when creating or updating. This can help you categorize and filter monitors.
         */
        tags?:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: {'warning': 1, 'ok': 1, 'critical': 1}
         *
         * A dictionary of thresholds by status. This option is only available for service checks and metric alerts. Because each of them can have multiple thresholds, we don't define them directly in the query.
         */
        thresholds?: {
          [k: string]: unknown;
        };
        /**
         * Dictionary of scopes to timestamps or None. Each scope will be muted until the given POSIX timestamp or forever if the value is None.
         */
        silenced?: {
          [k: string]: unknown;
        };
        /**
         * Your DataDog app key.
         */
        app_key: string;
        /**
         * A boolean indicating whether this monitor will notify when data stops reporting..
         */
        notify_no_data?:
          | boolean
          | (0 | 1)
          | (
              | "yes"
              | "no"
              | "Yes"
              | "No"
              | "YES"
              | "NO"
              | "on"
              | "off"
              | "On"
              | "Off"
              | "ON"
              | "OFF"
              | "1"
              | "0"
              | "true"
              | "false"
              | "True"
              | "FalseTRUE"
              | "FALSE"
            );
        /**
         * The number of minutes after the last notification before a monitor will re-notify on the current status. It will only re-notify if it's not resolved.
         */
        renotify_interval?: string;
        /**
         * The designated state of the monitor.
         */
        state: string;
        /**
         * A message to include with a re-notification. Supports the '@username' notification we allow elsewhere. Not applicable if renotify_interval is None
         */
        escalation_message?: string;
        /**
         * The monitor query to notify on with syntax varying depending on what type of monitor you are creating.
         */
        query?: string;
        /**
         * A message to include with notifications for this monitor. Email notifications can be sent to specific users by using the same '@username' notation as events. Monitor message template variables can be accessed by using double square brackets, i.e '[[' and ']]'.
         */
        message?: string;
        /**
         * Your DataDog API key.
         */
        api_key: string;
        /**
         * The type of the monitor.
         * The 'event alert'is available starting at Ansible 2.1
         */
        type?: string;
        /**
         * Default: 2x timeframe for metric, 2 minutes for service
         *
         * The number of minutes before a monitor will notify when data stops reporting. Must be at least 2x the monitor timeframe for metric alerts or 2 minutes for service checks.
         */
        no_data_timeframe?: string;
        /**
         * The name of the alert.
         */
        name: string;
        [k: string]: unknown;
      };
      /**
       * Create, update or delete a virtual networks. Allows setting and updating the available IPv4 address ranges and setting custom DNS servers. Use the azure_rm_subnet module to associate subnets with a virtual network.
       */
      azure_rm_virtualnetwork?: {
        [k: string]: unknown;
      } & {
        [k: string]: unknown;
      };
      /**
       * Manages IGMP global configuration configuration settings.
       */
      nxos_igmp?: {
        /**
         * Default: present
         *
         * Manages desired state of the resource.
         */
        state?: string;
        /**
         * Enables or disables the enforce router alert option check for IGMPv2 and IGMPv3 packets.
         */
        enforce_rtr_alert?: string;
        /**
         * Restarts the igmp process (using an exec config command).
         */
        restart?: string;
        /**
         * Removes routes when the IGMP process is restarted. By default, routes are not flushed.
         */
        flush_routes?: string;
        [k: string]: unknown;
      };
      /**
       * An Ansible module to Create, Delete and Restore server snapshots in CenturyLink Cloud.
       */
      clc_server_snapshot?: {
        /**
         * Default: 7
         *
         * The number of days to keep the server snapshot before it expires.
         */
        expiration_days?: string;
        /**
         * The list of CLC server Ids.
         */
        server_ids:
          | string
          | unknown[]
          | {
              [k: string]: unknown;
            };
        /**
         * Default: present
         *
         * The state to insure that the provided resources are in.
         */
        state?: "present" | "absent" | "restore";
        /**
         * Default: True
         *
         * Whether to wait for the provisioning tasks to finish before returning.
         */
        wait?: string;
        [k: string]: unknown;
      };
      /**
       * Manages UDLD global configuration params.
       */
      nxos_udld?: {
        /**
         * Ability to reset UDLD down interfaces.
         */
        reset?: string;
        /**
         * Message time in seconds for UDLD packets.
         */
        msg_time?: string;
        /**
         * Toggles aggressive mode.
         */
        aggressive?: string;
        /**
         * Default: present
         *
         * Manage the state of the resource.
         */
        state?: string;
        [k: string]: unknown;
      };
      [k: string]: unknown;
    }
)[];
